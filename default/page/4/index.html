<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/4/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/11/15/digital-S.M.A.R.T/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/15/digital-S.M.A.R.T/" class="post-title-link" itemprop="url">S.M.A.R.T 概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-15T00:00:00+08:00">2024-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:19:24" itemprop="dateModified" datetime="2025-05-05T11:19:24+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">数码</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、SMART概述"><a href="#一、SMART概述" class="headerlink" title="一、SMART概述"></a>一、SMART概述</h2><p><a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/yingpan/">硬盘</a>的故障一般分为两种：可预测的（predictable）和不可预测的（unpredictable）。后者偶而会发生，也没有办法去预防它，例如芯片突然失效，机械撞击等。但像电机轴承磨损、盘片磁介质性能下降等都属于可预测的情况，可以在在几天甚至几星期前就发现这种不正常的现象。如果发生这种问题，SMART功能会在开机时响起警报，至少让使用者有足够的时间把重要资料转移到其它储存设备上。</p>
<p>最早期的硬盘监控技术起源于1992年，IBM在AS/400计算机的IBM 0662 SCSI 2代硬盘驱动器中使用了后来被命名为Predictive Failure Analysis（故障预警分析技术）的监控技术，它是通过在固件中测量几个重要的硬盘安全参数和评估他们的情况，然后由监控软件得出两种结果：“硬盘安全”或“不久后会发生故障”。</p>
<p>不久，当时的微机制造商康柏和硬盘制造商希捷、昆腾以及康纳共同提出了名为IntelliSafe的类似技术。通过该技术，硬盘可以测量自身的的健康指标并将参量值传送给操作系统和用户的监控软件中，每个硬盘生产商有权决定哪些指标需要被监控以及设定它们的安全阈值。</p>
<p>1995年，康柏公司将该技术方案提交到Small Form Factor(SFF)委员会进行标准化，该方案得到IBM、希捷、昆腾、康纳和西部数据的支持，1996年6月进行了1.3版的修正，正式更名为S.M.A.R.T.（Self-Monitoring Analysis And Reporting Technology），全称就是“自我检测分析与报告技术”，成为一种自动监控硬盘驱动器完好状况和报告潜在问题的技术标准。</p>
<p>作为行业规范，SMART规定了硬盘制造厂商应遵循的标准，满足SMART标准的条件主要包括：</p>
<p>1）在设备制造期间完成SMART需要的各项参数、属性的设定；</p>
<p>2）在特定系统平台下，能够正常使用SMART；通过BIOS检测，能够识别设备是否支持SMART并可显示相关信息，而且能辨别有效和失效的SMART信息；</p>
<p>3）允许用户自由开启和关闭SMART功能；</p>
<p>4）在用户使用过程中，能提供SMART的各项有效信息，确定设备的工作状态，并能发出相应的修正指令或警告。在硬盘及操作系统都支持SMART技术并且开启的情况下，若硬盘状态不良，SMART技术能够在屏幕上显示英文警告信息：“WARNING：IMMEDIATLY BACKUP YOUR DATA AND REPLACE YOUR HARD DISK DRIVE，A FAILURE MAY BE IMMINENT．”(警告：立刻备份你的数据并更换硬盘，硬盘可能失效。)</p>
<p>SMART功能不断从硬盘上的各个传感器收集信息，并把信息保存在硬盘的系统保留区(service area)内，这个区域一般位于硬盘0物理面的最前面几十个物理磁道，由厂商写入相关的内部管理程序。这里除了SMART信息表外还包括低级格式化程序、加密解密程序、自监控程序、自动修复程序等。用户使用的监测软件通过名为“SMART Return Status”的命令（命令代码为：B0h）对SMART信息进行读取，且不允许最终用户对信息进行修改。</p>
<h2 id="二、SMART的ID代码"><a href="#二、SMART的ID代码" class="headerlink" title="二、SMART的ID代码"></a>二、SMART的ID代码</h2><p>硬盘SMART检测的ID代码以两位十六进制数表示（括号里对应的是十进制数）硬盘的各项检测参数。目前，各硬盘制造商的绝大部分SMART ID代码所代表的参数含义是一致的，但厂商也可以根据需要使用不同的ID代码，或者根据检测项目的多少增减ID代码。一般来说，以下这些检测项是必需的：</p>
<p>01（001） 底层数据读取错误率 Raw Read Error Rate</p>
<p>04（004） 启动/停止计数 Start/Stop Count</p>
<p>05（005） 重映射扇区数 Relocated Sector Count</p>
<p>09（009） 通电时间累计 Power-On Time Count (POH)</p>
<p>0A（010） 主轴起旋重试次数（即硬盘主轴电机启动重试次数） Spin up Retry Count</p>
<p>0B（011） 磁盘校准重试次数 Calibration Retry Count</p>
<p>0C（012） 磁盘通电次数 Power Cycle Count</p>
<p>C2（194） 温度 Temperature</p>
<p>C7（199） ULTRA DMA奇偶校验错误率 ULTRA ATA CRC Error Rate</p>
<p>C8（200） 写错误率 Write Error Rate</p>
<h2 id="三、SMART的描述（Description）"><a href="#三、SMART的描述（Description）" class="headerlink" title="三、SMART的描述（Description）"></a>三、SMART的描述（Description）</h2><p>描述，即某一检测项目的名称，是ID代码的文字解释。对用户而言，不仅要了解描述的含义，重要的是要了解各参数的值如“临界值”、“最差值”的定义，“当前值”与“数据值”的区别等，才能对自己的硬盘状态有一个基本了解。</p>
<h2 id="四、SMART的值"><a href="#四、SMART的值" class="headerlink" title="四、SMART的值"></a>四、SMART的值</h2><h3 id="1、临界值（Threshold）"><a href="#1、临界值（Threshold）" class="headerlink" title="1、临界值（Threshold）"></a>1、临界值（Threshold）</h3><p>临界值是硬盘厂商指定的表示某一项目可靠性的门限值，也称阈值，它通过特定公式计算而得。如果某个参数的当前值接近了临界值，就意味着硬盘将变得不可靠，可能导致数据丢失或者硬盘故障。由于临界值是硬盘厂商根据自己产品特性而确定的，因此用厂商提供的专用检测软件往往会跟Windows下检测软件的检测结果有较大出入。</p>
<p>以参数Raw Read Error Rate（底层数据读取错误率）为例：某型硬盘对该参数的计算公式为“10×log10（主机和硬盘之间所传输数据的扇区数）×512×8／重读的扇区数”。其中“512×8”是把扇区数转化为所传输的数据位(bits)，这个值只在所传输的数据位处于1010～1012范围时才作计算，而当Windows系统启动后，主机和硬盘之间所传输的数据扇区大于或等于1012时，此值将重新复位，所以有些值在不同的操作环境、不同检测程序下时会有较大的波动。</p>
<h3 id="2、当前值（Normalized-value）"><a href="#2、当前值（Normalized-value）" class="headerlink" title="2、当前值（Normalized value）"></a>2、当前值（Normalized value）</h3><p>当前值是各ID项在硬盘运行时根据实测数据通过公式计算的结果，计算公式由硬盘厂家自定。</p>
<p>硬盘出厂时各ID项目都有一个预设的最大正常值，也即出厂值，这个预设的依据及计算方法为硬盘厂家保密，不同型号的硬盘都不同，最大正常值通常为100或200或253，新硬盘刚开始使用时显示的当前值可以认为是预设的最大正常值（有些ID项如温度等除外）。随着使用损耗或出现错误，当前值会根据实测数据而不断刷新并逐渐减小。因此，当前值接近临界值就意味着硬盘寿命的减少，发生故障的可能性增大，所以当前值也是判定硬盘健康状态或推测寿命的依据之一。</p>
<h3 id="3、最差值（Worst）"><a href="#3、最差值（Worst）" class="headerlink" title="3、最差值（Worst）"></a>3、最差值（Worst）</h3><p>最差值是硬盘运行时各ID项曾出现过的最大的非正常值。</p>
<p>最差值是对硬盘运行中某项数据变劣的峰值统计，该数值也会不断刷新。通常，最差值与当前值是相等的，如果最差值出现较大的波动（小于当前值），表明硬盘曾出现错误或曾经历过恶劣的工作环境（如温度）。</p>
<h3 id="4、数据值（Data或Raw-value）"><a href="#4、数据值（Data或Raw-value）" class="headerlink" title="4、数据值（Data或Raw value）"></a>4、数据值（Data或Raw value）</h3><p>数据值是硬盘运行时各项参数的实测值，大部分SMART工具以十进制显示数据。</p>
<p>数据值代表的意义随参数而定，大致可以分为三类：</p>
<p>1）数据值并不直接反映硬盘状态，必须经过硬盘内置的计算公式换算成当前值才能得出结果；</p>
<p>2）数据值是直接累计的，如Start/Stop Count（启动/停止计数）的数据是50，即表示该硬盘从出厂到现在累计启停了50次；</p>
<p>3）有些参数的数据是即时数，如Temperature（温度）的数据值是44，表示硬盘的当前温度是44℃。</p>
<p>因此，有些参数直接查看数据也能大致了解硬盘目前的工作状态。</p>
<h2 id="五、状态-Status"><a href="#五、状态-Status" class="headerlink" title="五、状态(Status)"></a>五、状态(Status)</h2><p>硬盘的每项SMART信息中都有一个临界值（阈值），不同硬盘的临界值是不同的，SMART针对各项的当前值、最差值和临界值的比较结果以及数据值进行分析后，提供硬盘当前的评估状态，也是我们直观判断硬盘健康状态的重要信息。根据SMART的规定，状态一般有正常、警告、故障或错误三种状态。</p>
<p>SMART判定这三个状态与SMART的 Pre-failure/advisory BIT（预测错误/发现位）参数的赋值密切相关，当Pre-failure/advisory BIT=0，并且当前值、最差值远大于临界值的情况下，为正常标志。当Pre-failure/advisory BIT=0，并且当前值、最差值大于但接近临界值时，为警告标志；当Pre-failure/advisory BIT=1，并且当前值、最差值小于临界值时，为故障或错误标志。</p>
<h2 id="六、SMART参数详解"><a href="#六、SMART参数详解" class="headerlink" title="六、SMART参数详解"></a>六、SMART参数详解</h2><p>一般情况下，用户只要观察当前值、最差值和临界值的关系，并注意状态提示信息即可大致了解硬盘的健康状况。下面简单介绍各参数的含义，以红色标出的项目是寿命关键项，蓝色为<a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/gutaiyingpan/">固态硬盘</a>（SSD）特有的项目。</p>
<p>在基于闪存的固态硬盘中，存储单元分为两类：SLC（Single Layer Cell，单层单元）和MLC（Multi-Level Cell，多层单元）。SLC成本高、容量小、但读写速度快，可靠性高，擦写次数可高达100000次，比MLC高10倍。而MLC虽容量大、成本低，但其性能大幅落后于SLC。为了保证MLC的寿命，控制芯片还要有智能磨损平衡技术算法，使每个存储单元的写入次数可以平均分摊，以达到100万小时的平均无故障时间。因此固态硬盘有许多SMART参数是<a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/jixieyingpan/">机械硬盘</a>所没有的，如存储单元的擦写次数、备用块统计等等，这些新增项大都由厂家自定义，有些尚无详细的解释，有些解释也未必准确，此处也只是仅供参考。下面凡未注明厂商的固态硬盘特有的项均为SandForce主控芯片特有的，其它厂商各自单独注明。</p>
<h3 id="01（001）底层数据读取错误率-Raw-Read-Error-Rate"><a href="#01（001）底层数据读取错误率-Raw-Read-Error-Rate" class="headerlink" title="01（001）底层数据读取错误率 Raw Read Error Rate"></a>01（001）底层数据读取错误率 Raw Read Error Rate</h3><p>数据为0或任意值，当前值应远大于与临界值。</p>
<p>底层数据读取错误率是磁头从磁盘表面读取数据时出现的错误，对某些硬盘来说，大于0的数据表明磁盘表面或者读写磁头发生问题，如介质损伤、磁头污染、磁头共振等等。不过对希捷硬盘来说，许多硬盘的这一项会有很大的数据量，这不代表有任何问题，主要是看当前值下降的程度。</p>
<p>在固态硬盘中，此项的数据值包含了可校正的错误与不可校正的RAISE错误（UECC＋URAISE）。</p>
<p>注：RAISE（Redundant Array of Independent Silicon Elements）意为独立硅元素冗余阵列，是固态硬盘特有的一种冗余恢复技术，保证内部有类似RAID阵列的数据安全性。</p>
<h3 id="02（002）磁盘读写通量性能-Throughput-Performance"><a href="#02（002）磁盘读写通量性能-Throughput-Performance" class="headerlink" title="02（002）磁盘读写通量性能 Throughput Performance"></a>02（002）磁盘读写通量性能 Throughput Performance</h3><p>此参数表示硬盘的读写通量性能，数据值越大越好。当前值如果偏低或趋近临界值，表示硬盘存在严重的问题，但现在的硬盘通常显示数据值为0或根本不显示此项，一般在进行了人工脱机SMART测试后才会有数据量。</p>
<h3 id="03（003）主轴起旋时间-Spin-Up-Time"><a href="#03（003）主轴起旋时间-Spin-Up-Time" class="headerlink" title="03（003）主轴起旋时间 Spin Up Time"></a>03（003）主轴起旋时间 Spin Up Time</h3><p>主轴起旋时间就是主轴电机从启动至达到额定转速所用的时间，数据值直接显示时间，单位为毫秒或者秒，因此数据值越小越好。不过对于正常硬盘来说，这一项仅仅是一个参考值，硬盘每次的启动时间都不相同，某次启动的稍慢些也不表示就有问题。</p>
<p>硬盘的主轴电机从启动至达到额定转速大致需要4秒～15秒左右，过长的启动时间说明电机驱动电路或者轴承机构有问题。旦这一参数的数据值在某些型号的硬盘上总是为0，这就要看当前值和最差值来判断了。</p>
<p>对于固态硬盘来说，所有的数据都是保存在半导体集成电路中，没有主轴电机，所以这项没有意义，数据固定为0，当前值固定为100。</p>
<h3 id="04（004）启停计数-Start-Stop-Count"><a href="#04（004）启停计数-Start-Stop-Count" class="headerlink" title="04（004）启停计数 Start/Stop Count"></a>04（004）启停计数 Start/Stop Count</h3><p>这一参数的数据是累计值，表示硬盘主轴电机启动/停止的次数，新硬盘通常只有几次，以后会逐渐增加。系统的某些功能如空闲时关闭硬盘等会使硬盘启动/停止的次数大为增加，在排除定时功能的影响下，过高的启动/停止次数（远大于通电次数0C）暗示硬盘电机及其驱动电路可能有问题。</p>
<p>这个参数的当前值是依据某种公式计算的结果，例如对希捷某硬盘来说临界值为20，当前值是通过公式“100－（启停计数/1024）”计算得出的。若新硬盘的启停计数为0，当前值为100－(0/1024)＝100，随着启停次数的增加，该值不断下降，当启停次数达到81920次时，当前值为100－(81920/1024)＝20，已达到临界值，表示从启停次数来看，该硬盘已达设计寿命，当然这只是个寿命参考值，并不具有确定的指标性。</p>
<p>这一项对于固态硬盘同样没有意义，数据固定为0，当前值固定为100。</p>
<h3 id="05（005）重映射扇区计数-Reallocated-Sectors-Count-退役块计数-Retired-Block-Count"><a href="#05（005）重映射扇区计数-Reallocated-Sectors-Count-退役块计数-Retired-Block-Count" class="headerlink" title="05（005）重映射扇区计数 Reallocated Sectors Count/ 退役块计数 Retired Block Count"></a>05（005）重映射扇区计数 Reallocated Sectors Count/ 退役块计数 Retired Block Count</h3><p>数据应为0，当前值应远大于临界值。</p>
<p>当硬盘的某扇区持续出现读/写/校验错误时，硬盘固件程序会将这个扇区的物理地址加入缺陷表(G-list)，将该地址重新定向到预先保留的备用扇区并将其中的数据一并转移，这就称为重映射。执行重映射操作后的硬盘在Windows常规检测中是无法发现不良扇区的，因其地址已被指向备用扇区，这等于屏蔽了不良扇区。</p>
<p>这项参数的数据值直接表示已经被重映射扇区的数量，当前值则随着数据值的增加而持续下降。当发现此项的数据值不为零时，要密切注意其发展趋势，若能长期保持稳定，则硬盘还可以正常运行；若数据值不断上升，说明不良扇区不断增加，硬盘已处于不稳定状态，应当考虑更换了。如果当前值接近或已到达临界值（此时的数据值并不一定很大，因为不同硬盘保留的备用扇区数并不相同），表示缺陷表已满或备用扇区已用尽，已经失去了重映射功能，再出现不良扇区就会显现出来并直接导致数据丢失。</p>
<p>这一项不仅是硬盘的寿命关键参数，而且重映射扇区的数量也直接影响硬盘的性能，例如某些硬盘会出现数据量很大，但当前值下降不明显的情况，这种硬盘尽管还可正常运行，但也不宜继续使用。因为备用扇区都是位于磁盘尾部（靠近盘片轴心处），大量的使用备用扇区会使寻道时间增加，硬盘性能明显下降。</p>
<p>这个参数在机械硬盘上是非常敏感的，而对于固态硬盘来说同样具有重要意义。闪存的寿命是正态分布的，例如说MLC能写入一万次以上，实际上说的是写入一万次之前不会发生“批量损坏”，但某些单元可能写入几十次就损坏了。换言之，机械硬盘的盘片不会因读写而损坏，出现不良扇区大多与工艺质量相关，而闪存的读写次数则是有限的，因而损坏是正常的。所以固态硬盘在制造时也保留了一定的空间，当某个存储单元出现问题后即把损坏的部分隔离，用好的部分来顶替。这一替换方法和机械硬盘的扇区重映射是一个道理，只不过机械硬盘正常时极少有重映射操作，而对于固态硬盘是经常性的。</p>
<p>在固态硬盘中这一项的数据会随着使用而不断增长，只要增长的速度保持稳定就可以。通常情况下，数据值＝100－（100×被替换块/必需块总数），因此也可以估算出硬盘的剩余寿命。</p>
<p>Intel固态硬盘型号的第十二个字母表示了两种规格，该字母为1表示第一代的50纳米技术的SSD，为2表示第二代的34纳米技术的SSD，如SSDSA2M160G2GN就表示是34nm的SSD。所以参数的查看也有两种情况：</p>
<p>50nm的SSD（一代）要看当前值。这个值初始是100，当出现替换块的时候这个值并不会立即变化，一直到已替换四个块时这个值变为1，之后每增加四个块当前值就＋1。也就是100对应0～3个块，1对应4～7个块，2对应8～11个块……</p>
<p>34nm的SSD（二代）直接查看数据值，数据值直接表示有多少个被替换的块。</p>
<h3 id="06（006）读取通道余量-Read-Channel-Margin"><a href="#06（006）读取通道余量-Read-Channel-Margin" class="headerlink" title="06（006）读取通道余量 Read Channel Margin"></a>06（006）读取通道余量 Read Channel Margin</h3><p>这一项功能不明，现在的硬盘也不显示这一项。</p>
<h3 id="07（007）寻道错误率-Seek-Error-Rate"><a href="#07（007）寻道错误率-Seek-Error-Rate" class="headerlink" title="07（007）寻道错误率 Seek Error Rate"></a>07（007）寻道错误率 Seek Error Rate</h3><p>数据应为0，当前值应远大于与临界值。</p>
<p>这一项表示磁头寻道时的错误率，有众多因素可导致寻道错误率上升，如磁头组件的机械系统、伺服电路有局部问题，盘片表面介质不良，硬盘温度过高等等。</p>
<p>通常此项的数据应为0，但对希捷硬盘来说，即使是新硬盘，这一项也可能有很大的数据量，这不代表有任何问题，还是要看当前值是否下降。</p>
<h3 id="08（008）寻道性能-Seek-Time-Performance"><a href="#08（008）寻道性能-Seek-Time-Performance" class="headerlink" title="08（008）寻道性能 Seek Time Performance"></a>08（008）寻道性能 Seek Time Performance</h3><p>此项表示硬盘寻道操作的平均性能（寻道速度），通常与前一项（寻道错误率）相关联。当前值持续下降标志着磁头组件、寻道电机或伺服电路出现问题，但现在许多硬盘并不显示这一项。</p>
<h3 id="09（009）通电时间累计-Power-On-Time-Count-POH"><a href="#09（009）通电时间累计-Power-On-Time-Count-POH" class="headerlink" title="09（009）通电时间累计 Power-On Time Count (POH)"></a>09（009）通电时间累计 Power-On Time Count (POH)</h3><p>这个参数的含义一目了然，表示硬盘通电的时间，数据值直接累计了设备通电的时长，新硬盘当然应该接近0，但不同硬盘的计数单位有所不同，有以小时计数的，也有以分、秒甚至30秒为单位的，这由磁盘制造商来定义。</p>
<p>这一参数的临界值通常为0，当前值随着硬盘通电时间增加会逐渐下降，接近临界值表明硬盘已接近预计的设计寿命，当然这并不表明硬盘将出现故障或立即报废。参考磁盘制造商给出的该型号硬盘的MTBF（平均无故障时间）值，可以大致估计剩余寿命或故障概率。</p>
<p>对于固态硬盘，要注意“设备优先电源管理功能（device initiated power management，DIPM）”会影响这个统计：如果启用了DIPM，持续通电计数里就不包括睡眠时间；如果关闭了DIPM功能，那么活动、空闲和睡眠三种状态的时间都会被统计在内。</p>
<h3 id="0A（010）主轴起旋重试次数-Spin-up-Retry-Count"><a href="#0A（010）主轴起旋重试次数-Spin-up-Retry-Count" class="headerlink" title="0A（010）主轴起旋重试次数 Spin up Retry Count"></a>0A（010）主轴起旋重试次数 Spin up Retry Count</h3><p>数据应为0，当前值应大于临界值。</p>
<p>主轴起旋重试次数的数据值就是主轴电机尝试重新启动的计数，即主轴电机启动后在规定的时间里未能成功达到额定转速而尝试再次启动的次数。数据量的增加表示电机驱动电路或是机械子系统出现问题，整机供电不足也会导致这一问题。</p>
<h3 id="0B（011）磁头校准重试计数-Calibration-Retry-Count"><a href="#0B（011）磁头校准重试计数-Calibration-Retry-Count" class="headerlink" title="0B（011）磁头校准重试计数 Calibration Retry Count"></a>0B（011）磁头校准重试计数 Calibration Retry Count</h3><p>数据应为0，当前值应远大于与临界值。</p>
<p>硬盘在温度发生变化时，机械部件（特别是盘片）会因热胀冷缩出现形变，因此需要执行磁头校准操作消除误差，有的硬盘还内置了磁头定时校准功能。这一项记录了需要再次校准（通常因上次校准失败）的次数。</p>
<p>这一项的数据量增加，表示电机驱动电路或是机械子系统出现问题，但有些型号的新硬盘也有一定的数据量，并不表示有问题，还要看当前值和最差值。</p>
<h3 id="0C（012）通电周期计数-Power-Cycle-Count"><a href="#0C（012）通电周期计数-Power-Cycle-Count" class="headerlink" title="0C（012）通电周期计数 Power Cycle Count"></a>0C（012）通电周期计数 Power Cycle Count</h3><p>通电周期计数的数据值表示了硬盘通电/断电的次数，即电源开关次数的累计，新硬盘通常只有几次。</p>
<p>这一项与启停计数（04）是有区别的，一般来说，硬盘通电/断电意味着计算机的开机与关机，所以经历一次开关机数据才会加1；而启停计数（04）表示硬盘主轴电机的启动/停止（硬盘在运行时可能多次启停，如系统进入休眠或被设置为空闲多少时间而关闭）。所以大多情况下这个通电/断电的次数会小于启停计数（04）的次数。</p>
<p>通常，硬盘设计的通电次数都很高，如至少5000次，因此这一计数只是寿命参考值，本身不具指标性。</p>
<h3 id="0D（013）软件读取错误率-Soft-Read-Error-Rate"><a href="#0D（013）软件读取错误率-Soft-Read-Error-Rate" class="headerlink" title="0D（013）软件读取错误率 Soft Read Error Rate"></a>0D（013）软件读取错误率 Soft Read Error Rate</h3><p>软件读取错误率也称为可校正的读取误码率，就是报告给操作系统的未经校正的读取错误。数据值越低越好，过高则可能暗示盘片磁介质有问题。</p>
<h3 id="AA（170）坏块增长计数-Grown-Failing-Block-Count（Micron-镁光）"><a href="#AA（170）坏块增长计数-Grown-Failing-Block-Count（Micron-镁光）" class="headerlink" title="AA（170）坏块增长计数 Grown Failing Block Count（Micron 镁光）"></a>AA（170）坏块增长计数 Grown Failing Block Count（Micron 镁光）</h3><p>读写失败的块增长的总数。</p>
<h3 id="AB（171）编程失败块计数-Program-Fail-Block-Count"><a href="#AB（171）编程失败块计数-Program-Fail-Block-Count" class="headerlink" title="AB（171）编程失败块计数 Program Fail Block Count"></a>AB（171）编程失败块计数 Program Fail Block Count</h3><p>Flash编程失败块的数量。</p>
<h3 id="AC（172）擦写失败块计数-Erase-Fail-Block-Count"><a href="#AC（172）擦写失败块计数-Erase-Fail-Block-Count" class="headerlink" title="AC（172）擦写失败块计数 Erase Fail Block Count"></a>AC（172）擦写失败块计数 Erase Fail Block Count</h3><p>擦写失败块的数量。</p>
<h3 id="AD（173）磨损平衡操作次数（平均擦写次数）-Wear-Leveling-Count（Micron-镁光）"><a href="#AD（173）磨损平衡操作次数（平均擦写次数）-Wear-Leveling-Count（Micron-镁光）" class="headerlink" title="AD（173）磨损平衡操作次数（平均擦写次数） / Wear Leveling Count（Micron 镁光）"></a>AD（173）磨损平衡操作次数（平均擦写次数） / Wear Leveling Count（Micron 镁光）</h3><p>所有好块的平均擦写次数。</p>
<p>Flash芯片有写入次数限制，当使用FAT文件系统时，需要频繁地更新文件分配表。如果闪存的某些区域读写过于频繁，就会比其它区域磨损的更快，这将明显缩短整个硬盘的寿命（即便其它区域的擦写次数还远小于最大限制）。所以，如果让整个区域具有均匀的写入量，就可明显延长芯片寿命，这称为磨损均衡措施。</p>
<h3 id="AE（174）意外失电计数-Unexpected-Power-Loss-Count"><a href="#AE（174）意外失电计数-Unexpected-Power-Loss-Count" class="headerlink" title="AE（174）意外失电计数 Unexpected Power Loss Count"></a>AE（174）意外失电计数 Unexpected Power Loss Count</h3><p>硬盘自启用后发生意外断电事件的次数。</p>
<h3 id="B1（177）磨损范围对比值-Wear-Range-Delta"><a href="#B1（177）磨损范围对比值-Wear-Range-Delta" class="headerlink" title="B1（177）磨损范围对比值 Wear Range Delta"></a>B1（177）磨损范围对比值 Wear Range Delta</h3><p>磨损最重的块与磨损最轻的块的磨损百分比之差。</p>
<h3 id="B4（180）未用的备用块计数-Unused-Reserved-Block-Count-Total（惠普）"><a href="#B4（180）未用的备用块计数-Unused-Reserved-Block-Count-Total（惠普）" class="headerlink" title="B4（180）未用的备用块计数 Unused Reserved Block Count Total（惠普）"></a>B4（180）未用的备用块计数 Unused Reserved Block Count Total（惠普）</h3><p>固态硬盘会保留一些容量来准备替换损坏的存储单元，所以可用的预留空间数非常重要。这个参数的当前值表示的是尚未使用的预留的存储单元数量。</p>
<h3 id="B5（181）编程失败计数-Program-Fail-Count"><a href="#B5（181）编程失败计数-Program-Fail-Count" class="headerlink" title="B5（181）编程失败计数 Program Fail Count"></a>B5（181）编程失败计数 Program Fail Count</h3><p>用4个字节显示已编程失败的次数，与（AB）参数相似。</p>
<h3 id="B5（181）非4KB对齐访问数-Non-4k-Aligned-Access（Micron-镁光）"><a href="#B5（181）非4KB对齐访问数-Non-4k-Aligned-Access（Micron-镁光）" class="headerlink" title="B5（181）非4KB对齐访问数 Non-4k Aligned Access（Micron 镁光）"></a>B5（181）非4KB对齐访问数 Non-4k Aligned Access（Micron 镁光）</h3><h3 id="B6（182）擦写失败计数-Erase-Fail-Count"><a href="#B6（182）擦写失败计数-Erase-Fail-Count" class="headerlink" title="B6（182）擦写失败计数 Erase Fail Count"></a>B6（182）擦写失败计数 Erase Fail Count</h3><p>用4个字节显示硬盘自启用后块擦写失败的次数，与（AC）参数相似。</p>
<h3 id="B7（183）串口降速错误计数-SATA-Downshift-Error-Count"><a href="#B7（183）串口降速错误计数-SATA-Downshift-Error-Count" class="headerlink" title="B7（183）串口降速错误计数 SATA Downshift Error Count"></a>B7（183）串口降速错误计数 SATA Downshift Error Count</h3><p>这一项表示了SATA接口速率错误下降的次数。通常硬盘与主板之间的兼容问题会导致SATA传输级别降级运行。</p>
<h3 id="B8（184）I-O错误检测与校正-I-O-Error-Detection-and-Correction（IOEDC）"><a href="#B8（184）I-O错误检测与校正-I-O-Error-Detection-and-Correction（IOEDC）" class="headerlink" title="B8（184）I/O错误检测与校正 I/O Error Detection and Correction（IOEDC）"></a>B8（184）I/O错误检测与校正 I/O Error Detection and Correction（IOEDC）</h3><p>“I/O错误检测与校正”是惠普公司专有的SMART IV技术的一部分，与其他制造商的I/O错误检测和校正架构一样，它记录了数据通过驱动器内部高速缓存RAM传输到主机时的奇偶校验错误数量。</p>
<h3 id="B8（184）点到点错误检测计数-End-to-End-Error-Detection-Count"><a href="#B8（184）点到点错误检测计数-End-to-End-Error-Detection-Count" class="headerlink" title="B8（184）点到点错误检测计数 End to End Error Detection Count"></a>B8（184）点到点错误检测计数 End to End Error Detection Count</h3><p>Intel第二代的34nm固态硬盘有点到点错误检测计数这一项。固态硬盘里有一个LBA（logical block addressing，逻辑块地址）记录，这一项显示了SSD内部逻辑块地址与真实物理地址间映射的出错次数。</p>
<p>B8（184）原始坏块数 Init Bad Block Count（Indilinx芯片）</p>
<p>硬盘出厂时已有的坏块数量。</p>
<h3 id="B9（185）磁头稳定性-Head-Stability（西部数据）"><a href="#B9（185）磁头稳定性-Head-Stability（西部数据）" class="headerlink" title="B9（185）磁头稳定性 Head Stability（西部数据）"></a>B9（185）磁头稳定性 Head Stability（西部数据）</h3><p>意义不明。</p>
<h3 id="BA（186）感应运算振动检测-nduced-Op-Vibration-Detection（西部数据）"><a href="#BA（186）感应运算振动检测-nduced-Op-Vibration-Detection（西部数据）" class="headerlink" title="BA（186）感应运算振动检测 nduced Op-Vibration Detection（西部数据）"></a>BA（186）感应运算振动检测 nduced Op-Vibration Detection（西部数据）</h3><p>意义不明。</p>
<h3 id="BB（187）无法校正的错误-Reported-Uncorrectable-Errors（希捷）"><a href="#BB（187）无法校正的错误-Reported-Uncorrectable-Errors（希捷）" class="headerlink" title="BB（187）无法校正的错误 Reported Uncorrectable Errors（希捷）"></a>BB（187）无法校正的错误 Reported Uncorrectable Errors（希捷）</h3><p>报告给操作系统的无法通过硬件ECC校正的错误。如果数据值不为零，就应该备份硬盘上的数据了。</p>
<p>报告给操作系统的在所有存取命令中出现的无法校正的RAISE（URAISE）错误。</p>
<h3 id="BC（188）命令超时-Command-Timeout"><a href="#BC（188）命令超时-Command-Timeout" class="headerlink" title="BC（188）命令超时 Command Timeout"></a>BC（188）命令超时 Command Timeout</h3><p>由于硬盘超时导致操作终止的次数。通常数据值应为0，如果远大于零，最有可能出现的是电源供电问题或者<a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/shujuxian/">数据线</a>氧化致使接触不良，也可能是硬盘出现严重问题。</p>
<h3 id="BD（189）高飞写入-High-Fly-Writes"><a href="#BD（189）高飞写入-High-Fly-Writes" class="headerlink" title="BD（189）高飞写入 High Fly Writes"></a>BD（189）高飞写入 High Fly Writes</h3><p>磁头飞行高度监视装置可以提高读写的可靠性，这一装置时刻监测磁头的飞行高度是否在正常范围来保证可靠的写入数据。如果磁头的飞行高度出现偏差，写入操作就会停止，然后尝试重新写入或者换一个位置写入。这种持续的监测过程提高了写入数据的可靠性，同时也降低了读取错误率。这一项的数据值就统计了写入时磁头飞行高度出现偏差的次数。</p>
<h3 id="BD（189）出厂坏块计数-Factory-Bad-Block-Count（Micron-镁光芯片）"><a href="#BD（189）出厂坏块计数-Factory-Bad-Block-Count（Micron-镁光芯片）" class="headerlink" title="BD（189）出厂坏块计数 Factory Bad Block Count（Micron 镁光芯片）"></a>BD（189）出厂坏块计数 Factory Bad Block Count（Micron 镁光芯片）</h3><h3 id="BE（190）气流温度-Airflow-Temperature"><a href="#BE（190）气流温度-Airflow-Temperature" class="headerlink" title="BE（190）气流温度 Airflow Temperature"></a>BE（190）气流温度 Airflow Temperature</h3><p>这一项表示的是硬盘内部盘片表面的气流温度。在希捷公司的某些硬盘中，当前值=（100－当前温度），因此气流温度越高，当前值就越低，最差值则是当前值曾经到达过的最低点，临界值由制造商定义的最高允许温度来确定，而数据值不具实际意义。许多硬盘也没有这一项参数。</p>
<h3 id="BF（191）冲击错误率-G-sense-error-rate"><a href="#BF（191）冲击错误率-G-sense-error-rate" class="headerlink" title="BF（191）冲击错误率 G-sense error rate"></a>BF（191）冲击错误率 G-sense error rate</h3><p>这一项的数据值记录了硬盘受到机械冲击导致出错的频度。</p>
<h3 id="C0（192）断电返回计数-Power-Off-Retract-Count"><a href="#C0（192）断电返回计数-Power-Off-Retract-Count" class="headerlink" title="C0（192）断电返回计数 Power-Off Retract Count"></a>C0（192）断电返回计数 Power-Off Retract Count</h3><p>当计算机关机或意外断电时，硬盘的磁头都要返回停靠区，不能停留在盘片的数据区里。正常关机时电源会给硬盘一个通知，即Standby Immediate，就是说主机要求将缓存数据写入硬盘，然后就准备关机断电了（休眠、待机也是如此）；意外断电则表示硬盘在未收到关机通知时就失电，此时磁头会自动复位，迅速离开盘片。</p>
<p>这个参数的数据值累计了磁头返回的次数。但要注意这个参数对某些硬盘来说仅记录意外断电时磁头的返回动作；而某些硬盘记录了所有（包括休眠、待机，但不包括关机时）的磁头返回动作；还有些硬盘这一项没有记录。因此这一参数的数据值在某些硬盘上持续为0或稍大于0，但在另外的硬盘上则会大于通电周期计数（0C）或启停计数（04）的数据。在一些新型节能硬盘中，这一参数的数据量还与硬盘的节能设计相关，可能会远大于通电周期计数（0C）或启停计数（04）的数据，但又远小于磁头加载/卸载计数（C1）的数据量。</p>
<p>对于固态硬盘来说，虽然没有磁头的加载/卸载操作，但这一项的数据量仍然代表了不安全关机，即发生意外断电的次数。</p>
<h3 id="C1（193）磁头加载-卸载计数-Load-Unload-Cycle-Count"><a href="#C1（193）磁头加载-卸载计数-Load-Unload-Cycle-Count" class="headerlink" title="C1（193）磁头加载/卸载计数 Load/Unload Cycle Count"></a>C1（193）磁头加载/卸载计数 Load/Unload Cycle Count</h3><p>对于过去的硬盘来说，盘片停止旋转时磁头臂停靠于盘片中心轴处的停泊区，磁头与盘片接触，只有当盘片旋转到一定转速时，磁头才开始漂浮于盘片之上并开始向外侧移动至数据区。这使得磁头在硬盘启停时都与盘片发生摩擦，虽然盘片的停泊区不存储数据，但无疑启停一个循环，就使磁头经历两次磨损。所以对以前的硬盘来说，磁头起降（加载/卸载）次数是一项重要的寿命关键参数。</p>
<p>而在现代硬盘中，平时磁头臂是停靠于盘片之外的一个专门设计的停靠架上，远离盘片。只有当盘片旋转达到额定转速后，磁头臂才开始向内（盘片轴心）转动使磁头移至盘片区域（加载），磁头臂向外转动返回至停靠架即卸载。这样就彻底杜绝了硬盘启停时磁头与盘片接触的现象，西部数据公司将其称为“斜坡加载技术”。由于磁头在加载/卸载过程中始终不与盘片接触，不存在磁头的磨损，使得这一参数的重要性已经大大下降。</p>
<p>这个参数的数据值就是磁头执行加载/卸载操作的累计次数。从原理上讲，这个加载/卸载次数应当与硬盘的启停次数相当，但对于笔记本内置硬盘以及<a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/taishiji/">台式机</a>新型节能硬盘来说，这一项的数据量会很大。这是因为磁头臂组件设计有一个固定的返回力矩，保证在意外断电时磁头能靠弹簧力自动离开盘片半径范围，迅速返回停靠架。所以要让硬盘运行时磁头保持在盘片的半径之内，就要使磁头臂驱动电机（寻道电机）持续通以电流。而让磁头臂在硬盘空闲几分钟后就立即执行卸载动作，返回到停靠架上，既有利于节能，又降低了硬盘受外力冲击导致磁头与盘片接触的概率。虽然再次加载会增加一点寻道时间，但毕竟弊大于利，所以在这类硬盘中磁头的加载/卸载次数会远远大于通电周期计数（0C）或启停计数（04）的数据量。不过这种加载/卸载方式已经没有了磁头与盘片的接触，所以设计值也已大大增加，通常笔记本内置硬盘的磁头加载/卸载额定值在30～60万次，而台式机新型节能硬盘的磁头加载/卸载设计值可达一百万次。</p>
<h3 id="C2（194）温度-Temperature"><a href="#C2（194）温度-Temperature" class="headerlink" title="C2（194）温度 Temperature"></a>C2（194）温度 Temperature</h3><p>温度的数据值直接表示了硬盘内部的当前温度。硬盘运行时最好不要超过45℃，温度过高虽不会导致数据丢失，但引起的机械变形会导致寻道与读写错误率上升，降低硬盘性能。硬盘的最高允许运行温度可查看硬盘厂商给出的数据，一般不会超过60℃。</p>
<p>不同厂家对温度参数的当前值、最差值和临界值有不同的表示方法：希捷公司某些硬盘的当前值就是实际温度（摄氏）值，最差值则是曾经达到过的最高温度，临界值不具意义；而西部数据公司一些硬盘的最差值是温度上升到某值后的时间函数，每次升温后的持续时间都将导致最差值逐渐下降，当前值则与当前温度成反比，即当前温度越高，当前值越低，随实际温度波动。</p>
<h3 id="C3（195）硬件ECC校正-Hardware-ECC-Recovered"><a href="#C3（195）硬件ECC校正-Hardware-ECC-Recovered" class="headerlink" title="C3（195）硬件ECC校正 Hardware ECC Recovered"></a>C3（195）硬件ECC校正 Hardware ECC Recovered</h3><p>ECC（Error Correcting Code）的意思是“错误检查和纠正”，这个技术能够容许错误，并可以将错误更正，使读写操作得以持续进行，不致因错误而中断。这一项的数据值记录了磁头在盘片上读写时通过ECC技术校正错误的次数，不过许多硬盘有其制造商特定的数据结构，因此数据量的大小并不能直接说明问题。</p>
<h3 id="C3（195）实时无法校正错误计数-On-the-fly-ECC-Uncorrectable-Error-Count"><a href="#C3（195）实时无法校正错误计数-On-the-fly-ECC-Uncorrectable-Error-Count" class="headerlink" title="C3（195）实时无法校正错误计数 On the fly ECC Uncorrectable Error Count"></a>C3（195）实时无法校正错误计数 On the fly ECC Uncorrectable Error Count</h3><p>这一参数记录了无法校正（UECC）的错误数量。</p>
<h3 id="C3（195）编程错误块计数-Program-Failure-block-Count（Indilinx芯片）"><a href="#C3（195）编程错误块计数-Program-Failure-block-Count（Indilinx芯片）" class="headerlink" title="C3（195）编程错误块计数 Program Failure block Count（Indilinx芯片）"></a>C3（195）编程错误块计数 Program Failure block Count（Indilinx芯片）</h3><h3 id="C4（196）重映射事件计数-Reallocetion-Events-Count"><a href="#C4（196）重映射事件计数-Reallocetion-Events-Count" class="headerlink" title="C4（196）重映射事件计数 Reallocetion Events Count"></a>C4（196）重映射事件计数 Reallocetion Events Count</h3><p>数据应为0，当前值应远大于临界值。</p>
<p>这个参数的数据值记录了将重映射扇区的数据转移到备用扇区的尝试次数，是重映射操作的累计值，成功的转移和不成功的转移都会被计数。因此这一参数与重映射扇区计数（05）相似，都是反映硬盘已经存在不良扇区。</p>
<h3 id="C4（196）擦除错误块计数-Erase-Failure-block-Count（Indilinx芯片）"><a href="#C4（196）擦除错误块计数-Erase-Failure-block-Count（Indilinx芯片）" class="headerlink" title="C4（196）擦除错误块计数 Erase Failure block Count（Indilinx芯片）"></a>C4（196）擦除错误块计数 Erase Failure block Count（Indilinx芯片）</h3><p>在固态硬盘中，这一参数记录了被重映射的块编程失败的数量。</p>
<h3 id="C5（197）当前待映射扇区计数-Current-Pending-Sector-Count"><a href="#C5（197）当前待映射扇区计数-Current-Pending-Sector-Count" class="headerlink" title="C5（197）当前待映射扇区计数 Current Pending Sector Count"></a>C5（197）当前待映射扇区计数 Current Pending Sector Count</h3><p>数据应为0，当前值应远大于临界值。</p>
<p>这个参数的数据表示了“不稳定的”扇区数，即等待被映射的扇区（也称“被挂起的扇区”）数量。如果不稳定的扇区随后被读写成功，该扇区就不再列入等待范围，数据值就会下降。</p>
<p>仅仅读取时出错的扇区并不会导致重映射，只是被列入“等待”，也许以后读取就没有问题，所以只有在写入失败时才会发生重映射。下次对该扇区写入时如果继续出错，就会产生一次重映射操作，此时重映射扇区计数（05）与重映射事件计数（C4）的数据值增加，此参数的数据值下降。</p>
<h3 id="C5（197）读取错误块计数（不可修复错误）Read-Failure-block-Count（Indilinx芯片）"><a href="#C5（197）读取错误块计数（不可修复错误）Read-Failure-block-Count（Indilinx芯片）" class="headerlink" title="C5（197）读取错误块计数（不可修复错误）Read Failure block Count（Indilinx芯片）"></a>C5（197）读取错误块计数（不可修复错误）Read Failure block Count（Indilinx芯片）</h3><h3 id="C6（198）脱机无法校正的扇区计数-Offline-Uncorrectable-Sector-Count"><a href="#C6（198）脱机无法校正的扇区计数-Offline-Uncorrectable-Sector-Count" class="headerlink" title="C6（198）脱机无法校正的扇区计数 Offline Uncorrectable Sector Count"></a>C6（198）脱机无法校正的扇区计数 Offline Uncorrectable Sector Count</h3><p>数据应为0，当前值应远大于临界值。</p>
<p>这个参数的数据累计了读写扇区时发生的无法校正的错误总数。数据值上升表明盘片表面介质或机械子系统出现问题，有些扇区肯定已经不能读取，如果有文件正在使用这些扇区，操作系统会返回读盘错误的信息。下一次写操作时会对该扇区执行重映射。</p>
<h3 id="C6（198）总读取页数-Total-Count-of-Read-Sectors（Indilinx芯片）"><a href="#C6（198）总读取页数-Total-Count-of-Read-Sectors（Indilinx芯片）" class="headerlink" title="C6（198）总读取页数 Total Count of Read Sectors（Indilinx芯片）"></a>C6（198）总读取页数 Total Count of Read Sectors（Indilinx芯片）</h3><h3 id="C7（199）Ultra-ATA访问校验错误率-Ultra-ATA-CRC-Error-Rate"><a href="#C7（199）Ultra-ATA访问校验错误率-Ultra-ATA-CRC-Error-Rate" class="headerlink" title="C7（199）Ultra ATA访问校验错误率 Ultra ATA CRC Error Rate"></a>C7（199）Ultra ATA访问校验错误率 Ultra ATA CRC Error Rate</h3><p>这个参数的数据值累计了通过接口循环冗余校验（Interface Cyclic Redundancy Check，ICRC）发现的数据线传输错误的次数。如果数据值不为0且持续增长，表示硬盘控制器→数据线→硬盘接口出现错误，劣质的数据线、接口接触不良都可能导致此现象。由于这一项的数据值不会复零，所以某些新硬盘也会出现一定的数据量，只要更换数据线后数据值不再继续增长，即表示问题已得到解决。</p>
<h3 id="C7（199）总写入页数-Total-Count-of-Write-Sectors（Indilinx芯片）"><a href="#C7（199）总写入页数-Total-Count-of-Write-Sectors（Indilinx芯片）" class="headerlink" title="C7（199）总写入页数 Total Count of Write Sectors（Indilinx芯片）"></a>C7（199）总写入页数 Total Count of Write Sectors（Indilinx芯片）</h3><h3 id="C8（200）写入错误率-Write-Error-Rate-多区域错误率-Multi-Zone-Error-Rate（西部数据）"><a href="#C8（200）写入错误率-Write-Error-Rate-多区域错误率-Multi-Zone-Error-Rate（西部数据）" class="headerlink" title="C8（200）写入错误率 Write Error Rate / 多区域错误率 Multi-Zone Error Rate（西部数据）"></a>C8（200）写入错误率 Write Error Rate / 多区域错误率 Multi-Zone Error Rate（西部数据）</h3><p>数据应为0，当前值应远大于临界值。</p>
<p>这个参数的数据累计了向扇区写入数据时出现错误的总数。有的新硬盘也会有一定的数据量，若数据值持续快速升高（当前值偏低），表示盘片、磁头组件可能有问题。</p>
<h3 id="C8（200）总读取指令数-Total-Count-of-Read-Command（Indilinx芯片）"><a href="#C8（200）总读取指令数-Total-Count-of-Read-Command（Indilinx芯片）" class="headerlink" title="C8（200）总读取指令数 Total Count of Read Command（Indilinx芯片）"></a>C8（200）总读取指令数 Total Count of Read Command（Indilinx芯片）</h3><h3 id="C9（201）脱道错误率-Off-Track-Error-Rate-逻辑读取错误率-Soft-Read-Error-Rate"><a href="#C9（201）脱道错误率-Off-Track-Error-Rate-逻辑读取错误率-Soft-Read-Error-Rate" class="headerlink" title="C9（201）脱道错误率 Off Track Error Rate / 逻辑读取错误率 Soft Read Error Rate"></a>C9（201）脱道错误率 Off Track Error Rate / 逻辑读取错误率 Soft Read Error Rate</h3><p>数据值累积了读取时脱轨的错误数量，如果数据值不为0，最好备份硬盘上的资料。</p>
<h3 id="C9（201）TA-Counter-Detected（意义不明）"><a href="#C9（201）TA-Counter-Detected（意义不明）" class="headerlink" title="C9（201）TA Counter Detected（意义不明）"></a>C9（201）TA Counter Detected（意义不明）</h3><h3 id="C9（201）写入指令总数-Total-Count-of-Write-Command（Indilinx芯片）"><a href="#C9（201）写入指令总数-Total-Count-of-Write-Command（Indilinx芯片）" class="headerlink" title="C9（201）写入指令总数 Total Count of Write Command（Indilinx芯片）"></a>C9（201）写入指令总数 Total Count of Write Command（Indilinx芯片）</h3><h3 id="CA（202）数据地址标记错误-Data-Address-Mark-errors"><a href="#CA（202）数据地址标记错误-Data-Address-Mark-errors" class="headerlink" title="CA（202）数据地址标记错误 Data Address Mark errors"></a>CA（202）数据地址标记错误 Data Address Mark errors</h3><p>此项的数据值越低越好（或者由制造商定义）。</p>
<h3 id="CA（202）TA-Counter-Increased（意义不明）"><a href="#CA（202）TA-Counter-Increased（意义不明）" class="headerlink" title="CA（202）TA Counter Increased（意义不明）"></a>CA（202）TA Counter Increased（意义不明）</h3><h3 id="CA（202）剩余寿命-Percentage-Of-The-Rated-Lifetime-Used（Micron-镁光芯片）"><a href="#CA（202）剩余寿命-Percentage-Of-The-Rated-Lifetime-Used（Micron-镁光芯片）" class="headerlink" title="CA（202）剩余寿命 Percentage Of The Rated Lifetime Used（Micron 镁光芯片）"></a>CA（202）剩余寿命 Percentage Of The Rated Lifetime Used（Micron 镁光芯片）</h3><p>当前值从100开始下降至0，表示所有块的擦写余量统计。计算方法是以MLC擦写次数除以50，SLC擦写次数除以1000，结果取整数，将其与100的差值作为当前值（MLC预计擦写次数为5000，SLC预计擦写次数为100000）。</p>
<h3 id="CA（202）闪存总错误bit数-Total-Count-of-error-bits-from-flash（Indilinx芯片）"><a href="#CA（202）闪存总错误bit数-Total-Count-of-error-bits-from-flash（Indilinx芯片）" class="headerlink" title="CA（202）闪存总错误bit数 Total Count of error bits from flash（Indilinx芯片）"></a>CA（202）闪存总错误bit数 Total Count of error bits from flash（Indilinx芯片）</h3><h3 id="CB（203）软件ECC错误数-Run-Out-Cancel"><a href="#CB（203）软件ECC错误数-Run-Out-Cancel" class="headerlink" title="CB（203）软件ECC错误数 Run Out Cancel"></a>CB（203）软件ECC错误数 Run Out Cancel</h3><p>错误检查和纠正（ECC）出错的频度。</p>
<h3 id="CB（203）校正bit错误的总读取页数-Total-Count-of-Read-Sectors-with-correct-bits-error（Indilinx芯片）"><a href="#CB（203）校正bit错误的总读取页数-Total-Count-of-Read-Sectors-with-correct-bits-error（Indilinx芯片）" class="headerlink" title="CB（203）校正bit错误的总读取页数 Total Count of Read Sectors with correct bits error（Indilinx芯片）"></a>CB（203）校正bit错误的总读取页数 Total Count of Read Sectors with correct bits error（Indilinx芯片）</h3><h3 id="CC（204）软件ECC校正-Soft-ECC-Correction"><a href="#CC（204）软件ECC校正-Soft-ECC-Correction" class="headerlink" title="CC（204）软件ECC校正 Soft ECC Correction"></a>CC（204）软件ECC校正 Soft ECC Correction</h3><p>通过软件ECC纠正错误的计数。</p>
<h3 id="CC（204）坏块满标志-Bad-Block-Full-Flag（Indilinx芯片）"><a href="#CC（204）坏块满标志-Bad-Block-Full-Flag（Indilinx芯片）" class="headerlink" title="CC（204）坏块满标志 Bad Block Full Flag（Indilinx芯片）"></a>CC（204）坏块满标志 Bad Block Full Flag（Indilinx芯片）</h3><h3 id="CD（205）热骚动错误率-Thermal-Asperity-Rate-TAR"><a href="#CD（205）热骚动错误率-Thermal-Asperity-Rate-TAR" class="headerlink" title="CD（205）热骚动错误率 Thermal Asperity Rate (TAR)"></a>CD（205）热骚动错误率 Thermal Asperity Rate (TAR)</h3><p>由超温导致的错误。数据值应为0。</p>
<h3 id="CD（205）最大可编程-擦除次数-Max-P-E-Count（Indilinx芯片）"><a href="#CD（205）最大可编程-擦除次数-Max-P-E-Count（Indilinx芯片）" class="headerlink" title="CD（205）最大可编程/擦除次数 Max P/E Count（Indilinx芯片）"></a>CD（205）最大可编程/擦除次数 Max P/E Count（Indilinx芯片）</h3><h3 id="CE（206）磁头飞行高度-Flying-Height"><a href="#CE（206）磁头飞行高度-Flying-Height" class="headerlink" title="CE（206）磁头飞行高度 Flying Height"></a>CE（206）磁头飞行高度 Flying Height</h3><p>磁头距离盘片表面的垂直距离。高度过低则增加了磁头与盘片接触导致损坏的可能性；高度偏高则增大了读写错误率。不过准确地说，硬盘中并没有任何装置可以直接测出磁头的飞行高度，制造商也只是根据磁头读取的信号强度来推算磁头飞行高度。</p>
<h3 id="CE（206）底层数据写入出错率-Write-Error-Rate"><a href="#CE（206）底层数据写入出错率-Write-Error-Rate" class="headerlink" title="CE（206）底层数据写入出错率 Write Error Rate"></a>CE（206）底层数据写入出错率 Write Error Rate</h3><h3 id="CE（206）最小擦写次数-Erase-Count-Min（Indilinx芯片）"><a href="#CE（206）最小擦写次数-Erase-Count-Min（Indilinx芯片）" class="headerlink" title="CE（206）最小擦写次数 Erase Count Min（Indilinx芯片）"></a>CE（206）最小擦写次数 Erase Count Min（Indilinx芯片）</h3><h3 id="CF（207）主轴过电流-Spin-High-Current"><a href="#CF（207）主轴过电流-Spin-High-Current" class="headerlink" title="CF（207）主轴过电流 Spin High Current"></a>CF（207）主轴过电流 Spin High Current</h3><p>数据值记录了主轴电机运行时出现浪涌电流的次数，数据量的增加意味着轴承或电机可能有问题。</p>
<h3 id="CF（207）最大擦写次数-Erase-Count-Max（Indilinx芯片）"><a href="#CF（207）最大擦写次数-Erase-Count-Max（Indilinx芯片）" class="headerlink" title="CF（207）最大擦写次数 Erase Count Max（Indilinx芯片）"></a>CF（207）最大擦写次数 Erase Count Max（Indilinx芯片）</h3><h3 id="D0（208）主轴电机重启次数-Spin-Buzz"><a href="#D0（208）主轴电机重启次数-Spin-Buzz" class="headerlink" title="D0（208）主轴电机重启次数 Spin Buzz"></a>D0（208）主轴电机重启次数 Spin Buzz</h3><p>数据值记录了主轴电机反复尝试启动的次数，这通常是由于电源供电不足引起的。</p>
<h3 id="D0（208）平均擦写次数Erase-Count-Average（Indilinx芯片）"><a href="#D0（208）平均擦写次数Erase-Count-Average（Indilinx芯片）" class="headerlink" title="D0（208）平均擦写次数Erase Count Average（Indilinx芯片）"></a>D0（208）平均擦写次数Erase Count Average（Indilinx芯片）</h3><h3 id="D1（209）脱机寻道性能-Offline-Seek-Performance"><a href="#D1（209）脱机寻道性能-Offline-Seek-Performance" class="headerlink" title="D1（209）脱机寻道性能 Offline Seek Performance"></a>D1（209）脱机寻道性能 Offline Seek Performance</h3><p>这一项表示驱动器在脱机状态下的寻道性能，通常用于工厂内部测试。</p>
<h3 id="D1（209）剩余寿命百分比-Remaining-Life-（Indilinx芯片）"><a href="#D1（209）剩余寿命百分比-Remaining-Life-（Indilinx芯片）" class="headerlink" title="D1（209）剩余寿命百分比 Remaining Life %（Indilinx芯片）"></a>D1（209）剩余寿命百分比 Remaining Life %（Indilinx芯片）</h3><h3 id="D2（210）斜坡加载值-Ramp-Load-Value"><a href="#D2（210）斜坡加载值-Ramp-Load-Value" class="headerlink" title="D2（210）斜坡加载值 Ramp Load Value"></a>D2（210）斜坡加载值 Ramp Load Value</h3><p>这一项仅见于几年前迈拓制造的部分硬盘。通常数据值为0，意义不明。</p>
<h3 id="D2（210）坏块管理错误日志-BBM-Error-Log（Indilinx芯片）"><a href="#D2（210）坏块管理错误日志-BBM-Error-Log（Indilinx芯片）" class="headerlink" title="D2（210）坏块管理错误日志 BBM Error Log（Indilinx芯片）"></a>D2（210）坏块管理错误日志 BBM Error Log（Indilinx芯片）</h3><h3 id="D3（211）写入时振动-Vibration-During-Write"><a href="#D3（211）写入时振动-Vibration-During-Write" class="headerlink" title="D3（211）写入时振动 Vibration During Write"></a>D3（211）写入时振动 Vibration During Write</h3><p>写入数据时受到受到外部振动的记录。</p>
<h3 id="D3（211）SATA主机接口CRC写入错误计数-SATA-Error-Count-CRC-Write-（Indilinx芯片）"><a href="#D3（211）SATA主机接口CRC写入错误计数-SATA-Error-Count-CRC-Write-（Indilinx芯片）" class="headerlink" title="D3（211）SATA主机接口CRC写入错误计数 SATA Error Count CRC (Write)（Indilinx芯片）"></a>D3（211）SATA主机接口CRC写入错误计数 SATA Error Count CRC (Write)（Indilinx芯片）</h3><h3 id="D4（212）写入时冲击-Shock-During-Write"><a href="#D4（212）写入时冲击-Shock-During-Write" class="headerlink" title="D4（212）写入时冲击 Shock During Write"></a>D4（212）写入时冲击 Shock During Write</h3><p>写入数据时受到受到外部机械冲击的记录。</p>
<h3 id="D4（212）SATA主机接口读取错误计数-SATA-Error-Count-Count-CRC-Read-（Indilinx芯片）"><a href="#D4（212）SATA主机接口读取错误计数-SATA-Error-Count-Count-CRC-Read-（Indilinx芯片）" class="headerlink" title="D4（212）SATA主机接口读取错误计数 SATA Error Count Count CRC (Read)（Indilinx芯片）"></a>D4（212）SATA主机接口读取错误计数 SATA Error Count Count CRC (Read)（Indilinx芯片）</h3><h3 id="DC（220）盘片偏移量-Disk-Shift"><a href="#DC（220）盘片偏移量-Disk-Shift" class="headerlink" title="DC（220）盘片偏移量 Disk Shift"></a>DC（220）盘片偏移量 Disk Shift</h3><p>硬盘中的盘片相对主轴的偏移量（通常是受外力冲击或温度变化所致），单位未知，数据值越小越好。</p>
<h3 id="DD（221）冲击错误率-G-sense-error-rate"><a href="#DD（221）冲击错误率-G-sense-error-rate" class="headerlink" title="DD（221）冲击错误率 G-sense error rate"></a>DD（221）冲击错误率 G-sense error rate</h3><p>与（BF）相同，数据值记录了硬盘受到外部机械冲击或振动导致出错的频度。</p>
<h3 id="DE（222）磁头寻道时间累计-Loaded-Hours"><a href="#DE（222）磁头寻道时间累计-Loaded-Hours" class="headerlink" title="DE（222）磁头寻道时间累计 Loaded Hours"></a>DE（222）磁头寻道时间累计 Loaded Hours</h3><p>磁头臂组件运行的小时数，即寻道电机运行时间累计。</p>
<h3 id="DF（223）磁头加载-卸载重试计数-Load-Unload-Retry-Count"><a href="#DF（223）磁头加载-卸载重试计数-Load-Unload-Retry-Count" class="headerlink" title="DF（223）磁头加载/卸载重试计数 Load/Unload Retry Count"></a>DF（223）磁头加载/卸载重试计数 Load/Unload Retry Count</h3><p>这一项与（C1）项类似，数据值累积了磁头尝试重新加载/卸载的次数。</p>
<h3 id="E0（224）磁头阻力-Load-Friction"><a href="#E0（224）磁头阻力-Load-Friction" class="headerlink" title="E0（224）磁头阻力 Load Friction"></a>E0（224）磁头阻力 Load Friction</h3><p>磁头工作时受到的机械部件的阻力。</p>
<h3 id="E1（225）主机写入数据量-Host-Writes"><a href="#E1（225）主机写入数据量-Host-Writes" class="headerlink" title="E1（225）主机写入数据量 Host Writes"></a>E1（225）主机写入数据量 Host Writes</h3><p>由于闪存的擦写次数是有限的，所以这项是固态硬盘特有的统计。Intel的SSD是每当向硬盘写入了65536个扇区，这一项的数据就＋1。如果用HDTune等软件查看SMART时可以自己计算，Intel SSD Toolbox已经为你算好了，直接就显示了曾向SSD中写入过的数据量。</p>
<h3 id="E2（226）磁头加载时间累计-Load-‘In’-time"><a href="#E2（226）磁头加载时间累计-Load-‘In’-time" class="headerlink" title="E2（226）磁头加载时间累计 Load ‘In’-time"></a>E2（226）磁头加载时间累计 Load ‘In’-time</h3><p>磁头组件运行时间的累积数，即磁头臂不在停靠区的时间，与（DE）项相似。</p>
<h3 id="E3（227）扭矩放大计数-Torque-Amplification-Count"><a href="#E3（227）扭矩放大计数-Torque-Amplification-Count" class="headerlink" title="E3（227）扭矩放大计数 Torque Amplification Count"></a>E3（227）扭矩放大计数 Torque Amplification Count</h3><p>主轴电机试图提高扭矩来补偿盘片转速变化的次数。当主轴轴承存在问题时，主轴电机会尝试增加驱动力使盘片稳定旋转。这个参数的当前值下降，说明硬盘的机械子系统出现了严重的问题。</p>
<h3 id="E4（228）断电返回计数-Power-Off-Retract-Cycle"><a href="#E4（228）断电返回计数-Power-Off-Retract-Cycle" class="headerlink" title="E4（228）断电返回计数 Power-Off Retract Cycle"></a>E4（228）断电返回计数 Power-Off Retract Cycle</h3><p>数据值累计了磁头因设备意外断电而自动返回的次数，与（C0）项相似。</p>
<h3 id="E6（230）GMR磁头振幅-GMR-Head-Amplitude"><a href="#E6（230）GMR磁头振幅-GMR-Head-Amplitude" class="headerlink" title="E6（230）GMR磁头振幅 GMR Head Amplitude"></a>E6（230）GMR磁头振幅 GMR Head Amplitude</h3><p>磁头“抖动”，即正向/反向往复运动的距离。</p>
<h3 id="E7（231）温度-Temperature"><a href="#E7（231）温度-Temperature" class="headerlink" title="E7（231）温度 Temperature"></a>E7（231）温度 Temperature</h3><p>温度的数据值直接表示了硬盘内部的当前温度，与（C2）项相同。</p>
<h3 id="E7（231）剩余寿命-SSD-Life-Left"><a href="#E7（231）剩余寿命-SSD-Life-Left" class="headerlink" title="E7（231）剩余寿命 SSD Life Left"></a>E7（231）剩余寿命 SSD Life Left</h3><p>剩余寿命是基于P/E周期与可用的备用块作出的预测。新硬盘为100；10表示PE周期已到设计值，但尚有足够的保留块；0表示保留块不足，硬盘将处于只读方式以便备份数据。</p>
<h3 id="E8（232）寿命余量-Endurance-Remaining"><a href="#E8（232）寿命余量-Endurance-Remaining" class="headerlink" title="E8（232）寿命余量 Endurance Remaining"></a>E8（232）寿命余量 Endurance Remaining</h3><p>寿命余量是指硬盘已擦写次数与设计最大可擦写次数的百分比，与（CA）项相似。</p>
<h3 id="E8（232）预留空间剩余量-Available-Reserved-Space（Intel芯片）"><a href="#E8（232）预留空间剩余量-Available-Reserved-Space（Intel芯片）" class="headerlink" title="E8（232）预留空间剩余量 Available Reserved Space（Intel芯片）"></a>E8（232）预留空间剩余量 Available Reserved Space（Intel芯片）</h3><p>对于Intel的SSD来说，前边05项提到会保留一些容量来准备替换损坏的存储单元，所以可用的预留空间数非常重要。当保留的空间用尽，再出现损坏的单元就将出现数据丢失，这个SSD的寿命就结束了。所以仅看05项意义并不大，这一项才最重要。这项参数可以看当前值，新的SSD里所有的预留空间都在，所以是100。随着预留空间的消耗，当前值将不断下降，减小到接近临界值（一般是10）时，就说明只剩下10%的预留空间了，SSD的寿命将要结束。这个与（B4）项相似。</p>
<h3 id="E9（233）通电时间累计-Power-On-Hours"><a href="#E9（233）通电时间累计-Power-On-Hours" class="headerlink" title="E9（233）通电时间累计 Power-On Hours"></a>E9（233）通电时间累计 Power-On Hours</h3><p>对于普通硬盘来说，这一项与（09）相同。</p>
<h3 id="E9（233）介质磨耗指数-Media-Wareout-Indicator（Intel芯片）"><a href="#E9（233）介质磨耗指数-Media-Wareout-Indicator（Intel芯片）" class="headerlink" title="E9（233）介质磨耗指数 Media Wareout Indicator（Intel芯片）"></a>E9（233）介质磨耗指数 Media Wareout Indicator（Intel芯片）</h3><p>由于固态硬盘的擦写次数是有限的，当到达一定次数的时候，就会出现大量的单元同时损坏，这时候预留空间也顶不住了，所以这项参数实际上表示的是硬盘设计寿命。Intel的SSD要看当前值，随着NAND的平均擦写次数从0增长到最大的设计值，这一参数的当前值从开始的100逐渐下降至1为止。这表示SSD的设计寿命已经终结。当然到达设计寿命也不一定意味着SSD就立即报废，这与闪存芯片的品质有着很大的关系。</p>
<p>注：Total Erase Count全擦写计数是指固态硬盘中所有块的擦写次数的总和，不同规格的NAND芯片以及不同容量的SSD，其最大全擦写次数均有所不同。</p>
<h3 id="F0（240）磁头飞行时间-Head-Flying-Hours-传输错误率-Transfer-Error-Rate（富士通）"><a href="#F0（240）磁头飞行时间-Head-Flying-Hours-传输错误率-Transfer-Error-Rate（富士通）" class="headerlink" title="F0（240）磁头飞行时间 Head Flying Hours / 传输错误率 Transfer Error Rate（富士通）"></a>F0（240）磁头飞行时间 Head Flying Hours / 传输错误率 Transfer Error Rate（富士通）</h3><p>磁头位于工作位置的时间。</p>
<p>富士通硬盘表示在数据传输时连接被重置的次数。</p>
<h3 id="F1（241）LBA写入总数-Total-LBAs-Written"><a href="#F1（241）LBA写入总数-Total-LBAs-Written" class="headerlink" title="F1（241）LBA写入总数 Total LBAs Written"></a>F1（241）LBA写入总数 Total LBAs Written</h3><p>LBA写入数的累计。</p>
<h3 id="F1（241）写入剩余寿命-Lifetime-Writes-from-Host"><a href="#F1（241）写入剩余寿命-Lifetime-Writes-from-Host" class="headerlink" title="F1（241）写入剩余寿命 Lifetime Writes from Host"></a>F1（241）写入剩余寿命 Lifetime Writes from Host</h3><p>自硬盘启用后主机向硬盘写入的数据总量，以4个字节表示，每写入64GB字节作为一个单位。</p>
<h3 id="F2（242）LBA读取总数-Total-LBAs-Read"><a href="#F2（242）LBA读取总数-Total-LBAs-Read" class="headerlink" title="F2（242）LBA读取总数 Total LBAs Read"></a>F2（242）LBA读取总数 Total LBAs Read</h3><p>LBA读取数的累计。某些SMART读取工具会显示负的数据值，是因为采用了48位LBA，而不是32位LBA。</p>
<h3 id="F2（242）读取剩余寿命-Lifetime-Reads-from-Host"><a href="#F2（242）读取剩余寿命-Lifetime-Reads-from-Host" class="headerlink" title="F2（242）读取剩余寿命 Lifetime Reads from Host"></a>F2（242）读取剩余寿命 Lifetime Reads from Host</h3><p>自硬盘启用后主机从硬盘读取的数据总量，以4个字节表示，每读取64GB字节作为一个单位。</p>
<h3 id="FA（250）读取错误重试率-Read-Error-Retry-Rate"><a href="#FA（250）读取错误重试率-Read-Error-Retry-Rate" class="headerlink" title="FA（250）读取错误重试率 Read Error Retry Rate"></a>FA（250）读取错误重试率 Read Error Retry Rate</h3><p>从磁盘上读取时出错的次数。</p>
<h3 id="FE（254）自由坠落保护-Free-Fall-Protection"><a href="#FE（254）自由坠落保护-Free-Fall-Protection" class="headerlink" title="FE（254）自由坠落保护 Free Fall Protection"></a>FE（254）自由坠落保护 Free Fall Protection</h3><p>现在有些笔记本硬盘具有自由坠落保护功能，当硬盘内置的加速度探测装置检测到硬盘位移时，会立即停止读写操作，将磁头臂复位。这个措施防止了磁头与盘片之间发生摩擦撞击，提高了硬盘的抗震性能。这个参数的数据里记录了这一保护装置动作的次数。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/28/jdk-juc-%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/28/jdk-juc-%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">并发集合框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-28 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-28T00:00:00+08:00">2024-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 14:38:18" itemprop="dateModified" datetime="2025-04-27T14:38:18+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="并发安全-Map"><a href="#并发安全-Map" class="headerlink" title="并发安全 Map"></a>并发安全 Map</h2><p><code>ConcurrentSkipListMap</code>: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="JDK-1-7-Segment-ReentrantLock"><a href="#JDK-1-7-Segment-ReentrantLock" class="headerlink" title="JDK 1.7: Segment(ReentrantLock)"></a>JDK 1.7: Segment(ReentrantLock)</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java7_concurrenthashmap.png" alt="Java7 ConcurrentHashMap 存储结构"></p>
<p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，</p>
<p>JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 继承自 <code>ReentrantLock</code>。每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p>
<ul>
<li><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</li>
<li><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 数组属于链表结构。</li>
</ul>
<p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</p>
<p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>
<p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>
<p>JDK 1.7 最大并发度是 Segment 的个数，默认是 16</p>
<h4 id="JDK-1-8-Node-CAS-synchronized"><a href="#JDK-1-8-Node-CAS-synchronized" class="headerlink" title="JDK 1.8: Node+CAS+synchronized"></a>JDK 1.8: Node+CAS+synchronized</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构"></p>
<p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是<mark>直接用 <code>Node</code></mark> 数组+链表+红黑树的数据结构来实现，并发控制使用 <mark><code>synchronized</code> 和 CAS</mark> 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
<p>JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p>
<ul>
<li><p>每个 <strong>桶（bucket）</strong> 对应一个链表或红黑树，用于解决<strong>哈希冲突</strong>。</p>
</li>
<li><p>如果链表长度超过一定阈值（默认为 8），链表会自动转换为<strong>红黑树</strong>，提高查询效率。</p>
</li>
<li><p>红黑树的情况需要使用 <code>TreeNode</code>。当冲突链表达到一定长度时，链表会转换成红黑树。<code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p>
</li>
</ul>
<p>JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p>
<p><strong>链表的线程安全性</strong> </p>
<p>在 <strong>ConcurrentHashMap</strong> 中，链表本身不是直接加锁的，而是通过更细粒度的<strong>CAS（Compare-And-Swap）机制</strong>和<strong>自旋锁</strong>来保证线程安全：</p>
<ol>
<li><strong>插入节点</strong>时通过 CAS 更新表头或表尾。</li>
<li><strong>查询节点</strong>时允许并发读操作，而不会阻塞其他线程。</li>
<li><strong>扩容操作</strong>采用链表迁移的方式，通过分段迁移减少阻塞时间。</li>
</ol>
<h4 id="不保证复合操作原子性"><a href="#不保证复合操作原子性" class="headerlink" title="不保证复合操作原子性"></a>不保证复合操作原子性</h4><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！</p>
<p>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作，例如先判断某个键是否存在<code>containsKey(key)</code>，然后根据结果进行插入或更新<code>put(key, value)</code>。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p><code>Hashtable</code>(同一把锁) :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低</p>
<h2 id="并发安全-List"><a href="#并发安全-List" class="headerlink" title="并发安全 List"></a>并发安全 List</h2><h3 id="线程不安全-ArrayList"><a href="#线程不安全-ArrayList" class="headerlink" title="线程不安全 ArrayList"></a>线程不安全 ArrayList</h3><p>我们通常使用的ArrayList就是线程不安全的，举个简单的例子</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestList</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并发修改异常</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;4&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">   at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">   at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">   at java.util.AbstractCollection.toString(AbstractCollection.java:<span class="number">461</span>)</span><br><span class="line">   at java.lang.String.valueOf(String.java:<span class="number">2994</span>)</span><br><span class="line">   at java.io.PrintStream.println(PrintStream.java:<span class="number">821</span>)</span><br><span class="line">   at com.hnguigu.<span class="keyword">unsafe</span>.TestList.lambda$main$<span class="number">0</span>(TestList.java:<span class="number">20</span>)</span><br><span class="line">   at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案，有以下几种！</strong></p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">concurrent</span>.<span class="property">CopyOnWriteArrayList</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestList</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * 1. List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                list.<span class="title function_">add</span>(<span class="variable constant_">UUID</span>.<span class="title function_">randomUUID</span>().<span class="title function_">toString</span>().<span class="title function_">substring</span>(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(list);</span><br><span class="line">            &#125;,<span class="title class_">String</span>.<span class="title function_">valueOf</span>(i)).<span class="title function_">start</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种通用优化策略。</p>
<p>CopyOnWrite容器即写入时复制的容器。<strong>通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</strong>这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据。CopyOnWrite并发容器用于读多写少的并发场景。</p>
<blockquote>
<p>CopyOnWriteArrayList 比 Vector 厉害在哪里？</p>
</blockquote>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224114551267-580082797.png" alt="CopyOnWrite"></p>
<p>CopyOnWriteArrayList底层采用了Lock锁，是JDK层面的，效率高！</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221223214340940-165732240.png" alt="VectorSource"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ul>
<li>CopyOnWriteArrayList 并发安全且性能比 Vector 好。Vector 是增删改查方法都加了synchronized 来保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而 CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于 Vector。</li>
<li>线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据一致性问题。这种实现只是保证数据的<strong>最终一致性</strong>，不能保证数据的<strong>实时一致性</strong>。在添加到拷贝数据而还没进行替换的时候，读到的仍然是旧数据。</li>
<li>内存占用问题。如果对象比较大，内存写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。 这个时候，我们应该考虑其他的容器，例如 ConcurrentHashMap。</li>
<li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点 多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种 操作分分钟引起故障。</li>
</ul>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector底层采用了Synchronized加锁的方式，保证了数据的安全性，但是效率低下！</p>
<p>解释一下：Synchronized是Java内置的机制，是JVM层面的，效率低是因为底层操作依赖于操作系统，操作系统切换线程要从用户态切换到内核态，花费很多时间。</p>
<h2 id="并发安全-Set"><a href="#并发安全-Set" class="headerlink" title="并发安全 Set"></a>并发安全 Set</h2><h3 id="线程不安全-HashSet"><a href="#线程不安全-HashSet" class="headerlink" title="线程不安全 HashSet"></a>线程不安全 HashSet</h3><p>Set和List同样是多线程下不安全的集合类，同样会报并发修改异常！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSet</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="keyword">set</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSet</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * set集合没有可替换的集合</span></span><br><span class="line"><span class="comment">         * 1. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 2. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;String&gt; <span class="keyword">set</span> = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="keyword">set</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和面试官谈到这里，一般都会问hashSet的底层实现原理。<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224125000674-1551081400.png" alt="hashSetSource"></p>
<p>底层其实就是用hashMap实现的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224125144809-649163275.png" alt="hashSetAdd"></p>
<p>HashSet底层使用了哈希表来支持的，特点：存储快 往HashSet添加元素的时候，HashSet会先调用元素的HashCode方法得到元素的哈希值，然后通过元素的哈希值经过异或移位等运算，就可以算出该元素在哈希表中的存储位置。如果算出的元素存储的位置目前没有任何元素存储，那么该元素可以直接存储在该位置上；如果算出的元素的存储位置上目前已经有了其他的元素，那么还会调用该元素的equals方法 ，与该位置的元素进行比较一次，如果过equals方法返回的是true，那么该位置上的元素就会被视为重复元素，不允许被添加，如果false，则允许添加。</p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>BlockingQueue</code> 是 Java 并发包（<code>java.util.concurrent</code>）中的一个接口，专门用于<strong>线程安全的生产者-消费者模型</strong>。它支持线程在队列为空或已满时自动阻塞，从而简化了多线程编程中的同步问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/arrayblockingqueue-class-diagram.png" alt="ArrayBlockingQueue 类图"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>线程安全：<ul>
<li>内部使用锁和条件变量（Condition）实现线程安全操作。</li>
</ul>
</li>
<li>阻塞机制：<ul>
<li>当队列为空时，获取元素的线程会被阻塞，直到队列中有可用元素。</li>
<li>当队列已满时，添加元素的线程会被阻塞，直到队列有空间。</li>
</ul>
</li>
<li>常用场景：<ul>
<li><strong>生产者-消费者模型</strong>，生产者向队列中添加数据，消费者从队列中取数据。</li>
<li>控制线程执行顺序或流量，避免资源争抢。</li>
</ul>
</li>
</ol>
<p><code>BlockingQueue</code>: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><code>ArrayBlockingQueue</code> </p>
<ul>
<li><strong>best performance</strong> </li>
<li>单lock 双condition 算法，必须显式设置容量</li>
<li>底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。</li>
</ul>
<p><code>LinkedBlockingQueue</code> / <code>LinkedBlockingDeque</code></p>
<ul>
<li>2 locks 2 conditions，默认Integer.MAX_VALUE</li>
<li>底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。</li>
</ul>
<p><code>SynchronousQueue</code></p>
<ul>
<li>每次插入操作必须等待一个取出操作，否则就会阻塞，适合高并发传递数据。</li>
<li>不允许null</li>
<li>本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。</li>
</ul>
<p><code>DelayQueue</code></p>
<ul>
<li>延时队列，只有到期的元素才能被取出，适合定时任务或延迟执行场景。</li>
<li>elements must implement <code>java.util.concurrent.Delayed</code> </li>
</ul>
<p><code>LinkedTransferQueue</code></p>
<ul>
<li>waits for consumer to consume the element (message passing need to be guaranteed)</li>
</ul>
<p><code>ConcurrentLinkedQueue</code>:</p>
<ul>
<li>高效的并发队列，使用链表实现。一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li>
</ul>
<p><code>PriorityBlockingQueue</code></p>
<ul>
<li>concurrent version of <code>PriorityQueue</code></li>
<li>无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</li>
<li>基于优先级堆实现的无界阻塞队列，元素按优先级排序，不保证 FIFO。</li>
</ul>
<h3 id="主要方法-put-take-offer-poll"><a href="#主要方法-put-take-offer-poll" class="headerlink" title="主要方法: put-take offer-poll"></a>主要方法: put-take offer-poll</h3><p>add、remove实际上是对offer的封装</p>
<ul>
<li><strong>插入元素：</strong><ul>
<li><code>put(E e)</code>：如果队列已满，阻塞等待空间。</li>
<li><code>offer(E e)</code>: 非阻塞插入<ul>
<li><code>offer(E e, long timeout, TimeUnit unit)</code>：带自旋的非阻塞插入</li>
</ul>
</li>
</ul>
</li>
<li><strong>取出元素：</strong> <ul>
<li><code>take()</code>：如果队列为空，阻塞等待数据。</li>
<li><code>poll()</code>: 非阻塞获取<ul>
<li><code>poll(long timeout, TimeUnit unit)</code>：带自旋的非阻塞获取</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查队列状态：</strong><ul>
<li><code>size()</code>：返回当前元素数量。</li>
<li><code>remainingCapacity()</code>：返回剩余可用空间。</li>
</ul>
</li>
<li>队列数据迁移<ul>
<li><code>int elemCount = queue.drainTo(list);</code></li>
<li> <code>drainTo</code> 会一次性将队列中所有元素存放到列表，如果队列中有元素，且成功存到 list 中则 <code>drainTo</code> 会返回本次转移到 list 中的元素数，若队列为空，<code>drainTo</code> 则直接返回 0</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    queue.put(i); <span class="comment">// 阻塞插入</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> queue.take(); <span class="comment">// 阻塞获取</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>实际上就是生产者——消费者模式的具体实现</p>
<p>加锁访问共享区域，阻塞使用的是和锁相关的condition条件变量，细化了等待条件</p>
<p>condition.await    condition.signal/signalAll   就是使用了这个细节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE <span class="number">8</span></span><br><span class="line"><span class="type">int</span> buffer[MAXSIZE];</span><br><span class="line"><span class="type">int</span> <span class="variable">fill_ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">use_ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">	fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> buffer[use_ptr];</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">cond_t notEmpty,notFull;</span><br><span class="line">mutex_t mutex;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == MAXSIZE)</span><br><span class="line">            cond_wait(&amp;notEmpty, &amp;mutex);</span><br><span class="line">    	put(i);</span><br><span class="line">        printf(<span class="string">&quot;producer:%d puts value:%d&quot;</span>, gettid(), i);</span><br><span class="line">        cond_signal((&amp;notFull);</span><br><span class="line">    	mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">            cond_wait(&amp;isEmpty, &amp;mutex);</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> get();</span><br><span class="line">        printf(<span class="string">&quot;pid:%d gets value:%d&quot;</span>, gettid(), value);</span><br><span class="line">        cond_signal(&amp;isFull);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                    </span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/24/digital-80%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/24/digital-80%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">如何定位端口占用问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-24 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-24T00:00:00+08:00">2024-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:47:08" itemprop="dateModified" datetime="2025-05-08T13:47:08+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">数码</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>80端口占用问题</p>
<p>找到占用者，其pid为4</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025203515838.png" alt="image-20241025203515838"></p>
<p>根据pid找到其名为System，不能直接taskKill</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025203538420.png" alt="image-20241025203538420"></p>
<p>netsh http show servicestate</p>
<p>发现是defaultAppPool在占用，控制器进程的pid为4671</p>
<p>任务管理器中找到4671，发现是iis Publishing 服务，禁用</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/20/redis-review-optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/20/redis-review-optimization/" class="post-title-link" itemprop="url">redis-review 项目优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-20T00:00:00+08:00">2024-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-16 22:09:00" itemprop="dateModified" datetime="2025-05-16T22:09:00+08:00">2025-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="redis-review"><a href="#redis-review" class="headerlink" title="redis-review"></a>redis-review</h1><p>配置环境： Nginx + SpringBoot + RabbitMQ + Redis</p>
<h2 id="redis-key-设计"><a href="#redis-key-设计" class="headerlink" title="redis key 设计"></a>redis key 设计</h2><p>STRING </p>
<ul>
<li><code>sign:&#123;userId&#125;:202411</code> 2024年11月的userId的签到信息 （bitmap）</li>
<li><code>incr:order:2024:11:10</code> 2024年11月10号的订单序列号serialNumber，唯一id（timestamp&lt;&lt;32 | serialNumber）</li>
<li><code>seckill:stock:&#123;voucherId&#125;</code> voucherId的优惠券对应的库存</li>
<li><code>cache:shop:&#123;shopId&#125;</code> shopId的商铺信息</li>
<li><code>login:code:&#123;phoneNumber&#125;</code> 验证码信息</li>
</ul>
<p>LIST </p>
<ul>
<li><code>cache:shoptype</code>（商铺类型信息JSON数组）</li>
</ul>
<p>ZSET </p>
<ul>
<li><p><code>shop:geo:&#123;shopId&#125;</code> 商铺地理位置信息</p>
</li>
<li><p><code>blog:liked:&#123;blogId&#125;</code> blogId的博客点赞信息，包括userId 以及对应的score（unix时间）</p>
</li>
<li><p><code>feed:&#123;userId&#125;</code> userId 的收件箱，保存笔记时推送到所有粉丝（看看谁follow了我）包括了 blogId 以及对应的score </p>
</li>
</ul>
<p>SET</p>
<ul>
<li><code>follows:&#123;userId&#125;</code> userId 关注的人</li>
<li><code>seckill:order:&#123;voucherId&#125;</code> 抢过voucherId的优惠券的人的集合</li>
</ul>
<p>HASH </p>
<ul>
<li><code>login:token:&#123;token&#125;</code> 存储token对应的userDTO </li>
</ul>
<h2 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h2><p>blog blog评论 关注的人(x在t时间关注了y) 用户表 </p>
<p>商铺 商铺类别</p>
<p>券 秒杀券 秒杀券订单</p>
<h2 id="热key-大key"><a href="#热key-大key" class="headerlink" title="热key 大key"></a>热key 大key</h2><p>在处理热key、大key以及分表问题时，可以采用以下策略进行优化：</p>
<p>• <strong>热Key</strong>：多级缓存 + 分片 + 异步更新。<br>• <strong>大Key</strong>：拆分 + 异步删除 + 设计规避。<br>• <strong>分表</strong>：合理分片规则 + 中间件 + 缓存加速。<br>• <strong>监控</strong>：实时监控Key大小和QPS，提前预防问题。</p>
<h3 id="热Key处理方案"><a href="#热Key处理方案" class="headerlink" title="热Key处理方案"></a>热Key处理方案</h3><ol>
<li><p><strong>监控与识别</strong><br>• 使用Redis监控工具（如<code>redis-cli --hotkeys</code>、<code>MONITOR</code>命令）或APM系统（如Prometheus）识别高频访问的key。<br>• 业务侧预判热点（如秒杀商品ID、热门话题），提前介入优化。</p>
</li>
<li><p><strong>多级缓存</strong><br>• <strong>本地缓存</strong>：结合Guava Cache或Caffeine，将热key缓存在应用服务器本地，减少Redis压力。<br>• <strong>分布式缓存冗余</strong>：复制热key到多个Redis实例（如<code>key:1</code>, <code>key:2</code>），通过随机访问分散压力。</p>
</li>
<li><p><strong>缓存续期与互斥锁</strong><br>• <strong>逻辑过期</strong>：Value中存储过期时间，异步更新缓存，避免物理过期后大量请求穿透到DB。<br>• <strong>互斥锁（Mutex Lock）</strong>：缓存失效时，仅允许一个线程重建数据，其他线程等待或返回降级结果。</p>
</li>
<li><p><strong>读写分离与分片</strong><br>• 使用Redis Cluster或Codis分片，分散热key压力。<br>• 读写分离：通过从节点处理读请求，主节点处理写请求。</p>
</li>
</ol>
<h3 id="大Key处理方案"><a href="#大Key处理方案" class="headerlink" title="大Key处理方案"></a>大Key处理方案</h3><ol>
<li><p><strong>拆分与分片</strong><br>• <strong>横向拆分</strong>：将大Hash/List按字段或元素拆分（如<code>user:1000:info</code>拆为<code>user:1000:base</code>、<code>user:1000:contact</code>）。<br>• <strong>分片存储</strong>：对Key添加分片后缀（如<code>user:&#123;id%10&#125;:profile</code>），分散存储。</p>
</li>
<li><p><strong>异步删除</strong><br>• 使用<code>UNLINK</code>替代<code>DEL</code>，非阻塞删除大Key。<br>• 渐进式删除：通过脚本分批删除Hash/Set元素（如<code>HSCAN</code>遍历删除）。</p>
</li>
<li><p><strong>压缩与存储优化</strong><br>• 序列化优化：使用Protobuf或MessagePack替代JSON。<br>• 冷热分离：将大Key中低频数据存入MySQL/HBase，高频数据保留在Redis。</p>
</li>
<li><p><strong>设计规避</strong><br>• 避免单个Key存储超过1MB的数据。<br>• 使用HyperLogLog替代大Set统计UV，或使用TimeSeries存储时序数据。</p>
</li>
</ol>
<h3 id="分表方案（以MySQL为例）"><a href="#分表方案（以MySQL为例）" class="headerlink" title="分表方案（以MySQL为例）"></a>分表方案（以MySQL为例）</h3><ol>
<li><p><strong>水平分表</strong><br>• <strong>规则分片</strong>：按哈希（如<code>user_id % 100</code>）、范围（如时间戳）或一致性哈希拆分数据。<br>• <strong>中间件</strong>：使用ShardingSphere、Vitess等工具自动路由查询。</p>
</li>
<li><p><strong>垂直分表</strong><br>• 将大表按列拆分（如用户基础信息表<code>user_base</code>与扩展信息表<code>user_extend</code>），减少单行数据量。</p>
</li>
<li><p><strong>全局ID与查询优化</strong><br>• 分布式ID生成（雪花算法、Redis自增ID）避免主键冲突。<br>• 冗余字段或索引表：通过异步维护冗余字段（如商户ID+订单ID）支持多维度查询。</p>
</li>
<li><p><strong>结合Redis</strong><br>• 缓存分表路由信息（如<code>user_shard:1000 -&gt; shard_2</code>），加速查询。<br>• 热数据缓存：将分表后的热数据单独缓存，降低DB压力。</p>
</li>
</ol>
<h3 id="Redis分片与集群"><a href="#Redis分片与集群" class="headerlink" title="Redis分片与集群"></a>Redis分片与集群</h3><ol>
<li><p><strong>Redis Cluster</strong><br>• 自动分片（16384 slots），支持水平扩展和高可用。<br>• 通过<code>CRC16(key) % 16384</code>计算slot，分散数据。</p>
</li>
<li><p><strong>客户端分片</strong><br>• 使用一致性哈希算法（如Jedis的<code>ShardedJedis</code>）在客户端路由请求。</p>
</li>
<li><p><strong>Proxy方案</strong><br>• 通过Twemproxy或Codis代理层管理分片，对业务透明。</p>
</li>
</ol>
<h1 id="项目剖析"><a href="#项目剖析" class="headerlink" title="项目剖析"></a>项目剖析</h1><h2 id="Login-Redis-Token"><a href="#Login-Redis-Token" class="headerlink" title="Login (Redis Token)"></a>Login (Redis Token)</h2><ol>
<li><p>短信登录的短信怎么发送的?</p>
<p>（使用hutool生成的随机六位数验证码）</p>
</li>
<li><p>如何标识用户</p>
<p>（主要是唯一的id主键，而登录靠的是也是唯一的手机号）</p>
</li>
<li><p>项目的权限刷新什么意思</p>
<p>（token具有ttl期，用户如果浏览网页就会刷新其ttl）</p>
</li>
</ol>
<p><strong>原来</strong>：tomcat 的 HttpSession 是集中的，如果要扩展的话同步是一个大问题，并且可能过多占用服务器的内存。</p>
<p><strong>改进</strong>：<mark>Redis Token</mark>是分布式的，天生不存在同步问题。</p>
<ul>
<li><strong>Redis</strong>：使用 Hash 数据结构—— KEY: token:xxxxxxxx, VALUE: UserDTO的字段信息</li>
<li><strong>拦截器</strong>：配置到需要拦截器的地方（个人中心等位置）根据请求头里的 token 查到对应的UserDTO，将其放入<mark>ThreadLocal</mark>，放行，同时也会刷新 token 有效期。<mark>核心方法：preHandle + afterCompletion</mark><ul>
<li>ThreadLocal 使用：<code>get()</code>,<code>set()</code> 在finally块调用<code>remove()</code> 用途 Spring 数据库连接、事务管理</li>
<li>内存泄露：每个线程有个 Map，键是 tl（弱引用），值是对应的值（强引用），如果线程没有销毁，但是 tl 销毁了，就容易泄露内存。</li>
</ul>
</li>
<li><strong>问题</strong>：访问别的页面也需要刷新，不然不浏览那些需要拦截器的页面就不会刷新token，莫名其妙就会过期</li>
<li><strong>解决</strong>：新加一个拦截器，负责查token、保存到tl、刷新，放行所有。原先的拦截器只负责从tl查询用户，tl 里没有就拒绝</li>
<li><strong>其他缺点</strong>：仍然依赖内存（redis是内存数据库） + redis接口调用会增加复杂性。需要注意的是，虽然这种方式支持分布式系统，但是根本上还是和 HttpSession 一样的<strong>中心化</strong>。</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320764547.png" alt="优化拦截器" style="zoom:33%;" />

<p>JWT：去中心化，服务端压力减小，便于分布式系统使用。基本信息可直接放在token中。功能权限较少可以直接放在token中，用bit位表示用户所具有的功能权限。但是缺点也很明显，签发以后就不能主动让其失效，拿到了就可以进行重放攻击。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>使用 Redis 作为商户信息缓存，避免大量请求直接打到数据库引发宕机，采取<mark>主动更新、旁路缓存</mark>的方法保证数<br>据库与 Redis 之间的缓存一致性问题。使用<mark>布隆过滤器</mark>解决商户信息的缓存穿透问题，使用 <strong>Redis 集群</strong>等方式减<br>小缓存雪崩的概率，使用<mark>逻辑过期</mark>解决缓存击穿。</p>
<p><strong>内存更新</strong>：</p>
<ul>
<li>内存淘汰机制和TTL（对于低一致性场景）</li>
<li><mark>主动更新</mark>：编写业务逻辑，修改数据库的同时操作缓存，解决一致性问题。（对于高一致性场景）✅</li>
</ul>
<p><strong>一致性解决方案</strong>：</p>
<ul>
<li><strong>cache aside 旁路缓存</strong> 编码使用客户端自行将数据写入cache ✅ 适合读多写少</li>
<li>读写穿透：封装了旁路缓存功能，其工作由cache层的服务自动完成，但是redis并不支持写入db</li>
<li>异步缓存写入：只操作cache，其他线程异步写到db。一般是写密集允许短暂的数据不一致</li>
</ul>
<p><strong>Cache Aside</strong>：</p>
<ul>
<li>选择删除cache，<em>更新导致的无效写比较多（更新多次但只有最后一次被查询），并且线程安全问题难以解决：<strong>要求数据库和缓存写入都要成功</strong>，此时有可能A更新到v1，线程B突然插进来把缓存更新到v2，最后A把脏数据v1更新到缓存，如果缓存更新涉及多表的查询就更加难以维护。</em> <strong>cache删除和db更新放入一个事务</strong></li>
<li><strong>删缓存、更新db的先后顺序</strong>：读未命中、更新操作的互相穿插<ul>
<li>选择先更新db后删除cache。导致不一致的情况：读未命中的过程中插进来一个更新操作，最后缓存里是旧数据</li>
<li><em>如果反过来，先删cache，更新db过程中进来一个查询的又把旧数据填充到缓存里，最后导致db和cache不一致。</em></li>
</ul>
</li>
<li><strong>如果缓存删除失败怎么办</strong>？（异步重试）<ul>
<li>单机可用线程池重试，分布式用MQ</li>
<li><strong>延迟双删：删完之后，隔段时间再尝试删一次。</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>解决方案</strong></th>
<th><strong>适用性</strong></th>
</tr>
</thead>
<tbody><tr>
<td>瞬时故障</td>
<td>同步重试（3次以内）</td>
<td>低并发，容忍短暂阻塞</td>
</tr>
<tr>
<td>缓存服务不稳定</td>
<td>异步队列 + 重试（最终一致性）</td>
<td>高并发，要求最终一致</td>
</tr>
<tr>
<td>长期不可用</td>
<td>降级读数据库 + 告警</td>
<td>高一致性要求场景</td>
</tr>
<tr>
<td>无法接受任何不一致</td>
<td>版本号校验 + 同步双写</td>
<td>金融、交易等强一致性场景</td>
</tr>
</tbody></table>
<ul>
<li><strong>如果删除失败以后读脏数据怎么办</strong>？<ul>
<li>写入标记+短ttl：删除失败之后写入一个特殊的key，短ttl，标记这个缓存可能不准确，然后在正常读缓存逻辑之前加上if判断即可，遇到特殊key就直读数据库，统计缓存失败率，可以据此熔断。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>解决方案</strong></th>
<th><strong>适用性</strong></th>
</tr>
</thead>
<tbody><tr>
<td>短暂删除失败（网络抖动）</td>
<td><strong>标记待修复</strong> + 读取时主动修复</td>
<td>高并发，允许短暂不一致</td>
</tr>
<tr>
<td>长期缓存服务不可用</td>
<td>熔断降级 + 直读数据库</td>
<td>强一致性要求场景</td>
</tr>
<tr>
<td>数据版本频繁变更</td>
<td><strong>版本号校验</strong> + 异步补偿任务</td>
<td>金融、订单等关键业务</td>
</tr>
<tr>
<td>灰度验证修复效果</td>
<td>流量染色 + 强制对比</td>
<td>需要验证缓存一致性的场景</td>
</tr>
</tbody></table>
<p><mark>缓存穿透和缓存击穿都实现在 <strong>CacheClient</strong> 中</mark></p>
<p><strong>缓存穿透</strong>：恶意查询db里不存在的数据，导致db崩溃</p>
<ul>
<li>缓存空对象设置ttl：实现简单，维护方便。<em>造成短期的不一致，额外内存消耗。</em> <ul>
<li>适合空key数目可控的场景，支持动态更新</li>
</ul>
</li>
<li><strong>布隆过滤器</strong>：内存占用较少，没有多余key。<em>实现复杂，可能误判。</em>   本项目使用 Guava 实现。<ul>
<li>适合海量数据，且需要高效拦截绝对不存在的请求时（如用户注册校验）需要预先初始化 @PostConstruct </li>
<li>容量由bitmap大小与哈希函数数量决定，可能会满，满了以后可以扩容，可以业务层兜底（比如缓存空对象）。</li>
<li>删除、扩容：不支持。</li>
<li><strong>计数布隆过滤器</strong>(Counting Bloom Filter): 用空间复杂度换来删除功能，bit改为计数器，查询时所有位置的计数器都大于0才算存在。插入时在所有位置加1，删除时在所有位置减1，只要有一个归0就认定其不存在。</li>
<li><strong>布谷鸟过滤器</strong>(Cuckoo Filter): <strong>指纹</strong>使用抗碰撞性强的哈希函数计算哈希值后截取低位获得。使用<strong>桶数组</strong>存储指纹，一个桶存四个指纹(连续,cpucache)。使用与当前指纹的哈希值异或的方式计算出另一个指纹副本的桶索引。<ul>
<li>插入时，第一个桶索引 i1= hash(x) 计算，第二个桶索引 i2 = i1 ⊕ hash(fingerprint(x))。桶只要有一个空位就可以插入，如果直接和指纹本身异或，在指纹跟桶数组大小差距悬殊时两个桶离得较近不利于均匀分布。如果没有空位就从其中挑一个指纹 f’ 迁出然后迁入，对于f’我们直接使用当前的桶索引和 f’ 进行异或就能计算出就能 f’ 备用桶的位置。</li>
<li>查询时，看两个桶里面是否存在 x 的指纹，有指纹就算存在。删除时，从两个桶里删除匹配的指纹。</li>
<li>降低误判率：增大指纹长度，减小桶的尺寸</li>
<li>大多数情况下，选择2个哈希函数，桶的尺寸选择4，能够达到最佳或接近最佳的空间效率的假阳性率。</li>
</ul>
</li>
<li>动态数据集应该预防写满，或者使用多级过滤，例如使用 HashSet 过滤高频数据，然后用BF处理长尾数据</li>
<li>可以使用功能更加强大的 RedisBloom</li>
</ul>
</li>
</ul>
<p><strong>缓存击穿</strong>：一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。常见的解决方案有两种：</p>
<ul>
<li>互斥锁 MUTEX。线程 1 未命中，拿到锁去<strong>同步地重建缓存</strong>，线程 2 此时也紧随其后，拿不到锁就重复查询缓存。直到重建完成，线程 2 就能拿到重建的缓存值。优点是<strong>一致性可以确保</strong>，缺点是重建期间其他的线程会一直<strong>同步递归调用</strong>。</li>
<li>逻辑过期 LOGICAL EXPIRE。不存在未命中情况，发现过期就拿到锁然后提交一个重建缓存的任务（异步重建完之后finally释放锁），然后直接返回旧值。优点是<strong>响应比较快</strong>，是非阻塞的，缺点是一致性受影响。</li>
</ul>
<p><strong>缓存雪崩</strong>：同一时段大量的缓存key同时失效或redis宕机</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><h3 id="RestControllerAdvice-和-ExceptionHandler"><a href="#RestControllerAdvice-和-ExceptionHandler" class="headerlink" title="@RestControllerAdvice 和 @ExceptionHandler"></a>@RestControllerAdvice 和 @ExceptionHandler</h3><p>对于更简单的异常处理，推荐使用 <code>@RestControllerAdvice</code>：所有方法默认返回 JSON，等价于自动添加 <code>@ResponseBody</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalApiExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动返回 JSON，无需 @ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(UserNotFoundException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleUserNotFound</span><span class="params">(UserNotFoundException ex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(ex.getMessage(), <span class="number">404</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更灵活的控制：自定义状态码和响应体</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ValidationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleValidationError</span><span class="params">(ValidationException ex)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(ex.getMessage(), <span class="number">400</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest().body(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ul>
<li><strong>执行顺序</strong>：解析器按注册顺序执行。返回非空 <code>ModelAndView</code> 时终止处理。</li>
<li><strong>默认解析器</strong>：使用 <code>extendHandlerExceptionResolvers</code> 避免覆盖Spring默认解析器（如处理<code>@ExceptionHandler</code>的解析器）。</li>
<li><strong>与Spring Boot整合</strong>：在Spring Boot中，可结合 <code>@ControllerAdvice</code> 和 <code>ErrorController</code> 进行全局处理。</li>
</ul>
<h3 id="Result-封装"><a href="#Result-封装" class="headerlink" title="Result 封装"></a>Result 封装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">true</span>, <span class="literal">null</span>, data, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(List&lt;?&gt; data, Long total)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">true</span>, <span class="literal">null</span>, data, total);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fail</span><span class="params">(String errorMsg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">false</span>, errorMsg, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="秒杀抢购"><a href="#秒杀抢购" class="headerlink" title="秒杀抢购"></a>秒杀抢购</h2><p>• 使用乐观锁避免秒杀券超卖，同时提高并发。通过控制事务的粒度以及动态代理保证事务的有效性。使用 Lua 脚本解决秒杀券更新的原子性问题。 Redisson 分布式 锁解决集群环境下一人一单可能导致的并发安全问题。在 3000 并发测试中成功拦截 100%的重复请求</p>
<h3 id="乐观锁-防止超卖"><a href="#乐观锁-防止超卖" class="headerlink" title="乐观锁 防止超卖"></a>乐观锁 防止超卖</h3><p><strong>做完&gt;0库存判断之后：</strong></p>
<ul>
<li>原来：不检查直接扣【超卖】</li>
<li>改进1：扣减时的库存必须跟原来一样才成功。（类似于版本号）【成功率太低】</li>
<li>改进2：只要大于0就可以进行扣减。</li>
</ul>
<h3 id="一人一单（订单接口的幂等性）"><a href="#一人一单（订单接口的幂等性）" class="headerlink" title="一人一单（订单接口的幂等性）"></a>一人一单（订单接口的幂等性）</h3><ol>
<li><p>订单接口的幂等性是怎么做的？</p>
<p>（意思就是post请求带着：一个用户id，一个优惠卷id。发送多次请求，如何保证只有一个成功，也就是一人一单，订单做成唯一id）还有一种方法是新加一个状态字段。</p>
</li>
<li><p>库存扣减之后，还要去insert一个新的订单，你是如何保存这个的一致性的？<code>createOrder(order)</code></p>
<p>（使用spring自带的事务，将其放到一个事务里 @Transactional，注意事务有效性）</p>
</li>
<li><p>抢优惠券没有及时处理怎么办?</p>
<p>（通知用户已经抢了，延迟推送结果）</p>
</li>
<li><p>抢优惠券处理完了如何通知用户？</p>
<p>（没有通知，实际的业务还是基于DB的，使用券的时候db里没有就是没有，db处理完了自然就能用了）</p>
</li>
<li><p>秒杀场景下扣减库存太慢了怎么办？</p>
<p>（数据库集群，分库分表，索引优化，Redis热key，大key，Redis缓存过小）</p>
</li>
</ol>
<h4 id="单机解决方案"><a href="#单机解决方案" class="headerlink" title="单机解决方案"></a>单机解决方案</h4><ul>
<li>原来：一人n单过来之后，一开始都还没有订单，问题还是一样。</li>
<li>改进1：变成同步方法以后锁太大 createVoucherOrder()</li>
<li>改进2：使用this作为锁缩小范围，this获取的是服务对象，只要获得了服务对象就要参与竞争，导致所有人都参与竞争</li>
<li>改进3：使用userId.toString().intern()作为锁对象锁住一人一单的判断逻辑，但是锁在事务内部会导致事务尚未提交锁就已经释放，所以应该在 createVoucherOrder() 外部进行加锁。</li>
<li>改进4：上方依然有问题，因为直接调用实例方法默认是使用this.createVoucherOrder的，而Spring的事务基于aop动态代理，因此需要显式获取代理对象。</li>
<li>改进5：外部的方法不要加事务，因为事务传播机制默认是加入已经存在的事务。这边锁释放了大事务还没提交所以没用</li>
</ul>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>集群环境下同步代码块会失效，因此需要使用redis作为公共的分布式锁进行改进</p>
<p><strong>原来</strong>：setnx 到期删除锁</p>
<ul>
<li>问题是如果在锁内部阻塞导致过期删除，别人抢来了锁开始执行，自己出来以后就会把别人的锁删掉。</li>
</ul>
<p><strong>改进</strong>：分布式锁的value为自己的线程id，释放逻辑里判断id是否和自己相同。</p>
<ul>
<li>问题是如果发生比较极端的情况，判断逻辑里id相同，准备delete时可能发生fullgc导致超时释放，仍然会误删别人的锁，拿锁、比锁、删锁不是原子性的。因此引入LUA脚本。</li>
<li>自定义锁的局限性：实现比较简单，没有高级功能。</li>
</ul>
<p><strong>REDISSON</strong> 解决了setnx的以下痛点：</p>
<ol>
<li>不可重入，死锁，获取锁的线程不能进入相同的所的代码块。<ul>
<li><strong>重入机制</strong>：重入次数从0开始增加，使用hash结构存储线程id以及其重入次数。</li>
</ul>
</li>
<li>不可重试，尝试获取一次就返回没有重试机制。要么就是无效自旋耗费资源<ul>
<li>获取失败会订阅（pub/sub）释放消息，再等一段时间，收到释放信号就重试，如果一直没获取到，超出最大等待时间之后返回false。</li>
</ul>
</li>
<li>超时释放：业务执行时间长导致锁过期，虽然不会误删，但是有隐患。<ul>
<li><strong>续约</strong>：<strong>watchdog</strong> 线程，只要持有锁就会有定时更新ttl的任务，业务完成释放锁也会将定时任务取消。</li>
</ul>
</li>
<li>主从一致：主从同步出现问题可能出现死锁<ul>
<li><strong>multilock</strong>：解决主从一致问题。必须所有的redis全获取成功才算获取到。</li>
</ul>
</li>
</ol>
<h3 id="RabbitMQ-异步秒杀"><a href="#RabbitMQ-异步秒杀" class="headerlink" title="RabbitMQ 异步秒杀"></a>RabbitMQ 异步秒杀</h3><p>项目为什么要加个消息队列?</p>
<ul>
<li>Redis 效率比较高，而数据库效率不如redis快，tomcat中的程序，会进行串行操作，分成如下几步：查询优惠卷、<strong>判断秒杀库存是否足够</strong>、查询订单、<strong>校验是否是一人一单</strong>、扣减库存、创建订单。在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行。</li>
<li>将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息。</li>
<li>为什么不使用线程池或者异步编排。如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求。</li>
</ul>
<h4 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h4><p><strong>Lua 脚本</strong>：把库存和一人一单做好判断，符合就直接返回成功。构建好订单发给rabbitMQ。</p>
<p>为了支持集群和维持原子性，lua脚本内操作的键必须在同一个哈希插槽内，因此需要使用前缀 + {voucherid}进行拼接，这样的两个键一定能在同一个哈西插槽内 HASHTAG</p>
<h4 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h4><p>MQ 这边本身支持 concurrency，不过用默认的 1 就好，我们手动配置好线程池的参数，然后提交给线程池。</p>
<p>异步：时效性不是那么重要，因此使用 MQ 慢慢消化即可。</p>
<p>单机——轻量级异步任务编排：如并行调用多个本地接口、合并结果、链式处理。</p>
<ul>
<li>高并发请求处理：通过线程池快速响应，避免阻塞主线程。</li>
<li>无需跨进程通信：所有操作在同一个 JVM 内完成。</li>
</ul>
<p><strong>分布式——RabbitMQ</strong>：</p>
<ul>
<li><p>直连交换机 <code>hmdianping.direct</code> 负责接收和分发消息</p>
</li>
<li><p>队列 <code>direct.seckill.queue</code>  存储消息，是消息的“最终目的地”。</p>
</li>
<li><p>绑定关系：队列通过路由键 <code>direct.seckill</code> 绑定到交换机。分发消息的依据（地址）</p>
</li>
<li><p><strong>参数注入</strong>：</p>
<ul>
<li><code>Message</code>：原始消息对象（含元数据）。</li>
<li><code>Channel</code>：RabbitMQ 通道，用于手动确认消息（ACK/NACK）。</li>
<li><code>VoucherOrder</code>：消息体自动反序列化后的业务对象（需配置消息转换器，如 <code>Jackson2JsonMessageConverter</code>）。</li>
</ul>
</li>
<li><p><strong>手动ACK</strong>：manual。业务处理成功调用 <code>basicAck</code>，告知 RabbitMQ 消息已被消费。</p>
</li>
<li><p><strong>消息持久化</strong>：发送者发消息时设置DeliveryMode为Persistent，同时队列创建时也要指定durable = true</p>
</li>
<li><p><strong>生产者 confirm</strong>：correlated。需要@PostConstruct配置回调函数，到达交换机和路由成功之后会触发回调。</p>
</li>
<li><p>重试机制：生产者发送消息的时候设置好消息头的 <code>retryCount = 0</code>，消费者检测 <code>retryCount &lt;= 3</code>才消费。如果订单保存失败则抛异常，此时拒绝消息并重新入队，达到三次重试就将这条消息转发到延时队列中去。这样，配置延时队列的死信队列为我们的正常队列，等到消息的 ttl 到了就 Reject消息，消息就重新回到了“死信队列”，也就是消费者对应的对列中，确保了消息不丢失。</p>
</li>
</ul>
<h4 id="数据库操作失败（Redis已经预扣）"><a href="#数据库操作失败（Redis已经预扣）" class="headerlink" title="数据库操作失败（Redis已经预扣）"></a>数据库操作失败（Redis已经预扣）</h4><p>lua脚本对库存（string）执行了减1操作，对集合（set）进行了add操作</p>
<ol>
<li>指数退避重试机制（订单id唯一保证幂等性）</li>
<li><strong>补偿机制：最终一致性兜底</strong>。如果重试到达一定次数就变成死信，死信监听器接受消息之后出发redis回滚对库存加1，对集合进行remove的操作。</li>
</ol>
<h4 id="请求堆积"><a href="#请求堆积" class="headerlink" title="请求堆积"></a>请求堆积</h4><p>MQ消息堆积：使用 CallerRunsPolicy()</p>
<table>
<thead>
<tr>
<th><strong>方案</strong></th>
<th><strong>实施难度</strong></th>
<th><strong>见效速度</strong></th>
<th><strong>适用阶段</strong></th>
<th><strong>成本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>限流降级</td>
<td>低</td>
<td>立即</td>
<td>紧急处理</td>
<td>低</td>
</tr>
<tr>
<td>代码优化</td>
<td>中</td>
<td>1-3天</td>
<td>短期优化</td>
<td>低</td>
</tr>
<tr>
<td>数据库读写分离</td>
<td>高</td>
<td>1周</td>
<td>中期架构调整</td>
<td>中</td>
</tr>
<tr>
<td>微服务拆分</td>
<td>高</td>
<td>1-3个月</td>
<td>长期重构</td>
<td>高</td>
</tr>
<tr>
<td>消息队列削峰</td>
<td>中</td>
<td>3-7天</td>
<td>中期解耦</td>
<td>中</td>
</tr>
</tbody></table>
<h3 id="用户体感反馈"><a href="#用户体感反馈" class="headerlink" title="用户体感反馈"></a>用户体感反馈</h3><ol>
<li>活动开始/结束，token，参数非法</li>
<li>判断资格，成功则返回“抢购成功，请耐心等待结果”避免用户重复点击。</li>
<li>入队阶段：网络异常/MQ不可用，回滚 Redis，告知用户系统繁忙</li>
<li>异步落库：成功可以推送一个站内信，失败就发送失败通知，同时后台记录好日志，做好异常落库工作。</li>
</ol>
<h2 id="点赞、排行榜"><a href="#点赞、排行榜" class="headerlink" title="点赞、排行榜"></a>点赞、排行榜</h2><p><strong>使用 ZSet 与 MySQL 的自定义排序实现点赞及排行榜，使用 Set 作为共同关注的解决方案。</strong> </p>
<p>使用Zset存储每个blog的点赞者。 保证按照点赞时间排序，并且点赞人不会重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  idStr 是前5个点赞的用户的 id，由于MySQL查询的结果顺序不定，因此需要 手动使用 ORDER BY FIELD 指定 ID 字段 按照 idStr 的顺序</span></span><br><span class="line">List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">        .in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">        .stream()</span><br><span class="line">        .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h2 id="分页查询-时间线"><a href="#分页查询-时间线" class="headerlink" title="分页查询 时间线"></a>分页查询 时间线</h2><p><strong>实现了基于推模式的关注内容推送，用基于时间戳的分页查询实现时间线功能。</strong>  </p>
<p>优点：时效快，不用临时拉取</p>
<p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>
<p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p>
<p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">            .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    os = minTime == max ? os : os + offset;</span><br><span class="line">    <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        setBlogUserInfo(blog);</span><br><span class="line">        setBlogIsLike(blog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(os);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;</span><br><span class="line">    <span class="keyword">private</span> Integer offset;</span><br><span class="line">    <span class="comment">//minTime 上次查询的最小值 offset从上次查询最小值偏移的个数(上次最小值有多少个)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-Bitmap-签到"><a href="#使用-Bitmap-签到" class="headerlink" title="使用 Bitmap 签到"></a>使用 Bitmap 签到</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 签到实际上就是将天数所在的位置 SETBIT，重点是记录连续签到天数</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">            .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;<span class="keyword">return</span> Result.ok(<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.getFirst();</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;<span class="keyword">return</span> Result.ok(<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分布式锁≠流量削峰"><a href="#分布式锁≠流量削峰" class="headerlink" title="分布式锁≠流量削峰"></a>分布式锁≠流量削峰</h1><p>不，光开了分布式锁并不会减少外部打过来的请求数——它只是保证「同一时刻只有一个请求能拿到锁去真正执行业务」，但所有其他请求还是会去 Redis 调用一次 <code>tryLock()</code>，只不过拿不到锁而已。所以，分布式锁并不能从源头上降请求量或 Redis 的流量。</p>
<p>如果你想真正减轻 Redis 压力、提前拦截大批量的并发请求，可以考虑在业务层或网关层做以下几种优化：</p>
<ol>
<li><strong>本地预热+内存拦截</strong><ul>
<li>把库存、限流配额等关键信息缓存在应用内存（比如 <code>ConcurrentHashMap</code>、Guava Cache、Caffeine）里，先在本地判断 “库存是否用完” 或 “是否超过限流阈值”，</li>
<li>只有本地判断通过的请求才继续走远程 Redis 锁或库存扣减，未通过的直接快速返回。</li>
<li>这样在高并发时，大部分请求都被本地拦截掉，Redis 压力会大幅下降。</li>
</ul>
</li>
<li><strong>网关限流/熔断</strong><ul>
<li>在 Nginx 或 API 网关（如 Kong、Zuul、Spring Cloud Gateway）层面，给热点接口打限流，使用漏桶、令牌桶算法，把峰值流量削峰；</li>
<li>超出限流阈值的请求直接在网关被拒绝，不会转到业务后端。</li>
</ul>
</li>
<li><strong>消息队列异步排队</strong><ul>
<li>接口层接到请求后，迅速把请求放到 MQ（RabbitMQ、Kafka、RocketMQ），立即返回“排队中”给用户；</li>
<li>后端消费者单线程或限并发地从队列里拉取消息、串行执行业务、更新库存、入库；</li>
<li>这样除了一条队列写入，后续几乎零并发冲突，也不会给 Redis 带来峰值压力。</li>
</ul>
</li>
<li><strong>Lua 脚本原子化合并操作</strong><ul>
<li>把库存检查、扣减、锁定、消息入队等逻辑写到一段 Redis Lua 脚本里，一次网络 RTT 就能完成多步校验和更新，虽然还是落到 Redis，但网络交互次数最低。</li>
<li>适合逻辑较简单的场景。</li>
</ul>
</li>
<li><strong>多级限流</strong><ul>
<li>前端做点击防抖/禁用按钮，避免用户重复快速点击；</li>
<li>服务端在 Controller 层用注解（如 <code>@RateLimiter</code>）做粗粒度限流；</li>
<li>再到业务层做精确限流、库存预判。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>分布式锁能防止并发冲突</strong>，但它并不是流量削峰的手段，<strong>并不会减少对 Redis 的调用次数</strong>；</li>
<li>如果想从源头上削峰，必须借助 <strong>本地缓存预判、网关限流、消息队列排队</strong> 等手段，才能真正降低对 Redis（或后端服务）的并发压力。</li>
</ul>
<h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p><strong>CAP 理论</strong>，也称为 <strong>Brewer 定理</strong>，是分布式系统设计中的一个基本原则。它指出，在一个分布式存储系统中，<strong>一致性（Consistency）</strong>、<strong>可用性（Availability）</strong>、<strong>分区容错性（Partition Tolerance）</strong> 三者不可兼得，只能同时满足其中的两项。下面分点说明。</p>
<ul>
<li><strong>CAP 不告诉你选哪两个</strong>，而是帮助你在设计时<strong>明确取舍</strong>：<ul>
<li>如果业务对<strong>强一致性</strong>要求高（如支付、库存扣减），在分区时宁可牺牲可用性 → 选 <strong>CP</strong>。</li>
<li>如果业务对<strong>可用性/延迟</strong>要求高（如社交、日志收集），在分区时宁可牺牲一致性 → 选 <strong>AP</strong>。</li>
</ul>
</li>
<li>在<strong>真实业务中</strong>，常结合<strong>最终一致性</strong>、<strong>多副本延迟补偿</strong>、<strong>幂等重试</strong>等手段，综合平衡一致性与可用性。</li>
</ul>
<p>了解 CAP 理论，有助于你在做分布式架构选型时，<strong>根据业务特性、容忍度和运维成本</strong>做出最合适的权衡。</p>
<hr>
<h2 id="三个核心"><a href="#三个核心" class="headerlink" title="三个核心"></a>三个核心</h2><ol>
<li><strong>一致性（Consistency）</strong><br> 所有节点在同一时间看到的数据是一致的。一次写入操作完成后，所有后续的读取都能立刻返回最新的写入值。</li>
<li><strong>可用性（Availability）</strong><br> 每个请求都会在有限时间内得到非错误响应（不保证是最新数据，但保证服务不宕机、总有回应）。</li>
<li><strong>分区容错性（Partition Tolerance）</strong><br> 系统能够容忍网络分区（节点或网络断开）而继续提供服务。即使部分节点之间无法通信，系统仍能保持一致性或可用性之一。</li>
</ol>
<p>项目当中，CP：分布式锁判定一人一单，强一致性    AP：最终一致性，redis预扣。redis集群。</p>
<hr>
<h2 id="“不可兼得”-的含义"><a href="#“不可兼得”-的含义" class="headerlink" title="“不可兼得” 的含义"></a>“不可兼得” 的含义</h2><p>CAP 告诉我们：“当系统发生网络分区时（P发生），你必须在<strong>一致性</strong>（C）和<strong>可用性</strong>（A）之间做选择，<strong>不能同时满足</strong>。”</p>
<p>在真实的分布式环境中，<strong>网络分区故障（网络抖动、链路中断）几乎不可避免</strong>。因此，<strong>要构建一个健壮的分布式系统，必须选择在网络分区时牺牲“一致性”或“可用性”中的一项</strong>：</p>
<ul>
<li><strong>CP 系统（Consistency + Partition Tolerance）</strong>：在网络分区时，放弃可用性，保证一致性。常见于金融交易系统。</li>
<li><strong>AP 系统（Availability + Partition Tolerance）</strong>：在网络分区时，放弃一致性，保证可用性。常见于社交媒体、缓存系统。</li>
<li><strong>CA 系统（Consistency + Availability）</strong>：保证一致性和可用性，但无法容忍网络分区。严格来说，分布式环境中无法真正做到 CA，因为分区总会发生。</li>
</ul>
<table>
<thead>
<tr>
<th>模型</th>
<th>分区发生时的策略</th>
<th>场景举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CP</strong></td>
<td>停止提供服务或延迟响应，直到网络恢复并保证数据一致</td>
<td>ZooKeeper、HBase（强一致读写）</td>
</tr>
<tr>
<td><strong>AP</strong></td>
<td>继续提供服务，但有可能读到老数据，待网络恢复后数据再最终一致</td>
<td>Cassandra、Redis Cluster（异步复制）</td>
</tr>
<tr>
<td><strong>CA</strong></td>
<td>不适用于跨网络数据中心的分布式系统；只在单机或无网络分区场景满足</td>
<td>传统关系型数据库（单实例）</td>
</tr>
</tbody></table>
<hr>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><ul>
<li><strong>Cassandra（AP）</strong><ul>
<li>选用最终一致性模型，允许在分区时继续读写，性能和可用性高，但短期内可能读不到最新写入。</li>
</ul>
</li>
<li><strong>MongoDB（CP 可调）</strong><ul>
<li>默认主从复制，主节点写入保证一致性；分区时次节点不可写（牺牲可用性），保证读写一致。</li>
</ul>
</li>
<li><strong>Redis Sentinel/ZK（CP）</strong><ul>
<li>在主备切换时，会阻止客户端写入，直到选举出新主节点，保证强一致。</li>
</ul>
</li>
</ul>
<h1 id="线程池调优"><a href="#线程池调优" class="headerlink" title="线程池调优"></a><a href="https://scatteredream.github.io/2024/11/30/juc-in-one/#connectpool">线程池调优</a></h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/12/redie-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/12/redie-review/" class="post-title-link" itemprop="url">redis-review</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-12 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-12T00:00:00+08:00">2024-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 14:10:26" itemprop="dateModified" datetime="2025-05-08T14:10:26+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="开篇导读"><a href="#开篇导读" class="headerlink" title="开篇导读"></a>开篇导读</h2><p>亲爱的小伙伴们大家好，马上咱们就开始实战篇的内容了，相信通过本章的学习，小伙伴们就能理解各种redis的使用啦，接下来咱们来一起看看实战篇我们要学习一些什么样的内容</p>
<ul>
<li>短信登录</li>
</ul>
<p>这一块我们会使用redis TOKEN共享session来实现</p>
<ul>
<li>商户查询缓存</li>
</ul>
<p>通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容</p>
<ul>
<li>优惠卷秒杀</li>
</ul>
<p>通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</p>
<ul>
<li>附近的商户</li>
</ul>
<p>我们利用Redis的GEOHash来完成对于地理坐标的操作</p>
<ul>
<li>UV统计</li>
</ul>
<p>主要是使用Redis来完成统计功能</p>
<ul>
<li>用户签到</li>
</ul>
<p>使用Redis的BitMap数据统计功能</p>
<ul>
<li>好友关注</li>
</ul>
<p>基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下</p>
<ul>
<li>打人探店</li>
</ul>
<p>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</p>
<p>以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用Redis</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653056228879.png" alt="1653056228879"></p>
<h2 id="短信登录：分布式session-token-redis"><a href="#短信登录：分布式session-token-redis" class="headerlink" title="短信登录：分布式session (token+redis)"></a>短信登录：分布式session (token+redis)</h2><h3 id="导入黑马点评项目"><a href="#导入黑马点评项目" class="headerlink" title="导入黑马点评项目"></a>导入黑马点评项目</h3><h4 id="导入SQL"><a href="#导入SQL" class="headerlink" title="导入SQL"></a>导入SQL</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653057872536.png" alt="1653057872536"></p>
<h4 id="有关当前模型"><a href="#有关当前模型" class="headerlink" title="有关当前模型"></a>有关当前模型</h4><p>手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p>
<p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653059409865.png" alt="1653059409865"></p>
<h4 id="导入后端项目"><a href="#导入后端项目" class="headerlink" title="导入后端项目"></a>导入后端项目</h4><p>在资料中提供了一个项目源码：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653060237073.png" alt="1653060237073"></p>
<h4 id="导入前端工程"><a href="#导入前端工程" class="headerlink" title="导入前端工程"></a>导入前端工程</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653060337562.png" alt="1653060337562"></p>
<h4 id="运行前端项目"><a href="#运行前端项目" class="headerlink" title="运行前端项目"></a>运行前端项目</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653060588190.png" alt="1653060588190"></p>
<h3 id="基于Session实现登录流程"><a href="#基于Session实现登录流程" class="headerlink" title="基于Session实现登录流程"></a>基于Session实现登录流程</h3><p>cookie不安全，session绝对安全</p>
<p><strong>发送验证码：</strong> </p>
<p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p>
<p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p>
<p><strong>短信验证码登录、注册：</strong></p>
<p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p>
<p><strong>校验登录状态:</strong></p>
<p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653066208144.png" alt="1653066208144"></p>
<h3 id="实现发送短信验证码功能"><a href="#实现发送短信验证码功能" class="headerlink" title="实现发送短信验证码功能"></a>实现发送短信验证码功能</h3><p><strong>页面流程</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653067054461.png" alt="1653067054461"></p>
<p><strong>具体代码如下</strong></p>
<p><strong>贴心小提示：</strong></p>
<p>具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。</p>
<ul>
<li>发送验证码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.保存验证码到 session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">// 5.发送验证码</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="comment">// 返回ok</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>登录</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span>(cacheCode == <span class="literal">null</span> || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">         <span class="comment">//3.不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一致，根据手机号查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//不存在，则创建</span></span><br><span class="line">        user =  createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现登录拦截功能"><a href="#实现登录拦截功能" class="headerlink" title="实现登录拦截功能"></a>实现登录拦截功能</h3><p><strong>温馨小贴士：tomcat的运行原理</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653068196656.png" alt="1653068196656"></p>
<p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p>
<p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p>
<p><strong>温馨小贴士：关于threadlocal</strong></p>
<p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653068874258.png" alt="1653068874258"></p>
<p>拦截器代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//1.获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2.获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">//4.不存在，拦截，返回401状态码</span></span><br><span class="line">              response.setStatus(<span class="number">401</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser((User)user);</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让拦截器生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p>
<p>Data Transfer Object 不包含业务逻辑，只包含传输时必要的字段，精简敏感信息</p>
<p><strong>在登录方法处修改</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtils.copyProperties(user,UserDTO.class));</span><br></pre></td></tr></table></figure>

<p><strong>在拦截器处：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">UserHolder.saveUser((UserDTO) user);</span><br></pre></td></tr></table></figure>

<p><strong>在UserHolder处：将user对象换成UserDTO</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="session共享问题"><a href="#session共享问题" class="headerlink" title="session共享问题"></a>session共享问题</h3><p><strong>核心思路分析：</strong></p>
<p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p>
<p>但是这种方案具有两个大问题</p>
<p>1、每台服务器中都有完整的一份session数据，服务器内存压力过大。</p>
<p>2、session拷贝数据时，可能会出现延迟，影响效率</p>
<p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653069893050.png" alt="1653069893050"></p>
<p>为什么用cookie,session,redis而不是数据库？</p>
<p>有些东西并不需要持久化到数据库中，只需要存在内存中即可，键值对型数据能够实现高效的查询与获取</p>
<h3 id="Redis代替session的业务流程"><a href="#Redis代替session的业务流程" class="headerlink" title="Redis代替session的业务流程"></a>Redis代替session的业务流程</h3><h4 id="设计key的结构"><a href="#设计key的结构" class="headerlink" title="设计key的结构"></a>设计key的结构</h4><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653319261433.png" alt="1653319261433"></p>
<h4 id="设计key的具体细节"><a href="#设计key的具体细节" class="headerlink" title="设计key的具体细节"></a>设计key的具体细节</h4><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p>
<p>在设计这个key的时候，我们之前讲过需要满足两点</p>
<p>1、key要具有唯一性</p>
<p>2、key要方便携带</p>
<p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了。</p>
<p><mark>session：浏览器请求自动携带sessionID，服务器根据sessionID访问相应的内存空间存储的信息，<mark></p>
<p><mark>redis+token：浏览器请求携带token，服务器根据token访问redis数据库存储的信息。<mark></p>
<ul>
<li><mark>前端实现逻辑：将服务端生成的<u>token</u>保存到浏览器的sessionStorage域中，在axios发送ajax请求时进行方法拦截，在请求头requestHeader中加入authorization:<u>token</u> ，因为要保存到浏览器，所以不能使用手机号作为token而应该生成一个uuid字符串<mark>: </li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241031173338907.png" alt="image-20241031173338907"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241031173340660.png" alt="image-20241031173340660"></p>
<ul>
<li><mark>后端逻辑：将token取出，根据token访问redis数据库<mark></li>
</ul>
<h4 id="整体访问流程"><a href="#整体访问流程" class="headerlink" title="整体访问流程"></a>整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653319474181.png" alt="1653319474181"></p>
<h3 id="基于Redis实现短信登录"><a href="#基于Redis实现短信登录" class="headerlink" title="基于Redis实现短信登录"></a>基于Redis实现短信登录</h3><p>这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。</p>
<p><strong>UserServiceImpl代码</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.从redis获取验证码并校验</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.equals(code)) &#123;</span><br><span class="line">        <span class="comment">// 不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.不存在，创建新用户并保存</span></span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.保存用户信息到 redis中</span></span><br><span class="line">    <span class="comment">// 7.1.随机生成token，作为登录令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 7.2.将User对象转为HashMap存储</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">    <span class="comment">// 7.3.存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">// 7.4.设置token有效期</span></span><br><span class="line">    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.返回token</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决状态登录刷新问题"><a href="#解决状态登录刷新问题" class="headerlink" title="解决状态登录刷新问题"></a>解决状态登录刷新问题</h3><h4 id="初始方案思路总结"><a href="#初始方案思路总结" class="headerlink" title="初始方案思路总结"></a>初始方案思路总结</h4><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，比如主页之类的那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的。</p>
<p>只有访问拦截的网页才会刷redis，这样就导致如果用户访问的是其他网页，不会出发拦截器，过期token就会失效</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320822964.png" alt="1653320822964"></p>
<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320764547.png" alt="1653320764547"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><strong>RefreshTokenInterceptor</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><strong>LoginInterceptor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有用户，则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45673401/article/details/132065407">Hutool BeanUtils.copyProperties的四种用法 空不拷贝/忽略拷贝/空不和忽略拷贝/全拷贝_hutool beanutil.copyproperties-CSDN博客</a> </p>
<p>beanToMap 属性转换异常</p>
<h2 id="商户查询缓存-分布式缓存cache"><a href="#商户查询缓存-分布式缓存cache" class="headerlink" title="商户查询缓存 分布式缓存cache"></a>商户查询缓存 分布式缓存cache</h2><h3 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存?"></a>什么是缓存?</h3><p><strong>前言</strong>:<strong>什么是缓存?</strong></p>
<p>就像自行车,越野车的避震器<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E9%81%BF%E9%9C%87%E5%99%A8.gif"></p>
<p>举个例子:越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样;</p>
<p>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;</p>
<p>这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;</p>
<p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1</span>:Static <span class="keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); 本地用于高并发</span><br><span class="line"></span><br><span class="line">例<span class="number">2</span>:<span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存</span><br><span class="line"></span><br><span class="line">例<span class="number">3</span>:Static <span class="keyword">final</span> Map&lt;K,V&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>(); 本地缓存</span><br></pre></td></tr></table></figure>

<p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;</p>
<h4 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h4><p>一句话:因为<strong>速度快,好用</strong></p>
<p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p>
<p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p>
<p>但是缓存也会增加代码复杂度和运营的成本:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220523214414123.png"></p>
<h4 id="如何使用缓存"><a href="#如何使用缓存" class="headerlink" title="如何使用缓存"></a>如何使用缓存</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p>
<p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p>
<p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p>
<p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p>
<p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220523212915666.png"></p>
<h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h3><p>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    //这里是直接查询数据库</span><br><span class="line">    return shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓存模型和思路"><a href="#缓存模型和思路" class="headerlink" title="缓存模型和思路"></a>缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322097736.png" alt="1653322097736"></p>
<h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322190155.png" alt="1653322190155"></p>
<h4 id="练习：商铺信息缓存处理"><a href="#练习：商铺信息缓存处理" class="headerlink" title="练习：商铺信息缓存处理"></a>练习：商铺信息缓存处理</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241101145321055.png" alt="image-20241101145321055"></p>
<p>增加程序健壮性，先查看redis是否有key，没有就创建，如果有key但是长度为0，也创建，长度不为0，肯定有key，读取后解析为list返回</p>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p>
<p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>
<p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p>
<p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322506393.png" alt="1653322506393"></p>
<h4 id="DB-Cache数据一致性解决方案"><a href="#DB-Cache数据一致性解决方案" class="headerlink" title="DB, Cache数据一致性解决方案"></a>DB, Cache数据一致性解决方案</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p>
<p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p>
<h5 id="Cache-Aside-Pattern-旁路缓存"><a href="#Cache-Aside-Pattern-旁路缓存" class="headerlink" title="Cache Aside Pattern 旁路缓存"></a>Cache Aside Pattern 旁路缓存</h5><p>人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>
<h5 id="Read-Write-Through-Pattern-读写穿透"><a href="#Read-Write-Through-Pattern-读写穿透" class="headerlink" title="Read/Write Through Pattern 读写穿透"></a>Read/Write Through Pattern 读写穿透</h5><p>由系统本身完成，数据库与缓存的问题交由缓存系统本身去处理，实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>但是Redis本身并没有支持将cache写入db的功能，因此也不常见</p>
<h5 id="Write-Behind-Caching-Pattern-异步缓存写入"><a href="#Write-Behind-Caching-Pattern-异步缓存写入" class="headerlink" title="Write Behind Caching Pattern 异步缓存写入"></a>Write Behind Caching Pattern 异步缓存写入</h5><p>调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p>
<p>举例：消息队列中消息的 异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制</p>
<p> db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么 高的场景，比如浏览量、点赞量</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322857620.png" alt="1653322857620"></p>
<h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p>
<p>操作缓存和数据库时有三个问题需要考虑：</p>
<h5 id="删除cache还是更新cache？"><a href="#删除cache还是更新cache？" class="headerlink" title="删除cache还是更新cache？"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38420688/article/details/108803569">删除cache还是更新cache？</a></h5><ul>
<li><p>更新缓存：每次更新数据库都更新缓存，无效写操作较多，并且可能有线程安全问题</p>
</li>
<li><p>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</p>
</li>
</ul>
<p>无效写：假设我们每次操作数据库后，都去更新缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来。</p>
<p>线程安全：比如可能更新了某个表的一个字段，然后更新对应的缓存需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值。而另外的表数据可能已经被其他线程修改，从而出现线程安全问题。</p>
<h5 id="如何保证cache与db的操作的同时成功或失败？"><a href="#如何保证cache与db的操作的同时成功或失败？" class="headerlink" title="如何保证cache与db的操作的同时成功或失败？"></a>如何保证cache与db的操作的同时成功或失败？</h5><ul>
<li><p>单体系统，将缓存与数据库操作放在一个事务</p>
</li>
<li><p>分布式系统，利用TCC等分布式事务方案</p>
</li>
</ul>
<h5 id="先操作cache还是先操作db？"><a href="#先操作cache还是先操作db？" class="headerlink" title="先操作cache还是先操作db？"></a>先操作cache还是先操作db？</h5><ul>
<li><p>先删除缓存，再操作数据库</p>
</li>
<li><p>先操作数据库，再删除缓存</p>
</li>
</ul>
<p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653323595206.png" alt="1653323595206"></p>
<p>先删了，没来得及更新数据库20，另一个抢先未命中然后从数据库读取10并写入缓存，最后造成不一致</p>
<p>查的进程刚好缓存失效了，已经查完数据库10，没来的及写缓存，插进来一个更新的进程，更新数据库20并删缓存，最后写缓存10</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241101154820526.png" alt="image-20241101154820526"></p>
<h4 id="Cache-Aside-Pattern-代码实现"><a href="#Cache-Aside-Pattern-代码实现" class="headerlink" title="Cache Aside Pattern 代码实现"></a>Cache Aside Pattern 代码实现</h4><p>核心思路如下：</p>
<p>修改ShopController中的业务逻辑，满足下面的需求：</p>
<p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p>
<p>根据id修改店铺时，先修改数据库，再删除缓存</p>
<p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p>
<p><strong>设置redis缓存时添加过期时间</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653325871232.png" alt="1653325871232"></p>
<p><strong>修改重点代码2</strong></p>
<p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653325929549.png" alt="1653325929549"></p>
<h3 id="缓存穿透—Cache-Penetration"><a href="#缓存穿透—Cache-Penetration" class="headerlink" title="缓存穿透—Cache Penetration"></a>缓存穿透—Cache Penetration</h3><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p>
<p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p>
<p>假设布隆过滤器判断这个数据不存在，则直接返回</p>
<p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653326156516.png" alt="1653326156516"></p>
<h4 id="编码解决商品查询的缓存穿透问题"><a href="#编码解决商品查询的缓存穿透问题" class="headerlink" title="编码解决商品查询的缓存穿透问题"></a>编码解决商品查询的缓存穿透问题</h4><p>核心思路如下：</p>
<p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p>
<p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p>
<p>caching sharding load balancing</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653327124561.png" alt="1653327124561"></p>
<p><strong>小总结：</strong></p>
<p>缓存穿透产生的原因是什么？</p>
<ul>
<li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li>
</ul>
<p>缓存穿透的解决方案有哪些？</p>
<ul>
<li>缓存null值</li>
<li>布隆过滤</li>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h3 id="缓存雪崩—Cache-Avalanche"><a href="#缓存雪崩—Cache-Avalanche" class="headerlink" title="缓存雪崩—Cache Avalanche"></a>缓存雪崩—Cache Avalanche</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653327884526.png" alt="1653327884526"></p>
<h3 id="缓存击穿—Hotspot-Invalid"><a href="#缓存击穿—Hotspot-Invalid" class="headerlink" title="缓存击穿—Hotspot Invalid"></a>缓存击穿—Hotspot Invalid</h3><h4 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h4><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁 MUTEX</li>
<li>逻辑过期 LOGICAL EXPIRE</li>
</ul>
<p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653328022622.png" alt="1653328022622"></p>
<p>解决方案一、使用锁来解决：</p>
<p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p>
<p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653328288627.png" alt="1653328288627"></p>
<p>解决方案二、逻辑过期方案</p>
<p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p>
<p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
<p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653328663897.png" alt="1653328663897"></p>
<p>进行对比</p>
<p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p>
<p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653357522914.png" alt="1653357522914"></p>
<h4 id="利用互斥锁解决缓存击穿—Mutex—基于setnx"><a href="#利用互斥锁解决缓存击穿—Mutex—基于setnx" class="headerlink" title="利用互斥锁解决缓存击穿—Mutex—基于setnx"></a>利用互斥锁解决缓存击穿—Mutex—基于setnx</h4><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p>
<p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653357860001.png" alt="1653357860001"></p>
<p><strong>操作锁的代码：</strong></p>
<p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>  &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">// 1、从redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">       <span class="comment">// 2、判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="comment">// 存在,直接返回</span></span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的值是否是空值</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//返回一个错误信息</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4.实现缓存重构</span></span><br><span class="line">       <span class="comment">//获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span> + id;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">           <span class="comment">// 判断否获取成功</span></span><br><span class="line">           <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">               <span class="comment">//失败，则休眠重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//成功，根据id查询数据库</span></span><br><span class="line">            shop = getById(id);</span><br><span class="line">           <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">           <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//将空值写入redis</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="comment">//返回错误信息</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//6.写入redis</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//7.释放互斥锁 </span></span><br><span class="line">           unlock(lockKey);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241101214618482.png" alt="image-20241101214618482"></p>
<h4 id="利用逻辑过期解决缓存击穿—LogicalExpire"><a href="#利用逻辑过期解决缓存击穿—LogicalExpire" class="headerlink" title="利用逻辑过期解决缓存击穿—LogicalExpire"></a>利用逻辑过期解决缓存击穿—LogicalExpire</h4><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p>
<p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653360308731.png" alt="1653360308731"></p>
<p>如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你</p>
<p><strong>步骤一、</strong></p>
<p>新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class RedisData &#123;</span><br><span class="line">    private LocalDateTime expireTime;</span><br><span class="line">    private Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤二、</strong></p>
<p>在<strong>ShopServiceImpl</strong> 新增此方法，利用单元测试进行缓存预热</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653360807133.png" alt="1653360807133"></p>
<p><strong>在测试类中</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653360864839.png" alt="1653360864839"></p>
<p>步骤三：正式代码</p>
<p><strong>ShopServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">( Long id )</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装Redis工具类—CacheClient"><a href="#封装Redis工具类—CacheClient" class="headerlink" title="封装Redis工具类—CacheClient"></a>封装Redis工具类—CacheClient</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p>
<ul>
<li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li>
<li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓</li>
</ul>
<p>存击穿问题</p>
<ul>
<li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li>
<li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li>
</ul>
<p>将逻辑进行封装</p>
<p>重点在于为了普适性要加入泛型，尽可能提高代码复用性，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ShopServiceImpl 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 解决缓存穿透</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient</span><br><span class="line">                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 互斥锁解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逻辑过期解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="引入布隆过滤器-BloomFilter"><a href="#引入布隆过滤器-BloomFilter" class="headerlink" title="引入布隆过滤器 BloomFilter"></a>引入布隆过滤器 BloomFilter</h3><h4 id="引入Guava依赖"><a href="#引入Guava依赖" class="headerlink" title="引入Guava依赖"></a>引入Guava依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>33.2.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="将布隆过滤器交给IoC容器"><a href="#将布隆过滤器交给IoC容器" class="headerlink" title="将布隆过滤器交给IoC容器"></a>将布隆过滤器交给IoC容器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuavaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;custom.expectedInsertions&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long expectedInsertions;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;custom.fpp&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double fpp;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BloomFilter&lt;Long&gt; <span class="title function_">shopIdBloomFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BloomFilter.create(Funnels.longFunnel(), expectedInsertions, fpp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BloomFilter&lt;String&gt; <span class="title function_">stringBloomFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BloomFilter.create(Funnels.stringFunnel(StandardCharsets.UTF_8), expectedInsertions, fpp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li><p>bloomFilter.put() 加入布隆过滤器</p>
</li>
<li><p>bloomFilter.mightContain()判断是否存在</p>
</li>
<li><p>expectedInsertions 布隆过滤器中预期加入的数字</p>
</li>
<li><p>fpp 可接受的误判率</p>
</li>
</ol>
<h2 id="优惠卷秒杀-乐观锁、悲观锁（synchronized）"><a href="#优惠卷秒杀-乐观锁、悲观锁（synchronized）" class="headerlink" title="优惠卷秒杀 乐观锁、悲观锁（synchronized）"></a>优惠卷秒杀 乐观锁、悲观锁（synchronized）</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="-全局唯一ID"></a>-全局唯一ID</h3><p>每个店铺都可以发布优惠券：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653362612286.png" alt="1653362612286"></p>
<p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p>
<ul>
<li>id的规律性太明显</li>
<li>受单表数据量的限制</li>
</ul>
<p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p>
<p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p>
<p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653363100502.png" alt="1653363100502"></p>
<p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653363172079.png" alt="1653363172079">ID的组成部分：符号位：1bit，永远为0</p>
<p>时间戳：31bit，以秒为单位，可以使用69年</p>
<p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p>
<h3 id="Redis实现全局唯一Id"><a href="#Redis实现全局唯一Id" class="headerlink" title="-Redis实现全局唯一Id"></a>-Redis实现全局唯一Id</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<p>知识小贴士：关于countdownlatch </p>
<p>countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</p>
<p>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</p>
<p>CountDownLatch 中有两个最重要的方法</p>
<p>1、countDown</p>
<p>2、await</p>
<p>await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + (end - begin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加优惠卷"><a href="#添加优惠卷" class="headerlink" title="添加优惠卷"></a>添加优惠卷</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653365145124.png" alt="1653365145124"></p>
<p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p>
<p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p>
<p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p>
<p>**新增普通卷代码：  **VoucherController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>新增秒杀卷代码：</strong></p>
<p><strong>VoucherController</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VoucherServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现秒杀下单"><a href="#实现秒杀下单" class="headerlink" title="实现秒杀下单"></a>实现秒杀下单</h3><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653365839526.png" alt="1653365839526"></p>
<p>秒杀下单应该思考的内容：</p>
<p>下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p>下单核心逻辑分析：</p>
<p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p>
<p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653366238564.png" alt="1653366238564"></p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="库存超卖问题分析"><a href="#库存超卖问题分析" class="headerlink" title="库存超卖问题分析"></a>库存超卖问题分析</h3><p>有关超卖问题分析：在我们原有代码中是这么写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">// 库存不足</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5，扣减库存</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">           .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">           .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">   <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">       <span class="comment">//扣减库存</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653368335155.png" alt="1653368335155"></p>
<p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653368562591.png" alt="1653368562591"></p>
<p><strong>悲观锁：</strong></p>
<p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p>
<p><strong>乐观锁：</strong></p>
<p>  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p>
<p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p>
<p>  其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure>

<p><strong>课程中的使用方式：</strong></p>
<p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version=1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version =1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version=1 的条件了，所以线程2无法执行成功</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653369268550.png" alt="1653369268550"></p>
<h3 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h3><p><strong>修改代码方案一、</strong></p>
<p>VoucherOrderServiceImpl 在扣减库存时，改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>) <span class="comment">//set stock = stock -1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="comment">//where id = ？ and stock = ?</span></span><br></pre></td></tr></table></figure>

<p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p>
<p><strong>修改代码方案二、</strong></p>
<p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure>

<p><strong>知识小扩展：</strong></p>
<p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p>
<p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p>
<p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p>
<p>所以利用这么一个类，LongAdder来进行优化</p>
<p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653370271627.png" alt="1653370271627"></p>
<h3 id="优惠券秒杀-一人一单"><a href="#优惠券秒杀-一人一单" class="headerlink" title="优惠券秒杀-一人一单"></a>优惠券秒杀-一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p>
<p><strong>现在的问题在于：</strong></p>
<p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p>
<p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653371854389.png" alt="1653371854389"></p>
<p>VoucherOrderServiceImpl  </p>
<p><strong>初步代码：增加一人一单逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.一人一单逻辑</span></span><br><span class="line">    <span class="comment">// 5.1.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户已经购买过了</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 7.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 7.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>存在问题：</strong>现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</p>
<p><strong>注意：</strong>在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：</p>
<h4 id="锁的真正含义"><a href="#锁的真正含义" class="headerlink" title="锁的真正含义"></a>锁的真正含义</h4><p><mark>锁的真正含义<mark>: 导致线程安全问题的线程之间需要拥有同一把锁，比如：字符串常量作为锁，意味着只要能得到这个字符串常量的锁都会参与到锁的竞争中，这会使不相关的线程被阻塞，同样的如果使用<code> synchronized(this)</code>，也会导致所有获得服务对象的线程都会参与锁的竞争，也就是所有用户都被挡在门外，引入悲观锁只是用来解决一人一单问题的，所以应该使用userId作为锁对象，这样不同的用户就不会互相影响。（数据库层面的乐观锁仍然可以有效防止库存负数的问题，先查后改）</p>
<p>拿到相同对象（锁）的线程会串行执行同步代码块，所以不同用户可以并行执行这段代码。</p>
<p>intern() 这个方法是从常量池中拿到数据，如果我们直接使用 <code>userId.toString()</code>他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">	<span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事务内部加锁导致事务失效"><a href="#事务内部加锁导致事务失效" class="headerlink" title="事务内部加锁导致事务失效"></a>事务内部加锁导致事务失效</h4><p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放，下一个拿到锁的对象就开始执行事务方法了，从而导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题如下：</p>
<p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653373434815.png" alt="1653373434815"></p>
<h4 id="事务自调用导致事务失效"><a href="#事务自调用导致事务失效" class="headerlink" title="事务自调用导致事务失效"></a>事务自调用导致事务失效</h4><p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象，来操作事务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653383810643.png" alt="1653383810643"></p>
<h4 id="事务的粒度控制"><a href="#事务的粒度控制" class="headerlink" title="事务的粒度控制"></a>事务的粒度控制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">secKillVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//省略.......</span></span><br><span class="line">    <span class="keyword">synchronized</span> (id.toString().intern()) &#123;</span><br><span class="line">        <span class="comment">//开启事务要用代理对象</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//省略.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在回过头来再看，为什么在外部的<code>seckillVoucher()</code>需要去掉@Transactional注解？里外都声明了事务，并且传播都是默认的<code>REQUIRE</code>，外部方法先开启事务，最后<code>createVoucherOrder()</code> 也是加入的这个大事务，而这样同样会导致锁释放了，事务还没提交。</p>
<h4 id="Transactional-amp-Lock"><a href="#Transactional-amp-Lock" class="headerlink" title="@Transactional &amp; Lock"></a>@Transactional &amp; Lock</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/thisiswhy/p/15175380.html">当Transactional碰到锁，有个大坑，要小心。 - why技术 - 博客园 (cnblogs.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Adoucequan/article/details/123844506">事务中使用分布式锁问题_分布式锁在事务里面,加50毫秒等上一个事务提交后再执行-CSDN博客</a> </p>
<h3 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p>
<p>1、我们将服务启动两份，端口分别为8081和8082：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653373887844.png" alt="1653373887844"></p>
<p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653373908620.png" alt="1653373908620"></p>
<p><strong>具体操作(略)</strong></p>
<h4 id="有关锁失效原因分析"><a href="#有关锁失效原因分析" class="headerlink" title="有关锁失效原因分析"></a><strong>有关锁失效原因分析</strong></h4><p>不同JVM实例的常量池也不同，是隔绝开的，所以实例之间的互斥仅仅靠普通的对象锁是不可靠的</p>
<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653374044740.png" alt="1653374044740"></p>
<h2 id="分布式锁—为解决分布式-集群进程间的并发安全问题"><a href="#分布式锁—为解决分布式-集群进程间的并发安全问题" class="headerlink" title="分布式锁—为解决分布式/集群进程间的并发安全问题"></a>分布式锁—为解决分布式/集群进程间的并发安全问题</h2><h3 id="基本原理和实现方式对比"><a href="#基本原理和实现方式对比" class="headerlink" title="基本原理和实现方式对比"></a>基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653374296906.png" alt="1653374296906"></p>
<p>那么分布式锁他应该满足一些什么样的条件呢？</p>
<p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p>
<p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p>
<p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p>
<p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p>
<p>安全性：安全也是程序中必不可少的一环</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653381992018.png" alt="1653381992018"></p>
<p>常见的分布式锁有三种</p>
<p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p>
<p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p>
<p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653382219377.png" alt="1653382219377"></p>
<h3 id="Redis分布式锁的实现核心思路"><a href="#Redis分布式锁的实现核心思路" class="headerlink" title="Redis分布式锁的实现核心思路"></a>Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li><p>获取锁：</p>
<ul>
<li>互斥：确保只能有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功返回true，失败返回false</li>
</ul>
</li>
<li><p>释放锁：</p>
<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653382669900.png" alt="1653382669900"></p>
</li>
</ul>
<p>核心思路：</p>
<p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653382830810.png" alt="1653382830810"></p>
<h3 id="实现分布式锁版本一"><a href="#实现分布式锁版本一" class="headerlink" title="实现分布式锁版本一"></a>实现分布式锁版本一</h3><ul>
<li>加锁逻辑</li>
</ul>
<p><strong>锁的基本接口</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1656079017728.png" alt="1656079017728"></p>
<p><strong>SimpleRedisLock</strong></p>
<p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁逻辑</li>
</ul>
<p>SimpleRedisLock</p>
<p>释放锁，防止删除别人的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改业务代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">      <span class="comment">// 1.查询优惠券</span></span><br><span class="line">      <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">      <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 库存不足</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="comment">//创建锁对象(新增代码)</span></span><br><span class="line">      <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">      <span class="comment">//获取锁对象</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line"><span class="comment">//加锁失败</span></span><br><span class="line">      <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">          <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">          <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redis分布式锁误删情况说明"><a href="#Redis分布式锁误删情况说明" class="headerlink" title="Redis分布式锁误删情况说明"></a>Redis分布式锁误删情况说明</h3><p>逻辑说明：</p>
<p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p>
<p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653385920025.png" alt="1653385920025"></p>
<h3 id="解决Redis分布式锁误删问题—本线程误删了其他线程的锁"><a href="#解决Redis分布式锁误删问题—本线程误删了其他线程的锁" class="headerlink" title="解决Redis分布式锁误删问题—本线程误删了其他线程的锁"></a>解决Redis分布式锁误删问题—本线程误删了其他线程的锁</h3><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）<br>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p>
<ul>
<li>如果一致则释放锁</li>
<li>如果不一致则不释放锁</li>
</ul>
<p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653387398820.png" alt="1653387398820"></p>
<p>具体代码如下：加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有关代码实操说明：</strong></p>
<p>在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。</p>
<h3 id="分布式锁的原子性问题—Full-GC带来的JAVA代码阻塞延时"><a href="#分布式锁的原子性问题—Full-GC带来的JAVA代码阻塞延时" class="headerlink" title="分布式锁的原子性问题—Full GC带来的JAVA代码阻塞延时"></a>分布式锁的原子性问题—Full GC带来的JAVA代码阻塞延时</h3><p><mark>Full GC<mark>，即完全垃圾回收，是指JVM对堆内存的所有区域（年轻代、老年代以及永久代/元空间）进行的全面清理过程。与之相对的是Minor GC，通常只清理年轻代。Full GC的触发通常是响应式而非主动的，比如堆内存不足、永久代满载等情况。由于Full GC涉及范围广，耗时较长，因此可能会引起应用程序的显著暂停（Stop-the-world），影响用户体验。</p>
<p><mark>判断的动作 与 真正delete的动作不是同步的<mark> 导致在delete操作之前锁已经超时释放，被另一个线程获取，但是依然被第一个线程误删</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">currentLockerId</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOCK_KEY_PREFIX + name);</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.equals(currentLockerId, threadId)) &#123;</span><br><span class="line">        <span class="comment">//阻塞。。。。。</span></span><br><span class="line">        stringRedisTemplate.delete(LOCK_KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>更为极端的误删逻辑说明：</p>
<p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653387764938.png" alt="1653387764938"></p>
<h3 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%EF%BC%8C%E4%BD%9C%E4%B8%BAJava%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%99%E4%B8%80%E5%9D%97%E5%B9%B6%E4%B8%8D%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A6%81%E6%B1%82%EF%BC%8C%E5%B9%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%A7%E5%AE%B6%E8%BF%87%E4%BA%8E%E7%B2%BE%E9%80%9A%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%8D%B3%E5%8F%AF%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。</a></p>
<h4 id="原子性的含义"><a href="#原子性的含义" class="headerlink" title="原子性的含义"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%80%A7&spm=1001.2101.3001.7020">原子性的含义</a></h4><p>首先何为<strong>原子性</strong> ？原子性 是指<strong>操作不可分割</strong>，要么全部执行成功，要么全部执行失败，中间不会被打断。</p>
<p><strong>使用 lua 脚本就可以实现一组操作的原子性</strong>，这些操作作为一个整体，要么全部执行成功，要么全部执行失败，也就不会存在不同的操作先后执行、多个线程之间相互穿插的情况了。</p>
<h4 id="Redis-单线程模型"><a href="#Redis-单线程模型" class="headerlink" title="Redis 单线程模型"></a>Redis 单线程模型</h4><p><strong>redis 是一个单线程模型的数据库</strong>。redis 虽然可以支持多个客户端的并发连接，<strong>但是每个客户端的操作其实是按照顺序进行的</strong>。也就是说，如果一个客户端正在执行某个操作，其他客户端需要等待这个操作执行完毕后才能进行操作。</p>
<p>看到这里，应该也就能够明白了。我们把多个操作写成一个 lua 脚本，使其具备原子性，作为一个整体执行。再由于 redis 是单线程模型，<strong>不同线程的 lua 脚本是依次执行的</strong>。也就是说，<strong>只有一个线程原子性的多个操作执行完，下一个线程才可以执行</strong>。实际上也是保证了在 redis 内部不同线程操作的串行执行，从而能够解决并发安全问题。</p>
<p>因此，结合 lua 脚本可以实现原子操作，对于需要对多个 key 进行操作的场景，可以把多个操作封装到一个 lua 脚本中，这样就可以保证这些操作的原子性，避免多个线程之间的数据竞争问题，从而保证<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Redis%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">Redis数据库</a>的数据一致性和可靠性。</p>
<h4 id="Lua-脚本语法"><a href="#Lua-脚本语法" class="headerlink" title="Lua 脚本语法"></a>Lua 脚本语法</h4><p>这里重点介绍Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure>

<p>例如，我们要执行set name jack，则脚本是这样：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>

<p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653392181413.png" alt="1653392181413"></p>
<p>例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653392218531.png" alt="1653392218531"></p>
<p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653392438917.png" alt="1653392438917"></p>
<p>接下来我们来回一下我们释放锁的逻辑：</p>
<p>释放锁的业务流程是这样的</p>
<p>​    1、获取锁中的线程标示</p>
<p>​    2、判断是否与指定的标示（当前线程标示）一致</p>
<p>​    3、如果一致则释放锁（删除）</p>
<p>​    4、如果不一致则什么都不做</p>
<p>如果用Lua脚本来表示则是这样的：</p>
<p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h3 id="利用Java代码调用Lua脚本改造分布式锁"><a href="#利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="利用Java代码调用Lua脚本改造分布式锁"></a>利用Java代码调用Lua脚本改造分布式锁</h3><p>lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。</p>
<p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653393304844.png" alt="1653393304844"></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line">经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span><br></pre></td></tr></table></figure>

<p>小总结：</p>
<p>基于Redis的分布式锁实现思路：</p>
<ul>
<li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li>
<li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul>
<li>特性：<ul>
<li>利用set nx满足互斥性</li>
<li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li>
<li>利用Redis集群保证高可用和高并发特性</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p>
<p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p>
<p><strong>测试逻辑：</strong></p>
<p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p>
<h2 id="分布式锁-Redission"><a href="#分布式锁-Redission" class="headerlink" title="分布式锁-Redission"></a>分布式锁-Redission</h2><h3 id="分布式锁-Redission-功能介绍"><a href="#分布式锁-Redission-功能介绍" class="headerlink" title="分布式锁-Redission 功能介绍"></a>分布式锁-Redission 功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p>
<p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，<strong>他的方法都是使用synchronized修饰</strong>的（锁对象都是this），假如他在A方法内，调用B方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p>
<p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653546070602.png" alt="1653546070602"></p>
<p>那么什么是Redission呢</p>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<p>Redission提供了分布式锁的多种多样的功能</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653546736063.png" alt="1653546736063"></p>
<h3 id="分布式锁-Redission-快速入门"><a href="#分布式锁-Redission-快速入门" class="headerlink" title="分布式锁-Redission 快速入门"></a>分布式锁-Redission 快速入门</h3><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置Redisson客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何使用Redission的分布式锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 VoucherOrderServiceImpl</p>
<p>注入RedissonClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span></span><br><span class="line">        <span class="comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//获取锁对象</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">       </span><br><span class="line">		<span class="comment">//加锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁-Redission-可重入锁原理"><a href="#分布式锁-Redission-可重入锁原理" class="headerlink" title="分布式锁-Redission 可重入锁原理"></a>分布式锁-Redission 可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state=0，假如有人持有这把锁，那么state=1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p>
<p>在redission中，我们的也支持支持可重入锁</p>
<p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个lua表达式</p>
<p>这个地方一共有3个参数</p>
<p><strong>KEYS[1] ： 锁名称</strong></p>
<p><strong>ARGV[1]：  锁失效时间</strong></p>
<p><strong>ARGV[2]：  id + “:” + threadId; 锁的小key</strong></p>
<p>exists: 判断数据是否存在  name：是lock是否存在,如果==0，就表示当前这把锁不存在</p>
<p>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构</p>
<p>Lock{</p>
<p>​    id + <strong>“:”</strong> + threadId :  1</p>
<p>}</p>
<p>如果当前这把锁存在，则第一个条件不满足，再判断</p>
<p>redis.call(‘hexists’, KEYS[1], ARGV[2]) == 1</p>
<p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p>
<p>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)</p>
<p>将当前这个锁的value进行+1 ，redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间</p>
<p>如果小伙帮们看了前边的源码， 你会发现他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653548087334.png" alt="1653548087334"></p>
<h3 id="分布式锁-Redission锁重试和WatchDog机制"><a href="#分布式锁-Redission锁重试和WatchDog机制" class="headerlink" title="分布式锁-Redission锁重试和WatchDog机制"></a>分布式锁-Redission锁重试和WatchDog机制</h3><p><strong>说明</strong>：由于课程中已经说明了有关tryLock的源码解析以及其看门狗原理，所以笔者在这里给大家分析lock()方法的源码解析，希望大家在学习过程中，能够掌握更多的知识</p>
<p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p>
<p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p>
<p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p>
<p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime != -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p>
<p>ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure>

<p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法</p>
<p>Method(  <strong>new</strong> TimerTask() {},参数2 ，参数3  )</p>
<p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p>
<p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p>
<p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redisson-获取锁、释放锁逻辑"><a href="#Redisson-获取锁、释放锁逻辑" class="headerlink" title="Redisson 获取锁、释放锁逻辑"></a>Redisson 获取锁、释放锁逻辑</h4><p>tryLock() 只获取一次，不重试</p>
<p>tryLock(waitTime, leaseTime, TimeUnit) 可重试，有等待时间和超时释放</p>
<p><code>leaseTime</code>超时释放时间，<code>waitTime</code>最大等待时间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241109153113839.png" alt="image-20241109153113839"></p>
<h5 id="超时续约（TTL与业务执行情况挂钩）"><a href="#超时续约（TTL与业务执行情况挂钩）" class="headerlink" title="超时续约（TTL与业务执行情况挂钩）"></a>超时续约（TTL与业务执行情况挂钩）</h5><p>获取成功，但不设置释放时间，此时会把leaseTime设置为-1，然后开启看门狗线程，设置定时任务定时更新TTL，实现了锁有效期的不断重置。<strong>如何跟业务产生联系</strong>：当业务执行完毕会释放锁，此时会将定时任务取消。如果看门狗线程出现宕机，过一段时间也会自动释放。</p>
<p>在释放的同时会发布<code>publish</code>一个释放的消息给其他等待的线程。</p>
<h5 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h5><p>获取失败会订阅<code>subscribe</code>释放的消息，再等一段时间，如果获取到释放锁的信号，重试获取锁，如果一直没获取到，超出最大等待时间之后会返回false。</p>
<h3 id="分布式锁-Redission锁的MultiLock原理"><a href="#分布式锁-Redission锁的MultiLock原理" class="headerlink" title="分布式锁-Redission锁的MultiLock原理"></a>分布式锁-Redission锁的MultiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p>
<p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653553998403.png" alt="1653553998403"></p>
<p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653554055048.png" alt="1653554055048"></p>
<p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p>
<p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间(waitTime)，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试，重试要从头再来。</p>
<p>成功获取所有锁之后，如果之前设置了leaseTime释放时间，还要重新设置一下TTL，因为成功获取一把锁，这把锁就开始倒计时了，导致expireTime不统一</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653553093967.png" alt="1653553093967"></p>
<h3 id="分布式锁-总结"><a href="#分布式锁-总结" class="headerlink" title="分布式锁 总结"></a>分布式锁 总结</h3><h4 id="不可重入Redis分布式锁—基于setnx"><a href="#不可重入Redis分布式锁—基于setnx" class="headerlink" title="不可重入Redis分布式锁—基于setnx"></a>不可重入Redis分布式锁—基于setnx</h4><p>利用setnx互斥性，释放锁时使用线程标示防止误删</p>
<p>缺陷：不可重入（同一线程无法重复获取）无法重试（完全非阻塞）超时失效</p>
<h4 id="可重入Redis分布式锁—基于Redisson"><a href="#可重入Redis分布式锁—基于Redisson" class="headerlink" title="可重入Redis分布式锁—基于Redisson"></a>可重入Redis分布式锁—基于Redisson</h4><p>与ReentrantLock类似，利用Hash结构，记录线程标示，同时也记录重入次数（可重入）</p>
<p>使用Watchdog机制实现超时可续约，将锁与业务执行情况挂钩。</p>
<p>利用信号量，使用发布订阅这样的异步等待机制实现可重试</p>
<p>缺点：Redis主从模式下主机宕机会引起锁失效</p>
<h4 id="铁锁连环—Redisson-Multilock"><a href="#铁锁连环—Redisson-Multilock" class="headerlink" title="铁锁连环—Redisson Multilock"></a>铁锁连环—Redisson Multilock</h4><p>将多个Redisson锁合并成一把锁，必须把这些锁全部拿到才算获取成功，一扇门用若干锁锁起来。</p>
<p>缺陷：运维成本高，需要多个Redis节点，实现起来较为复杂</p>
<h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><h3 id="秒杀优化-异步秒杀思路"><a href="#秒杀优化-异步秒杀思路" class="headerlink" title="秒杀优化-异步秒杀思路"></a>秒杀优化-异步秒杀思路</h3><p>我们来回顾一下下单流程</p>
<p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p>
<p>1、查询优惠卷</p>
<p><mark>2、判断秒杀库存是否足够<mark></p>
<p>3、查询订单</p>
<p><mark>4、校验是否是一人一单<mark></p>
<p>5、扣减库存</p>
<p>6、创建订单</p>
<p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？</p>
<p>在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用异步编排来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653560986599.png" alt="1653560986599"></p>
<p>优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p>
<p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p>
<p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653561657295.png" alt="1653561657295"></p>
<p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p>
<p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653562234886.png" alt="1653562234886"></p>
<h3 id="秒杀优化-Redis完成秒杀资格判断"><a href="#秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="秒杀优化-Redis完成秒杀资格判断"></a>秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p>
<ul>
<li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p>
</li>
<li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p>
</li>
<li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列  </p>
</li>
<li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1656080546603.png" alt="1656080546603"></p>
</li>
</ul>
<p>VoucherServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整lua表达式</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="秒杀优化-基于阻塞队列实现秒杀优化"><a href="#秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="秒杀优化-基于阻塞队列实现秒杀优化"></a>秒杀优化-基于阻塞队列实现秒杀优化</h3><p>VoucherOrderServiceImpl</p>
<p>修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步处理线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">   SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于线程池处理的任务</span></span><br><span class="line"><span class="comment">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">          	 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">            <span class="comment">// 2.创建锁对象</span></span><br><span class="line">            <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">            <span class="comment">// 3.尝试获取锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.lock();</span><br><span class="line">            <span class="comment">// 4.判断是否获得锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">                log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span></span><br><span class="line">                proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                redisLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//a</span></span><br><span class="line">	<span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="keyword">new</span>  <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 2.3.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 2.4.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 2.5.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">// 2.6.放入阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line">        <span class="comment">//3.获取代理对象</span></span><br><span class="line">         proxy = (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="comment">//4.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">           log.error(<span class="string">&quot;用户已经购买过了&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="秒杀业务的优化思路"><a href="#秒杀业务的优化思路" class="headerlink" title="秒杀业务的优化思路"></a>秒杀业务的优化思路</h3><p>之前：通过查数据库判断用户是否有资格下单，然后同步创建订单对象</p>
<p>现在：</p>
<ul>
<li>先利用Redis完成库存余量、一人一单判断，提前创建订单，完成抢单业务（直接返回给前端结果）</li>
<li>再将下单业务放入阻塞队列，利用独立线程异步下单，完成数据库的更改</li>
</ul>
<h4 id="基于阻塞队列的异步秒杀存在哪些问题"><a href="#基于阻塞队列的异步秒杀存在哪些问题" class="headerlink" title="基于阻塞队列的异步秒杀存在哪些问题"></a>基于阻塞队列的异步秒杀存在哪些问题</h4><ul>
<li>内存限制问题：BlockingQueue基于JVM，会受JVM内存限制</li>
<li>数据安全问题：<ul>
<li>JVM宕机会导致订单信息全部丢失，无法进行数据库更改</li>
<li>订单从阻塞队列中取出，执行之前发生了一些问题，导致任务失败，但是已经找不回来了</li>
</ul>
</li>
</ul>
<h2 id="Redis消息队列（Stream）"><a href="#Redis消息队列（Stream）" class="headerlink" title="Redis消息队列（Stream）"></a>Redis消息队列（Stream）</h2><h3 id="Redis消息队列-认识消息队列"><a href="#Redis消息队列-认识消息队列" class="headerlink" title="Redis消息队列-认识消息队列"></a>Redis消息队列-认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653574849336.png" alt="1653574849336"></p>
<p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p>
<p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p>
<p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p>
<h3 id="Redis消息队列-基于List实现消息队列"><a href="#Redis消息队列-基于List实现消息队列" class="headerlink" title="Redis消息队列-基于List实现消息队列"></a>Redis消息队列-基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p>
<p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p>
<p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653575176451.png" alt="1653575176451"></p>
<p>基于List的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法避免消息丢失</li>
<li>只支持单消费者</li>
</ul>
<h3 id="Redis消息队列-基于PubSub的消息队列"><a href="#Redis消息队列-基于PubSub的消息队列" class="headerlink" title="Redis消息队列-基于PubSub的消息队列"></a>Redis消息队列-基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653575506373.png" alt="1653575506373"></p>
<p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持数据持久化</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失</li>
</ul>
<h3 id="Redis消息队列-基于Stream的消息队列"><a href="#Redis消息队列-基于Stream的消息队列" class="headerlink" title="Redis消息队列-基于Stream的消息队列"></a>Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
<p>发送消息的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577301737.png" alt="1653577301737"></p>
<p>例如：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577349691.png" alt="1653577349691"></p>
<p>读取消息的方式之一：XREAD</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577445413.png" alt="1653577445413"></p>
<p>例如，使用XREAD读取第一个消息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577643629.png" alt="1653577643629"></p>
<p>XREAD阻塞方式，读取最新的消息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577659166.png" alt="1653577659166"></p>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577689129.png" alt="1653577689129"></p>
<p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p>
<p>STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h3 id="Redis消息队列-基于Stream的消息队列-消费者组"><a href="#Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="Redis消息队列-基于Stream的消息队列-消费者组"></a>Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577801668.png" alt="1653577801668"></p>
<p>创建消费者组：<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577984924.png" alt="1653577984924"><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p>
<p> <strong>删除指定的消费者组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure>

<p> <strong>给指定的消费者组添加消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p> <strong>删除消费者组中的指定消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p>从消费者组读取消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定队列名称</li>
<li>ID：获取消息的起始ID：</li>
</ul>
<p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br><span class="line">位于消费者组g1的消费者c1读取一条消息，没有消息最长阻塞等待2000ms，</span><br><span class="line">消息来源key为s1，从s1下一个未消费的消息开始</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XACK s1 g1 ID1 ID2 ID3</span><br><span class="line">消息来源为s1，使用g1把ID1 ID2 ID3消息确认，从pendinglist中移除消息</span><br></pre></td></tr></table></figure>



<p>消费者监听消息的基本思路：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578211854.png" alt="1653578211854">STREAM类型消息队列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<p>最后我们来个小对比</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578560691.png" alt="1653578560691"></p>
<h3 id="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p>
<ul>
<li>创建一个Stream类型的消息队列，名为stream.orders</li>
<li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li>
<li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</li>
</ul>
<p>修改lua表达式,新增3.6</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1656082824939.png" alt="1656082824939"></p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                <span class="comment">//处理异常消息</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Redis消息队列—Stream结构总结"><a href="#Redis消息队列—Stream结构总结" class="headerlink" title="Redis消息队列—Stream结构总结"></a>Redis消息队列—Stream结构总结</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577801668.png" alt="1653577801668"></p>
<p>STREAM类型消息队列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可阻塞读取</li>
<li>消息可分流：多个消费者争抢消息，加快处理速度</li>
<li>消息标示机制：确保没有消息被漏读</li>
<li>消息确认机制：获取消息后加入pending-list，处理完成要通过XACK从pending-list移除，实现消息回溯</li>
<li>保证消息至少被消费一次</li>
</ul>
<p>最后我们来个小对比</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578560691.png" alt="1653578560691"></p>
<p>——秒杀 完——</p>
<h2 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h2><h3 id="达人探店-发布探店笔记"><a href="#达人探店-发布探店笔记" class="headerlink" title="达人探店-发布探店笔记"></a>达人探店-发布探店笔记</h3><p>发布探店笔记</p>
<p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p>
<p><strong>具体发布流程</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578992639.png" alt="1653578992639"></p>
<p>上传接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 生成新文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：同学们在操作时，需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p>
<p>BlogController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IBlogService blogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(<span class="meta">@RequestBody</span> Blog blog)</span> &#123;</span><br><span class="line">        <span class="comment">//获取登录用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        blog.setUpdateTime(user.getId());</span><br><span class="line">        <span class="comment">//保存探店博文</span></span><br><span class="line">        blogService.saveBlog(blog);</span><br><span class="line">        <span class="comment">//返回id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-查看探店笔记"><a href="#达人探店-查看探店笔记" class="headerlink" title="达人探店-查看探店笔记"></a>达人探店-查看探店笔记</h3><p>实现查看发布探店笔记的接口</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653579931626.png" alt="1653579931626"></p>
<p>实现代码：</p>
<p>BlogServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询blog</span></span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (blog == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询blog有关的用户</span></span><br><span class="line">    queryBlogUser(blog);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-点赞功能"><a href="#达人探店-点赞功能" class="headerlink" title="达人探店-点赞功能"></a>达人探店-点赞功能</h3><p>初始代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//修改点赞数量</span></span><br><span class="line">    blogService.update().setSql(<span class="string">&quot;liked = liked +1 &quot;</span>).eq(<span class="string">&quot;id&quot;</span>,id).update();</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题分析：这种方式会导致一个用户无限点赞，明显是不合理的</p>
<p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653581590453.png" alt="1653581590453"></p>
<p>完善点赞功能</p>
<p>需求：</p>
<ul>
<li>同一个用户只能点赞一次，再次点击则取消点赞</li>
<li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li>
</ul>
<p>实现步骤：</p>
<ul>
<li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li>
<li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li>
<li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
<li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
</ul>
<p>为什么采用set集合：</p>
<p>因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是</p>
<p>具体步骤：</p>
<p>1、在Blog 添加一个字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(exist = false)</span></span><br><span class="line"><span class="keyword">private</span> Boolean isLike;</span><br></pre></td></tr></table></figure>

<p>2、修改代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">       <span class="comment">// 1.获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">       <span class="keyword">if</span>(BooleanUtil.isFalse(isMember))&#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">           <span class="comment">//数据库点赞数+1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//保存用户到Redis的set集合</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().add(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//4.如果已点赞，取消点赞</span></span><br><span class="line">           <span class="comment">//数据库点赞数-1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//把用户从Redis的set集合移除</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().remove(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-点赞排行榜"><a href="#达人探店-点赞排行榜" class="headerlink" title="达人探店-点赞排行榜"></a>达人探店-点赞排行榜</h3><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p>
<p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653805077118.png" alt="1653805077118"></p>
<p>我们接下来来对比一下这些集合的区别是什么</p>
<p>所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet</p>
<p>其次我们需要排序，就可以直接锁定使用sortedSet啦</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653805203758.png" alt="1653805203758"></p>
<p>修改代码</p>
<p>BlogServiceImpl</p>
<p>点赞逻辑代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.获取登录用户</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">     <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">     <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">     <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 3.如果未点赞，可以点赞</span></span><br><span class="line">         <span class="comment">// 3.1.数据库点赞数 + 1</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">         <span class="comment">// 3.2.保存用户到Redis的set集合  zadd key value score</span></span><br><span class="line">         <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">             stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 4.如果已点赞，取消点赞</span></span><br><span class="line">         <span class="comment">// 4.1.数据库点赞数 -1</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">         <span class="comment">// 4.2.把用户从Redis的set集合移除</span></span><br><span class="line">         <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">             stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Result.ok();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isBlogLiked</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.获取登录用户</span></span><br><span class="line">     <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">     <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 用户未登录，无需查询是否点赞</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">     <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;blog:liked:&quot;</span> + blog.getId();</span><br><span class="line">     <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">     blog.setIsLike(score != <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>点赞列表查询列表</p>
<p>BlogController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogLikes(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MySQL自定义排序-ORDER-BY-FIELD"><a href="#MySQL自定义排序-ORDER-BY-FIELD" class="headerlink" title="MySQL自定义排序 ORDER BY FIELD"></a>MySQL自定义排序 ORDER BY FIELD</h4><p>MySQL查询结果如果不指定排序顺序，返回结果通常是不确定的，而点赞排行榜是按照用户的点赞时间先后顺序排序的，所以要显式指定特定的排序规则，</p>
<p>根据用户ids查询用户 WHERE id IN ( 5 , 1 )  结果默认是按照ids中元素的id大小升序排序的，我们要让ids的顺序保留到最后，使用ORDER BY FIELD </p>
<p>BlogService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="comment">// 1.查询top5的点赞用户 zrange key 0 4</span></span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.解析出其中的用户id</span></span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    <span class="comment">// 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h2><h3 id="好友关注-关注和取消关注"><a href="#好友关注-关注和取消关注" class="headerlink" title="好友关注-关注和取消关注"></a>好友关注-关注和取消关注</h3><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806140822.png" alt="1653806140822"></p>
<p>实现思路：</p>
<p>需求：基于该表数据结构，实现两个接口：</p>
<ul>
<li>关注和取关接口</li>
<li>判断是否关注的接口</li>
</ul>
<p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806253817.png" alt="1653806253817"></p>
<p>注意: 这里需要把主键修改为自增长，简化开发。</p>
<p>FollowController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关注</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> followService.follow(followUserId, isFollow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消关注</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> followService.isFollow(followUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FollowService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">取消关注service</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">        <span class="comment">// 3.判断</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 关注service</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">        <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">        <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">            <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">            <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">            follow.setUserId(userId);</span><br><span class="line">            follow.setFollowUserId(followUserId);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">            remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                    .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-共同关注"><a href="#好友关注-共同关注" class="headerlink" title="好友关注-共同关注"></a>好友关注-共同关注</h3><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p>
<p>1、去查询用户的详情</p>
<p>2、去查询用户的笔记</p>
<p>以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了，我们的重点在于共同关注功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806706296.png" alt="1653806706296"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserController 根据id查询用户</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">	<span class="comment">// 查询详情</span></span><br><span class="line">	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">	<span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Result.ok();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">	<span class="comment">// 返回</span></span><br><span class="line">	<span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlogController  根据id查询博主的探店笔记</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/of/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogByUserId</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">		<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">	<span class="comment">// 根据用户查询</span></span><br><span class="line">	Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">			.eq(<span class="string">&quot;user_id&quot;</span>, id).page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">	<span class="comment">// 获取当前页数据</span></span><br><span class="line">	List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">	<span class="keyword">return</span> Result.ok(records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来看看共同关注如何实现：</p>
<p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p>
<p>当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806973212.png" alt="1653806973212"></p>
<p>我们先来改造当前的关注列表</p>
<p>改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到set集合中，方便后续进行共同关注，同时当取消关注时，也需要从set集合中进行删除</p>
<p>FollowServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">    <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">        <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(followUserId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id，放入redis的set集合 sadd userId followerUserId</span></span><br><span class="line">            stringRedisTemplate.opsForSet().add(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id从Redis集合中移除</span></span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体的关注代码：</strong></p>
<p>FollowServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 2.求交集</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);</span><br><span class="line">    <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 无交集</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.解析id集合</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.查询用户</span></span><br><span class="line">    List&lt;UserDTO&gt; users = userService.listByIds(ids)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-Feed流-实现"><a href="#好友关注-Feed流-实现" class="headerlink" title="好友关注-Feed流 实现"></a>好友关注-Feed流 实现</h3><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p>
<p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653808641260.png" alt="1653808641260"></p>
<p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653808993693.png" alt="1653808993693"></p>
<p>Feed流的实现有两种模式：</p>
<p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p>
<ul>
<li>优点：信息全面，不会有缺失。并且实现也相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li>
</ul>
<p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p>
<ul>
<li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li>
<li>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li>
</ul>
<p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p>
<p>，因此采用Timeline的模式。该模式的实现方案有三种：</p>
<ul>
<li>拉模式</li>
<li>推模式</li>
<li>推拉结合</li>
</ul>
<p><strong>拉模式</strong>：也叫做读扩散</p>
<p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p>
<p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p>
<p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653809450816.png" alt="1653809450816"></p>
<p><strong>推模式</strong>：也叫做写扩散。</p>
<p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p>
<p>优点：时效快，不用临时拉取</p>
<p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653809875208.png" alt="1653809875208"></p>
<p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p>
<p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653812346852.png" alt="1653812346852"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241112191818612.png" alt="image-20241112191818612"></p>
<h3 id="好友关注-推送到粉丝收件箱"><a href="#好友关注-推送到粉丝收件箱" class="headerlink" title="好友关注-推送到粉丝收件箱"></a>好友关注-推送到粉丝收件箱</h3><p>需求：</p>
<ul>
<li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li>
<li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li>
<li>查询收件箱数据时，可以实现分页查询</li>
</ul>
<p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p>
<p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p>
<p>假设在t1 时刻，我们去读取第一页，此时page = 1 ，size = 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page=2 ，size=5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653813047671.png" alt="1653813047671"></p>
<p>Feed流的滚动分页</p>
<p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p>
<p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653813462834.png" alt="1653813462834"></p>
<p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 2.保存探店笔记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">// 4.推送笔记id给所有粉丝</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="comment">// 4.1.获取粉丝id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="comment">// 4.2.推送</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-实现分页查询收邮箱"><a href="#好友关注-实现分页查询收邮箱" class="headerlink" title="好友关注-实现分页查询收邮箱"></a>好友关注-实现分页查询收邮箱</h3><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p>
<p>具体操作如下：</p>
<p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p>
<p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p>
<p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p>
<p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653819821591.png" alt="1653819821591"></p>
<p>一、定义出来具体的返回值实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;</span><br><span class="line">    <span class="keyword">private</span> Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogController</p>
<p>注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">        .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	os = minTime == max ? os : os + offset;</span><br><span class="line">    <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">// 5.1.查询blog有关的用户</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">// 5.2.查询blog是否被点赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(os);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="附近商户—GEO"><a href="#附近商户—GEO" class="headerlink" title="附近商户—GEO"></a>附近商户—GEO</h2><h3 id="附近商户-GEO数据结构的基本用法"><a href="#附近商户-GEO数据结构的基本用法" class="headerlink" title="附近商户-GEO数据结构的基本用法"></a>附近商户-GEO数据结构的基本用法</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li>
</ul>
<h3 id="附近商户-导入店铺数据到GEO"><a href="#附近商户-导入店铺数据到GEO" class="headerlink" title="附近商户-导入店铺数据到GEO"></a>附近商户-导入店铺数据到GEO</h3><p>具体场景说明：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653822036941.png" alt="1653822036941"></p>
<p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653822021827.png" alt="1653822021827"></p>
<p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p>
<p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p>
<p>代码</p>
<p>HmDianPingApplicationTests</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">    <span class="comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">            <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="附近商户-实现附近商户—redis逻辑分页查询"><a href="#附近商户-实现附近商户—redis逻辑分页查询" class="headerlink" title="附近商户-实现附近商户—redis逻辑分页查询"></a>附近商户-实现附近商户—redis逻辑分页查询</h3><p>SpringDataRedis的版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p>
<p>第一步：导入pom</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：</p>
<p>ShopController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId, current, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShopServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">            Page&lt;Shop&gt; page = query()</span><br><span class="line">                    .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                    .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.计算分页参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">                .search(</span><br><span class="line">                        key,</span><br><span class="line">                        GeoReference.fromCoordinate(x, y),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 4.解析出id</span></span><br><span class="line">        <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">            <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">        List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">        Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">        list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">            ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">            <span class="comment">// 4.3.获取距离</span></span><br><span class="line">            <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">            distanceMap.put(shopIdStr, distance);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="用户签到—BitMap"><a href="#用户签到—BitMap" class="headerlink" title="用户签到—BitMap"></a>用户签到—BitMap</h2><h3 id="用户签到-BitMap功能演示"><a href="#用户签到-BitMap功能演示" class="headerlink" title="用户签到-BitMap功能演示"></a>用户签到-BitMap功能演示</h3><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653823145495.png" alt="1653823145495"></p>
<p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p>
<p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p>
<p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p>
<p>我们可以采用类似这样的方案来实现我们的签到需求。</p>
<p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p>
<p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p>
<p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653824498278.png" alt="1653824498278"></p>
<p>BitMap的操作命令有：</p>
<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT ：获取指定位置（offset）的bit值</li>
<li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li>
<li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h4 id="1用户签到-实现签到功能"><a href="#1用户签到-实现签到功能" class="headerlink" title="1用户签到-实现签到功能"></a>1用户签到-实现签到功能</h4><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p>
<p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p>
<p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653833970361.png" alt="1653833970361"></p>
<p><strong>代码</strong></p>
<p>UserController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储肯定是以字节为单位，因此后面会补0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111230319873.png" alt="image-20241111230319873"></p>
<h4 id="用户签到-签到统计"><a href="#用户签到-签到统计" class="headerlink" title="用户签到-签到统计"></a>用户签到-签到统计</h4><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653834455899.png" alt="1653834455899"></p>
<p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p>
<p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p>
<p>  BITFIELD key GET u[dayOfMonth] 0</p>
<p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p>
<p><strong>问题3：如何从后向前遍历每个bit位？</strong></p>
<p>注意：bit<mark>Map返回的数据是10进制<mark>，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p>
<p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653835784444.png" alt="1653835784444"></p>
<p>代码</p>
<p><strong>UserController</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="额外加餐-关于使用bitmap来解决缓存穿透的方案"><a href="#额外加餐-关于使用bitmap来解决缓存穿透的方案" class="headerlink" title="额外加餐-关于使用bitmap来解决缓存穿透的方案"></a>额外加餐-关于使用bitmap来解决缓存穿透的方案</h4><p>回顾<strong>缓存穿透</strong>：</p>
<p>发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击</p>
<p>解决方案：</p>
<ul>
<li><p>判断id&lt;0</p>
</li>
<li><p>如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来</p>
</li>
</ul>
<p>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</p>
<p>第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据</p>
<p>所以我们如何解决呢？</p>
<p>我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653836416586.png" alt="1653836416586"></p>
<p>现在的问题是这个主键其实并没有那么短，而是很长的一个 主键</p>
<p>哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个</p>
<p>所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间</p>
<p>我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：</p>
<p>id % bitmap.size  = 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，  采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653836578970.png" alt="1653836578970"></p>
<h2 id="UV统计—HyperLogLog"><a href="#UV统计—HyperLogLog" class="headerlink" title="UV统计—HyperLogLog"></a>UV统计—HyperLogLog</h2><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903785744056333#heading-0">HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的聪明的你可能会马上想到，用 HashMap 这种数 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53416615">Redis源码中hyperloglog结构的实现原理是什么？ - 知乎 (zhihu.com)</a></p>
<p>首先我们搞懂两个概念：</p>
<ul>
<li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
</ul>
<p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p>
<p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p>
<p>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653837988985.png" alt="1653837988985"></p>
<h3 id="UV统计-测试百万数据的统计"><a href="#UV统计-测试百万数据的统计" class="headerlink" title="UV统计-测试百万数据的统计"></a>UV统计-测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653838053608.png" alt="1653838053608"></p>
<p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/04/mysql-maintain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/04/mysql-maintain/" class="post-title-link" itemprop="url">MySQL 运维篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-04 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-04T00:00:00+08:00">2024-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:28:34" itemprop="dateModified" datetime="2025-05-05T11:28:34+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="MySQL-客户端管理"><a href="#MySQL-客户端管理" class="headerlink" title="MySQL 客户端管理"></a>MySQL 客户端管理</h2><h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018231950720-1730191893980-1.png" alt="image-20241018231950720"></p>
<h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018231940461-1730191893981-2.png" alt="image-20241018231940461"></p>
<p>import只能导入dump加-T参数导出的txt文本，source用来执行.sql文件</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>记录了当 mysqld 启动和停止时，以及<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9C%8D%E5%8A%A1%E5%99%A8&spm=1001.2101.3001.7020">服务器</a>在运行过程中<strong>发生任何严重错误时的相关信息</strong>。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</p>
<p>该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log 。查看日志位置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#先登录mysql</span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p1234</span><br><span class="line"></span><br><span class="line">#通过此系统变量查看日志文件的位置</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span>;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>记录 MySQL 上的所有<strong>变化</strong>并<strong>以二进制形式</strong>保存在磁盘上。包括所有的DDL和DML语句，但不包括DQL语句。主要用于<mark>主从复制<mark>、<mark>灾难时的数据库恢复<mark>。</p>
<p>binlog由server层的执行器生成，历史比redolog和undolog都早，和存储引擎没有关系。</p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="STATEMENT"><a href="#STATEMENT" class="headerlink" title="STATEMENT"></a>STATEMENT</h5><p>记录SQL语句，如果有动态函数会恢复不准确，这里就属于逻辑日志</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029171133144.png" alt="image-20241029171133144"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191323110.png" alt="image-20241029191323110"></p>
<h5 id="ROW"><a href="#ROW" class="headerlink" title="ROW"></a>ROW</h5><p>记录行数据修改之前和之后的数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029171203288.png" alt="image-20241029171203288"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191145845.png" alt="image-20241029191145845"></p>
<h5 id="MIXED"><a href="#MIXED" class="headerlink" title="MIXED"></a>MIXED</h5><h4 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h4><p>事务开始以后的执行过程都写到内存中的binlog cache，事务提交后会write写入 page cache，仍然在内存中，需要通过刷盘操作fsync才能持久化到磁盘。</p>
<ul>
<li><code>sync_binlog</code> = <code>1(default)</code> 表示每次提交事务都要在写入page cache的同时刷盘，性能较低但安全；</li>
<li><code>sync_binlog</code> = <code>0</code> 表示每次提交事务以后只写入page cache，刷盘时机交给系统确定，性能高但是不安全，会导致宕机以后page cache的binlog全部丢失；</li>
<li><code>sync_binlog</code> = <code>N</code> 表示累计N个事务才write，折中方案。 </li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029174232239.png" alt="image-20241029174232239"></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="手动删除"><a href="#手动删除" class="headerlink" title="手动删除"></a>手动删除</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/aa35434/article/details/133524177">MySql运维篇—008：日志：错误日志、二进制日志、查询日志、慢查询日志，主从复制：概述 虚拟机更改ip注意事项、原理、搭建步骤_mysql 错误日志-CSDN博客</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191529628.png" alt="image-20241029191529628"></p>
<h5 id="自动删除"><a href="#自动删除" class="headerlink" title="自动删除"></a>自动删除</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191602409.png" alt="image-20241029191602409"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191632832.png" alt="image-20241029191632832"></p>
<h4 id="和其他日志的异同"><a href="#和其他日志的异同" class="headerlink" title="和其他日志的异同"></a>和其他日志的异同</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pengweid/article/details/136887291">彻底讲透：MySQL中的三种日志（Undo Log、Redo Log和Binlog）_undolog日志类型-CSDN博客</a></p>
<h5 id="RedoLog-amp-BinLog"><a href="#RedoLog-amp-BinLog" class="headerlink" title="RedoLog &amp; BinLog"></a>RedoLog &amp; BinLog</h5><h6 id="持久化粒度不同"><a href="#持久化粒度不同" class="headerlink" title="持久化粒度不同"></a>持久化粒度不同</h6><ul>
<li>redolog让InnoDB有了事务崩溃恢复能力，保证了<strong>事务</strong>中的持久性，确保事务已经提交的修改能正确写入磁盘中。</li>
<li>binlog则是保证整个MySQL<strong>数据库</strong>集群架构的数据一致性。</li>
</ul>
<h6 id="写入时机不同—两阶段写入"><a href="#写入时机不同—两阶段写入" class="headerlink" title="写入时机不同—两阶段写入"></a>写入时机不同—两阶段写入</h6><ul>
<li>redolog在事务执行过程中可以不断写入，依赖于存储引擎：</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029174344508.png" alt="image-20241029174344508"></p>
<ul>
<li>binlog只有在事务提交时才写入，依赖于执行器（调用完存储引擎API）。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029175255030.png" alt="image-20241029175255030"></p>
<ul>
<li>这就导致虽然两个都能保证持久化能力，但两个是相对独立的，如果其中一个出现错误，就会出现数据不一致的情况，因此需要分阶段写入：将redolog的状态分成两个阶段：prepare和commit，在提交事务时，先写入binlog，再进行redolog commit。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029175500294.png" alt="image-20241029175500294"></p>
<ul>
<li>遇到事故时停机重启，根据redolog恢复数据，redolog处于commit阶段，表明binlog正常写入；redolog处于prepare阶段，binlog正常写入，这时也是完整的，也会提交；redolog处于prepare阶段，找不到对应binlog，此次更改作废。</li>
</ul>
<h6 id="顺序写入但方式不同"><a href="#顺序写入但方式不同" class="headerlink" title="顺序写入但方式不同"></a>顺序写入但方式不同</h6><ul>
<li>redolog是一个日志文件组循环写，当数据成功刷到磁盘就会擦除日志</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029173203896.png" alt="image-20241029173203896"></p>
<p>binlog一直追加写，写满一个文件就创建新文件继续写，保存的是全量日志。事务更改提交以后刷盘失败的恢复能用redolog，如果是整个数据库层级的操作，比如主从复制或者数据备份，就必须用全量日志binlog。</p>
<h5 id="UndoLog-amp-BinLog"><a href="#UndoLog-amp-BinLog" class="headerlink" title="UndoLog &amp; BinLog"></a>UndoLog &amp; BinLog</h5><h6 id="逻辑日志，粒度与方向不同"><a href="#逻辑日志，粒度与方向不同" class="headerlink" title="逻辑日志，粒度与方向不同"></a>逻辑日志，粒度与方向不同</h6><ul>
<li><p>UndoLog属于底层的InnoDB，记录反向操作，粒度更细，用于<strong>事务</strong>的回滚和MVCC（避免锁竞争，提高并发性能）</p>
</li>
<li><p>Binlog属于Server层的执行器，记录正向操作，用于<strong>数据库</strong>备份和复制</p>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>Undo Log和Redo Log是为了实现ACID特性中的A（原子性）、C（一致性）和D（持久性）。Undo Log保证了事务内部的一致性以及事务失败后的回滚能力；而Redo Log则是为了保证即使在意外情况下也能恢复已提交事务的更改。</li>
<li>Binlog的设计则更多地关注于高可用性、数据冗余以及分布式环境下的数据同步。它提供了跨节点间的数据复制功能，同时也为数据库管理员提供了审计跟踪和数据恢复手段。</li>
</ul>
<p>类比实际生活：</p>
<ul>
<li><p>首先，Undo Log这位“传令兵”，负责记录每一步操作的反向指令，一旦有差池，便能瞬间执行“撤退”命令，让事务回滚至初始状态，确保了原子性与一致性，就如同战场上的兵马未动粮草先行，进退有序。</p>
<p>其次，Redo Log这位“记事官”，专司记录每一次<strong>物理操作</strong>的详细步骤，即便遭遇突袭或断电，也能根据记录重新搭建战局，恢复已提交事务的影响，确保数据持久不灭，犹如战场上刀光剑影过后，总能找到重整旗鼓的依据。</p>
<p>最后，Binlog这位“信使”，肩负着跨营地同步信息的重要使命，无论主从服务器之间还是备份恢复之时，只需将它传递的信息忠实执行，就能保证所有营地的数据步调一致，仿佛军令如山，一呼百应，千里之外亦可响应无误。</p>
</li>
</ul>
<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191825721.png" alt="image-20241029191825721"></p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>所有查询时间，扫描记录数超过阈值的SQL语句</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191835513.png" alt="image-20241029191835513"></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>主库出现问题，快速切换服务</li>
<li>读写分离降低主库压力</li>
<li>从库执行备份，避免主库被全局锁定</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029192549256.png" alt="image-20241029192549256"></p>
<p>从上图来看，复制分成三步:<br>1.Master 主库在事务提交时，会把数据变更记录（DDL.DML）在二进制日志文件 Binlog 中。</p>
<p>2.Slave 从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</p>
<p>3.Slave 从库重做中继日志中的事件，将改变反映它自己的数据</p>
<h2 id="读写分离-分库分表"><a href="#读写分离-分库分表" class="headerlink" title="读写分离 分库分表"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html">读写分离 分库分表</a></h2><h2 id="冷热数据分离"><a href="#冷热数据分离" class="headerlink" title="冷热数据分离"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/data-cold-hot-separation.html">冷热数据分离</a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/03/distributed-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/03/distributed-lock/" class="post-title-link" itemprop="url">分布式锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-03 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-03T00:00:00+08:00">2024-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:15:30" itemprop="dateModified" datetime="2025-05-05T11:15:30+08:00">2025-05-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在应用开发中，特别是web工程开发，通常都是并发编程，不是多进程就是多线程。这种场景下极易出现线程并发性安全问题，此时不得不使用锁来解决问题。在多线程高并发场景下，为了保证资源的线程安全问题，jdk为我们提供了synchronized关键字和ReentrantLock可重入锁，但是它们只能保证一个工程内的线程安全。在分布式集群、微服务、云原生横行的当下，如何保证不同进程、不同服务、不同机器的线程安全问题，jdk并没有给我们提供既有的解决方案。此时，我们就必须借助于相关技术手动实现了。目前主流的实现有以下方式：</p>
<ol>
<li>基于mysql关系型实现</li>
<li>基于redis非关系型数据实现</li>
<li>基于zookeeper/etcd实现</li>
</ol>
<p>本课程将会全面深入、全程手撸代码式的讲解这三种分布式锁的实现。并深入源码讲解第三方分布式锁框架。</p>
<p>基础知识储备及技术要求： </p>
<p>​    开发工具：idea + jdk1.8<br>​    工程构建工具：maven<br>​    相关框架基础：SpringBoot SpringMVC Spring Mybatis（mybatis-plus） SpringData-Redis<br>​    数据库：mysql（InnoDB引擎 事务 锁机制） redis<br>​    负载均衡工具：nginx<br>​    压力测试工具：jmeter<br>​    其他：zookeeper lua脚本语言 JUC(java.util.concurrent相关背景知识) 微服务相关背景知识</p>
<h1 id="传统分布式锁"><a href="#传统分布式锁" class="headerlink" title="传统分布式锁"></a>传统分布式锁</h1><h2 id="从减库存聊起"><a href="#从减库存聊起" class="headerlink" title="从减库存聊起"></a>从减库存聊起</h2><p>多线程并发安全问题最典型的代表就是超卖现象</p>
<p>库存在并发量较大情况下很容易发生超卖现象，一旦发生超卖现象，就会出现多成交了订单而发不了货的情况。</p>
<p>场景：</p>
<p>​        商品S库存余量为5时，用户A和B同时来购买一个商品，此时查询库存数都为5，库存充足则开始减库存：</p>
<p>用户A：update db_stock set stock = stock - 1 where id = 1</p>
<p>用户B：update db_stock set stock = stock - 1 where id = 1</p>
<p>并发情况下，更新后的结果可能是4，而实际的最终库存量应该是3才对</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `db_stock` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `product_code` varchar(255) DEFAULT NULL COMMENT &#x27;商品编号&#x27;,</span><br><span class="line">  `stock_code` varchar(255) DEFAULT NULL COMMENT &#x27;仓库编号&#x27;,</span><br><span class="line">  `count` int(11) DEFAULT NULL COMMENT &#x27;库存量&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>表中数据如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606400425343.png" alt="1606400425343"></p>
<p>1001商品在001仓库有5000件库存。</p>
<p>创建分布式锁demo工程：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606393792456.png" alt="1606393792456"></p>
<p>创建好之后：</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606395123427.png" alt="1606395123427"></p>
<p>pom.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>distributed-lock<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>distributed-lock<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>分布式锁demo工程<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.yml配置文件：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://172.16.116.100:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">172.16</span><span class="number">.116</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>

<p>DistributedLockApplication启动类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.distributedlock.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedLockApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DistributedLockApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stock实体类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@TableName(&quot;db_stock&quot;)</span><br><span class="line">public class Stock &#123;</span><br><span class="line"></span><br><span class="line">    @TableId</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String productCode;</span><br><span class="line"></span><br><span class="line">    private String stockCode;</span><br><span class="line"></span><br><span class="line">    private Integer count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StockMapper接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StockMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Stock&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="简单实现减库存"><a href="#简单实现减库存" class="headerlink" title="简单实现减库存"></a>简单实现减库存</h2><p>接下来咱们代码实操一下。</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606400144254.png" alt="1606400144254"></p>
<p>StockController：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;check/lock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">checkAndLock</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.stockService.checkAndLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;验库存并锁库存成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StockService：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">        <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再减库存</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606400294689.png" alt="1606400294689"></p>
<p>查看数据库：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606400340594.png" alt="1606400340594"></p>
<p>在浏览器中一个一个访问时，每访问一次，库存量减1，没有任何问题。</p>
<h2 id="演示超卖现象"><a href="#演示超卖现象" class="headerlink" title="演示超卖现象"></a>演示超卖现象</h2><p>接下来咱们使用jmeter压力测试工具，高并发下压测一下，添加线程组：并发100循环50次，即5000次请求。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606442946203.png" alt="1606442946203"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606443124589.png" alt="1606443124589"></p>
<p>给线程组添加HTTP Request请求：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606443172072.png" alt="1606443172072"></p>
<p>填写测试接口路径如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606443276322.png" alt="1606443276322"></p>
<p>再选择你想要的测试报表，例如这里选择聚合报告：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606443541407.png" alt="1606443541407"></p>
<p>启动测试，查看压力测试报告：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220313204754310.png" alt="image-20220313204754310"></p>
<ul>
<li>Label          取样器别名，如果勾选<strong>Include group name</strong> ，则会添加线程组的名称作为前缀</li>
<li># Samples      取样器运行次数</li>
<li>Average       请求（事务）的平均响应时间</li>
<li>Median        中位数</li>
<li>90% Line       90%用户响应时间</li>
<li>95% Line       90%用户响应时间</li>
<li>99% Line       90%用户响应时间</li>
<li>Min           最小响应时间</li>
<li>Max           最大响应时间</li>
<li>Error          错误率</li>
<li>Throughput     吞吐率</li>
<li>Received KB/sec  每秒收到的千字节</li>
<li>Sent KB/sec      每秒收到的千字节</li>
</ul>
<p>测试结果：请求总数5000次，平均请求时间37ms，中位数（50%）请求是在36ms内完成的，错误率0%，每秒钟平均吞吐量2568.1次。</p>
<p>查看mysql数据库剩余库存数：还有4870</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606445079298.png" alt="1606445079298"></p>
<p>此时如果还有人来下单，就会出现超卖现象（别人购买成功，而无货可发）。</p>
<h2 id="jvm锁问题演示"><a href="#jvm锁问题演示" class="headerlink" title="jvm锁问题演示"></a>jvm锁问题演示</h2><h3 id="添加jvm锁"><a href="#添加jvm锁" class="headerlink" title="添加jvm锁"></a>添加jvm锁</h3><p>使用jvm锁（synchronized关键字或者ReetrantLock）试试：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606448306438.png" alt="1606448306438"></p>
<p>重启tomcat服务，再次使用jmeter压力测试，效果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220313212150451.png" alt="image-20220313212150451"></p>
<p>查看mysql数据库：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606448616499.png" alt="1606448616499"></p>
<p>并没有发生超卖现象，完美解决。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>添加synchronized关键字之后，StockService就具备了对象锁，由于添加了独占的排他锁，同一时刻只有一个请求能够获取到锁，并减库存。此时，所有请求只会one-by-one执行下去，也就不会发生超卖现象。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606448189738.png" alt="1606448189738"></p>
<h2 id="多服务问题"><a href="#多服务问题" class="headerlink" title="多服务问题"></a>多服务问题</h2><p>使用jvm锁在单工程单服务情况下确实没有问题，但是在集群情况下会怎样？</p>
<p>接下启动多个服务并使用nginx负载均衡，结构如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606453095867.png" alt="1606453095867"></p>
<p>启动三个服务（端口号分别8000 8100 8200），如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606468851705.png" alt="1606468851705"></p>
<h3 id="安装配置nginx"><a href="#安装配置nginx" class="headerlink" title="安装配置nginx"></a>安装配置nginx</h3><p>基于安装nginx：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull nginx:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建nginx对应资源、日志及配置目录</span></span><br><span class="line">mkdir -p /opt/nginx/logs /opt/nginx/conf /opt/nginx/html</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先在conf目录下创建nginx.conf文件，配置内容参照下方</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再运行容器</span></span><br><span class="line">docker run -d -p 80:80 --name nginx -v /opt/nginx/html:/usr/share/nginx/html -v /opt/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /opt/nginx/logs:/var/log/nginx nginx</span><br></pre></td></tr></table></figure>

<p>nginx.conf配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line">	</span><br><span class="line">	<span class="section">upstream</span> distributed &#123;</span><br><span class="line">		<span class="attribute">server</span> <span class="number">172.16.116.1:8000</span>;</span><br><span class="line">		<span class="attribute">server</span> <span class="number">172.16.116.1:8100</span>;</span><br><span class="line">		<span class="attribute">server</span> <span class="number">172.16.116.1:8200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="section">server</span> &#123;</span><br><span class="line">		<span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">172.16.116.100</span>;</span><br><span class="line">		<span class="section">location</span> / &#123;</span><br><span class="line">			<span class="attribute">proxy_pass</span> http://distributed;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在浏览器中测试：172.16.116.100是我的nginx服务器地址</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606467613477.png" alt="1606467613477"></p>
<p>经过测试，通过nginx访问服务一切正常。</p>
<h3 id="Jmeter压力测试"><a href="#Jmeter压力测试" class="headerlink" title="Jmeter压力测试"></a>Jmeter压力测试</h3><p>注意：先把数据库库存量还原到5000。</p>
<p>参照之前的测试用例，再创建一个新的测试组：参数给之前一样</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606467848874.png" alt="1606467848874"></p>
<p>配置nginx的地址及 服务的访问路径如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606467953589.png" alt="1606467953589"></p>
<p>测试结果：性能只是略有提升。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220313215233371.png" alt="image-20220313215233371"></p>
<p>数据库库存剩余量如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606469161544.png" alt="1606469161544"></p>
<p>又出现了并发问题，即出现了超卖现象。</p>
<h2 id="mysql锁演示"><a href="#mysql锁演示" class="headerlink" title="mysql锁演示"></a>mysql锁演示</h2><p>除了使用jvm锁之外，还可以使用数据锁：<strong>悲观锁</strong> 或者 <strong>乐观锁</strong></p>
<ol>
<li><p>一个sql：直接更新时判断，在更新中判断库存是否大于0 </p>
<p>update table set surplus = (surplus - buyQuantity) where id = 1 and (surplus - buyQuantity) &gt; 0 ;</p>
</li>
<li><p>悲观锁：在读取数据时锁住那几行，其他对这几行的更新需要等到悲观锁结束时才能继续 。</p>
<p>select … for update</p>
</li>
<li><p>乐观锁：读取数据时不锁，更新时检查是否数据已经被更新过，如果是则取消当前更新进行重试。</p>
<p>version 或者 时间戳（CAS思想）。</p>
</li>
</ol>
<h3 id="一个sql"><a href="#一个sql" class="headerlink" title="一个sql"></a>一个sql</h3><p>略。。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>在MySQL的InnoDB中，预设的Tansaction isolation level 为REPEATABLE READ（可重读）</p>
<p><strong>在SELECT 的读取锁定主要分为两种方式：</strong></p>
<ul>
<li>SELECT … LOCK IN SHARE MODE　（共享锁）</li>
<li>SELECT … FOR UPDATE                     （悲观锁）</li>
</ul>
<p>这两种方式在事务(Transaction) 进行当中SELECT 到同一个数据表时，都必须等待其它事务数据被提交(Commit)后才会执行。</p>
<p>而主要的不同在于LOCK IN SHARE MODE 在有一方事务要Update 同一个表单时很容易造成死锁。</p>
<p>简单的说，如果SELECT 后面若要UPDATE 同一个表单，最好使用SELECT … FOR UPDATE。</p>
<p><strong>代码实现</strong></p>
<p>改造StockService：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606487086837.png" alt="1606487086837"></p>
<p>在StockeMapper中定义selectStockForUpdate方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StockMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Stock&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Stock <span class="title function_">selectStockForUpdate</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在StockMapper.xml中定义对应的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.distributedlock.mapper.StockMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStockForUpdate&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.distributedlock.pojo.Stock&quot;</span>&gt;</span></span><br><span class="line">        select * from db_stock where id = #&#123;id&#125; for update</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>压力测试</strong></p>
<p>注意：测试之前，需要把库存量改成5000。压测数据如下：比jvm性能高很多，比无锁要低将近1倍</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606487362848.png" alt="1606487362848"></p>
<p>mysql数据库存：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606487554822.png" alt="1606487554822"></p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则重试。那么我们如何实现乐观锁呢</p>
<p>使用数据版本（Version）记录机制实现，这是乐观锁最常用的实现 方式。一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录 的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新。</p>
<p>给db_stock表添加version字段：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606489307266.png" alt="1606489307266"></p>
<p>对应也需要给Stock实体类添加version属性。此处略。。。。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">    <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再减库存</span></span><br><span class="line">    <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 获取版本号</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">version</span> <span class="operator">=</span> stock.getVersion();</span><br><span class="line"></span><br><span class="line">        stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 每次更新 版本号 + 1</span></span><br><span class="line">        stock.setVersion(stock.getVersion() + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 更新之前先判断是否是之前查询的那个版本，如果不是重试</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stockMapper.update(stock, <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;Stock&gt;().eq(<span class="string">&quot;id&quot;</span>, stock.getId()).eq(<span class="string">&quot;version&quot;</span>, version)) == <span class="number">0</span>) &#123;</span><br><span class="line">            checkAndLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启后使用jmeter压力测试工具结果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606491642613.png" alt="1606491642613"></p>
<p>修改测试参数如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606491689743.png" alt="1606491689743"></p>
<p>测试结果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606491754596.png" alt="1606491754596"></p>
<p>说明乐观锁在并发量越大的情况下，性能越低（因为需要大量的重试）；并发量越小，性能越高。</p>
<h3 id="mysql锁总结"><a href="#mysql锁总结" class="headerlink" title="mysql锁总结"></a>mysql锁总结</h3><p>性能：一个sql &gt; 悲观锁 &gt; jvm锁 &gt; 乐观锁</p>
<p>如果追求极致性能、业务场景简单并且不需要记录数据前后变化的情况下。</p>
<p>​        优先选择：一个sql</p>
<p>如果写并发量较低（多读），争抢不是很激烈的情况下优先选择：乐观锁</p>
<p>如果写并发量较高，一般会经常冲突，此时选择乐观锁的话，会导致业务代码不间断的重试。</p>
<p>​        优先选择：mysql悲观锁</p>
<p>不推荐jvm本地锁。</p>
<h2 id="redis乐观锁"><a href="#redis乐观锁" class="headerlink" title="redis乐观锁"></a>redis乐观锁</h2><p>利用redis监听 + 事务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watch stock</span><br><span class="line">multi</span><br><span class="line">set stock 5000</span><br><span class="line">exec</span><br></pre></td></tr></table></figure>

<p>如果执行过程中stock的值没有被其他链接改变，则执行成功</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220428200109930.png" alt="image-20220428200109930"></p>
<p>如果执行过程中stock的值被改变，则执行失败效果如下：</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220428200244567.png" alt="image-20220428200244567"></p>
<p>具体代码实现，只需要改造对应的service方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">            operations.watch(<span class="string">&quot;stock&quot;</span>);</span><br><span class="line">            <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">stock</span> <span class="operator">=</span> operations.opsForValue().get(<span class="string">&quot;stock&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">st</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; (st = Integer.parseInt(stock.toString())) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 3. 扣减库存</span></span><br><span class="line">                operations.multi();</span><br><span class="line">                operations.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">                <span class="type">List</span> <span class="variable">exec</span> <span class="operator">=</span> operations.exec();</span><br><span class="line">                <span class="keyword">if</span> (exec == <span class="literal">null</span> || exec.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    deduct();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> exec;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>借助于redis中的命令setnx(key, value)，key不存在就新增，存在就什么都不做。同时有多个客户端发送setnx命令，只有一个客户端可以成功，返回1（true）；其他的客户端返回0（false）。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606626611922.png" alt="1606626611922"></p>
<ol>
<li>多个客户端同时获取锁（setnx）</li>
<li>获取成功，执行业务逻辑，执行完成释放锁（del）</li>
<li>其他客户端等待重试</li>
</ol>
<p>改造StockService方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁setnx</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">        <span class="comment">// 重试：递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (!lock)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="built_in">this</span>.deduct();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">                <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">st</span> <span class="operator">=</span> Integer.valueOf(stock);</span><br><span class="line">                    <span class="keyword">if</span> (st &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 3.扣减库存</span></span><br><span class="line">                        redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                <span class="built_in">this</span>.redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，加锁也可以使用循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁，获取锁失败重试</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>))&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">40</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="built_in">this</span>.redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用Jmeter压力测试如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606736612201.png" alt="1606736612201"></p>
<h2 id="防死锁"><a href="#防死锁" class="headerlink" title="防死锁"></a>防死锁</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606702476465.png" alt="1606702476465"></p>
<p>问题：setnx刚刚获取到锁，当前服务器宕机，导致del释放锁无法执行，进而导致锁无法锁无法释放（死锁）</p>
<p>解决：给锁设置过期时间，自动释放锁。</p>
<p>设置过期时间两种方式：</p>
<ol>
<li>通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</li>
<li>使用set指令设置过期时间：set key value ex 3 nx（既达到setnx的效果，又设置了过期时间）</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504102416597.png" alt="image-20220504102416597"></p>
<p>压力测试肯定也没有问题。</p>
<h2 id="防误删"><a href="#防误删" class="headerlink" title="防误删"></a>防误删</h2><p>问题：可能会释放其他服务器的锁。</p>
<p>场景：如果业务逻辑的执行时间是7s。执行流程如下</p>
<ol>
<li><p>index1业务逻辑没执行完，3秒后锁被自动释放。</p>
</li>
<li><p>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</p>
</li>
<li><p>index3获取到锁，执行业务逻辑</p>
</li>
<li><p>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</p>
<p>最终等于没锁的情况。</p>
</li>
</ol>
<p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606707959639.png" alt="1606707959639"></p>
<p>实现如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504102714512.png" alt="image-20220504102714512"></p>
<p>问题：删除操作缺乏原子性。</p>
<p>场景：</p>
<ol>
<li>index1执行删除时，查询到的lock值确实和uuid相等</li>
<li>index1执行删除前，lock刚好过期时间已到，被redis自动释放</li>
<li>index2获取了lock</li>
<li>index1执行删除，此时会把index2的lock删除</li>
</ol>
<p>解决方案：没有一个命令可以同时做到判断 + 删除，所有只能通过其他方式实现（<strong>LUA脚本</strong>）</p>
<h2 id="redis中的lua脚本"><a href="#redis中的lua脚本" class="headerlink" title="redis中的lua脚本"></a>redis中的lua脚本</h2><h3 id="现实问题"><a href="#现实问题" class="headerlink" title="现实问题"></a>现实问题</h3><p>redis采用单线程架构，可以保证单个命令的原子性，但是无法保证一组命令在高并发场景下的原子性。例如：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606711874388.png" alt="1606711874388"></p>
<p>在串行场景下：A和B的值肯定都是3</p>
<p>在并发场景下：A和B的值可能在0-6之间。</p>
<p>极限情况下1：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606712580214.png" alt="1606712580214"></p>
<p>则A的结果是0，B的结果是3</p>
<p>极限情况下2：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606712697401.png" alt="1606712697401"></p>
<p>则A和B的结果都是6</p>
<p>如果redis客户端通过lua脚本把3个命令一次性发送给redis服务器，那么这三个指令就不会被其他客户端指令打断。Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 这和使用 MULTI/ EXEC 包围的事务很类似。 </p>
<p>但是MULTI/ EXEC方法来使用事务功能，将一组命令打包执行，无法进行业务逻辑的操作。这期间有某一条命令执行报错（例如给字符串自增），其他的命令还是会执行，并不会回滚。</p>
<h3 id="lua介绍"><a href="#lua介绍" class="headerlink" title="lua介绍"></a>lua介绍</h3><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<p><strong>设计目的</strong></p>
<p>​    其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<p><strong>Lua 特性</strong></p>
<ul>
<li><strong>轻量级</strong>：它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。</li>
<li><strong>可扩展</strong>：Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。</li>
<li>其它特性：<ul>
<li>支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；</li>
<li>自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；</li>
<li>语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；</li>
<li>通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。</li>
</ul>
</li>
</ul>
<h3 id="lua基本语法"><a href="#lua基本语法" class="headerlink" title="lua基本语法"></a>lua基本语法</h3><p>对lua脚本感兴趣的同学，请移步到官方教程或者《菜鸟教程》。这里仅以redis中可能会用到的部分语法作介绍。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>               <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">5</span>         <span class="comment">-- 局部变量， redis只支持局部变量</span></span><br><span class="line">a, b = <span class="number">10</span>, <span class="number">2</span>*x      <span class="comment">-- 等价于       a=10; b=2*x</span></span><br></pre></td></tr></table></figure>

<p>流程控制：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( 布尔表达式 <span class="number">1</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 1 为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">elseif</span>( 布尔表达式 <span class="number">2</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 2 为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="comment">--[ 如果以上布尔表达式都不为 true 则执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="redis执行lua脚本-EVAL指令"><a href="#redis执行lua脚本-EVAL指令" class="headerlink" title="redis执行lua脚本 - EVAL指令"></a>redis执行lua脚本 - EVAL指令</h3><p>在redis中需要通过eval命令执行lua脚本。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br><span class="line">script：lua脚本字符串，这段Lua脚本不需要（也不应该）定义函数。</span><br><span class="line">numkeys：lua脚本中KEYS数组的大小</span><br><span class="line">key [key ...]：KEYS数组中的元素</span><br><span class="line">arg [arg ...]：ARGV数组中的元素</span><br></pre></td></tr></table></figure>

<p>案例1：基本案例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;return 10&quot; 0</span><br></pre></td></tr></table></figure>

<p>输出：(integer) 10</p>
<p>案例2：动态传参</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 5 10 20 30 40 50 60 70 80 90</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出：10 20 60 70</span></span><br><span class="line"></span><br><span class="line">EVAL &quot;if KEYS[1] &gt; ARGV[1] then return 1 else return 0 end&quot; 1 10 20</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出：0</span></span><br><span class="line"></span><br><span class="line">EVAL &quot;if KEYS[1] &gt; ARGV[1] then return 1 else return 0 end&quot; 1 20 10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出：1</span></span><br></pre></td></tr></table></figure>

<p>传入了两个参数10和20，KEYS的长度是1，所以KEYS中有一个元素10，剩余的一个20就是ARGV数组的元素。</p>
<p>redis.call()中的redis是redis中提供的lua脚本类库，仅在redis环境中可以使用该类库。</p>
<p>案例3：执行redis类库方法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set aaa 10  -- 设置一个aaa值为10</span><br><span class="line">EVAL &quot;return redis.call(&#x27;get&#x27;, &#x27;aaa&#x27;)&quot; 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过<span class="built_in">return</span>把call方法返回给redis客户端，打印：<span class="string">&quot;10&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>脚本里使用的所有键都应该由 KEYS 数组来传递。</strong>但并不是强制性的，代价是这样写出的脚本不能被 Redis 集群所兼容。</p>
<p>案例4：给redis类库方法动态传参</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot; 1 bbb 20</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1600610957600.png" alt="1600610957600"></p>
<p>学到这里基本可以应付redis分布式锁所需要的脚本知识了。</p>
<p>案例5：pcall函数的使用（了解）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 当call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，输出错误信息</span><br><span class="line">EVAL &quot;return redis.call(&#x27;sets&#x27;, KEYS[1], ARGV[1]), redis.call(&#x27;set&#x27;, KEYS[2], ARGV[2])&quot; 2 bbb ccc 20 30</span><br><span class="line">-- pcall函数不影响后续指令的执行</span><br><span class="line">EVAL &quot;return redis.pcall(&#x27;sets&#x27;, KEYS[1], ARGV[1]), redis.pcall(&#x27;set&#x27;, KEYS[2], ARGV[2])&quot; 2 bbb ccc 20 30</span><br></pre></td></tr></table></figure>

<p><strong>注意：set方法写成了sets</strong>，肯定会报错。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1600612707202.png" alt="1600612707202"></p>
<h2 id="使用lua保证删除原子性"><a href="#使用lua保证删除原子性" class="headerlink" title="使用lua保证删除原子性"></a>使用lua保证删除原子性</h2><p>删除LUA脚本：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]) <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">// 加锁setnx</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">// 重试：循环</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// this.redisTemplate.expire(&quot;lock&quot;, 3, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">st</span> <span class="operator">=</span> Integer.valueOf(stock);</span><br><span class="line">            <span class="keyword">if</span> (st &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.扣减库存</span></span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 先判断是否自己的锁，再解锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] &quot;</span> +</span><br><span class="line">            <span class="string">&quot;then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;else &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">            <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(<span class="string">&quot;lock&quot;</span>), uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>压力测试，库存量也没有问题，截图略过。。。</p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>由于上述加锁命令使用了 SETNX ，一旦键存在就无法再设置成功，这就导致后续同一线程内继续加锁，将会加锁失败。当一个线程执行一段代码成功获取锁之后，继续执行时，又遇到加锁的子任务代码，可重入性就保证线程能继续执行，而不可重入就是需要等待锁释放之后，再次获取锁成功，才能继续往下执行。</p>
<p>用一段 Java 代码解释可重入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// pass</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 X 线程在 a 方法获取锁之后，继续执行 b 方法，如果此时<strong>不可重入</strong>，线程就必须等待锁释放，再次争抢锁。</p>
<p>锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~</p>
<p>可重入性就可以解决这个尴尬的问题，当线程拥有锁之后，往后再遇到加锁方法，直接将加锁次数加 1，然后再执行方法逻辑。退出加锁方法之后，加锁次数再减 1，当加锁次数为 0 时，锁才被真正的释放。</p>
<p>可以看到可重入锁最大特性就是计数，计算加锁的次数。所以当可重入锁需要在分布式环境实现时，我们也就需要统计加锁次数。</p>
<p>解决方案：redis + Hash</p>
<h3 id="加锁脚本"><a href="#加锁脚本" class="headerlink" title="加锁脚本"></a>加锁脚本</h3><p>Redis 提供了 Hash （哈希表）这种可以存储键值对数据结构。所以我们可以使用 Redis Hash 存储的锁的重入次数，然后利用 lua 脚本判断逻辑。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span> <span class="keyword">or</span> redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span>) </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>假设值为：KEYS:[lock], ARGV[uuid, expire]</p>
<p>如果锁不存在或者这是自己的锁，就通过hincrby（不存在就新增并加1，存在就加1）获取锁或者锁次数加1。</p>
<h3 id="解锁脚本"><a href="#解锁脚本" class="headerlink" title="解锁脚本"></a>解锁脚本</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 判断 hash set 可重入 key 的值是否等于 0</span></span><br><span class="line"><span class="comment">-- 如果为 nil 代表 自己的锁已不存在，在尝试解其他线程的锁，解锁失败</span></span><br><span class="line"><span class="comment">-- 如果为 0 代表 可重入次数被减 1</span></span><br><span class="line"><span class="comment">-- 如果为 1 代表 该可重入 key 解锁成功</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line"><span class="keyword">elseif</span>(redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">-1</span>) &gt; <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>



<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>由于加解锁代码量相对较多，这里可以封装成一个工具类：</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504095916188.png" alt="image-20220504095916188"></p>
<p>DistributedLockClient工厂类具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedLockClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedLockClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uuid = UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DistributedRedisLock <span class="title function_">getRedisLock</span><span class="params">(String lockName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DistributedRedisLock</span>(redisTemplate, lockName, uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DistributedRedisLock实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedRedisLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedRedisLock</span><span class="params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockName;</span><br><span class="line">        <span class="built_in">this</span>.uuid = uuid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.tryLock(-<span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (time != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.expire = unit.toSeconds(time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), getId(), String.valueOf(expire)))&#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return nil &quot;</span> +</span><br><span class="line">                <span class="string">&quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class), Arrays.asList(lockName), getId());</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;this lock doesn&#x27;t belong to you!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给线程拼接唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uuid + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="使用及测试"><a href="#使用及测试" class="headerlink" title="使用及测试"></a>使用及测试</h3><p>在业务代码中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DistributedRedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="built_in">this</span>.distributedLockClient.getRedisLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    redisLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">st</span> <span class="operator">=</span> Integer.valueOf(stock);</span><br><span class="line">            <span class="keyword">if</span> (st &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.扣减库存</span></span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606747747780.png" alt="1606747747780"></p>
<p>测试可重入性：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504101636357.png" alt="image-20220504101636357"></p>
<h2 id="自动续期"><a href="#自动续期" class="headerlink" title="自动续期"></a>自动续期</h2><p>lua脚本：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span>) <span class="keyword">then</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在RedisDistributeLock中添加renewExpire方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedRedisLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedRedisLock</span><span class="params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockName;</span><br><span class="line">        <span class="built_in">this</span>.uuid = uuid + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.tryLock(-<span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (time != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.expire = unit.toSeconds(time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), uuid, String.valueOf(expire)))&#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加锁成功，返回之前，开启定时器自动续期</span></span><br><span class="line">        <span class="built_in">this</span>.renewExpire();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return nil &quot;</span> +</span><br><span class="line">                <span class="string">&quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class), Arrays.asList(lockName), uuid);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;this lock doesn&#x27;t belong to you!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String getId()&#123;</span></span><br><span class="line">    <span class="comment">//     return this.uuid + &quot;:&quot; + Thread.currentThread().getId();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpire</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Timer</span>().schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), uuid, String.valueOf(expire))) &#123;</span><br><span class="line">                    renewExpire();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="built_in">this</span>.expire * <span class="number">1000</span> / <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在tryLock方法中使用：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504100503780.png" alt="image-20220504100503780"></p>
<p>构造方法作如下修改：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504100728343.png" alt="image-20220504100728343"></p>
<p>解锁方法作如下修改：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504100850162.png" alt="image-20220504100850162"></p>
<h2 id="手写分步式锁小结"><a href="#手写分步式锁小结" class="headerlink" title="手写分步式锁小结"></a>手写分步式锁小结</h2><p>特征：</p>
<ol>
<li><p>独占排他：setnx</p>
</li>
<li><p>防死锁：</p>
<p>redis客户端程序获取到锁之后，立马宕机。给锁添加过期时间</p>
<p>不可重入：可重入</p>
</li>
<li><p>防误删：</p>
<p>先判断是否自己的锁才能删除</p>
</li>
<li><p>原子性：</p>
<p>加锁和过期时间之间：set k v ex 3 nx</p>
<p>判断和释放锁之间：lua脚本</p>
</li>
<li><p>可重入性：hash（key field value） + lua脚本 </p>
</li>
<li><p>自动续期：Timer定时器 + lua脚本</p>
</li>
<li><p>在集群情况下，导致锁机制失效：</p>
<ol>
<li>客户端程序10010，从主中获取锁</li>
<li>从还没来得及同步数据，主挂了</li>
<li>于是从升级为主</li>
<li>客户端程序10086就从新主中获取到锁，导致锁机制失效</li>
</ol>
</li>
</ol>
<p>锁操作：</p>
<p>加锁：</p>
<ol>
<li><p>setnx：独占排他   死锁、不可重入、原子性</p>
</li>
<li><p>set k v ex 30 nx：独占排他、死锁         不可重入 </p>
</li>
<li><p>hash + lua脚本：可重入锁</p>
<ol>
<li>判断锁是否被占用（exists），如果没有被占用则直接获取锁（hset/hincrby）并设置过期时间（expire）</li>
<li>如果锁被占用，则判断是否当前线程占用的（hexists），如果是则重入（hincrby）并重置过期时间（expire）</li>
<li>否则获取锁失败，将来代码中重试</li>
</ol>
</li>
<li><p>Timer定时器 + lua脚本：实现锁的自动续期</p>
<p>判断锁是否自己的锁（hexists == 1），如果是自己的锁则执行expire重置过期时间</p>
</li>
</ol>
<p>解锁 </p>
<ol>
<li>del：导致误删</li>
<li>先判断再删除同时保证原子性：lua脚本</li>
<li>hash + lua脚本：可重入 <pre><code>1. 判断当前线程的锁是否存在，不存在则返回nil，将来抛出异常
</code></pre>
<ol start="2">
<li>存在则直接减1（hincrby -1），判断减1后的值是否为0，为0则释放锁（del），并返回1</li>
<li>不为0，则返回0</li>
</ol>
</li>
</ol>
<p>重试：递归 循环 </p>
<h2 id="红锁算法"><a href="#红锁算法" class="headerlink" title="红锁算法"></a>红锁算法</h2><p>redis集群状态下的问题：</p>
<ol>
<li>客户端A从master获取到锁</li>
<li>在master将锁同步到slave之前，master宕掉了。</li>
<li>slave节点被晋级为master节点</li>
<li>客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。</li>
</ol>
<p><strong>安全失效</strong>！</p>
<p>解决集群下锁失效，参照redis官方网站针对redlock文档：<a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></p>
<p>在算法的分布式版本中，我们假设有N个Redis服务器。这些节点是完全独立的，因此我们不使用复制或任何其他隐式协调系统。<strong>前几节已经描述了如何在单个实例中安全地获取和释放锁，在分布式锁算法中，将使用相同的方法在单个实例中获取和释放锁。</strong>将N设置为5是一个合理的值，因此需要在不同的计算机或虚拟机上运行5个Redis主服务器，确保它们以独立的方式发生故障。</p>
<p>为了获取锁，客户端执行以下操作：</p>
<ol>
<li>客户端以毫秒为单位获取当前时间的时间戳，作为<strong>起始时间</strong>。</li>
<li>客户端尝试在所有N个实例中顺序使用相同的键名、相同的随机值来获取锁定。每个实例尝试获取锁都需要时间，客户端应该设置一个远小于总锁定时间的超时时间。例如，如果自动释放时间为10秒，则<strong>尝试获取锁的超时时间</strong>可能在5到50毫秒之间。这样可以防止客户端长时间与处于故障状态的Redis节点进行通信：如果某个实例不可用，尽快尝试与下一个实例进行通信。</li>
<li>客户端获取当前时间 减去在步骤1中获得的<strong>起始时间</strong>，来计算<strong>获取锁所花费的时间</strong>。当且仅当客户端能够在大多数实例（至少3个）中获取锁时，并且获取锁所花费的总时间小于锁有效时间，则认为已获取锁。</li>
<li>如果获取了锁，则将锁有效时间减去 <strong>获取锁所花费的时间</strong>，如步骤3中所计算。</li>
<li>如果客户端由于某种原因（无法锁定N / 2 + 1个实例或有效时间为负）而未能获得该锁，它将尝试解锁所有实例（即使没有锁定成功的实例）。</li>
</ol>
<p>每台计算机都有一个本地时钟，我们通常可以依靠不同的计算机来产生很小的时钟漂移。只有在拥有锁的客户端将在锁有效时间内（如步骤3中获得的）减去一段时间（仅几毫秒）的情况下终止工作，才能保证这一点。以补偿进程之间的时钟漂移</p>
<p>当客户端无法获取锁时，它应该在随机延迟后重试，以避免同时获取同一资源的多个客户端之间不同步（这可能会导致脑裂的情况：没人胜）。同样，客户端在大多数Redis实例中尝试获取锁的速度越快，出现裂脑情况（以及需要重试）的窗口就越小，因此理想情况下，客户端应尝试将SET命令发送到N个实例同时使用多路复用。</p>
<p>值得强调的是，对于未能获得大多数锁的客户端，尽快释放（部分）获得的锁有多么重要，这样就不必等待锁定期满才能再次获得锁（但是，如果发生了网络分区，并且客户端不再能够与Redis实例进行通信，则在等待密钥到期时需要付出可用性损失）。</p>
<h2 id="redisson中的分布式锁"><a href="#redisson中的分布式锁" class="headerlink" title="redisson中的分布式锁"></a>redisson中的分布式锁</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220501155501783.png" alt="image-20220501155501783"></p>
<p>​        Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1568176834908.png" alt="1568176834908"></p>
<p>官方文档地址：<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki">https://github.com/redisson/redisson/wiki</a></p>
<h3 id="2-1-可重入锁（Reentrant-Lock）"><a href="#2-1-可重入锁（Reentrant-Lock）" class="headerlink" title="2.1 可重入锁（Reentrant Lock）"></a>2.1 可重入锁（Reentrant Lock）</h3><p>基于Redis的Redisson分布式可重入锁<code>RLock</code> Java对象实现了<code>java.util.concurrent.locks.Lock</code>接口。</p>
<p>大家都知道，如果负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗检查锁的超时时间是30秒钟，也可以通过修改<code>Config.lockWatchdogTimeout</code>来另行指定。</p>
<p><code>RLock</code>对象完全符合Java的Lock规范。也就是说只有拥有锁的进程才能解锁，其他进程解锁则会抛出<code>IllegalMonitorStateException</code>错误。</p>
<p>另外Redisson还通过加锁的方法提供了<code>leaseTime</code>的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁以后10秒钟自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>添加配置</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 可以用&quot;rediss://&quot;来启用SSL连接</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://172.16.116.100:6379&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>代码中使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁，获取锁失败重试</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">    <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">// 再减库存</span></span><br><span class="line">    <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>压力测试</li>
</ol>
<p>性能跟我们手写的区别不大。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606958454966.png" alt="1606958454966"></p>
<p>数据库也没有问题</p>
<h3 id="2-1-公平锁（Fair-Lock）"><a href="#2-1-公平锁（Fair-Lock）" class="headerlink" title="2.1 公平锁（Fair Lock）"></a>2.1 公平锁（Fair Lock）</h3><p>基于Redis的Redisson分布式可重入公平锁也是实现了<code>java.util.concurrent.locks.Lock</code>接口的一种<code>RLock</code>对象。同时还提供了<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockAsync.html">异步（Async）</a>、<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockReactive.html">反射式（Reactive）</a>和<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockRx.html">RxJava2标准</a>的接口。它保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> redisson.getFairLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">fairLock.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10秒钟以后自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">fairLock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> fairLock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">fairLock.unlock();</span><br></pre></td></tr></table></figure>



<h3 id="2-1-联锁（MultiLock）"><a href="#2-1-联锁（MultiLock）" class="headerlink" title="2.1 联锁（MultiLock）"></a>2.1 联锁（MultiLock）</h3><p>基于Redis的Redisson分布式联锁<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/RedissonMultiLock.html"><code>RedissonMultiLock</code></a>对象可以将多个<code>RLock</code>对象关联为一个联锁，每个<code>RLock</code>对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonInstance1.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonInstance2.getLock(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonInstance3.getLock(<span class="string">&quot;lock3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">RedissonMultiLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonMultiLock</span>(lock1, lock2, lock3);</span><br><span class="line"><span class="comment">// 同时加锁：lock1 lock2 lock3</span></span><br><span class="line"><span class="comment">// 所有的锁都上锁成功才算成功。</span></span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>



<h3 id="2-1-红锁（RedLock）"><a href="#2-1-红锁（RedLock）" class="headerlink" title="2.1 红锁（RedLock）"></a>2.1 红锁（RedLock）</h3><p>基于Redis的Redisson红锁<code>RedissonRedLock</code>对象实现了<a target="_blank" rel="noopener" href="http://redis.cn/topics/distlock.html">Redlock</a>介绍的加锁算法。该对象也可以用来将多个<code>RLock</code>对象关联为一个红锁，每个<code>RLock</code>对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonInstance1.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonInstance2.getLock(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonInstance3.getLock(<span class="string">&quot;lock3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">RedissonRedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonRedLock</span>(lock1, lock2, lock3);</span><br><span class="line"><span class="comment">// 同时加锁：lock1 lock2 lock3</span></span><br><span class="line"><span class="comment">// 红锁在大部分节点上加锁成功就算成功。</span></span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>



<h3 id="2-1-读写锁（ReadWriteLock）"><a href="#2-1-读写锁（ReadWriteLock）" class="headerlink" title="2.1 读写锁（ReadWriteLock）"></a>2.1 读写锁（ReadWriteLock）</h3><p>基于Redis的Redisson分布式可重入读写锁<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.4.3/org/redisson/api/RReadWriteLock.html"><code>RReadWriteLock</code></a> Java对象实现了<code>java.util.concurrent.locks.ReadWriteLock</code>接口。其中读锁和写锁都继承了<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8#81-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81reentrant-lock">RLock</a>接口。</p>
<p>分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;anyRWLock&quot;</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10秒钟以后自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">rwlock.readLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">rwlock.writeLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rwlock.readLock().tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rwlock.writeLock().tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>



<p>添加StockController方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/read&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRead</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> stockService.testRead();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;测试读&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;test/write&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testWrite</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> stockService.testWrite();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;测试写&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>添加StockService方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">testRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getReadWriteLock(<span class="string">&quot;rwLock&quot;</span>);</span><br><span class="line">    rwLock.readLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;测试读锁。。。。&quot;</span>);</span><br><span class="line">    <span class="comment">// rwLock.readLock().unlock();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testWrite</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getReadWriteLock(<span class="string">&quot;rwLock&quot;</span>);</span><br><span class="line">    rwLock.writeLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;测试写锁。。。。&quot;</span>);</span><br><span class="line">    <span class="comment">// rwLock.writeLock().unlock();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>打开开两个浏览器窗口测试：</p>
<ul>
<li>同时访问写：一个写完之后，等待一会儿（约10s），另一个写开始</li>
<li>同时访问读：不用等待</li>
<li>先写后读：读要等待（约10s）写完成</li>
<li>先读后写：写要等待（约10s）读完成</li>
</ul>
<h3 id="2-10-6-信号量（Semaphore）"><a href="#2-10-6-信号量（Semaphore）" class="headerlink" title="2.10.6. 信号量（Semaphore）"></a>2.10.6. 信号量（Semaphore）</h3><p>基于Redis的Redisson的分布式信号量（<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphore.html">Semaphore</a>）Java对象<code>RSemaphore</code>采用了与<code>java.util.concurrent.Semaphore</code>相似的接口和用法。同时还提供了<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreAsync.html">异步（Async）</a>、<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreReactive.html">反射式（Reactive）</a>和<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreRx.html">RxJava2标准</a>的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RSemaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> redisson.getSemaphore(<span class="string">&quot;semaphore&quot;</span>);</span><br><span class="line">semaphore.trySetPermits(<span class="number">3</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>



<p>在StockController添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/semaphore&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSemaphore</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testSemaphore();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;测试信号量&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在StockService添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSemaphore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RSemaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getSemaphore(<span class="string">&quot;semaphore&quot;</span>);</span><br><span class="line">    semaphore.trySetPermits(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>添加测试用例：并发10次，循环一次</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606961296212.png" alt="1606961296212"></p>
<p>控制台效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">控制台1：</span><br><span class="line">1606960790234</span><br><span class="line">1606960800337</span><br><span class="line">1606960800443</span><br><span class="line">1606960805248</span><br><span class="line"></span><br><span class="line">控制台2：</span><br><span class="line">1606960790328</span><br><span class="line">1606960795332</span><br><span class="line">1606960800245</span><br><span class="line"></span><br><span class="line">控制台3：</span><br><span class="line">1606960790433</span><br><span class="line">1606960795238</span><br><span class="line">1606960795437</span><br></pre></td></tr></table></figure>



<p>由此可知：</p>
<p>1606960790秒有3次请求进来：每个控制台各1次</p>
<p>1606960795秒有3次请求进来：控制台2有1次，控制台3有2次</p>
<p>1606960800秒有3次请求进来：控制台1有2次，控制台2有1次</p>
<p>1606960805秒有1次请求进来：控制台1有1次</p>
<h3 id="2-1-闭锁（CountDownLatch）"><a href="#2-1-闭锁（CountDownLatch）" class="headerlink" title="2.1 闭锁（CountDownLatch）"></a>2.1 闭锁（CountDownLatch）</h3><p>基于Redisson的Redisson分布式闭锁（<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RCountDownLatch.html">CountDownLatch</a>）Java对象<code>RCountDownLatch</code>采用了与<code>java.util.concurrent.CountDownLatch</code>相似的接口和用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;anyCountDownLatch&quot;</span>);</span><br><span class="line">latch.trySetCount(<span class="number">1</span>);</span><br><span class="line">latch.await();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程或其他JVM里</span></span><br><span class="line"><span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;anyCountDownLatch&quot;</span>);</span><br><span class="line">latch.countDown();</span><br></pre></td></tr></table></figure>

<p>需要两个方法：一个等待，一个计数countDown</p>
<p>给StockController添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/latch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testLatch</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testLatch();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;班长锁门。。。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;test/countdown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testCountDown</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testCountDown();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;出来了一位同学&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>给StockService添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getCountDownLatch(<span class="string">&quot;latch&quot;</span>);</span><br><span class="line">    latch.trySetCount(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCountDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getCountDownLatch(<span class="string">&quot;latch&quot;</span>);</span><br><span class="line">    latch.trySetCount(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重启测试，打开两个页面：当第二个请求执行6次之后，第一个请求才会执行。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606962536746.png" alt="1606962536746"></p>
<h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><p>实现分布式锁目前有三种流行方案，分别为基于数据库、Redis、Zookeeper的方案。这里主要介绍基于zk怎么实现分布式锁。在实现分布式锁之前，先回顾zookeeper的相关知识点</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220622191952608.png" alt="image-20220622191952608"></p>
<h2 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h2><h3 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h3><p>安装：把zk安装包上传到/opt目录下，并切换到/opt目录下，执行以下指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf zookeeper-3.7.0-bin.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重命名</span></span><br><span class="line">mv apache-zookeeper-3.7.0-bin/ zookeeper</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开zookeeper根目录</span></span><br><span class="line">cd /opt/zookeeper</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个数据目录，备用</span></span><br><span class="line">mkdir data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开zk的配置目录</span></span><br><span class="line">cd /opt/zookeeper/conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">copy配置文件，zk启动时会加载zoo.cfg文件</span></span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑配置文件</span></span><br><span class="line">vim zoo.cfg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改dataDir参数为之前创建的数据目录：/opt/zookeeper/data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到bin目录</span></span><br><span class="line">cd /opt/zookeeper/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span> </span><br><span class="line">./zkServer.sh start</span><br><span class="line">./zkServer.sh status # 查看启动状态</span><br><span class="line">./zkServer.sh stop # 停止</span><br><span class="line">./zkServer.sh restart # 重启</span><br><span class="line">./zkCli.sh # 查看zk客户端</span><br></pre></td></tr></table></figure>

<p>如下，说明启动成功：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220501175644704.png" alt="image-20220501175644704"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>Zookeeper提供一个多层级的节点命名空间（节点称为znode），每个节点都用一个以斜杠（/）分隔的路径表示，而且每个节点都有父节点（根节点除外），非常类似于文件系统。并且每个节点都是唯一的。</p>
<p>znode节点有四种类型：</p>
<ul>
<li><strong>PERSISTENT</strong>：永久节点。客户端与zookeeper断开连接后，该节点依旧存在</li>
<li><strong>EPHEMERAL</strong>：临时节点。客户端与zookeeper断开连接后，该节点被删除</li>
<li><strong>PERSISTENT_SEQUENTIAL</strong>：永久节点、序列化。客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</li>
<li><strong>EPHEMERAL_SEQUENTIAL</strong>：临时节点、序列化。客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</li>
</ul>
<p>创建这四种节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] create /aa test  # 创建持久化节点</span><br><span class="line">Created /aa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] create -s /bb test  # 创建持久序列化节点</span><br><span class="line">Created /bb0000000001</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e /cc test  # 创建临时节点</span><br><span class="line">Created /cc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] create -e -s /dd test  # 创建临时序列化节点</span><br><span class="line">Created /dd0000000003</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /   # 查看某个节点下的子节点</span><br><span class="line">[aa, bb0000000001, cc, dd0000000003, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] stat /  # 查看某个节点的状态</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x5</span><br><span class="line">cversion = 3</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 5</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] get /aa  # 查看某个节点的内容</span><br><span class="line">test</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] delete /aa  # 删除某个节点</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] ls /  # 再次查看</span><br><span class="line">[bb0000000001, cc, dd0000000003, zookeeper]</span><br></pre></td></tr></table></figure>



<p>事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前zookeeper针对节点的监听有如下四种事件：</p>
<ol>
<li><p>节点创建：stat -w /xx</p>
<p>当/xx节点创建时：NodeCreated</p>
</li>
<li><p>节点删除：stat -w /xx</p>
<p>当/xx节点删除时：NodeDeleted</p>
</li>
<li><p>节点数据修改：get -w /xx</p>
<p>当/xx节点数据发生变化时：NodeDataChanged</p>
</li>
<li><p>子节点变更：ls -w /xx</p>
<p>当/xx节点的子节点创建或者删除时：NodeChildChanged</p>
</li>
</ol>
<h3 id="java客户端"><a href="#java客户端" class="headerlink" title="java客户端"></a>java客户端</h3><p>ZooKeeper的java客户端有：原生客户端、ZkClient、Curator框架（类似于redisson，有很多功能性封装）。</p>
<ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>常用api及其方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取zookeeper链接</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ZooKeeper</span> <span class="variable">zooKeeper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">&quot;172.16.116.100:2181&quot;</span>, <span class="number">30000</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Event.KeeperState.SyncConnected.equals(event.getState()) </span><br><span class="line">                            &amp;&amp; Event.EventType.None.equals(event.getType())) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;获取链接成功。。。。。。&quot;</span> + event);</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个节点，1-节点路径 2-节点内容 3-节点的访问权限 4-节点类型</span></span><br><span class="line">        <span class="comment">// OPEN_ACL_UNSAFE：任何人可以操作该节点</span></span><br><span class="line">        <span class="comment">// CREATOR_ALL_ACL：创建者拥有所有访问权限</span></span><br><span class="line">        <span class="comment">// READ_ACL_UNSAFE: 任何人都可以读取该节点</span></span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/aa&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span></span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/test&quot;</span>, <span class="string">&quot;haha~~&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/cc&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span></span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/dd&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span></span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/dd&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span></span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/dd&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断节点是否存在</span></span><br><span class="line">        <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> zooKeeper.exists(<span class="string">&quot;/test&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前节点存在！&quot;</span> + stat.getVersion());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断节点是否存在，同时添加监听</span></span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/test&quot;</span>, event -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取一个节点的数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">&quot;/atguigu/ss0000000001&quot;</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询一个节点的所有子节点</span></span><br><span class="line">        List&lt;String&gt; children = zooKeeper.getChildren(<span class="string">&quot;/test&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(children);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        zooKeeper.setData(<span class="string">&quot;/test&quot;</span>, <span class="string">&quot;wawa...&quot;</span>.getBytes(), stat.getVersion());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除一个节点</span></span><br><span class="line">        <span class="comment">//zooKeeper.delete(&quot;/test&quot;, -1);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (zooKeeper != <span class="literal">null</span>)&#123;</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>分布式锁的步骤：</p>
<ol>
<li>获取锁：create一个节点</li>
<li>删除锁：delete一个节点</li>
<li>重试：没有获取到锁的请求重试</li>
</ol>
<p>参照redis分布式锁的特点：</p>
<ol>
<li>互斥 排他</li>
<li>防死锁：<ol>
<li>可自动释放锁（临时节点） ：获得锁之后客户端所在机器宕机了，客户端没有主动删除子节点；如果创建的是永久的节点，那么这个锁永远不会释放，导致死锁；由于创建的是临时节点，客户端宕机后，过了一定时间zookeeper没有收到客户端的心跳包判断会话失效，将临时节点删除从而释放锁。</li>
<li>可重入锁：借助于ThreadLocal</li>
</ol>
</li>
<li>防误删：宕机自动释放临时节点，不需要设置过期时间，也就不存在误删问题。</li>
<li>加锁/解锁要具备原子性</li>
<li>单点问题：使用Zookeeper可以有效的解决单点问题，ZK一般是集群部署的。</li>
<li>集群问题：zookeeper集群是强一致性的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li>
</ol>
<h2 id="基本实现-1"><a href="#基本实现-1" class="headerlink" title="基本实现"></a>基本实现</h2><p>实现思路：</p>
<ol>
<li>多个请求同时添加一个相同的临时节点，只有一个可以添加成功。添加成功的获取到锁</li>
<li>执行业务逻辑</li>
<li>完成业务流程后，删除节点释放锁。</li>
</ol>
<p>由于zookeeper获取链接是一个耗时过程，这里可以在项目启动时，初始化链接，并且只初始化一次。借助于spring特性，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">connectString</span> <span class="operator">=</span> <span class="string">&quot;172.16.116.100:2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 连接zookeeper服务器</span></span><br><span class="line">            <span class="built_in">this</span>.zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(connectString, <span class="number">30000</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取链接成功！！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建分布式锁根节点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.zooKeeper.exists(ROOT_PATH, <span class="literal">false</span>) == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.zooKeeper.create(ROOT_PATH, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取链接失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (zooKeeper != <span class="literal">null</span>)&#123;</span><br><span class="line">                zooKeeper.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化zk分布式锁对象方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ZkDistributedLock <span class="title function_">getZkDistributedLock</span><span class="params">(String lockName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZkDistributedLock</span>(zooKeeper, lockName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zk分布式锁具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZkDistributedLock</span><span class="params">(ZooKeeper zooKeeper, String lockName)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">        <span class="built_in">this</span>.path = ROOT_PATH + <span class="string">&quot;/&quot;</span> + lockName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper.create(path, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                lock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.zooKeeper.delete(path, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>改造StockService的checkAndLock方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ZkClient client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁，获取锁失败重试</span></span><br><span class="line">    <span class="type">ZkDistributedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.client.getZkDistributedLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">    <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">// 再减库存</span></span><br><span class="line">    <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Jmeter压力测试：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607046072239.png" alt="1607046072239"></p>
<p>性能一般，mysql数据库的库存余量为0（注意：所有测试之前都要先修改库存量为5000）</p>
<p>基本实现存在的问题：</p>
<ol>
<li>性能一般（比mysql分布式锁略好）</li>
<li>不可重入</li>
</ol>
<p>接下来首先来提高性能</p>
<h2 id="优化：性能优化"><a href="#优化：性能优化" class="headerlink" title="优化：性能优化"></a>优化：性能优化</h2><p>基本实现中由于无限自旋影响性能：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607048160051.png" alt="1607048160051"></p>
<p>试想：每个请求要想正常的执行完成，最终都是要创建节点，如果能够避免争抢必然可以提高性能。</p>
<p>这里借助于zk的临时序列化节点，实现分布式锁：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607048783043.png" alt="1607048783043"></p>
<h3 id="实现阻塞锁"><a href="#实现阻塞锁" class="headerlink" title="实现阻塞锁"></a>实现阻塞锁</h3><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZkDistributedLock</span><span class="params">(ZooKeeper zooKeeper, String lockName)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">            <span class="built_in">this</span>.path = zooKeeper.create(ROOT_PATH + <span class="string">&quot;/&quot;</span> + lockName + <span class="string">&quot;-&quot;</span>, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> getPreNode(path);</span><br><span class="line">        <span class="comment">// 如果该节点没有前一个节点，说明该节点时最小节点，放行执行业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(preNode))&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新检查。是否获取到锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.zooKeeper.delete(path, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定节点的前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getPreNode</span><span class="params">(String path)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的序列化号</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">curSerial</span> <span class="operator">=</span> Long.valueOf(StringUtils.substringAfterLast(path, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取根路径下的所有序列化子节点</span></span><br><span class="line">            List&lt;String&gt; nodes = <span class="built_in">this</span>.zooKeeper.getChildren(ROOT_PATH, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判空</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(nodes))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取前一个节点</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">                <span class="comment">// 获取每个节点的序列化号</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">serial</span> <span class="operator">=</span> Long.valueOf(StringUtils.substringAfterLast(node, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">                <span class="keyword">if</span> (serial &lt; curSerial &amp;&amp; serial &gt; flag)&#123;</span><br><span class="line">                    flag = serial;</span><br><span class="line">                    preNode = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> preNode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>主要修改了构造方法和lock方法：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607051823582.png" alt="1607051823582"></p>
<p>并添加了getPreNode获取前置节点的方法。</p>
<p>测试结果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607051896117.png" alt="1607051896117"></p>
<p>性能反而更弱了。</p>
<p>原因：虽然不用反复争抢创建节点了，但是会自旋判断自己是最小的节点，这个判断逻辑反而更复杂更耗时。</p>
<p>解决方案：监听。</p>
<h3 id="监听实现阻塞锁"><a href="#监听实现阻塞锁" class="headerlink" title="监听实现阻塞锁"></a>监听实现阻塞锁</h3><p>对于这个算法有个极大的优化点：假如当前有1000个节点在等待锁，如果获得锁的客户端释放锁时，这1000个客户端都会被唤醒，这种情况称为“羊群效应”；在这种羊群效应中，zookeeper需要通知1000个客户端，这会阻塞其他的操作，最好的情况应该只唤醒新的最小节点对应的客户端。应该怎么做呢？在设置事件监听时，每个客户端应该对刚好在它之前的子节点设置事件监听，例如子节点列表为/locks/lock-0000000000、/locks/lock-0000000001、/locks/lock-0000000002，序号为1的客户端监听序号为0的子节点删除消息，序号为2的监听序号为1的子节点删除消息。</p>
<p>所以调整后的分布式锁算法流程如下：</p>
<ul>
<li>客户端连接zookeeper，并在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/locks/lock-0000000000，第二个为/locks/lock-0000000001，以此类推；</li>
<li>客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，<strong>否则监听刚好在自己之前一位的子节点删除消息</strong>，获得子节点变更通知后重复此步骤直至获得锁；</li>
<li>执行业务代码；</li>
<li>完成业务流程后，删除对应的子节点释放锁。</li>
</ul>
<p>改造ZkDistributedLock的lock方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> getPreNode(path);</span><br><span class="line">        <span class="comment">// 如果该节点没有前一个节点，说明该节点时最小节点，放行执行业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(preNode))&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.zooKeeper.exists(ROOT_PATH + <span class="string">&quot;/&quot;</span> + preNode, <span class="keyword">new</span> <span class="title class_">Watcher</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞。。。。</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// 重新检查。是否获取到锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>压力测试效果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607052541669.png" alt="1607052541669"></p>
<p>由此可见性能提高不少，接近于redis的分布式锁</p>
<h2 id="优化：可重入锁"><a href="#优化：可重入锁" class="headerlink" title="优化：可重入锁"></a>优化：可重入锁</h2><p>引入ThreadLocal线程局部变量保证zk分布式锁的可重入性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; THREAD_LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZkDistributedLock</span><span class="params">(ZooKeeper zooKeeper, String lockName)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">            <span class="keyword">if</span> (THREAD_LOCAL.get() == <span class="literal">null</span> || THREAD_LOCAL.get() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.path = zooKeeper.create(ROOT_PATH + <span class="string">&quot;/&quot;</span> + lockName + <span class="string">&quot;-&quot;</span>, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">flag</span> <span class="operator">=</span> THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="literal">null</span> &amp;&amp; flag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            THREAD_LOCAL.set(flag + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> getPreNode(path);</span><br><span class="line">            <span class="comment">// 如果该节点没有前一个节点，说明该节点时最小节点，放行执行业务逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(preNode))&#123;</span><br><span class="line">                THREAD_LOCAL.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.zooKeeper.exists(ROOT_PATH + <span class="string">&quot;/&quot;</span> + preNode, <span class="keyword">new</span> <span class="title class_">Watcher</span>()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    THREAD_LOCAL.set(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 阻塞。。。。</span></span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                THREAD_LOCAL.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 重新检查。是否获取到锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            THREAD_LOCAL.set(THREAD_LOCAL.get() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (THREAD_LOCAL.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.zooKeeper.delete(path, <span class="number">0</span>);</span><br><span class="line">                THREAD_LOCAL.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定节点的前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getPreNode</span><span class="params">(String path)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的序列化号</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">curSerial</span> <span class="operator">=</span> Long.valueOf(StringUtils.substringAfterLast(path, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取根路径下的所有序列化子节点</span></span><br><span class="line">            List&lt;String&gt; nodes = <span class="built_in">this</span>.zooKeeper.getChildren(ROOT_PATH, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判空</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(nodes))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取前一个节点</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">                <span class="comment">// 获取每个节点的序列化号</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">serial</span> <span class="operator">=</span> Long.valueOf(StringUtils.substringAfterLast(node, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">                <span class="keyword">if</span> (serial &lt; curSerial &amp;&amp; serial &gt; flag)&#123;</span><br><span class="line">                    flag = serial;</span><br><span class="line">                    preNode = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> preNode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="zk分布式锁小结"><a href="#zk分布式锁小结" class="headerlink" title="zk分布式锁小结"></a>zk分布式锁小结</h2><p>参照redis分布式锁的特点：</p>
<ol>
<li>互斥 排他：zk节点的不可重复性，以及序列化节点的有序性</li>
<li>防死锁：<ol>
<li>可自动释放锁：临时节点</li>
<li>可重入锁：借助于ThreadLocal</li>
</ol>
</li>
<li>防误删：临时节点</li>
<li>加锁/解锁要具备原子性</li>
<li>单点问题：使用Zookeeper可以有效的解决单点问题，ZK一般是集群部署的。</li>
<li>集群问题：zookeeper集群是强一致性的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li>
<li>公平锁：有序性节点</li>
</ol>
<h2 id="Curator中的分布式锁"><a href="#Curator中的分布式锁" class="headerlink" title="Curator中的分布式锁"></a>Curator中的分布式锁</h2><p>Curator是netflix公司开源的一套zookeeper客户端，目前是Apache的顶级项目。与Zookeeper提供的原生客户端相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量。Curator解决了很多zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册wathcer和NodeExistsException 异常等。</p>
<p>通过查看官方文档，可以发现Curator主要解决了三类问题：</p>
<ul>
<li>封装ZooKeeper client与ZooKeeper server之间的连接处理</li>
<li>提供了一套Fluent风格的操作API</li>
<li>提供ZooKeeper各种应用场景(recipe， 比如：分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等)的抽象封装，这些实现都遵循了zk的最佳实践，并考虑了各种极端情况</li>
</ul>
<p>Curator由一系列的模块构成，对于一般开发者而言，常用的是curator-framework和curator-recipes：</p>
<ul>
<li>curator-framework：提供了常见的zk相关的底层操作</li>
<li>curator-recipes：提供了一些zk的典型使用场景的参考。本节重点关注的分布式锁就是该包提供的</li>
</ul>
<p>引入依赖：</p>
<p>最新版本的curator 4.3.0支持zookeeper 3.4.x和3.5，但是需要注意curator传递进来的依赖，需要和实际服务器端使用的版本相符，以我们目前使用的zookeeper 3.4.14为例。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加curator客户端配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework <span class="title function_">curatorFramework</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 重试策略，这里使用的是指数补偿重试策略，重试3次，初始重试间隔1000ms，每次重试之后重试间隔递增。</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 初始化Curator客户端：指定链接信息 及 重试策略</span></span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;172.16.116.100:2181&quot;</span>, retry);</span><br><span class="line">        client.start(); <span class="comment">// 开始链接，如果不调用该方法，很多方法无法工作</span></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可重入锁InterProcessMutex"><a href="#可重入锁InterProcessMutex" class="headerlink" title="可重入锁InterProcessMutex"></a>可重入锁InterProcessMutex</h3><p>Reentrant和JDK的ReentrantLock类似， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。它是由类<strong>InterProcessMutex</strong>来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessMutex</span><span class="params">(CuratorFramework client, String path)</span></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 带超时时间的可重入锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>改造service测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">InterProcessMutex</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(curatorFramework, <span class="string">&quot;/curator/lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        mutex.acquire();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">        <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">        <span class="comment">// 再减库存</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// this.testSub(mutex);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        mutex.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSub</span><span class="params">(InterProcessMutex mutex)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mutex.acquire();</span><br><span class="line">    	System.out.println(<span class="string">&quot;测试可重入锁。。。。&quot;</span>);</span><br><span class="line">        mutex.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意：<strong>如想重入，则需要使用同一个InterProcessMutex对象。</strong></p>
<p>压力测试结果：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607069431523.png" alt="1607069431523"></p>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h3 id="不可重入锁InterProcessSemaphoreMutex"><a href="#不可重入锁InterProcessSemaphoreMutex" class="headerlink" title="不可重入锁InterProcessSemaphoreMutex"></a>不可重入锁InterProcessSemaphoreMutex</h3><p>具体实现：InterProcessSemaphoreMutex。与InterProcessMutex调用方法类似，区别在于该锁是不可重入的，在同一个线程中不可重入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessSemaphoreMutex</span><span class="params">(CuratorFramework client, String path)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">InterProcessSemaphoreMutex</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessSemaphoreMutex</span>(curatorFramework, <span class="string">&quot;/curator/lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mutex.acquire();</span><br><span class="line">        <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">st</span> <span class="operator">=</span> Integer.valueOf(stock);</span><br><span class="line">            <span class="keyword">if</span> (st &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.扣减库存</span></span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可重入读写锁InterProcessReadWriteLock"><a href="#可重入读写锁InterProcessReadWriteLock" class="headerlink" title="可重入读写锁InterProcessReadWriteLock"></a>可重入读写锁InterProcessReadWriteLock</h3><p>类似JDK的ReentrantReadWriteLock。一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁。这也意味着写锁可以降级成读锁。从读锁升级成写锁是不成的。主要实现类InterProcessReadWriteLock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessReadWriteLock</span><span class="params">(CuratorFramework client, String basePath)</span>;</span><br><span class="line"><span class="comment">// 获取读锁对象</span></span><br><span class="line">InterProcessMutex <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取写锁对象</span></span><br><span class="line">InterProcessMutex <span class="title function_">writeLock</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>写锁在释放之前会一直阻塞请求线程，而读锁不会</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZkReadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InterProcessReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="string">&quot;/curator/rwlock&quot;</span>);</span><br><span class="line">        rwlock.readLock().acquire(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// TODO：一顿读的操作。。。。</span></span><br><span class="line">        <span class="comment">//rwlock.readLock().unlock();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZkWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InterProcessReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="string">&quot;/curator/rwlock&quot;</span>);</span><br><span class="line">        rwlock.writeLock().acquire(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// TODO：一顿写的操作。。。。</span></span><br><span class="line">        <span class="comment">//rwlock.writeLock().unlock();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="联锁InterProcessMultiLock"><a href="#联锁InterProcessMultiLock" class="headerlink" title="联锁InterProcessMultiLock"></a>联锁InterProcessMultiLock</h3><p>Multi Shared Lock是一个锁的容器。当调用acquire， 所有的锁都会被acquire，如果请求失败，所有的锁都会被release。同样调用release时所有的锁都被release(失败被忽略)。基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。实现类InterProcessMultiLock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数需要包含的锁的集合，或者一组ZooKeeper的path</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessMultiLock</span><span class="params">(List&lt;InterProcessLock&gt; locks)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessMultiLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; paths)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h3 id="信号量InterProcessSemaphoreV2"><a href="#信号量InterProcessSemaphoreV2" class="headerlink" title="信号量InterProcessSemaphoreV2"></a>信号量InterProcessSemaphoreV2</h3><p>一个计数的信号量类似JDK的Semaphore。JDK中Semaphore维护的一组许可(permits)，而Cubator中称之为租约(Lease)。注意，所有的实例必须使用相同的numberOfLeases值。调用acquire会返回一个租约对象。客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。主要实现类InterProcessSemaphoreV2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessSemaphoreV2</span><span class="params">(CuratorFramework client, String path, <span class="type">int</span> maxLeases)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意一次你可以请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。</span></span><br><span class="line"><span class="comment">// 同时还提供了超时的重载方法</span></span><br><span class="line"><span class="keyword">public</span> Lease <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> qty)</span>;</span><br><span class="line"><span class="keyword">public</span> Lease <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> qty, <span class="type">long</span> time, TimeUnit unit)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 租约还可以通过下面的方式返还</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnAll</span><span class="params">(Collection&lt;Lease&gt; leases)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnLease</span><span class="params">(Lease lease)</span>;</span><br></pre></td></tr></table></figure>



<p>案例代码：</p>
<p>StockController中添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/semaphore&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSemaphore</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testSemaphore();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello Semaphore&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StockService中添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSemaphore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置资源量 限流的线程数</span></span><br><span class="line">    <span class="type">InterProcessSemaphoreV2</span> <span class="variable">semaphoreV2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessSemaphoreV2</span>(curatorFramework, <span class="string">&quot;/locks/semaphore&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Lease</span> <span class="variable">acquire</span> <span class="operator">=</span> semaphoreV2.acquire();<span class="comment">// 获取资源，获取资源成功的线程可以继续处理业务操作。否则会被阻塞住</span></span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="string">&quot;log&quot;</span>, <span class="string">&quot;10010获取了资源，开始处理业务逻辑。&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>));</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="string">&quot;log&quot;</span>, <span class="string">&quot;10010处理完业务逻辑，释放资源=====================&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        semaphoreV2.returnLease(acquire); <span class="comment">// 手动释放资源，后续请求线程就可以获取该资源</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="栅栏barrier"><a href="#栅栏barrier" class="headerlink" title="栅栏barrier"></a>栅栏barrier</h3><ol>
<li><p><strong>DistributedBarrier</strong>构造函数中barrierPath参数用来确定一个栅栏，只要barrierPath参数相同(路径相同)就是同一个栅栏。通常情况下栅栏的使用如下：</p>
<ol>
<li>主client设置一个栅栏</li>
<li>其他客户端就会调用waitOnBarrier()等待栅栏移除，程序处理线程阻塞</li>
<li>主client移除栅栏，其他客户端的处理程序就会同时继续运行。</li>
</ol>
<p>DistributedBarrier类的主要方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setBarrier() - 设置栅栏</span><br><span class="line">waitOnBarrier() - 等待栅栏移除</span><br><span class="line">removeBarrier() - 移除栅栏</span><br></pre></td></tr></table></figure></li>
<li><p>DistributedDoubleBarrier双栅栏，允许客户端在计算的开始和结束时同步。当足够的进程加入到双栅栏时，进程开始计算，当计算完成时，离开栅栏。DistributedDoubleBarrier实现了双栅栏的功能。构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client - the client</span></span><br><span class="line"><span class="comment">// barrierPath - path to use</span></span><br><span class="line"><span class="comment">// memberQty - the number of members in the barrier</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DistributedDoubleBarrier</span><span class="params">(CuratorFramework client, String barrierPath, <span class="type">int</span> memberQty)</span>;</span><br><span class="line"></span><br><span class="line">enter()、enter(<span class="type">long</span> maxWait, TimeUnit unit) - 等待同时进入栅栏</span><br><span class="line">leave()、leave(<span class="type">long</span> maxWait, TimeUnit unit) - 等待同时离开栅栏</span><br></pre></td></tr></table></figure>

<p>memberQty是成员数量，当enter方法被调用时，成员被阻塞，直到所有的成员都调用了enter。当leave方法被调用时，它也阻塞调用线程，直到所有的成员都调用了leave。</p>
<p>注意：参数memberQty的值只是一个阈值，而不是一个限制值。当等待栅栏的数量大于或等于这个值栅栏就会打开！</p>
<p>与栅栏(DistributedBarrier)一样,双栅栏的barrierPath参数也是用来确定是否是同一个栅栏的，双栅栏的使用情况如下：</p>
<ol>
<li>从多个客户端在同一个路径上创建双栅栏(DistributedDoubleBarrier),然后调用enter()方法，等待栅栏数量达到memberQty时就可以进入栅栏。</li>
<li>栅栏数量达到memberQty，多个客户端同时停止阻塞继续运行，直到执行leave()方法，等待memberQty个数量的栅栏同时阻塞到leave()方法中。</li>
<li>memberQty个数量的栅栏同时阻塞到leave()方法中，多个客户端的leave()方法停止阻塞，继续运行。</li>
</ol>
</li>
</ol>
<h3 id="共享计数器"><a href="#共享计数器" class="headerlink" title="共享计数器"></a>共享计数器</h3><p>利用ZooKeeper可以实现一个集群共享的计数器。只要使用相同的path就可以得到最新的计数器值， 这是由ZooKeeper的一致性保证的。Curator有两个计数器， 一个是用int来计数，一个用long来计数。</p>
<h4 id="SharedCount"><a href="#SharedCount" class="headerlink" title="SharedCount"></a>SharedCount</h4><p>共享计数器SharedCount相关方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SharedCount</span><span class="params">(CuratorFramework client, String path, <span class="type">int</span> seedValue)</span>;</span><br><span class="line"><span class="comment">// 获取共享计数的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 设置共享计数的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> newCount)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">// 当版本号没有变化时，才会更新共享变量的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span>  <span class="title function_">trySetCount</span><span class="params">(VersionedValue&lt;Integer&gt; previous, <span class="type">int</span> newCount)</span>;</span><br><span class="line"><span class="comment">// 通过监听器监听共享计数的变化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(SharedCountListener listener)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(<span class="keyword">final</span> SharedCountListener listener, Executor executor)</span>;</span><br><span class="line"><span class="comment">// 共享计数在使用之前必须开启</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">// 关闭共享计数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>使用案例：</p>
<p>StockController：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/zk/share/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testZkShareCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testZkShareCount();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello shareData&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StockService：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZkShareCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第三个参数是共享计数的初始值</span></span><br><span class="line">        <span class="type">SharedCount</span> <span class="variable">sharedCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedCount</span>(curatorFramework, <span class="string">&quot;/curator/count&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 启动共享计数器</span></span><br><span class="line">        sharedCount.start();</span><br><span class="line">        <span class="comment">// 获取共享计数的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> sharedCount.getCount();</span><br><span class="line">        <span class="comment">// 修改共享计数的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>);</span><br><span class="line">        sharedCount.setCount(random);</span><br><span class="line">        System.out.println(<span class="string">&quot;我获取了共享计数的初始值：&quot;</span> + count + <span class="string">&quot;，并把计数器的值改为：&quot;</span> + random);</span><br><span class="line">        sharedCount.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="DistributedAtomicNumber"><a href="#DistributedAtomicNumber" class="headerlink" title="DistributedAtomicNumber"></a>DistributedAtomicNumber</h4><p>DistributedAtomicNumber接口是分布式原子数值类型的抽象，定义了分布式原子数值类型需要提供的方法。</p>
<p>DistributedAtomicNumber接口有两个实现：<code>DistributedAtomicLong</code> 和 <code>DistributedAtomicInteger</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220711225708066.png" alt="image-20220711225708066"></p>
<p>这两个实现将各种原子操作的执行委托给了<code>DistributedAtomicValue</code>，所以这两种实现是类似的，只不过表示的数值类型不同而已。这里以<code>DistributedAtomicLong</code> 为例进行演示</p>
<p>DistributedAtomicLong除了计数的范围比SharedCount大了之外，比SharedCount更简单易用。它首先尝试使用乐观锁的方式设置计数器， 如果不成功(比如期间计数器已经被其它client更新了)， 它使用InterProcessMutex方式来更新计数值。此计数器有一系列的操作：</p>
<ul>
<li>get(): 获取当前值</li>
<li>increment()：加一</li>
<li>decrement(): 减一</li>
<li>add()：增加特定的值</li>
<li>subtract(): 减去特定的值</li>
<li>trySet(): 尝试设置计数值</li>
<li>forceSet(): 强制设置计数值</li>
</ul>
<p>你必须检查返回结果的succeeded()， 它代表此操作是否成功。如果操作成功， preValue()代表操作前的值， postValue()代表操作后的值。</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>不管是jvm锁还是mysql锁，为了保证线程的并发安全，都提供了悲观独占排他锁。所以<strong>独占排他</strong>也是分布式锁的基本要求。</p>
<p>可以利用唯一键索引不能重复插入的特点实现。设计表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tb_lock` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `lock_name` varchar(50) NOT NULL COMMENT &#x27;锁名&#x27;,</span><br><span class="line">  `class_name` varchar(100) DEFAULT NULL COMMENT &#x27;类名&#x27;,</span><br><span class="line">  `method_name` varchar(50) DEFAULT NULL COMMENT &#x27;方法名&#x27;,</span><br><span class="line">  `server_name` varchar(50) DEFAULT NULL COMMENT &#x27;服务器ip&#x27;,</span><br><span class="line">  `thread_name` varchar(50) DEFAULT NULL COMMENT &#x27;线程名&#x27;,</span><br><span class="line">  `create_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;获取锁时间&#x27;,</span><br><span class="line">  `desc` varchar(100) DEFAULT NULL COMMENT &#x27;描述&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_unique` (`lock_name`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1332899824461455363 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>Lock实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_lock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> String serverName;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LockMapper接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LockMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Lock&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>synchronized关键字和ReetrantLock锁都是独占排他锁，即多个线程争抢一个资源时，同一时刻只有一个线程可以抢占该资源，其他线程只能阻塞等待，直到占有资源的线程释放该资源。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606620944823.png" alt="1606620944823"></p>
<ol>
<li>线程同时获取锁（insert）</li>
<li>获取成功，执行业务逻辑，执行完成释放锁（delete）</li>
<li>其他线程等待重试</li>
</ol>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>改造StockService：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LockMapper lockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库分布式锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>(<span class="literal">null</span>, <span class="string">&quot;lock&quot;</span>, <span class="built_in">this</span>.getClass().getName(), <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lockMapper.insert(lock);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，则重试</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="built_in">this</span>.checkAndLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">        <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再减库存</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="built_in">this</span>.lockMapper.deleteById(lock.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>(<span class="literal">null</span>, <span class="string">&quot;lock&quot;</span>, <span class="built_in">this</span>.getClass().getName(), <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lockMapper.insert(lock);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">// 获取锁失败，则重试</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        <span class="built_in">this</span>.checkAndLock();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="built_in">this</span>.lockMapper.deleteById(lock.getId());</span><br></pre></td></tr></table></figure>



<p>使用Jmeter压力测试结果：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606625971086.png" alt="1606625971086"></p>
<p>可以看到性能感人。mysql数据库库存余量为0，可以保证线程安全。</p>
<h2 id="缺陷及解决方案"><a href="#缺陷及解决方案" class="headerlink" title="缺陷及解决方案"></a>缺陷及解决方案</h2><p><strong>缺点</strong>：</p>
<ol>
<li><p>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</p>
<p>解决方案：给 锁数据库 搭建主备</p>
</li>
<li><p>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</p>
<p>解决方案：只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</p>
</li>
<li><p>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</p>
<p>解决方案：记录获取锁的主机信息和线程信息，如果相同线程要获取锁，直接重入。</p>
</li>
<li><p>受制于数据库性能，并发能力有限。</p>
<p>解决方案：无法解决。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实现的复杂性或者难度角度：Zookeeper &gt; redis &gt; 数据库</p>
<p>实际性能角度：redis &gt; Zookeeper &gt; 数据库</p>
<p>可靠性角度：Zookeeper &gt; redis = 数据库</p>
<p>这三种方式都不是尽善尽美，我们可以根据实际业务情况选择最适合的方案：</p>
<p>如果追求极致性能可以选择：reds方案</p>
<p>如果追求可靠性可以选择：zk</p>
<p>常见锁分类：</p>
<blockquote>
<p><strong>悲观锁</strong>：具有强烈的独占和排他特性，在整个数据处理过程中，将数据处于锁定状态。适合于写比较多，会阻塞读操作。<br><strong>乐观锁</strong>：采取了更加宽松的加锁机制，大多是基于数据版本（ Version ）及时间戳来实现。。适合于读比较多，不会阻塞读</p>
</blockquote>
<blockquote>
<p><strong>独占锁、互斥锁、排他锁</strong>：保证在任一时刻，只能被一个线程独占排他持有。synchronized、ReentrantLock<br><strong>共享锁</strong>：可同时被多个线程共享持有。CountDownLatch到计数器、Semaphore信号量</p>
</blockquote>
<blockquote>
<p><strong>可重入锁</strong>：又名递归锁。同一个线程在外层方法获取锁的时候，在进入内层方法时会自动获取锁。<br><strong>不可重入锁</strong>：例如早期的synchronized</p>
</blockquote>
<blockquote>
<p><strong>公平锁</strong>：有优先级的锁，先来先得，谁先申请锁就先获取到锁<br><strong>非公平锁</strong>：无优先级的锁，后来者也有机会先获取到锁</p>
</blockquote>
<blockquote>
<p><strong>自旋锁</strong>：当线程尝试获取锁失败时（锁已经被其它线程占用了），无限循环重试尝试获取锁<br><strong>阻塞锁</strong>：当线程尝试获取锁失败时，线程进入阻塞状态，直到接收信号后被唤醒。在竞争激烈情况下，性能较高</p>
</blockquote>
<blockquote>
<p><strong>读锁</strong>：共享锁<br><strong>写锁</strong>：独占排他锁</p>
</blockquote>
<blockquote>
<p><strong>偏向锁</strong>：一直被一个线程所访问，那么该线程会自动获取锁<br><strong>轻量级锁</strong>（CAS）：当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。<br><strong>重量级锁</strong>：当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候（10次），还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。<br>以上其实是synchronized的锁升级过程</p>
</blockquote>
<p>​    </p>
<blockquote>
<p><strong>表级锁</strong>：对整张表加锁，加锁快开销小，不会出现死锁，但并发度低，会增加锁冲突的概率<br><strong>行级锁</strong>：是mysql粒度最小的锁，只针对操作行，可大大减少锁冲突概率，并发度高，但加锁慢，开销大，会出现死锁</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/02/mysql-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/02/mysql-theory/" class="post-title-link" itemprop="url">MySQL 进阶篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-02 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-02T00:00:00+08:00">2024-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-19 10:04:02" itemprop="dateModified" datetime="2025-05-19T10:04:02+08:00">2025-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>度数：一个节点上面最大的指针数。度数为5，最多5个指针，4个key</p>
<p>当一个节点上面 key 数目超过 4，中间节点向上分裂，其余两段分成两个节点，连到上面。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008185901845-1728392950452-1.png" alt="image-20241008185901845"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008185828031-1728392950452-2.png" alt="image-20241008185828031"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008185947095-1728392950452-4.png" alt="image-20241008185947095"></p>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>只有叶子节点存储数据。非叶子节点只有索引的作用</p>
<p>中间节点向上分裂，并且中间节点保留在叶子节点，其余两段分成两个节点连到上面，节点与节点之间通过链表进行连接。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191613613-1728392950452-3.png" alt="image-20241008191613613"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191730054-1728392950453-5.png" alt="image-20241008191730054"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191755751-1728392950453-7.png" alt="image-20241008191755751"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191802276-1728392950454-9.png" alt="image-20241008191802276"></p>
<p>两个索引中间的指针指向的节点位于这两个索引之间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008192952009-1728392950453-6.png" alt="image-20241008192952009"></p>
<p>MySQL优化的B+Tree：双向链表</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008193116742-1728392950453-8.png" alt="image-20241008193116742"></p>
<p>段-区-页-行</p>
<h4 id="B-Tree-vs-B-Tree"><a href="#B-Tree-vs-B-Tree" class="headerlink" title="B+Tree vs. B-Tree"></a>B+Tree vs. B-Tree</h4><p>都比二叉树层级更少，搜索效率高。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241011162503825.png" alt="image-20241011162503825"></p>
<p>根据一页数据的大小能够得出一页中能储存几个指针，树高度为2，指向1171个节点，1171个节点一共有1171*16行数据。</p>
<ul>
<li>范围查询：  B+树在非叶子节点只存储键值信息，而不存储数据记录的具体位置，再加上底部的叶子节点之间还有双向链表连接，这使得B+树在进行范围查询时更加高效。B树还得进行回溯。</li>
<li>B+树的内部节点只存储键值信息，而不存储具体数据，这意味着在同样的内存空间下，B+树的内部节点可以容纳更多的key和指针，指向的节点多了，<strong>相同数据量，树高更低，查找快</strong>。<ul>
<li>m 阶 B+树，意思是每个非叶子节点最多指向m个子节点，上面只是为了举例说明使用了5阶B树，但是实际上数据库使用的是超高阶，三层就能存储2000万条数据。</li>
</ul>
</li>
<li>B+ 树<strong>搜索效率很稳定</strong>（数据全在叶子节点上）相比 Hash 索引，支持了<strong>范围匹配</strong>和<strong>排序</strong>操作</li>
</ul>
<h4 id="聚簇索引、二级索引"><a href="#聚簇索引、二级索引" class="headerlink" title="聚簇索引、二级索引"></a>聚簇索引、二级索引</h4><p><strong>聚集索引</strong>（key是主键/唯一键/自动隐式生成的rowid）通常键的值升序排列 底部存储一整行的数据（对应的键值）如下图所示。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/79bf1e4b38ccba1c02c487f2989af6bd.png" alt="在这里插入图片描述"></p>
<p><strong>二级索引</strong> 通常键的值以字典序排列 叶子节点是二级索引的key，下面不挂数据，只挂主键的值（聚集索引的键值 也就是主键值）</p>
<p><code>select * from tb_user where name = &#39;Arm&#39;;</code></p>
<p>查询时先根据<strong>二级索引</strong>找到主键（主键/唯一键/rowid），然后拿着key到聚集索引拿到具体行数据（回<strong>表查询</strong>）主键查询不需要回表。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/201308807GwQJsAM8f.png" alt="img"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> index <span class="keyword">on</span></span><br></pre></td></tr></table></figure>



<h3 id="SQL优化-性能指标"><a href="#SQL优化-性能指标" class="headerlink" title="SQL优化 性能指标"></a>SQL优化 性能指标</h3><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>可以设置 <code>long_query_time</code> 参数，定义什么算作“慢查询”。</p>
<p>输出到文件或者表中</p>
<h4 id="profiles"><a href="#profiles" class="headerlink" title="profiles"></a>profiles</h4><p>通过启用 <code>PROFILE</code>，可以获取查询的执行时间和资源消耗，包括 CPU 使用、锁等待、IO 等信息。</p>
<h4 id="explain-语句-执行计划"><a href="#explain-语句-执行计划" class="headerlink" title="explain +语句 执行计划"></a>explain +语句 执行计划</h4><ul>
<li>const：主键或者唯一索引查询</li>
<li>ref：非唯一索引查询</li>
<li>index，all 性能差</li>
</ul>
<h3 id="索引使用规则"><a href="#索引使用规则" class="headerlink" title="索引使用规则"></a>索引使用规则</h3><h4 id="最左前缀匹配（联合索引）"><a href="#最左前缀匹配（联合索引）" class="headerlink" title="最左前缀匹配（联合索引）"></a>最左前缀匹配（联合索引）</h4><p>最左原则指的就是如果你的 SQL 语句中<strong>用到了联合索引中的最左边的索引</strong>，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，值得注意的是：1. 当遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。2. 最左索引的条件不一定是最左边的那个，但必须要有这个条件，并且存在等值查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> mytable <span class="keyword">ADD</span> INDEX name_city_age (username,city,age);</span><br></pre></td></tr></table></figure>

<p>在构建联合索引时，是<strong>按字段的顺序进行排序和存储的</strong>，其实是相当于分别建立了下面三组组合索引：<code>[ username, city, age ] [ username, city ] [ username ]</code> </p>
<p>联合索引 <code>(a, b, c)</code> 的底层 B+ 树是按照 <code>a -&gt; b -&gt; c</code> 这样的字典序构建的：</p>
<ul>
<li>没有 <code>a</code>，数据库无法定位到哪一部分子树中可能存在 <code>b</code> 或 <code>c</code> 的值。</li>
<li>就像字典中查“banana”时，你必须先知道它以“b”开头，不能跳过前缀直接查“anana”。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/725429-20200324102532494-195018706.png" alt="img"></p>
<p>如图所示他们是按照a来进行排序，在a相等的情况下，才按b来排序。</p>
<p>因此，我们可以看到a是有序的1，1，2，2，3，3。而b是一种全局无序，局部相对有序状态!</p>
<h4 id="覆盖查询（联合索引）"><a href="#覆盖查询（联合索引）" class="headerlink" title="覆盖查询（联合索引）"></a>覆盖查询（联合索引）</h4><p><strong>回表</strong>是指根据<strong>非主键索引条件</strong>，先查出对应的主键值，拿着主键值去聚集索引树中检索数据，如果联合索引中，索引成功最左匹配，但是你查的内容不止索引里的内容，那就只能跟着底下挂着的主键去聚簇索引那里查询，这个就叫回表查询。</p>
<p>覆盖查询，联合索引查到了对应的键，也能查到对应的主键值，只查这几列不需要回表，如果多查其他的列就需要到聚集索引处回表查询，性能较慢。</p>
<p>对联合索引(col1,col2,col3)，如果有如下的sql: <code>select col1,col2,col3 from test where col1=1 and col2=2</code>。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/492e0e5857459a335db7c7aea5377791.png" alt="在这里插入图片描述" style="zoom: 67%;" />

<ul>
<li><p>效率高。<br>索引列越多，通过索引筛选出的数据越少。</p>
<p>有1000W条数据的表，有如下sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出<code>1000W*10%=100w</code>条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；</p>
<p>如果是联合索引，通过索引筛选出<code>1000w10% *10% *10%=1w</code>，效率提升可想而知！</p>
</li>
</ul>
<h4 id="单列索引还是联合索引？"><a href="#单列索引还是联合索引？" class="headerlink" title="单列索引还是联合索引？"></a>单列索引还是联合索引？</h4><p>or 其中一个没有索引，肯定全都不走索引。</p>
<p>都有索引，但是全是单列查询，则只会选择其中一个效率最高进行查询</p>
<p>所以多条件的查询用联合索引，减少回表。</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>搜索文本时对一些长字符数据没有必要把他们全部都创建索引，而只是截取一部分</p>
<p>算出他们的选择性数据，方法：对email截取不同的长度，去重count再除以总数count</p>
<p>前缀索引，查询字符串先截取前缀，根据前缀进行辅助查询，查到主键id就回表查询拿到整行数据，拿到整行数据以后再进行核实，看字段后半部分是否匹配。一定需要回表查询。</p>
<h4 id="索引失效的几种情况"><a href="#索引失效的几种情况" class="headerlink" title="索引失效的几种情况"></a>索引失效的几种情况</h4><ol>
<li><p><strong>不遵循最左匹配（联合索引）</strong>：跳过某个，或者出现范围匹配，后边的失效。</p>
<ul>
<li><strong>模糊匹配、范围匹配</strong>：跟上面一样，</li>
</ul>
</li>
<li><p><strong>对索引使用函数或者表达式计算</strong>：计算机不会解方程，如果出现表达式的情况，它会用全部的索引值一个一个尝试。</p>
<ul>
<li><strong>索引发生隐式转换（字符串没有用引号括起来）</strong>：会字符串和数字比较，会把字符串转为数字。跟上面其实一样，使用 CAST 函数</li>
</ul>
</li>
<li><p><strong>WHERE OR</strong>：OR 前索引列，但是 OR 后不是，会失效。这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p>
</li>
<li><p><strong>数据库自行判断：</strong>如果走全表查询比走索引还快，优化器会直接走全表索引</p>
</li>
</ol>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ul>
<li>什么样的表要建立索引：数据量超过百万，且查询很频繁。</li>
<li>控制索引数量，索引尽量小，列多的建索引。</li>
<li>哪些字段建立索引：where group by order by  并且尽量是唯一的，区分度要高。</li>
<li>尽量使用联合索引，联合索引很多时候能够覆盖索引，避免回表查询。</li>
<li>如果索引列不能存null，要用非空约束字段</li>
<li>字符串比较大小：不建议。</li>
<li>key_len理论上越短越好</li>
</ul>
<h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="SQL-优化-插入"><a href="#SQL-优化-插入" class="headerlink" title="SQL 优化 - 插入"></a>SQL 优化 - 插入</h3><ol>
<li>一条insert插入多条（insert）<ol>
<li>手动控制事务（事务较为耗费资源）</li>
<li>主键顺序插入</li>
</ol>
</li>
<li>load</li>
</ol>
<h3 id="SQL-优化-主键"><a href="#SQL-优化-主键" class="headerlink" title="SQL 优化 - 主键"></a>SQL 优化 - 主键</h3><p><strong>只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</strong> 若表的主键不是顺序的id，而是无规律数据，比如字符串，InnoDB无法简单的把一行记录插入到索引的最后，而是需要找一个合适的位置（已有数据的中间位置），甚至产生大量的页分裂并且移动大量数据，在寻找合适位置进行插入时，目标页可能不在内存中，这就导致了大量的随机IO操作，影响插入效率。除此之外，大量的页分裂会导致大量的内存碎片。</p>
<ol>
<li>主键顺序插入</li>
<li>主键自增 </li>
<li>主键长度尽量小一些，不要用uuid或者身份证号</li>
<li>避免在业务操作时修改主键</li>
</ol>
<h3 id="多个条件-OR-gt"><a href="#多个条件-OR-gt" class="headerlink" title="多个条件 OR -&gt;"></a>多个条件 OR -&gt;</h3><h3 id="SQL-优化-order-by"><a href="#SQL-优化-order-by" class="headerlink" title="SQL 优化 - order by"></a>SQL 优化 - order by</h3><ol>
<li>多个条件，使用联合索引，最左前缀</li>
<li>一升一降，需要额外创建独立的索引</li>
<li>覆盖查询，不然仍回表</li>
<li>增大sort_buffer_size(256k default)（不可避免使用filesort时，大数据量）</li>
</ol>
<h3 id="SQL-优化-group-by"><a href="#SQL-优化-group-by" class="headerlink" title="SQL 优化 - group by"></a>SQL 优化 - group by</h3><ol>
<li>多个条件，使用联合索引，最左前缀，需要都出现</li>
<li>肯定是覆盖查询，不然报错</li>
</ol>
<h3 id="SQL-优化-limit"><a href="#SQL-优化-limit" class="headerlink" title="SQL 优化 - limit"></a>SQL 优化 - limit</h3><ol>
<li>覆盖索引加子查询，先覆盖查询主键，根据返回的数据进行select *  </li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241015190857506.png" alt="image-20241015190857506"></p>
<p>不支持in后加limit，就可以联合两张表查询，只返回满足id相同条件的数据</p>
<ol>
<li><strong>延迟关联 (INNER JOIN)</strong>: 使用 <code>INNER JOIN</code> 将分页操作转移到主键索引上，减少回表次数。相比子查询，延迟关联的性能更优，适合大数据量的分页查询。</li>
<li><strong>覆盖索引</strong>: 通过索引直接获取所需字段，避免回表操作，减少 IO 开销，适合查询特定字段的场景。但当结果集较大时，MySQL 可能会选择全表扫描。</li>
</ol>
<h3 id="SQL-优化-count-优化"><a href="#SQL-优化-count-优化" class="headerlink" title="SQL 优化 - count 优化"></a>SQL 优化 - count 优化</h3><ul>
<li><p>MyISAM：可以直接读取</p>
</li>
<li><p>InnoDB：只能逐行读取，只能借助Redis等</p>
</li>
</ul>
<ul>
<li><p>count(字段)会判断是否为非空，如果没有非空约束，会把每一行的字段值都取出来，服务器判断是否为null，不为null计数累加。如果有非空约束，不用判断null直接累加。如果是主键，直接累加</p>
</li>
<li><p>count(1) count(*) 都是遍历整张表但是不取值，按照行进行累加</p>
</li>
</ul>
<h3 id="SQL-优化-update-优化"><a href="#SQL-优化-update-优化" class="headerlink" title="SQL 优化 - update 优化"></a>SQL 优化 - update 优化</h3><p>update利用了索引，行锁</p>
<p>如果没有利用索引，就要加表锁，因为行锁是根据索引加的，而且索引不能失效</p>
<h2 id="视图、存储过程、触发器"><a href="#视图、存储过程、触发器" class="headerlink" title="视图、存储过程、触发器"></a>视图、存储过程、触发器</h2><p>视图就是给子查询起了个名字，然后作为对象存储到数据库中</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>整个数据库的锁，用于全库备份</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>释放：事务提交</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>特点：手动开关</p>
<h5 id="S-共享读锁"><a href="#S-共享读锁" class="headerlink" title="S 共享读锁"></a>S 共享读锁</h5><p>​    所有事务都能读，但都不能写</p>
<h5 id="X-独占写锁"><a href="#X-独占写锁" class="headerlink" title="X 独占写锁"></a>X 独占写锁</h5><p>​    只有当前事务能读写，其他事务都不能读写 </p>
<h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>特点：自动</p>
<p>执行DML, DQL语句会自动加共享SHARED READ/WRITE锁，</p>
<p>执行DDL语句会自动加EXCLUSIVE锁，与上述的锁不兼容。</p>
<p><strong>锁的兼容性</strong>指的是不同类型的锁在同一数据对象（如表或行）上是否可以同时存在的特性，即两个或多个事务能否同时持有某种锁类型，而不会发生冲突或阻塞。</p>
<p>一个事务进行读操作，自动给表加上了共享读锁，另一个事务要改变表结构，此时这个事务想加上独占写的元数据锁，但是因为互相不兼容，所以只能阻塞等待直到另一个事务提交</p>
<h4 id="意向锁-解决行锁表锁冲突"><a href="#意向锁-解决行锁表锁冲突" class="headerlink" title="意向锁 解决行锁表锁冲突"></a>意向锁 解决行锁表锁冲突</h4><p>某个事务DML加行锁，另一个事务来加表锁的时候，要逐行扫描是否有行锁才能加上，性能较低。</p>
<p>因此引入了意向锁，DML加行锁同时对表加了意向写锁(IX)，另一个事务想加表锁，但是IX和常规的表锁不兼容，所以会阻塞等待。</p>
<p><strong>Intention Lock</strong></p>
<h5 id="IX"><a href="#IX" class="headerlink" title="IX"></a><u>IX</u></h5><ul>
<li><code>insert</code>、<code>update</code>、<code>delete </code>(DML自动添加)</li>
<li><code>select...for update</code> (表示查询加行级排他锁)</li>
</ul>
<h5 id="IS"><a href="#IS" class="headerlink" title="IS"></a><u>IS</u></h5><ul>
<li><code>select ... lock in share mode</code>(表示查询加行级共享锁)</li>
</ul>
<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>IX：加行锁的同时会自动加IX</p>
<p>IS：DQL后边加<code>Lock in share mode</code>表示手动加了IS</p>
<h4 id="表锁兼容性矩阵"><a href="#表锁兼容性矩阵" class="headerlink" title="表锁兼容性矩阵"></a>表锁兼容性矩阵</h4><table>
<thead>
<tr>
<th></th>
<th>共享锁 (S)</th>
<th>独占锁 (X)</th>
<th>意向共享锁 (IS)</th>
<th>意向独占锁 (IX)</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>O</td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>IS</td>
<td>O</td>
<td>X</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>IX</td>
<td>X</td>
<td>X</td>
<td>O</td>
<td>O</td>
</tr>
</tbody></table>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>InnoDB存储引擎，并发度高</p>
<p>行级锁是针对索引对行加的锁，事务提交后会释放</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017194645333.png" alt="image-20241017194645333"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017194802298.png" alt="image-20241017194802298"></p>
<p>DML自动加行级排他锁，自动加表级意向排他锁(IX)</p>
<p>DQL+<code>for update</code> 加行级排他锁，自动加IX</p>
<p>DQL+<code>lock in share mode</code> 加共享锁，自动加IS</p>
<p>IX 和 IS 就是行锁在表级锁中的一种呈现形式</p>
<ul>
<li><p>默认可重复读(RR)，使用 Next-Key 锁 进行搜索和索引扫描，防止幻读。</p>
</li>
<li><p>针对唯一索引进行检索，对已存在的记录等值匹配，自动优化为行锁（详见下文）</p>
<ul>
<li><p>当你执行以下查询时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span> <span class="string">&#x27;example@example.com&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>数据库会使用唯一索引快速找到这条记录。</li>
<li>然后，它会在找到的记录上加上行锁，确保其他事务无法修改或删除该行，直到当前事务提交。</li>
<li>由于只锁定了这一行，而不是整个表，其他事务仍然可以并发读取或修改表中的其他记录。</li>
</ul>
</li>
</ul>
</li>
<li><p><u>行锁是针对索引</u>加的，<strong>如果定位数据时不使用索引，</strong>如果此时加锁(除了普通的select查询都会加)那么会对表中所有记录都加上锁，此时<strong>升级为表锁</strong> </p>
</li>
</ul>
<p>由于锁的兼容性，行锁会影响另一个事务的DML以及加后缀的DQL。同时也会影响普通的DQL，除非使用RU隔离级别，否则另一个事务的普通DQL也会阻塞</p>
<h4 id="间隙、临键锁"><a href="#间隙、临键锁" class="headerlink" title="间隙、临键锁"></a>间隙、临键锁</h4><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁（Gap Lock）</strong>：锁定一个记录之前的范围，不包括记录本身。防止其他事务<strong>插入</strong>间隙，间隙锁之间可以共存</li>
<li><strong>临键锁（Next-Key Lock）</strong>：Record Lock + Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p>在 InnoDB 默认的隔离级别 <strong>REPEATABLE-READ</strong> 下，行锁默认使用的是 <strong>Next-Key Lock</strong>。但是，如果操作的索引是唯一索引或主键的等值查询，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock 或 Gap Lock。</p>
<p><strong>省流</strong>：</p>
<ul>
<li><p>查找过程中访问到的才会被加锁，遍历停止时访问的那个不符合条件的行也要加锁，默认加NextKeyLock。</p>
</li>
<li><p><strong>唯一索引的等值查询</strong>，存在加RecordLock，不存在加右边界的GapLock</p>
</li>
<li><p><strong>唯一索引的范围查询</strong> 或者 <strong>普通索引的查询</strong> 这些查询包含向右遍历，如果出现<strong>唯一索引的等值查询</strong>，加对应的RecordLock，其他被遍历到的都是Next-keyLock，出现正无穷加正无穷的Next-KeyLock</p>
</li>
<li><p>特别地，对于 <strong>唯一索引的范围查询</strong> 或者 <strong>普通索引等值查询</strong> ，遍历停止时访问的那个不符合条件的行，这一行的NextKeyLock会退化为GapLock</p>
</li>
</ul>
<h3 id="行级锁-加锁范围验证"><a href="#行级锁-加锁范围验证" class="headerlink" title="行级锁 加锁范围验证"></a>行级锁 加锁范围验证</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017215201503.png" alt="image-20241017215201503"></p>
<p>X 对应 默认的 Next-key Lock</p>
<p>X, REC_NOT_GAP 对应 Record Lock</p>
<p>X, GAP 对应 Gap Lock </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_t_a <span class="keyword">on</span> t(a);</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> INDEX_NAME, LOCK_MODE,LOCK_STATUS,LOCK_DATA <span class="keyword">from</span> performance_schema.data_locks;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;  <span class="comment">-- 主键等值查询 存在</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">9</span> <span class="keyword">for</span> <span class="keyword">update</span>;   <span class="comment">-- 主键等值查询 不存在</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 主键范围查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;   <span class="comment">-- 普通索引等值查询</span></span><br></pre></td></tr></table></figure>



<h4 id="主键等值查询-——-数据存在"><a href="#主键等值查询-——-数据存在" class="headerlink" title="主键等值查询 —— 数据存在"></a>主键等值查询 —— 数据存在</h4><p>查询 id = 10 REC_NOT_GAP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017223439818.png" alt="image-20241017223439818"></p>
<p>对主键等值加锁，且值存在，临键锁退化为Record，锁住10这条记录</p>
<h4 id="主键等值查询-——-数据不存在"><a href="#主键等值查询-——-数据不存在" class="headerlink" title="主键等值查询 —— 数据不存在"></a>主键等值查询 —— 数据不存在</h4><p>查询 id = 9 GAP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017223354241.png" alt="image-20241017223354241"></p>
<p>对主键等值加锁，值不存在，临键锁退化为Gap，锁住了10之前的间隙</p>
<h4 id="主键范围查询"><a href="#主键范围查询" class="headerlink" title="主键范围查询"></a>主键范围查询</h4><ol>
<li>查找id&gt;=10 有10,11,12,15,20满足条件</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017224916640.png" alt="image-20241017224916640"></p>
<p>10是等值查询，会退化成Record，其他都是NextKey，还有一个正无穷的NextKey</p>
<ol start="2">
<li>查找id在[10,15) 之间 </li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017230538715.png" alt="image-20241017230538715"></p>
<p>10是等值查询，退化Record，其他都是临键，查到15的时候不符合, 15退化为Gap</p>
<h4 id="普通索引等值查询"><a href="#普通索引等值查询" class="headerlink" title="普通索引等值查询"></a>普通索引等值查询</h4><p>查询 a = 10 一共三条符合的记录 id = 10,11,12 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017222539070.png" alt="image-20241017222539070"></p>
<ul>
<li>对于idx_t_a这个索引，加了四把锁，其中符合条件的3行都是nextKey(也就是默认的行锁)，检索到第一个不符合条件的行 （15,15）nextKey退化成GAP间隙</li>
<li>对于主键，所有的nextKey都退化成Record Lock</li>
</ul>
<p>不存在：查询 a = 9 只有Gap</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017235509444.png" alt="image-20241017235509444"></p>
<h4 id="普通索引范围查询"><a href="#普通索引范围查询" class="headerlink" title="普通索引范围查询"></a>普通索引范围查询</h4><p>查询 a &gt;= 10</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018000157308.png" alt="image-20241018000157308"></p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Mindmap.png" alt="MindMap"></p>
<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>在事务开始前和结束后，数据库的状态必须一致。InnoDB 在事务提交时会检查所有约束（如外键、唯一性约束），确保数据的完整性和<strong>一致性</strong>。</p>
<h4 id="RedoLog-持久性"><a href="#RedoLog-持久性" class="headerlink" title="RedoLog - 持久性"></a>RedoLog - 持久性</h4><ul>
<li>产生：更新数据之后，事务提交之时</li>
<li>销毁：数据成功刷新到磁盘之时</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029174344508-1730195209915-1.png" alt="image-20241029174344508"></p>
<ul>
<li><p>BufferPool中的脏页会定期刷新到磁盘中，如果写入磁盘失败，则会导致事务提交了，磁盘中的数据却没改变。</p>
</li>
<li><p>BufferPool首先把当次事务的<u>修改存入</u>RedoLogBuffer，RedoLogBuffer会刷新到磁盘中的RedoLogFile，然后过一段时间会将BP中的脏页刷新到磁盘中，如果写入失败，可以通过磁盘中的RedoLogFile恢复数据。</p>
</li>
</ul>
<p><strong>为什么不直接刷新到磁盘中</strong>？因为磁盘随机IO太慢，而日志文件是顺序IO，快得多（Write-Ahead Logging）先写日志，再刷新，并且WAL能够防止还没有刷盘就崩溃的情况。</p>
<p>重做日志记录的是数据页的具体变化<u>（物理修改）</u>，而不是 SQL 语句或逻辑操作，例如页的写入、删除或更新。这种方式确保了在崩溃恢复时，能够准确地重放这些操作，从而恢复数据到一致的状态。物理修改在执行时通常更高效。</p>
<p><mark>物理日志<mark></p>
<h4 id="UndoLog-原子性"><a href="#UndoLog-原子性" class="headerlink" title="UndoLog - 原子性"></a>UndoLog - 原子性</h4><ul>
<li>产生：事务执行具体SQL语句时</li>
<li>销毁：事务未提交时可以用于回滚，事务提交以后也不会立即删除，<strong>用于MVCC</strong> </li>
</ul>
<ul>
<li><mark>逻辑日志<mark>，是具体的SQL语句（反向）</li>
<li>事务Rollback时会从UndoLog读取逻辑语句并执行</li>
</ul>
<ul>
<li>存储在 表空间的 rollback segment 段中</li>
</ul>
<p>表空间TableSpaces-&gt;段Segment-&gt;区Extent-&gt;页Page-&gt;行Row</p>
<h3 id="MVCC-隔离性"><a href="#MVCC-隔离性" class="headerlink" title="MVCC - 隔离性"></a>MVCC - 隔离性</h3><p><strong>M</strong>ulti<strong>V</strong>ersion <strong>C</strong>oncurrency <strong>C</strong>ontrol</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取数据的当前版本（最新版本），读取时要加锁</p>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>读取的是记录数据的可见版本，不加锁</p>
<ul>
<li>Read Committed：每次select都生成一个快照读</li>
<li>Repeatable Read：开启事务以后的首个select才是快照读</li>
<li>Serializable：快照读退化为当前读</li>
</ul>
<p>MySQL用MVCC实现了一致性非锁定读，读操作只读该事务开始前的数据库的快照，也就是快照读（与当前读相对）</p>
<p>事务隔离级别越低，对应的锁就越少，MySQL用MVCC减少了高并发情况下锁的数量，也就是说默认的RR对性能没有影响</p>
<h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><p>TRX_ID 最后一次事务ID</p>
<p>ROLL_PTR 指向undolog</p>
<p>ROW_ID 如果没有主键会对每一行生成rowID</p>
<h4 id="利用-UndoLog"><a href="#利用-UndoLog" class="headerlink" title="利用 UndoLog"></a>利用 UndoLog</h4><h5 id="生成UndoLog"><a href="#生成UndoLog" class="headerlink" title="生成UndoLog"></a>生成UndoLog</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018150130329.png" alt="image-20241018150130329"></p>
<h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>事务对记录进行修改，会在Undolog生成对应的undo备份，事务对同一条记录进行修改，会在Undolog中生成一条版本链，链表尾部是最早的旧版本，链表头部是最新的旧版本，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018151050435.png" alt="image-20241018151050435"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018151107149.png" alt="image-20241018151107149"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018151128340.png" alt="image-20241018151128340"></p>
<h4 id="ReadView-amp-数据可见性算法"><a href="#ReadView-amp-数据可见性算法" class="headerlink" title="ReadView &amp; 数据可见性算法"></a>ReadView &amp; 数据可见性算法</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018161558601.png" alt="image-20241018161558601"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/trans_visible-ekj9bMvL.png" alt="trans_visible"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018205730125.png" alt="image-20241018205730125"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018161738996.png" alt="image-20241018161738996"></p>
<h4 id="RC-amp-RR-解决并发事务引发的问题"><a href="#RC-amp-RR-解决并发事务引发的问题" class="headerlink" title="RC &amp; RR 解决并发事务引发的问题"></a>RC &amp; RR 解决并发事务引发的问题</h4><p><mark><u>1. MVCC 通过 ReadView 的数据可见性算法 只会读取其他事务已提交的信息，完全避免了脏读</u><mark> </p>
<p><strong>RC</strong>：避免脏读（读已提交）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018155530221.png" alt="image-20241018155530221"></p>
<p><code>mIDs</code>包含活跃事务，<code>maxID</code>当前最大事务ID+1，<code>minID</code>最小活跃事务ID，<code>trxID</code>当前所浏览版本所属的事务ID</p>
<ol>
<li><code>trxID</code> =<code> create_trxID</code>  自己改的的肯定能读</li>
<li><code>trxID </code>&gt;= <code>maxID</code> 说明事务在快照创建之后才修改的，数据没有参考价值，不能读。</li>
<li><code>trxID </code>&lt;<code>maxID</code>说明事务在快照创建之前修改的，有参考价值，不在活跃列表中的就是已提交了</li>
<li><code>trxID</code> &lt; <code>minID</code>  肯定不在活跃列表，读<strong>已提交</strong>。</li>
<li><code>trxID</code>∈[<code>minID</code>,<code>maxID</code>) 说明事务在快照创建之前修改的，但不知道提交了没有。<ul>
<li>在<code>mIDs</code>中，说明还活跃着没有提交，不能读    </li>
<li>不在<code>mIDs</code>中，说明<strong>已提交</strong></li>
</ul>
</li>
<li><code>mIDs</code>为空，可读</li>
</ol>
<p><code>Read View</code>在SQL执行结束后自动销毁，下次生成新的</p>
<p><mark><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html#mvcc-%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%97%AE%E9%A2%98">2. MVCC 通过设置同一事务复用 ReadView 完全避免了不可重复读问题 </a><mark> </p>
<p><strong>RR</strong>：注意——RR是可以读已提交的，RR是用来解决不可重复读的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018155805136.png" alt="image-20241018155805136"></p>
<p>同一个事务的<code>Read View</code>相同，后开启的事务修改肯定不会去读，只会按照同一个<code>Read View</code>读版本链</p>
<ul>
<li>事务5第一次读，事务3修改了但还没提交，最后选择事务2的版本，生成的<code>Read View</code>不会马上销毁</li>
<li>事务5第二次读，复用之前的<code>Read View</code>，最重要的是记录了<strong>活跃事务列表</strong> <code>mIds</code>，即使事务3提交了，</li>
</ul>
<p><u><mark>3. MVCC 如何解决幻读问题？<mark></u> </p>
<ol>
<li>执行普通select语句，MVCC会使用快照读。RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。</li>
<li>对于当前读，通过设置Next-Key Lock，将间隙也锁住，阻塞其他事务插入数据，防止插入，幻读也就不会出现。</li>
</ol>
<p>没法防止的幻读：</p>
<p>事务A第一次查询id=5没查到，事务B此时插入了id=5并提交了，事务A为了维持可重复读第二次依然查不到5，但是此时事务A插入5会失败，update id = 5会成功，试图select for update也会成功，好像出现了幻觉，只能改变隔离模式为 Serializable </p>
<p>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生，</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/01/java-se/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/01/java-se/" class="post-title-link" itemprop="url">Java SE</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-01T00:00:00+08:00">2024-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-16 20:58:02" itemprop="dateModified" datetime="2025-05-16T20:58:02+08:00">2025-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向对象、基本语法"><a href="#面向对象、基本语法" class="headerlink" title="面向对象、基本语法"></a>面向对象、基本语法</h1><p>一个java文件内只能有1个public class 且public class名字需与文件名相同</p>
<p>生成类文件的名字=class名，几个类几个名字</p>
<p>运行的时候是按照类运行的，因此一个java文件里不同的类可以有不同的main</p>
<h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><p>在刷算法题时，Java 的常用包可以帮助你解决各种问题。以下是一些常见的包：</p>
<ol>
<li><p><strong>基础包</strong>（默认无需导入，属于 <code>java.lang</code>，直接使用）：</p>
<ul>
<li><code>java.lang</code>：包含基础类如 <code>String</code>, <code>Math</code>, <code>Integer</code>, <code>System</code>，它们是自动导入的，不需要显式导入。</li>
</ul>
</li>
<li><p><strong>集合框架</strong>：</p>
<ul>
<li><code>java.util.*</code>：包括大多数数据结构和集合类，常用于算法题：<ul>
<li><code>ArrayList</code>, <code>LinkedList</code>：动态数组和链表。</li>
<li><code>HashMap</code>, <code>TreeMap</code>, <code>LinkedHashMap</code>：哈希表和有序映射。</li>
<li><code>HashSet</code>, <code>TreeSet</code>：哈希集合和有序集合。</li>
<li><code>PriorityQueue</code>：优先队列（常用于堆排序、最小堆、最大堆）。</li>
<li><code>Stack</code>：栈结构。</li>
<li><code>Deque</code>, <code>ArrayDeque</code>：双端队列。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>并发包</strong>：</p>
<ul>
<li><code>java.util.concurrent.*</code>：多线程工具和并发数据结构。</li>
</ul>
</li>
<li><p><strong>数学计算</strong>：</p>
<ul>
<li><code>java.math.BigInteger</code> 和 <code>java.math.BigDecimal</code>：用于处理大整数和高精度小数。</li>
<li><code>java.util.Random</code>：生成随机数。</li>
</ul>
</li>
<li><p><strong>输入输出</strong>（用于处理大规模输入输出）：</p>
<ul>
<li><code>java.io.*</code>：包括 <code>BufferedReader</code>、<code>InputStreamReader</code> 等，常用于高效输入读取。</li>
<li><code>java.util.Scanner</code>：常用于简单的控制台输入。</li>
</ul>
</li>
<li><p><strong>时间处理</strong>：</p>
<ul>
<li><code>java.time.*</code>：处理日期和时间类（如果题目涉及日期计算）。</li>
</ul>
</li>
</ol>
<h3 id="常用导入："><a href="#常用导入：" class="headerlink" title="常用导入："></a>常用导入：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">// 通用集合框架</span></span><br><span class="line"><span class="keyword">import</span> java.math.*;  <span class="comment">// 高精度数学计算</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;    <span class="comment">// 文件、输入输出</span></span><br></pre></td></tr></table></figure>

<p>这些包涵盖了绝大多数算法题目需要的工具和数据结构。如果你有特定类型的题目或需求，也可以进一步讨论合适的导入包。</p>
<h2 id="基本数据类型-2024-9-9"><a href="#基本数据类型-2024-9-9" class="headerlink" title="基本数据类型 2024.9.9"></a>基本数据类型 2024.9.9</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>char <strong>2</strong> byte</p>
<p>路径 \\ 转义字符</p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>0x hex 、 0 oct    byte short int long </p>
<p>整数全部是int型，数字超出int范围后面要加L <code>long number = 666666666666L  </code></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>4e3 ⇔ 4000 这是一个浮点数 默认为double </p>
<p>float 32  double 64 </p>
<p>浮点数全部是double型，数字如果是float型后边必须要加上f</p>
<p>double类型不能给float类型赋值。 char 型可以兼容整型，也可以看成16位整型</p>
<table>
<thead>
<tr>
<th align="left"><strong>数据类型</strong></th>
<th align="left"><strong>默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">0L</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0.0f</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0.0d</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\u0000’</td>
</tr>
<tr>
<td align="left">String (or any object)</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">false</td>
</tr>
</tbody></table>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><ul>
<li><p>隐式(自动) 基本数据类型中除了boolean其他都兼容</p>
<ul>
<li>byte, short, char -&gt;int-&gt;long-&gt;float-&gt;double</li>
<li>byte+short 在表达式中参与运算自动提升为int 小类型自动转换成大类型</li>
<li></li>
</ul>
</li>
<li><p>强制转换</p>
<ul>
<li><p>小数转换成整数，保留整数部分 <code>double a = 1.2 </code> <code>int b = (int) a</code>  </p>
</li>
<li><p>四舍五入</p>
</li>
</ul>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI;</span><br><span class="line">pi = pi * <span class="number">10000</span> + <span class="number">0.5</span>;</span><br><span class="line">pi = (<span class="type">int</span>)pi;</span><br><span class="line">pi = pi / <span class="number">10000</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">pi_2</span> <span class="operator">=</span> Math.PI;</span><br><span class="line"><span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> Math.round(pi_2 * <span class="number">10000</span>);</span><br><span class="line">pi_2 = i / <span class="number">10000.0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>比较运算符 H <strong>instanceof</strong> Human H是否属于Human类型</li>
</ul>
<ul>
<li><p><strong>位运算符</strong> （整数） &gt;&gt;&gt; </p>
</li>
<li><p><strong>自增自减</strong>  i++ 的值等于i      ++i的值等于i+1</p>
</li>
<li><p><strong>取模</strong> 值只跟被模数有关 </p>
</li>
<li><p><strong>扩展赋值运算符</strong>：包含强制类型转换</p>
</li>
<li><p><strong>逻辑运算符</strong> </p>
<ul>
<li><p>&amp;&amp; 第一个false 不会判断 优先级较高</p>
</li>
<li><p>||  第一个true不会判断剩下的</p>
</li>
<li><p>^ 异或 相同false 不同true</p>
</li>
</ul>
</li>
</ul>
<h2 id="API-from-JDK"><a href="#API-from-JDK" class="headerlink" title="API from JDK"></a>API from JDK</h2><h3 id="Switch语句简化"><a href="#Switch语句简化" class="headerlink" title="Switch语句简化"></a>Switch语句简化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dayName</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> -&gt; <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> -&gt; <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> -&gt; <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span> -&gt; <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span> -&gt; <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span> -&gt; <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span> -&gt; <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid day: &quot;</span> + day);</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(dayName); <span class="comment">// 输出: Wednesday</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JDK12开始引入的写法，可以避免贯穿效应，并能直接在后面执行一个语句或者返回一个值</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;asd&quot;</span> <span class="comment">//常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(字符数组、字节数组)<span class="comment">//一般的堆</span></span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>str.toCharArray()</code>  返回一个字符数组</p>
<p><code>str.charAt(2)</code>   返回str[2]的字符</p>
<p><code>str1.equals(str2)</code> s1与s2是否相同</p>
<p><code>str1.equalsIgnoreCase(str2)</code> s1与s2是否相同 <strong>忽略大小写</strong> </p>
<p><code>str.substring(0,8)</code> 字符串截断</p>
<p><code>str.replace(x,y)</code> 将x替换成y</p>
<p><code>str.contains(&quot;Java&quot;)</code> 是否包含Java</p>
<p><code>str.startsWith(&quot;A&quot;)</code> 是否以A开头</p>
<p><code>str.split(&#39;,&#39;)</code> Split with PERIOD ‘,’</p>
<p><code>int compareToIgnoreCase(String str)</code> 按照字典顺序比较两个字符串，忽略大小写</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>用str = “aaa” 的方式，会把字符串存在<strong>字符常量池</strong>，内容相同只存储一份</p>
</li>
<li><p>用str = new String(“aaa”)的方式，每一次都new一个新对象存在堆中</p>
</li>
<li><p><strong>String是不可变对象</strong>，不可变性（Immutability）的含义 </p>
</li>
<li><p>只要对String进行操作，就要<u>创建新的字符串对象</u>，而非修改原有字符串。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot; World&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>str + &quot; World&quot;</code> 实际上创建了一个新的 <code>String</code> 对象，包含 “Hello World”，而原来的 <code>&quot;Hello&quot;</code> 对象仍然存在于内存中，并没有被修改。<code>str</code> 变量此时指向了这个新的对象。为什么 <code>String</code> 是不可变的？</p>
<ol>
<li><p><strong>安全性（Security）</strong>：不可变的对象可以避免在多个线程之间共享数据时的并发问题。由于 <code>String</code> 的值不会被改变，因此可以安全地在多个地方或多个线程中使用，而不必担心被其他代码修改。</p>
</li>
<li><p><strong>性能优化（String Pool）</strong>：Java 中有一个叫做 <strong>字符串常量池（String Pool）</strong> 的机制，当你创建一个 <code>String</code> 对象时，如果该字符串值已经存在于常量池中，那么不会重新创建对象，而是复用已有的对象。不可变性确保了这个机制的有效性，因为相同的 <code>String</code> 实例永远不会被修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>s1</code> 和 <code>s2</code> 实际上引用了常量池中的同一个 <code>String</code> 对象。</p>
<p><strong>3.  哈希值缓存</strong>：由于 <code>String</code> 对象不可变，它的哈希值只需要计算一次，可以缓存下来以提高哈希表操作的效率（如在 <code>HashMap</code> 中用作键）。如果 <code>String</code> 是可变的，那么它的哈希值也会随之变化，影响哈希表的正确性。 </p>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910180312621.png" alt="image-20240910180312621"></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>大小可变的 <strong>容器</strong>，auto extension </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910193135775.png" alt="image-20240910193135775"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>add 方法可重载 <code>add(Object o);</code> </p>
<p>注意 remove 方法会让整体左移，元素对应的索引会变化，会影响遍历的索引</p>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>)  <span class="comment">//0-9</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>,<span class="number">31</span>)  <span class="comment">// [10,31) 不包含31</span></span><br></pre></td></tr></table></figure>

<h3 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> sc.nextInt();</span><br></pre></td></tr></table></figure>

<h2 id="数组-2024-9-10"><a href="#数组-2024-9-10" class="headerlink" title="数组 2024.9.10"></a>数组 2024.9.10</h2><h3 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] data1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] data2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//简化写法</span></span><br></pre></td></tr></table></figure>

<p>引用数据类型 引用相当于是对象的地址</p>
<h3 id="动态数组（非动态长度）"><a href="#动态数组（非动态长度）" class="headerlink" title="动态数组（非动态长度）"></a>动态数组（非动态长度）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] data1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p><code>double 0.0</code> <code>int 0 </code> <code>boolean false </code> <code>String null</code> (<u>引用数据类型</u>) </p>
<p>new一个对象，就会在堆上创建空间，然后将空间的地址传给栈中的引用</p>
<h3 id="引用数据类型做参数"><a href="#引用数据类型做参数" class="headerlink" title="引用数据类型做参数"></a>引用数据类型做参数</h3><p>引用相当于封装好的指针，只能指向对象，可以通过它对<strong>对象</strong>进行操作，引用数据类型做参数，实际上是一个引用的拷贝，通过它可以操作对象，但是不能通过修改它来让真实的引用指向一个新的对象。修改对象就行了，没事修改人家引用干啥呢！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Personnel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyPerson</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        person = <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">// 修改引用，指向新的对象  不可以</span></span><br><span class="line">        person.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        modifyPerson(p);</span><br><span class="line">        System.out.println(p);  <span class="comment">// 仍然输出 &quot;Bob&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java的参数都是值传递，也就是副本传递。main 中 p的值始终不变， 进入modify方法之后，一开始person也是p的值，但是无法通过更改person的指向 来 更改p的指向</p>
<h3 id="方法的重载："><a href="#方法的重载：" class="headerlink" title="方法的重载："></a><strong>方法的重载</strong>：</h3><p>必须要有不同的<strong>参数列表</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">function</span><span class="params">(String... args)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">function</span><span class="params">(String [] args)</span>;</span><br></pre></td></tr></table></figure>

<p>这两种方法是等价的</p>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><ul>
<li><p>类名大写</p>
</li>
<li><p>不用赋初值</p>
</li>
<li><p>xx.java 中只能有一个public class 且名字必须叫xx 可以有多个class</p>
</li>
<li><p>对象失去引用，将成为垃圾无法被操作</p>
</li>
<li><p>this 用在<strong>方法内</strong> 用于拿到当前的对象 调用方法的时候this会自动接收当前对象的引用(防止对象的成员变量和方法内部的变量名称相同产生冲突)</p>
</li>
</ul>
<h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><p>构造函数，可重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">double</span> score)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建对象的同时完成初始化赋值</li>
<li>不写构造函数会自动生成无参构造</li>
<li>如果定义了有参构造，<strong>不会自动生成</strong>无参构造了</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>合理隐藏，合理暴露，考虑安全性</p>
<p>public(any)&gt;protected(继承类)&gt;friendly(同一package的类)&gt;private(只有当前类才有资格访问)</p>
<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><ul>
<li>变量私有，方法公开（get set 右键快捷生成）</li>
<li>必有公开的无参构造</li>
<li><strong>实体类</strong>负责数据存取，处理数据交给<strong>业务类</strong>来完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperator</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student student;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">StudentOperator</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.student = student;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaBean-vs-POJO"><a href="#JavaBean-vs-POJO" class="headerlink" title="JavaBean vs. POJO"></a>JavaBean vs. POJO</h3><p>JavaBean 和 POJO 的区别主要在于它们的用途和规范化程度：</p>
<ol>
<li><p><strong>JavaBean</strong>：</p>
<ul>
<li><strong>定义</strong>：JavaBean 是一种特殊的 Java 类，通常遵循严格的规范。它主要用于开发可复用的组件，尤其是在 Java EE 应用程序中，JavaBean 被广泛用于数据传输对象（DTO）、表单数据和企业级应用中。</li>
<li><strong>规范</strong>：<ul>
<li>必须有一个<strong>无参构造函数</strong>。</li>
<li>所有的属性（成员变量）必须是<strong>私有的</strong>（<code>private</code>），并通过<strong>getter</strong> 和 <strong>setter</strong> 方法进行访问。</li>
<li>必须实现 <strong>Serializable</strong> 接口（可选，但常见）。</li>
</ul>
</li>
<li><strong>应用场景</strong>：JavaBean 常用于 Java EE（例如 JSP、Servlet）中与视图层交互的数据封装，也可用于一些持久层框架如 Hibernate 和 Spring。</li>
</ul>
</li>
<li><p>**POJO (Plain Old Java Object)**：</p>
<ul>
<li><strong>定义</strong>：POJO 是一个普通的 Java 对象，没有任何特殊的要求或规范。它是最普通的 Java 类，通常只用来封装数据，避免依赖特定的框架或库。</li>
<li><strong>规范</strong>：没有严格的要求，可以有构造函数、任意修饰符的属性，甚至没有 getter 和 setter 方法。</li>
<li><strong>应用场景</strong>：POJO 被广泛用于各种场景中，特别是作为轻量级的数据承载类。它不依赖于任何框架的 API，目的是使代码更加简洁和易于维护。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>JavaBean</strong> 是一种受规范约束的 POJO，适合组件开发和框架集成。</li>
<li><strong>POJO</strong> 是一个没有任何限制或依赖的 Java 类，更加灵活自由。</li>
</ul>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>局部变量：方法内 一般在栈中</p>
<p>成员变量：一般在类的声明中表现</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910144323152.png" alt="image-20240910144323152"></p>
<p>out</p>
<h2 id="OOP-Advanced-2024-9-11"><a href="#OOP-Advanced-2024-9-11" class="headerlink" title="OOP Advanced 2024.9.11"></a>OOP Advanced 2024.9.11</h2><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><h4 id="修饰成员变量：类变量"><a href="#修饰成员变量：类变量" class="headerlink" title="修饰成员变量：类变量"></a>修饰成员变量：类变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> String name;<span class="comment">//所有类共享 （类变量）</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接通过类名访问：<code>Student.name = &quot;袁华&quot;</code> 只有一份 </p>
<ul>
<li>应用场景：某个数据只要一份（记住自己创建了多少个用户对象了）希望能够被共享、修改</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911105822932.png" alt="image-20240911105822932"></p>
<h4 id="类方法：属于类的方法"><a href="#类方法：属于类的方法" class="headerlink" title="类方法：属于类的方法"></a>类方法：属于类的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHelloworld</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line">Student.printHelloworld();</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911110754007.png" alt="image-20240911110754007"></p>
<ul>
<li>应用场景：工具类 提高代码复 用率</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911111331657.png" alt="image-20240911111331657"></p>
<h4 id="其他注意"><a href="#其他注意" class="headerlink" title="其他注意"></a>其他注意</h4><ul>
<li>static 方法 可以直接访问 static 成员变量 ，<u>不能访</u>问实例变量，不能有<strong>this</strong> </li>
<li>实例 方法 可以直接访问 static 成员变量和实例变量、方法，可以有<strong>this</strong> </li>
</ul>
<h5 id="应用：静态代码块-实例代码块"><a href="#应用：静态代码块-实例代码块" class="headerlink" title="应用：静态代码块 实例代码块"></a>应用：<strong>静态代码块 实例代码块</strong></h5><p>静态代码块：<mark>类加载的同时<mark>会加载静态代码块但只有一次，适用于静态变量的初始化</p>
<p>实例代码块：<mark>创建对象的时候<mark>执行，并在构造器<mark>之前<mark>执行，适用于非静态变量的初始化</p>
<h4 id="设计模式：单例"><a href="#设计模式：单例" class="headerlink" title="设计模式：单例"></a>设计模式：单例</h4><ul>
<li><p>一个类有且只有一个对象，创建对象之前就自己有了11:112311</p>
</li>
<li><p>私有构造器</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//自有，记住一个对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;&#125;<span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911114322070.png" alt="image-20240911114322070"> 上图为拿到一个<strong>对象</strong> <strong>以后</strong>才开始创建对象</p>
<h3 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h3><p>关键字：extends<code>public class B extends A</code> B能继承A的非私有成员和方法</p>
<h4 id="子类的访问"><a href="#子类的访问" class="headerlink" title="子类的访问"></a>子类的访问</h4><ul>
<li>子类不能直接访问父类的私有成员，但是他们<strong>仍然存在于子类对象中</strong>，父类的私有成员子类用get set方法可以完成访问或修改 /  (或者用父类的构造器)</li>
<li>父亲的私人物品儿子不能直接动，但是儿子能通过父亲认可的方法接触</li>
<li>子类方法中同名变量\方法的处理：优先调用方法中声明 的变量，<strong>this</strong>可以调用子类在方法外声明的，<strong>super</strong>可以调用父类声明的</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911115852654.png" alt="image-20240911115852654"></p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>本类</th>
<th>同一包的其他类(包括同一包的子类)</th>
<th>其他包的子类</th>
<th>其他包的其他类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>OK</td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>缺省</td>
<td>OK</td>
<td>OK</td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>protected</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>public</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
</tbody></table>
<ul>
<li><p>注意这些都是在对应的类 <strong>内部</strong> 才起作用 </p>
</li>
<li><p>java 单继承 ， 多层继承 ， 不支持多继承</p>
</li>
<li><p>所有类默认继承自<code>Object</code>类</p>
</li>
</ul>
<h4 id="子类的方法重写"><a href="#子类的方法重写" class="headerlink" title="子类的方法重写"></a>子类的方法重写</h4><ul>
<li><p>子类将父类的方法保持参数列表相同进行重写</p>
</li>
<li><p>用<code>@Override</code> 注解</p>
</li>
<li><p>子类的访问权限必须大于父类</p>
</li>
<li><p><code>private</code> 和 <code>static</code> 不能重写 </p>
</li>
<li><p>应用：println(A) 默认调用的是<code>A.toString()</code> 这是一个Object类的函数，返回地址信息，如果在A类重写toString函数就能改变,可以使用右键快捷生成toString函数</p>
</li>
</ul>
<h4 id="子类的构造器"><a href="#子类的构造器" class="headerlink" title="子类的构造器"></a>子类的<u>构造器</u></h4><ul>
<li><p>调用子类的构造器之前，自动调用父类的无参构造，默认存在<code>super()</code> </p>
</li>
<li><p>如果父类没有无参构造（有了有参构造），子类的构造器无法调用<code>super()</code> 就会报错，所以要在子类的构造器中手动调用 <code>super(name)</code>有参构造 </p>
</li>
<li><p>原因：子类中虽然不能直接操作父类的private成员，但是同样也是要有这些成员的，而且要避免一直调用父类的get set方法，那么子类构造时就要用<strong>父类的构造器</strong> 对父类的private成员进行初始化，再回来把对象里包含子类这部分数据赋值。</p>
</li>
<li><p>有参构造的重载：本来有三个参数，如果只接受两个参数，对其余的一个参数进行缺省设定，<code>this()</code> 就能调用本类的无参构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>(name, age, <span class="string">&quot;heima&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>(name, age);</span><br><span class="line">	<span class="built_in">this</span>.schoolName = schoolName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>this()和super()不能同时出现在构造器中，都必须放在第一行</p>
</li>
</ul>
<h3 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态 polymorphism"></a>多态 polymorphism</h3><ul>
<li><p><strong>对象多态</strong>：父类的引用类型变量 可以指向子类的对象</p>
</li>
<li><p><strong>行为多态</strong>：子类中和父类<strong>同名(重写)的方法</strong>，在多态调用时采用子类的方法(new的是Teacher的无参构造)</p>
</li>
<li><p>编译看的是左边引用的类型，但是实际运行起来看的是右边的构造函数，但是多态 <strong>不包括</strong> 成员变量 Person p = new Student() </p>
</li>
<li><p>右边对象是解耦合的，比如前面用的是Student后边想换成Person可以直接换掉</p>
</li>
<li><p>用父类的引用形参能接受一切子类的对象</p>
<ul>
<li>多态下不能使用子类的 <strong>独有功能</strong>  <ul>
<li>Method1 父类中定义一个抽象方法</li>
<li>Method2 instanceof判定ifelse</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多态的类型转换"><a href="#多态的类型转换" class="headerlink" title="多态的类型转换"></a><strong>多态的类型转换</strong></h4><p><strong>auto</strong> : <code>People p = new Teacher();</code> 小的自动转成大的</p>
<p><strong>force</strong>: <code>Teacher t = (Teacher)p;</code>大的必须强制才能转成小的 </p>
<p>编译阶段有继承或者实现关系就不会报错，但是运行会报<code>ClassCastException</code></p>
<p>Teacher有<code>teach() </code>Student 有<code>test()</code> ， 一个父类的引用person是无法调用他们的，必须类型转换</p>
<ul>
<li><p>但是如果p实际上是Student类，是无法强制转换成Teacher类的，引出 <code>instanceof</code> 运算符，结果是一个boolean类型的变量。</p>
</li>
<li><p>用父类的引用形参接受子类的对象，p instanceof Teacher = true 那么调用Teacher的独有功能，否则调用Student的独有功能</p>
</li>
</ul>
<h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>final 加在class上 类不能被继承， final加在方法上不能被重写，加在变量上 变量必须且仅能赋值一次   </p>
<p>static final 修饰的成员变量 String SCHOOL_NAME = “HEIMA” 相当于是 <strong>常量</strong></p>
<p>常量和直接用字面量性能一样</p>
<h3 id="抽象类-abstract-关键字"><a href="#抽象类-abstract-关键字" class="headerlink" title="抽象类 abstract 关键字"></a>抽象类 abstract 关键字</h3><ul>
<li><strong>抽象方法</strong> 只有方法签名，不能有具体的方法实现</li>
<li><strong>不能创建对象</strong> 只能作为父类让子类继承</li>
<li>如果一个类从抽象父类继承而来，除非重写完所有上一代的抽象方法，否则这个类也必须是抽象类</li>
<li>更好支持多态，父类知道子类都要做某个行为，但每个子类做的情况又不一样，父类就定义抽象方法，交给子类重写实现</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911172104015.png" alt="image-20240911172104015"></li>
</ul>
<h4 id="设计模式：模版方法"><a href="#设计模式：模版方法" class="headerlink" title="设计模式：模版方法"></a>设计模式：模版方法</h4><p>解决了什么问题：两个类的方法有大量的重复代码，仅仅有部分不同。</p>
<p>老师和学生都要写同一片作文，开头结尾相同，正文部分不一样，A B都需要<code>write()</code>且大量重复，抽象父类Father可以在<code>write()</code>写好重复的部分，插入抽象方法<code>body()</code>  并且父类的<code>write()</code>可以加<code>final</code>关键字，保证不被继承</p>
<h3 id="接口-interface-关键字"><a href="#接口-interface-关键字" class="headerlink" title="接口 interface 关键字"></a>接口 interface 关键字</h3><p>实现类 实现 接口  重写所有抽象方法</p>
<ul>
<li><p>方法 默认 <code>public</code> <code>abstract</code> </p>
</li>
<li><p>变量 默认 <code>public</code> <code> static</code> <code>final</code>（常量）</p>
</li>
<li><p>接口 不能 实例化，不能被类继承，可被类实现，可被接口继承</p>
</li>
<li><p>弥补单继承，可实现多接口(类似多继承)，一个类可以拥有更多的 能力(某专业方面的能力)</p>
</li>
<li><p>面向接口编程，业务实现的切换灵活，解耦，AB都实现了接口Driver Driver某一天想换人，直接new B就可以，AB都实现了drive方法。你是司机，你就必须会开车，这样的话想换司机只需要换人就可以，不需要额外增加方法 <code>Driver driver = new A();</code> <code>Driver driver = new B();</code> </p>
</li>
<li><p>同一个功能的多套方案：建立一个接口，用接口的抽象方法表示要实现的功能，然后分别做多个接口的实现类，把抽象方法具体化</p>
</li>
<li><p>JDK 8 new:  均非抽象方法，</p>
<ul>
<li>默认方法 default 接口 <strong>实现类的对象</strong> 才可以调用 用public修饰</li>
<li>私有方法 private 只有在接口 <strong>内部</strong> 才能访问</li>
<li>静态方法 static   只能通过 <strong>接口名调用</strong> 用public修饰 </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911221630071.png" alt="image-20240911221630071"></li>
</ul>
<p>外部软件包访问本包接口，需要将接口设置为public</p>
</li>
</ul>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法(同一个类)</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可以修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可以修改</td>
<td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">可以修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h3 id="内部类-9-12"><a href="#内部类-9-12" class="headerlink" title="内部类 9.12"></a>内部类 9.12</h3><ul>
<li><p>创建内部类对象：<code>Outer.Inner in = new Outer().new Inner();</code> 外部类.内部类</p>
<ul>
<li>内部类的方法访问内部类的成员变量 <code>this</code></li>
<li>Outer.this 返回外部类对象</li>
</ul>
</li>
<li><p>JDK16开始 可以定义内部类的静态成员</p>
</li>
<li><p>静态内部类：<code>public static class</code></p>
<ul>
<li><code>Outer.Inner in = new Outer.Inner();</code> </li>
<li>不需要创建外部对象就能获得内部类</li>
<li>可以访问外部类的静态成员</li>
</ul>
</li>
</ul>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul>
<li>本质上是一个子类，会立即创建出一个子类对象出来</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.cry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Animal这个抽象类不能实例化，在后面加一个大括号，然后在其中实现抽象方法，这样就创建了一个子类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Swimming</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Swim!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    go(s1); <span class="comment">//输出 Swim！</span></span><br><span class="line">    go(<span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Swim!2nd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)<span class="comment">//输出Swim！2nd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Swimming s)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Go!&quot;</span>);</span><br><span class="line">	s.swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimming</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用：快速创建子类对象，用于（interface）实现类对象作形参的情况 一般是被动去用</li>
<li>JFrame API: <code>button.addActionListener(ActionListener act)</code> <code>ActionListener</code> is an interface</li>
</ul>
<h3 id="枚举-enum-关键字"><a href="#枚举-enum-关键字" class="headerlink" title="枚举 enum 关键字"></a>枚举 enum 关键字</h3><ul>
<li><p> 特殊的class ，私有的构造器，只能创建固定数量的实例(对象)</p>
</li>
<li><p>如果有抽象方法，对象必须实现方法</p>
</li>
<li><p>遍历 for-each语句 没有索引，不能修改元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> number: numbers)&#123;</span><br><span class="line">	System.out.prinln(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912125835772.png" alt="image-20240912125835772"></p>
</li>
</ul>
<p>枚举变量实际是常对象，用public static final 修饰，创建了X,Y,Z三个常对象，调用的是无参的构造器，也可以自己写有参构造器， </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912130046257.png" alt="image-20240912130046257"></p>
<h4 id="设计模式：单例-1"><a href="#设计模式：单例-1" class="headerlink" title="设计模式：单例"></a>设计模式：单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">C</span>&#123;X;&#125;<span class="comment">//单例</span></span><br></pre></td></tr></table></figure>

<h4 id="信息标注"><a href="#信息标注" class="headerlink" title="信息标注"></a>信息标注</h4><p>常量输入的信息不受约束，用枚举做信息标注更好</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912131648801.png" alt="image-20240912131648801"></p>
<p>枚举做形参，方法内直接写出对应的枚举即可</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><p>相当于是类做参数</p>
</li>
<li><p><code>ArrayList</code> 没有指出泛型，默认是<code>Object</code>对象</p>
</li>
<li><p><code>ArrayList&lt;String&gt;</code> 只能接受<code>String</code>类型的数据</p>
</li>
<li><p><code>ArrayList&lt;T extends Animal&gt;</code> 只能接受<code>Animal</code>子类</p>
</li>
<li><p><code>ArrayList&lt;T implements Driver&gt;</code> 只能接受<code>Driver</code>实现类</p>
</li>
<li><p>把数据类型作为参数传递给类型变量，相当于缺省，然后对类的成员进行赋值</p>
</li>
<li><p><em>使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组(<code>Object[] arr</code>)排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</em> </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Data</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>;</span><br><span class="line">	ArrayList&lt;T&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Teacher&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Teacher teacher)</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ArrayList&lt;Teacher&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//泛型接口</span></span><br></pre></td></tr></table></figure>

<ul>
<li>泛型方法 用<code>&lt;E&gt;</code>修饰，表明方法中存在缺省<strong>类型</strong> class E，可能在参数列表中，也可能在返回值中，也可能在具体的实现中 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span>&#123;</span><br><span class="line">      <span class="comment">// 输出数组元素            </span></span><br><span class="line">    <span class="keyword">for</span> ( E element : inputArray )&#123;     </span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">    &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912141719516.png" alt="image-20240912141719516"></p>
<ul>
<li><p>定义的时候在返回值前加泛型，单纯使用可以在ArrayList加通配符</p>
<ul>
<li><code>public static &lt;T&gt; void go (ArrayList&lt;T&gt; cars)</code> </li>
<li><code>public static void go (ArrayList&lt;?&gt; cars)</code> </li>
<li><code>&lt;?&gt;</code>表示能接收一切类型的ArrayList </li>
<li><code>&lt;? extends Car&gt;</code>表示能接收Car以及Car子类的ArrayList，也叫上限</li>
<li><code>&lt;? super Car&gt;</code>表示能接收Car以及Car父类的ArrayList ，也叫下限</li>
</ul>
</li>
<li><p><strong>泛型擦除：</strong> 编译阶段工作，class字节码文件中并不存在泛型，都是将 Object 对象 强转为 E 类型</p>
</li>
<li><p>泛型<strong>不支持基本数据类型</strong>，Integer Double 类型解决</p>
</li>
</ul>
<h2 id="API-from-JDK-2024-9-12"><a href="#API-from-JDK-2024-9-12" class="headerlink" title="API from JDK 2024.9.12"></a>API from JDK 2024.9.12</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul>
<li><p>Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，<strong>子类可以使用 Object 的所有方法</strong>。</p>
</li>
<li><p>Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。</p>
</li>
<li><p><code>toString() 返回字符串形式</code> 可重写,以返回对象的内容</p>
</li>
<li><p><code>equals(Object o) 返回boolean </code>   判断对象是否相等 默认比较 <strong>地址</strong> 可重写成 比较两个的内容是否一样</p>
<ul>
<li>先判断地址是否一样</li>
<li>再判断是不是null/是不是同一个类</li>
<li>再判断变量是否相等 <code>return this.age == student.age &amp;&amp; Objects.equals(this.name,student.name)</code>  </li>
</ul>
</li>
</ul>
<h3 id="Object-的-clone"><a href="#Object-的-clone" class="headerlink" title="Object 的 clone()"></a>Object 的 clone()</h3><ul>
<li><p><code>protected o clone()</code> 复制一个完全相同的Object对象，内容相同，属于<strong>浅拷贝</strong> 调用子类方法需要强转 。我们用的类跟Object源文件不在一个包下，所以子类要用<code>clone()</code>必须要重写，通过子类<code>super</code>间接调用父类Object的<code>clone()</code>。并且子类必须是接口<code>Cloneable</code>的实现类.</p>
</li>
<li><p>浅拷贝：<strong>对象中包含的其他对象</strong>，依然指向同一个对象(相当于直接把对象的地址也复制过去了) </p>
</li>
<li><p>深拷贝：浅拷贝+对象中包含的对象单独浅拷贝<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912230730643.png" alt="image-20240912230730643"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> (Animal)<span class="built_in">super</span>.clone();</span><br><span class="line">        a.arr = a.arr.clone();<span class="comment">//数组内部没有其他的对象，</span></span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="浅拷贝：实现-Cloneable-接口，重写-clone-方法"><a href="#浅拷贝：实现-Cloneable-接口，重写-clone-方法" class="headerlink" title="浅拷贝：实现 Cloneable 接口，重写 clone() 方法"></a>浅拷贝：实现 Cloneable 接口，重写 clone() 方法</h4><p>clone(): protected-&gt;public  +  Cloneable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();  <span class="comment">// 浅拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其性能好，使用 native 方法复制对象。简单，适用于成员变量都是**<u>基本类型或不可变对象</u>**的情况。<code>Cloneable</code> 接口本身没有 <code>clone()</code> 方法，是一个标记接口，没有标记会抛出 <code>CloneNotSupportedException</code>。实际上就是调用的Object的clone()，但是你不能不重写，因为这个只有在子类里才能调用，必须将原来的 protected 改成 public。</p>
<h4 id="深拷贝：重写-clone-方法，可变对象引用单独调用clone"><a href="#深拷贝：重写-clone-方法，可变对象引用单独调用clone" class="headerlink" title="深拷贝：重写 clone() 方法，可变对象引用单独调用clone()"></a>深拷贝：重写 clone() 方法，可变对象引用单独调用clone()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">cloned</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.address = (Address) address.clone();  <span class="comment">// 手动深拷贝引用</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用序列化实现深拷贝（常用于对象图很复杂时）"><a href="#使用序列化实现深拷贝（常用于对象图很复杂时）" class="headerlink" title="使用序列化实现深拷贝（常用于对象图很复杂时）"></a>使用序列化实现深拷贝（<strong>常用于对象图很复杂时</strong>）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">cloned</span> <span class="operator">=</span> mapper.readValue(mapper.writeValueAsString(original), Person.class);</span><br></pre></td></tr></table></figure>

<h4 id="深拷贝：手写构造器进行复制"><a href="#深拷贝：手写构造器进行复制" class="headerlink" title="深拷贝：手写构造器进行复制"></a>深拷贝：手写构造器进行复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Person other)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = other.name;</span><br><span class="line">        <span class="built_in">this</span>.address = <span class="keyword">new</span> <span class="title class_">Address</span>(other.address);  <span class="comment">// 深拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912233304677.png" alt="image-20240912233304677"></p>
</li>
<li><p>equals方法是为了避免空指针异常，s1.equals()，s1 = null 会报NullPointerException</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a==b)||(a != <span class="literal">null</span> &amp;&amp; a.equals(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>int -&gt; Integer      char -&gt;Character</p>
<p>泛型和集合不支持基本数据类型，用包装类替代，有自动装箱和自动拆箱机制</p>
<ul>
<li><code>Integer.toString()</code> 将Integer对象转换成字符串 i.toString();</li>
<li><code>Integer.toString(int i)</code> 将23这个数字转换成字符串 静态方法 <ul>
<li>arr[i] + “” 数字+空串也可以转换成字符串</li>
</ul>
</li>
<li><code>Double.parseDouble(String str)</code> 将str转换成 double 静态方法</li>
<li><code>Double.valueOf(String str)</code> 将str转换成 double 静态方法</li>
<li>println 能加则加，不能加就一起输出</li>
</ul>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913000059749.png" alt="image-20240913000059749"></p>
<ul>
<li>StringBuilder重写了toString()  </li>
<li>append返回对象本身，可以链式调用，s.append(1).append(2).append(“!23213”);</li>
<li>reverse、length</li>
<li>操作字符串建议使用StringBuilder 是可变对象 效率更高</li>
<li>线程不安全。</li>
</ul>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><ul>
<li>线程安全</li>
</ul>
<h3 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h3><ul>
<li>格式化拼接，方便快捷</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913001740989.png" alt="image-20240913001740989"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getArr</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123; <span class="comment">//返回数组</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            sb.append(arr[i]);</span><br><span class="line">            <span class="keyword">if</span>(i!=arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getArr</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123; <span class="comment">//返回数组</span></span><br><span class="line">        <span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            sj.add(arr[i]+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> sj.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Math-2024-9-13"><a href="#Math-2024-9-13" class="headerlink" title="Math 2024.9.13"></a>Math 2024.9.13</h3><p>工具类，静态方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913134448095.png" alt="image-20240913134448095"></p>
<p>abs ceil floor round</p>
<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>工具类 静态方法</p>
<p><code>System.exit(0) </code> 人为停机</p>
<p><code>System.currentTimeMillis()</code> 返回毫秒值 统计程序时间</p>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><ul>
<li>java程序所在的运行环境</li>
<li><strong>单例类</strong> 构造器私有，声明一个public static final</li>
<li>exit exec</li>
</ul>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul>
<li><p><code>public BigDecimal(String val)</code>构造器 将double转成String类型然后付给BigDecimal</p>
</li>
<li><p><code>public static BigDecimal valueOf(double val)</code> 直接接一个double，据此创建一个BigDecimal对象（推荐）</p>
</li>
<li><p>divide(另一个BD对象，精确位数，舍入模式)</p>
<ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913140854393.png" alt="image-20240913140854393"></p>
</li>
<li><table>
<thead>
<tr>
<th>UP</th>
<th>DOWN</th>
<th>CEILING</th>
<th>FLOOR</th>
<th>HALF_UP</th>
<th>HALF_DOWN</th>
</tr>
</thead>
<tbody><tr>
<td>远离0方向</td>
<td>接近0方向</td>
<td>向上取整</td>
<td>向下取整</td>
<td>四舍五入</td>
<td>五舍六入</td>
</tr>
</tbody></table>
</li>
<li><p>HALF_EVEN 若（<strong>舍入位大于</strong>5）或者（<strong>舍入位等于</strong>5<strong>且前一位为奇数</strong>），则对舍入部分的前一位数字加1；若（<strong>舍入位小于</strong>5）或者（<strong>舍入位等于</strong>5且前一位为偶数），则直接舍弃。</p>
</li>
</ul>
</li>
<li><p>转成<code>double d =  bigdecimal.doubleValue()</code></p>
</li>
</ul>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913164633885.png" alt="image-20240913164633885"></p>
<h5 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h5><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><ul>
<li><p><code>toString([] arr)</code> 返回一个数组字符串，每个元素调用<code>toString()</code>转换成字符串，用<code>[,,,]</code>拼接成一个总字符串</p>
</li>
<li><p> <code>copyOfRange([] arr, from, to)</code> 返回值为数组， 内容为arr中索引 <strong>[from, to)</strong> 的部分</p>
</li>
<li><p><code>copyOf([] arr, int newlength)</code> 返回值为数组，内容为arr的内容，长度为newlength，不够的用0补齐，索引超出的截断</p>
</li>
<li><p><code>setAll</code>  第二个参数是接口<code>IntToDoubleFunction</code>的实现对象，重写了<code>applyAsDouble(int value)</code>方法，value是数组的索引，返回对数组中内容进行操作的结果，图中是将数组内容乘以0.8。这个对象传进来以后，对数组进行遍历，都用<code>applyAsDouble</code>的方法进行操作。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913170741004.png" alt="image-20240913170741004"></p>
</li>
<li><p><code>sort([] arr)</code> 对arr升序排序(默认升序)</p>
</li>
<li><p><code>asList()</code>:只能加<strong>引用类型</strong>，基本数据类型需要改成包装类，并且返回的<code>List</code>是不能运用<code>add remove clear</code>方法的，这个<code>list</code>是<code>AbstractList</code>的子类，如果要访问<code>utils</code>只能将返回的这个<code>List</code>添加到<code>new ArrayList&lt;&gt;()</code>作为有参构造</p>
</li>
</ul>
<h4 id="对象数组如何排序？-Comparable-Comparator-—匿名内部类实现函数式接口"><a href="#对象数组如何排序？-Comparable-Comparator-—匿名内部类实现函数式接口" class="headerlink" title="对象数组如何排序？ Comparable Comparator —匿名内部类实现函数式接口"></a>对象数组如何排序？ Comparable Comparator —匿名内部类实现函数式接口</h4><p><strong>自己指定比较规则</strong> </p>
<ul>
<li><p>方法1：对象类实现<code>Comparable&lt;E&gt;</code>这个泛型接口，类中重写<code>int compareTo(E e)</code> 方法，将E改为自己的对象类型。</p>
<ul>
<li>约定，左边大于右边 return 正整数，小于 return 负整数，等于 return 0;（升序排序）</li>
<li><code>return this.age - o.age</code>  注意返回值是int double可以调用<code>Double.compare(o1.height, o2.height)</code></li>
<li>调用<code>Arrays.sort(students)</code>即可</li>
</ul>
</li>
<li><p>方法2：实现<code>Comparator</code>这个泛型接口，运用</p>
<ul>
<li><p>sort有一个重载函数，第一个参数是对象数组<code>T[] arr</code>，第二个参数是<code>Comparator&lt;? super T&gt; comparator</code></p>
</li>
<li><p>泛型接口做参数用匿名内部类实现，类中重写<code>int compare(T o1,T o2)</code>方法，同时注意返回的是int</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Students&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1.height,o2.height);<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>ArrayList有自己的sort方法，实现同Comparator，可以免去泛型的指定</li>
</ul>
<h4 id="Lambda-表达式—简化匿名内部类"><a href="#Lambda-表达式—简化匿名内部类" class="headerlink" title="Lambda 表达式—简化匿名内部类"></a><strong>Lambda 表达式—简化匿名内部类</strong></h4><ul>
<li>简化匿名内部类的写法，并且只能简化函数式接口(只有一个抽象方法的接口)，表示该接口的一个实现</li>
<li>@FunctionalInterface</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Swimming</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		System.out.println(name + <span class="string">&quot;is a swimmer~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Swimming</span> <span class="variable">s</span> <span class="operator">=</span> (name) -&gt; &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;is a swimmer~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913220402634.png" alt="image-20240913220402634"></p>
</li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913220414015.png" alt="image-20240913220414015"></p>
</li>
<li><p>参数类型可省略不写，无参数也要空括号</p>
</li>
<li><p>如果只有一个参数，参数列表的括号可以省略不写</p>
</li>
<li><p>如果实现的抽象方法只有一行代码，可以省略大括号，同时也要省略<code>;</code>，若这一行是<code>return</code>语句，return也不能写</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1.age(),o2.age());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Arrays.sort(students, (Student o1,Student o2)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(o1.age(),o2.age());</span><br><span class="line">&#125;);</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;&#123;<span class="keyword">return</span> Double.compare(o1.age(),o2.age());&#125;);</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;Double.compare(o1.age(),o2.age());</span><br></pre></td></tr></table></figure>

<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ShuSheng0007/article/details/107562812">秒懂Java之方法引用（method reference）详解-CSDN博客</a></p>
<p>Lambda的简化 对于参数列表和返回值相同的情况</p>
<h5 id="类的静态方法引用-类的实例方法引用（对象本身并不作为参数）"><a href="#类的静态方法引用-类的实例方法引用（对象本身并不作为参数）" class="headerlink" title="类的静态方法引用/类的实例方法引用（对象本身并不作为参数）"></a>类的静态方法引用/类的实例方法引用（对象本身并不作为参数）</h5><ul>
<li><p>静态方法引用: 调用静态方法，不需要实例，前缀是类名</p>
</li>
<li><p>实例方法引用: 调用已经存在的对象的实例方法，对象本身并不是参数，方法引用前缀是具体的对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;E&gt;&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(E o1, E o2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompareByData</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareByAge</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Double.compare(o1.getAge(),o2.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareByAgeDesc</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Double.compare(o2.getAge(),o1.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> compareBy</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;CompareByData.compareByAge(o1,o2));<span class="comment">//lambda</span></span><br><span class="line">Arrays.sort(students, CompareByData::compareByAge);<span class="comment">//静态方法引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">CompareByData</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompareByData</span>();</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;com.compareByAgeDesc(o1,o2));<span class="comment">//lambda</span></span><br><span class="line">Arrays.sort(students, com::compareByAgeDesc);<span class="comment">//实例方法引用,com并不是参数</span></span><br></pre></td></tr></table></figure>

<h5 id="类的实例方法引用-对象本身作为参数"><a href="#类的实例方法引用-对象本身作为参数" class="headerlink" title="类的实例方法引用(对象本身作为参数)"></a>类的实例方法引用(对象本身作为参数)</h5><ul>
<li>调用实例方法，对象本身作为参数传进来，方法引用前缀为类名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(names, (String o1,String o2)-&gt;o1.compareToIgnoreCase(o2));</span><br><span class="line">Arrays.sort(names, String::compareToIgnoreCase);<span class="comment">//compareToIgnoreCase本身是String的一个实例方法</span></span><br><span class="line">    </span><br><span class="line">lqw.lt((User o1)-&gt;o1.getAge());</span><br><span class="line">lqw.lt(User::getAge, <span class="number">10</span>);<span class="comment">//getAge是User的一个实例方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>传入的对象o1是实例方法的调用者，其余的参数都是这个方法的参数</li>
</ul>
<h5 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h5><ul>
<li>Lambda表达式如果只是在创建一个对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Student <span class="title function_">getStudent</span><span class="params">(String name, <span class="type">int</span> age, BiFunction&lt;String, Integer, Student&gt; biFunction)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biFunction.apply(name, age);</span><br><span class="line">&#125;</span><br><span class="line">BiFunction&lt;String, Integer, Student&gt; s1 = <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;String, Integer, Student&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">apply</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(name, age);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//lambda表达式</span></span><br><span class="line">    BiFunction&lt;String, Integer, Student&gt; s2 = (name, age) -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>(name, age);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//对应的方法引用</span></span><br><span class="line">    BiFunction&lt;String, Integer, Student&gt; s3 = Student::<span class="keyword">new</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h5 id="方法引用-Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性"><a href="#方法引用-Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性" class="headerlink" title="方法引用/Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性"></a>方法引用/Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(names, (Comparator&lt;? <span class="built_in">super</span> String&gt;) String::compareToIgnoreCase);</span><br><span class="line">Arrays.sort(names, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>



<h2 id="Regex-正则表达式"><a href="#Regex-正则表达式" class="headerlink" title="Regex 正则表达式"></a>Regex 正则表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">qqCode</span> <span class="operator">=</span> <span class="string">&quot;12812415&quot;</span>;</span><br><span class="line">System.out.println(qqCode.matches(<span class="string">&quot;[1-9]\\d&#123;5-19&#125;&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="Exception-异常处理"><a href="#Exception-异常处理" class="headerlink" title="Exception 异常处理"></a>Exception 异常处理</h2><p><code>Error</code>属于严重异常</p>
<p>运行时异常<code>RuntimeException</code></p>
<p>编译时异常，不解决是无法运行的</p>
<h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914213155516.png" alt="image-20240914213155516"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时异常</span></span><br><span class="line"><span class="comment">//自定义异常对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeIllegalRuntimeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(....) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalRuntimeException</span>(<span class="string">&quot;Your age is illegal!&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//抛出一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        saveAge(<span class="number">123</span>);<span class="comment">//函数执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//catch 用来接受可能抛出的异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译时异常 强烈提醒检查</span></span><br><span class="line"><span class="comment">//自定义异常对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> AgeIllegalException&#123;<span class="comment">//接收方法内部可能抛出的异常</span></span><br><span class="line">    <span class="keyword">if</span>(....) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalException</span>(<span class="string">&quot;Your age is illegal!&quot;</span>);<span class="comment">//一开始会报错,throws抛出</span></span><br><span class="line">    &#125;<span class="comment">//抛出一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        saveAge(<span class="number">183</span>);<span class="comment">//函数执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//catch 用来接受可能抛出的异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>throws</code>:用于方法的声明当方法内部抛出指定类型的异常时，该异常会被传递给<strong>调用该方法的代码</strong>，并在该代码中处理异常</p>
<p><code>try-catch</code>:试图接收并处理异常</p>
<p><code>throw</code>:用于在当前方法中抛出一个异常，当代码执行到某个条件下无法继续正常执行时，可以使用 <strong>throw</strong> 关键字抛出异常，以告知调用者当前代码的执行状态</p>
<ul>
<li>底层异常往外抛,最外层接受并记录,响应给用户</li>
<li>最外层接收,并在底层尝试修复<ul>
<li><code>sc.nextDouble()</code>接收一个<code>double</code>类型,如果乱输aafads就会在运行时自动抛出错误给外层</li>
<li>只需要将外层调用的<code>try-catch</code>块用<code>while(true)</code>围起来即可</li>
</ul>
</li>
</ul>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><h3 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h3><p>file&amp;directory</p>
<ul>
<li><code>File(String pathname)</code>:有参构造, <code>pathname</code>路径分隔符<code> / \\ File.separator</code> <ul>
<li>绝对路径</li>
<li>相对路径：默认起始位置是工程目录<code>(模块)file-io-app\\src\\itheima.txt</code></li>
</ul>
</li>
<li><code>f1.length()</code>:返回文件,文件夹大小 字节数 文件夹是存储文件夹内部的一些文件信息</li>
<li><code>f3.exists()</code>:是否存在</li>
<li><code>f3.isFile()</code>:是否是文件</li>
<li><code>f3.isDirectory()</code>:是否是文件夹</li>
<li><code>f3.getName()</code>:获取文件名称，包含后缀</li>
<li><code>f3.lastModified()</code>:返回long 最后修改的时间</li>
<li><code>f1.getPath()</code>获取创建对象时输入的路径</li>
<li><code>f1.getAbsolutePath()</code>获取文件的绝对路径</li>
</ul>
<ul>
<li><code>f1.createNewFile()</code>:不存在才创建，存在就创建失败，返回<code>false</code>  没找到路径会报错</li>
<li><code>f1.mkdir()</code>:不存在才创建，存在就创建失败，返回<code>false</code> 只能创建一级目录</li>
<li><code>f1.mkdirs()</code>:可以创建多级目录，返回结果</li>
<li><code>f1.delete()</code>:删除文件、空文件夹，返回结果</li>
</ul>
<ul>
<li><code>f1.list()</code>:当前<strong>文件夹</strong>内的<strong>一级文件名称</strong>返回<code>String[]</code> 也包含文件夹</li>
<li><code>f1.listFiles()</code>:返回当前<strong>文件夹</strong>内的<strong>一级文件对象</strong>，返回文件对象数组<code>File[]</code>，也包含文件夹<ul>
<li>文件、路径不存在、无权限访问的文件夹 <code>return null</code></li>
<li>空文件夹返回长度为0的File数组</li>
<li>隐藏文件也显示</li>
</ul>
</li>
<li><code>renameTo(new File(file.getParent(), newName))</code> 改名，file是目录下子文件,<code>substring(from,to)</code>是截取<code>[from,to)</code>,<code>substring(from)</code>是截取<code>[from,最后]</code></li>
</ul>
<h4 id="文件搜索、非空文件夹删除"><a href="#文件搜索、非空文件夹删除" class="headerlink" title="文件搜索、非空文件夹删除"></a>文件搜索、非空文件夹删除</h4><p>递归，数学问题最好写出表达式</p>
<p>eg 猴子一天吃一半还要再吃一个，10天剩余1个。前9天各自吃了多少？</p>
<p>$f(x)$代表第x天的桃子数量，题干可得出$f(x)/2+1 = f(x+1), f(10)=1$ 直接写递归函数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNumberOfPeach</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*getNumberOfPeach(n+<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="C:\Users\Lenovo\IdeaProjects\MyFirstProject\src\com\it\IOtest\FileTestDemo.java">文件搜索、非空文件夹删除</a> </p>
<p><a href="C:\Users\Lenovo\IdeaProjects\MyFirstProject\src\com\it\IOtest\RecursiveDemo.java">递归练习</a> </p>
<h3 id="字符集（前置）"><a href="#字符集（前置）" class="headerlink" title="字符集（前置）"></a>字符集（前置）</h3><p>ASCII: 首位是0，使用1个字节存储英文数字</p>
<p>GBK: 1个中文字符编码成2个字节，兼容ASCII，并且对汉字规定第一个字节的第一位必须是1，与ASCII字符做区分</p>
<p>Unicode: </p>
<ul>
<li><p>UTF-32 4个字节表示一个字符</p>
</li>
<li><p>UTF-8 </p>
<ul>
<li>可变长编码方案 可以有1B 2B 3B 4B 四种长度 </li>
<li>兼容ASCII，汉字字符占3B</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916165638204.png" alt="image-20240916165638204"></li>
</ul>
</li>
<li><p>Encode Decode Identical</p>
</li>
<li><p>String提供了一些API，为字符串提供了编码和解码操作，以字节数组的形式<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916170250587.png" alt="image-20240916170250587"></p>
</li>
</ul>
<h3 id="IO流-字节流-amp-字符流"><a href="#IO流-字节流-amp-字符流" class="headerlink" title="IO流:字节流&amp;字符流"></a>IO流:字节流&amp;字符流</h3><ul>
<li><code>InputStream</code>:字节输入流:以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流</li>
<li><code>OutputStream</code>:字节输出流:以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流</li>
<li><code>Reader</code>:字符输入流:以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流，</li>
<li><code>Writer</code>:字符输出流:以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916171717591.png" alt="image-20240916171717591"></p>
<h4 id="FileInputStream-字节流"><a href="#FileInputStream-字节流" class="headerlink" title="FileInputStream 字节流"></a>FileInputStream 字节流</h4><ul>
<li>从文件一个字节一个字节地读取数据到内存中</li>
<li><code>InputStream is = new FileInputStream(&quot;........&quot;)</code></li>
<li><code>FileInputStream(String name)</code>:打开实际文件的连接创建文件字节输入流，也可用<code>File file</code>做形参，<code>String</code>重载会自动帮你转成file对象。</li>
<li>一次读取一个 <code>int read()</code> 读取一个字节并返回，无数据返回-1 <ul>
<li>改进：循环<code>(b=is.read())!=-1</code></li>
<li>调用系统硬件资源，性能较差</li>
<li>一次读一个，无法解决非ASCII的乱码</li>
<li>流使用系统资源，使用完记得关闭！<code>is.close()</code></li>
</ul>
</li>
<li>一次读取多个 <code>int read(byte[] buffer)</code> 用<code>buffer</code>字节数组装字节，字节数组的长度代表每次读取的字节数，返回每次读取的字节数（<code>buffer</code>可能会装不满）无数据返回-1<ul>
<li><code>buffer</code>字节数组要转换成字符串，转成<code>String</code>可以设定转的部分，<code>String(buffer, 0, len)</code>确保如实把<strong>这次</strong>读到的内容转为字符串 <code>len</code>为<code>read</code>的返回值 </li>
<li>性能得到了提升，汉字仍然乱码，会强行截断汉字</li>
</ul>
</li>
<li>一次读取全部<ul>
<li><code>int read(byte[] buffer)</code>buffer大小和文件的大小字节数相同</li>
<li><code>byte[] readAllBytes()</code> <code>is.readAllBytes()</code> </li>
<li>文件过大会导致内存溢出，字节数组过大，所以字节流不适合读文本，更适合做数据转移，比如文件复制</li>
</ul>
</li>
</ul>
<h4 id="FileOutputStream-字节流"><a href="#FileOutputStream-字节流" class="headerlink" title="FileOutputStream 字节流"></a>FileOutputStream 字节流</h4><ul>
<li>从内存一个字节一个字节地输出到文件中，目标文件自动生成</li>
<li><code>OutputStream os = new FileOutputStream(&quot;........&quot;)</code> 写文件（覆盖）</li>
<li><code>OutputStream os = new FileOutputStream(&quot;........&quot;, true)</code> 写文件（追加）<ul>
<li>换行：<code>&quot;\r\n&quot;</code> 将其转换成<code>bytes[]</code> 再<code>write</code></li>
</ul>
</li>
<li><code>os.write(int b)</code>把b写入文件 还是以字节形式</li>
<li><code>os.write(byte[] b)</code>把字节数组b写入文件</li>
<li><code>os.write(byte[] b,int off,int len)</code>把b写入文件, <code>off</code>表示起始的字节数组索引，<code>len</code>表示要写入的字节长度，3个汉字一共9字节</li>
</ul>
<h5 id="case-文件复制"><a href="#case-文件复制" class="headerlink" title="case: 文件复制"></a>case: 文件复制</h5><p>总结：字节流适合拷贝一切文件，因为一切文件的内容都是以字节形式存储的，一字不漏地转移所有字节，就不会出现问题</p>
<h4 id="释放资源的方式"><a href="#释放资源的方式" class="headerlink" title="释放资源的方式"></a>释放资源的方式</h4><p>原来：中间出现异常，就无法释放资源（关闭字节流）</p>
<h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论try是否正常执行，一定执行finally，除非JVM终止<code>System.exit(0)</code></p>
<p>finally可以无视<code>return</code>语句 一定执行一次，如果finally是return，原函数接受的就一定是finally里边的值，所以最好不要在finally里面return</p>
<p>在程序执行完成后进行资源的释放操作，finally不能访问try块里面的内容</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916200213214.png" alt="image-20240916200213214">先在try块外定义流，然后try块内对流进行操作，finally块内关闭流，关闭流因为系统不知道之前是否开流会报错，用try catch块包围起来即可<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916200719319.png" alt="image-20240916200719319"></p>
<p><strong>臃肿</strong></p>
<h5 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>（</span><br><span class="line">	<span class="comment">//资源的定义;</span></span><br><span class="line">	<span class="comment">//资源的定义;</span></span><br><span class="line">）&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能放置资源对象, 资源都会实现AutoClosable接口，资源放进去会自动调用close方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916201402673.png" alt="image-20240916201402673"></p>
<h4 id="FileReader-字符流"><a href="#FileReader-字符流" class="headerlink" title="FileReader 字符流"></a>FileReader 字符流</h4><ul>
<li>把文件数据以字符形式读到内存中去</li>
<li>构造器与<code>FileInputStream</code>类似 <code>Reader fr = new FileReader(String filename)</code></li>
<li><code>int read() </code>每次读取一个字符并返回</li>
<li><code>int read(char[] buffer) </code>每次读取多个字符并返回，返回此次读取字符的个数</li>
</ul>
<h4 id="FileWriter-字符流"><a href="#FileWriter-字符流" class="headerlink" title="FileWriter 字符流"></a>FileWriter 字符流</h4><ul>
<li>把字符数据写到文件中去,目标文件自动生成</li>
<li>构造器与<code>FileOutputStream</code>类似 <code>Writer fw = new FileWriter(String filename)</code>可以参数后加true表示追加</li>
<li><code>void write(int c)</code>写一个字符出去</li>
<li><code>void write(String str)</code>写一个字符串出去</li>
<li><code>void write(String str,int pos,int len)</code> 写字符串从<code>pos</code>开始长度为<code>len</code></li>
<li><code>void write(char[] buffer)</code>写一个字符数组</li>
<li><code>void write(char[] buffer,int pos,int len)</code>写字符数组从<code>pos</code>开始长度为<code>len</code></li>
<li>注意事项<ul>
<li>字符输出流写出数据以后，必须刷新流或者关闭流（包含刷新）才能生效。<code>flush() close()</code> 因为对文件操作比较耗费系统资源，所以都是先从管道写到缓冲区，写完之后一次性写到文件中去。</li>
</ul>
</li>
</ul>
<h3 id="IO流-缓冲流"><a href="#IO流-缓冲流" class="headerlink" title="IO流:缓冲流"></a>IO流:缓冲流</h3><p>对原始流进行包装，提高原始流读写数据的性能</p>
<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>开辟缓冲区，不用一次一次写 <strong>8KB缓冲池</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916231524970.png" alt="image-20240916231524970"></p>
<p>减少调用系统资源的次数</p>
<p><code>InputStream bis = new BufferedInputStream(InputStream is)</code></p>
<p><code>OutputStream bos = new BufferedOutputStream(OutputStream os)</code></p>
<p>方法和原始类一样，性能有所提高，有参构造可以自定义缓冲区大小，默认8192</p>
<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p>自带8K的字符缓冲池</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916232037970.png" alt="image-20240916232037970"></p>
<p><code>BufferedReader br = new BufferedReader(Reader r)</code> </p>
<p>不使用多态写法：新增了独有的功能</p>
<p>新增功能 <code>String readLine()</code> 读一整行，直到换行符，返回这行的内容，没有返回<code>null</code></p>
<p><code>BufferedWriter bw = new BufferedWriter(Writer r)</code> </p>
<p>新增功能：<code>void newLine()</code>换行</p>
<h3 id="原始-amp-缓冲流对比"><a href="#原始-amp-缓冲流对比" class="headerlink" title="原始&amp;缓冲流对比"></a>原始&amp;缓冲流对比</h3><ul>
<li>低级字节流一个一个字节的赋值，慢的简直让人无法忍受，直接淘汰! X</li>
<li>低级字节流一个一个字节数组的形式复制，速度较慢! </li>
<li>缓冲流按照一个一个字节的形式复制，速度较慢 X</li>
<li>缓冲流按照一个一个字节数组的形式复制，速度极快，推荐使用!</li>
<li>性能与字节数组的大小强相关，32MB最大，用空间换时间</li>
<li>与缓冲区的大小也有关</li>
</ul>
<p>并行&amp;多线程 异步IO 内存映射技术 减少系统调用 不要一个字节一个字节地输入</p>
<h3 id="字符转换流"><a href="#字符转换流" class="headerlink" title="字符转换流"></a>字符转换流</h3><h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><p><code>Reader isr = new InputStreamReader(InputStream is, String charset)</code> 把<strong>原始<mark>字节流<mark>is</strong>按照charset设定转换成对应字符输入流</p>
<p>新的字符输入流可以继续用<code>BufferedReader</code>包装</p>
<h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><p>控制写出去的字符集编码</p>
<ul>
<li><code>str.getBytes(&quot;GBK&quot;)</code></li>
<li>字符输出转换流</li>
</ul>
<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>PrintStream：是<strong>字节输出流</strong>的实现类</p>
<p>PrintWriter：是<strong>字符输出流</strong>的实现类 内部包装缓冲流</p>
<p><strong>方便高效</strong>，所见即所得</p>
<p>构造器：</p>
<ul>
<li><code>PrintStream(OutputStream os/File file/String filename)</code> 直接链接+包装原始流</li>
<li><code>PrintStream(String filename, Charset charset)</code> <code>Charset.forName(&quot;GBK&quot;)</code>能返回GBK的Charset</li>
<li><code>PrintStream(OutputStream os, boolean autoFlush, String charset)</code> 字符集可有可无</li>
<li><strong><code>ps.println()</code>:打印一行东西</strong></li>
<li><code>ps.write()</code>写int字节 字节数组 字节数组的一部分</li>
</ul>
<p>自身没有追加功能，只能包装<code>true输出流</code>:</p>
<p><code>PrintStream ps = PrintStream(new FileOutputStream(filename,true))</code> </p>
<p><code>PrintWriter pw = PrintWriter(new FileWriter(filename,true))</code>  </p>
<h4 id="拓展：Redirecting-PrintStream-PrintWriter"><a href="#拓展：Redirecting-PrintStream-PrintWriter" class="headerlink" title="拓展：Redirecting PrintStream/PrintWriter"></a>拓展：Redirecting PrintStream/PrintWriter</h4><p><code>System.out.println()</code> out实际上就是一个打印流，是指向控制台的</p>
<p><code>System.setOut(PrintStream ps)</code> 把系统的out设定到指定的打印流ps中</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917153902713.png" alt="image-20240917153902713"></p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><code>DataInputStream</code>:字节输入流的实现</p>
<p>构造器：包装低级的字节输入流 </p>
<p><code>dos.writeInt(int a)</code> 写出去a，包括数据类型</p>
<p><code>dis.readUTF()</code> 读进来字符串并返回 UTF-8</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154727844.png" alt="image-20240917154727844"></p>
<h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><p>序列化 见 serialization.md</p>
<p> 字节流实现类<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154853819.png" alt="image-20240917154853819"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154908066.png" alt="image-20240917154908066"></p>
<p><strong>First Step</strong> 创建对象字节输出流 包装原始字节输出流:</p>
<p><code>ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream)</code></p>
<p><strong>Second Step</strong> 调用 writeObject(具体对象)方法 </p>
<p>对象的类要**<code>implements</code> <code>Serializable</code>** 接口！</p>
<p><strong>Third Step</strong> 创建对象字节输入流 包装原始字节输入流</p>
<p><code>ObjectInputStream ois = new ObjectInputStream(new FileInputStream)</code> </p>
<h4 id="拓展：对象中某些变量不想参与序列化"><a href="#拓展：对象中某些变量不想参与序列化" class="headerlink" title="拓展：对象中某些变量不想参与序列化"></a>拓展：对象中某些变量不想参与序列化</h4><p><code>private </code> <code>transient</code> <code> String password;</code> transient关键字</p>
<h4 id="拓展：一次序列化多个对象"><a href="#拓展：一次序列化多个对象" class="headerlink" title="拓展：一次序列化多个对象"></a>拓展：一次序列化多个对象</h4><p>将对象存入ArrayList中，对ArrayList进行序列化</p>
<h3 id="IO框架"><a href="#IO框架" class="headerlink" title="IO框架"></a>IO框架</h3><p>框架：把编写好的类和接口编译成class形式，压缩成.jar结尾的文件发行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917162151321.png" alt="image-20240917162151321"></p>
<h2 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h2><p>存储有关系的数据作为系统的配置文件</p>
<h3 id="properties-属性文件"><a href="#properties-属性文件" class="headerlink" title=".properties 属性文件"></a>.properties 属性文件</h3><ul>
<li>存储键值对数据</li>
<li>键不重复</li>
</ul>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917163605651.png" alt="image-20240917163605651"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建属性对象，加载文件内容</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filename));</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建字符串集合，接收属性对象返回的键集合</span></span><br><span class="line">Set&lt;String&gt; keys = properties.stringPropertyNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历键集合，通过属性对象和键找到value</span></span><br><span class="line"><span class="keyword">for</span>(String key : keys)&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">	properties.forEach((k,v)-&gt;System.out.println(k + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917164532330.png" alt="image-20240917164532330"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;dfg&quot;</span>,<span class="string">&quot;213&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;hjk&quot;</span>,<span class="string">&quot;321&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">comments</span> <span class="operator">=</span> <span class="string">&quot;I have saved many users!!!&quot;</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filename), comments);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>



<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>E<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage</p>
<p>根标签 只有一个</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170133400.png" alt="image-20240917170133400"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170306289.png" alt="image-20240917170306289"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170346202.png" alt="image-20240917170346202"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170514649.png" alt="image-20240917170514649"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917185127560.png" alt="image-20240917185127560"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917185753893.png" alt="image-20240917185753893">好</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li>系统执行信息方便记录到指定的位置（控制台，文件，数据库）</li>
<li>随时用开关控制日志启停，不需要修改源代码</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917191534986.png" alt="image-20240917191534986"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917191744756.png" alt="image-20240917191744756"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192232262.png" alt="image-20240917192232262"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192328808.png" alt="image-20240917192328808"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192715641.png" alt="image-20240917192715641"></p>
<p><code>&lt;pattern&gt; &lt;/pattern&gt;</code> 日志格式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192956963.png" alt="image-20240917192956963"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193034517.png" alt="image-20240917193034517"></p>
<p>文件拆分规则，保证每个不超过1MB，过去的压缩成1MB的gz文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193427486.png" alt="image-20240917193427486"></p>
<p>控制日志输出情况</p>
<p>日志级别 trace&lt; <strong>debug</strong> &lt; info &lt; warn &lt; error </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193721056.png" alt="image-20240917193721056"></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><ul>
<li><code>java.net.*</code></li>
</ul>
<p>CS BS架构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918155511067-1726751033487-55.png" alt="image-20240918155511067"></p>
<h2 id="网络通信基本概念"><a href="#网络通信基本概念" class="headerlink" title="网络通信基本概念"></a>网络通信基本概念</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>设备在网络的地址，唯一标识</p>
<p><strong>IPv4:</strong> 32bit 点分十进制表示法    <strong>IPv6:</strong> 128bit 冒号分16进制表示法</p>
<p><strong>域名</strong>代表IP，<strong>DNS服务器</strong>会记录域名的真实IP</p>
<p><strong>公网IP</strong>：链接互联网 <strong>内网IP</strong>：局域网，内部使用</p>
<p>**<code>localhost = 127.0.0.1</code>**：代表本机IP，只会寻找当前所在的主机</p>
<p><strong><code>ping IP地址</code></strong> </p>
<h4 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h4><p>常用方法：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918160540846-1726751033487-56.png" alt="image-20240918160540846"></p>
<p><code>getByName()</code>: 根据主机名 返回IP地址对象</p>
<p><code>isReachable(int ms)</code> 相当于ping命令</p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>端口，应用程序在设备的地址，唯一标识</p>
<p>16bit 0-65535</p>
<p>0-1023: 预定义占用，周知端口</p>
<p>1024-49151: 注册端口</p>
<p>49152-65535: 动态分配</p>
<p>同一设备不能有两个程序的端口号一样</p>
<h3 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h3><p>协议，应用程序之间进行通信的规则</p>
<p>OSI 网络参考模型</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161423219-1726751033487-57.png" alt="image-20240918161423219"></p>
<p>TCP/IP 事实上的国际标准</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p><strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161816467-1726751033487-58.png" alt="image-20240918161816467"></p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p><strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161923650-1726751033487-59.png" alt="image-20240918161923650"></p>
<h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>第一次握手：客户端发消息，服务器收到消息，服务器知道客户端发消息没问题。</p>
<p>第二次握手：服务端发消息，客户端收到消息，客户端知道服务端收消息没问题，发消息也没问题。</p>
<p>第三次握手：客户端根据上一次握手的内容再次发出确认信息，服务器端收到信息，说明客户端收消息没问题。</p>
<p>全双工：双方都要确认对方同时具备收发信息的能力</p>
<p>不可靠信道上实现可靠的传输</p>
<p><strong>B 收到了 A 发来的消息，B 因此判断 A 具备发送能力</strong>：</p>
<ul>
<li>这个理解是正确的。当 B 收到 A 发送的 <code>SYN</code> 报文时，B 可以判断 A 具有发送消息的能力。A 通过发送 <code>SYN</code> 表示自己希望建立连接，并告诉 B 自己的初始序列号。</li>
<li>但需要注意的是，B 仅能判断 A 能发送数据，尚无法确定 A 能正确接收 B 发送的消息（即 A 的接收能力）。</li>
</ul>
<p><strong>A 收到了 B 发回的消息，A 判断 B 具备收发信息能力</strong>：</p>
<ul>
<li><strong>发送能力</strong>：正确。当 A 收到 B 发回的 <code>SYN-ACK</code> 消息后，A 可以确认 B 具备发送能力，因为 B 能够发送 <code>SYN-ACK</code> 报文。</li>
<li><strong>接收能力</strong>：A 也可以推断 B 具备接收能力，因为 B 不仅发送了 <code>SYN-ACK</code>，还包含了对 A 的 <code>SYN</code> 的确认（<code>ACK</code>），说明 B 成功接收了 A 的 <code>SYN</code> 报文。</li>
<li>因此，通过 B 的 <code>SYN-ACK</code> 报文，A 可以确认 B 既能够发送，也能够接收消息。</li>
</ul>
<p><strong>B 收到了 A 发回的信息，B 因此判断 A 具备接收能力，连接建立</strong>：</p>
<ul>
<li>这个理解也基本正确。当 B 收到 A 的 <code>ACK</code> 报文后，B 可以确认 A 的接收能力，因为 A 收到了 B 的 <code>SYN-ACK</code> 并发回了 <code>ACK</code>。如果 A 无法接收数据，就无法正确回应 B 的 <code>SYN-ACK</code> 报文。</li>
<li>至此，B 确定 A 既能发送也能接收，双方通信能力都得到确认，连接可以正式建立。</li>
</ul>
<ul>
<li>在 TCP 三次握手过程中，双方都通过序列号和确认号来确认彼此的发送和接收能力，确保连接是双向可靠的。</li>
<li>三次握手的过程确保了双方的<strong>发送能力</strong>和<strong>接收能力</strong>都正常，连接才会被建立。</li>
<li>你对各个步骤的理解是对的，只需要记住，每一步都不仅仅是确认对方的发送能力，还需要通过确认号和响应确认对方的接收能力。</li>
</ul>
<h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><ol>
<li>客户端发完数据，发出断连请求</li>
<li>服务器还没处理完最后的数据，先发一个消息，让客户端稍等</li>
<li>处理完数据后，服务器再发一个消息确认断开连接</li>
<li>客户端正式断开连接</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918213236026-1726751033487-61.png" alt="image-20240918213236026"></p>
<h2 id="Java-UDP"><a href="#Java-UDP" class="headerlink" title="Java UDP"></a><a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=com.it.netTest.UDP.Client">Java UDP</a></h2><ul>
<li><code>java.net.DatagramSocket</code> <code>java.net.DatagramPacket</code> </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918213602137-1726751033487-60.png" alt="image-20240918213602137"></li>
<li>创建DS对象，创建DP对象用于封装数据，DP对象里有字节数组，字节数组长度，目标IP,目标端口，客户端调用send方法发送数据包。</li>
<li>创建DS对象(端口号)，创建DP对象用于接收数据，DP对象里的数组长度64KB，然后服务段调用receive方法接收数据包。数据包调用getLength方法获取实际接收数据包的大小，以便正确输出数据包内数组的内容。</li>
<li>getAddress()可以拿到客户端IP地址</li>
<li>getPort()可以拿到客户端端口</li>
</ul>
<h2 id="Java-TCP"><a href="#Java-TCP" class="headerlink" title="Java TCP"></a><a href="jetbrains://idea/navigate/reference?project=MyFirstProject&path=com/JavaSE/netTest/tcp/Server.java">Java TCP</a></h2><p><code>java.net.Socket</code> <code>java.net.ServerSocket</code></p>
<p>服务端和客户端通过<code>socket</code>对象之间建立的管道进行通信，数据通过管道也就是流进行传输，而UDP是通过发送单个<code>datagram</code>数据报的形式，不需要建立联系，不需要建立稳定的管道</p>
<ul>
<li><p>客户端：    </p>
<ul>
<li>创建<code>Socket sk = new Socket(hostname, port)</code> 数据目的地的端口号</li>
<li><code>OutputStream os = sk.getOutputStream();</code> 把<code>socket</code>的流拿到</li>
<li><code>DataOutputStream dos = new DataOutputStream(os)</code> 对原始的流进行包装</li>
<li><code>dos.writeUTF(&quot;String sth&quot;)</code> </li>
<li>关闭<code>dos</code> 关闭<code>socket</code> </li>
</ul>
</li>
<li><p>服务端</p>
<ul>
<li>创建 <code>ServerSocket ss = new ServerSocket( port)</code> 注册端口，跟客户端里面的端口一样</li>
<li><code>Socket socket = ss.accept()</code> 等待客户端发来socket连接请求，端到端，这两个socket内容其实是一样的。</li>
<li><code>DataInputStream dis = new DataInputStream(socket.getInputStream());</code>用数据流包装原始的输入流</li>
<li><code>dis.readUTF().sout</code></li>
</ul>
</li>
</ul>
<p>支持一发一收 多发多收，因为只能是一个socket对应一个socket，是端到端的，要实现跟其他socket的通信只能断开连接，所以引入多线程，接到socket就开一个新线程，继续监听socket，用while循环实现。</p>
<p>要实现群聊，服务器可以用一个集合储存socket，如果某个socket收到了消息，就遍历集合发给所有socket（同客户端的发送代码）客户端建立socket对象之后，在while循环内部出不来，要监听</p>
<p>BrowserServer架构 Server要提供的内容必须符合HTTP规范</p>
<h1 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919211712463.png" alt="image-20240919211712463"></p>
<p>检测抛出异常</p>
<h2 id="断言机制"><a href="#断言机制" class="headerlink" title="断言机制"></a>断言机制</h2><p>Assert.assertEquals() bug提示 <strong>期望值</strong> 实际值 </p>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>可以一键进行所有测试，一键自动化测试</p>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>@Test 测试方法</p>
<p>@Before(BeforeEach) 每个测试前要跑的方法</p>
<p>@BeforeClass(All) 修饰静态方法，所有测试方法之前，最先 这两个是初始化</p>
<p>@After(AfterEach) 每个测试执行完要跑的方法</p>
<p>@AfterClass(All) 修饰静态方法，所有测试方法之后，最后 这两个是释放资源</p>
<p>如果是每一个测试方法都需要一个独立的资源，就用before</p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h2><p>让其他程序根据注解来决定怎么执行该程序</p>
<p><code>@Override</code>:让IDE判断方法是否重写成功 </p>
<p><code>@Test</code>: 让测试框架知道这个是测试方法</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest1&#123;</span><br><span class="line">    String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">    String[] ccc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value 属于特殊属性，可以只写值</span></span><br><span class="line"><span class="comment">//有 default 可以不用赋值</span></span><br><span class="line"><span class="comment">//没 default 必须赋值，带变量名和等号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyTest1</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span>&#123;<span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">true</span>;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String[] ccc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质是接口，都继承了Annotation接口</p>
<p><code>@MyTest1(aaa=&quot;123&quot;,bbb=false, ccc=&#123;&quot;str&quot;,&quot;asd&quot;&#125;)</code> 是一个实现类对象</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>修饰注解的注解, 在自定义注解的上面 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919214219300.png" alt="image-20240919214219300"></p>
<h2 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919214508991.png" alt="image-20240919214508991"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>模拟框架 解析注解，然后执行 模拟<a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=org.JavaSE.AdvancedTest.Annotation.JUnitSimulator">JUnitSimulator(Toolbox 引用)</a>识别并执行有特定注解的方法</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>加载类，允许用编程的方式，解剖类中的各种成分（万物皆对象）比如ide中创建一个对象，对象引用后加一个点就能显示可以调用的方法，说明这个类实现的方法已经提前加载好了。</p>
<p>反射（Reflection）是计算机编程中的一种机制，允许程序在运行时动态地检查、修改或调用其自身的结构或行为。它打破了传统静态代码的编译时绑定限制，使程序能够获取类、方法、属性等元信息，并动态操作它们。</p>
<h2 id="加载方法"><a href="#加载方法" class="headerlink" title="加载方法"></a>加载方法</h2><ol>
<li><p>加载类，获取 <code>Class</code> 对象</p>
<ul>
<li><code>Class c = 类名.class</code> </li>
<li><code>Class.forName(全名)</code>  </li>
<li><code>Class c = 对象.getClass()</code> </li>
<li><code>getName() 全名带包名 getSimpleName() 简名</code></li>
<li><code>getMethod() getConstructor() getField()</code> </li>
</ul>
</li>
<li><p>获取类的构造器 <code>Constructor</code> 对象，主调是 <code>Class 对象</code></p>
<ul>
<li><code>getConstructors</code> 只有 public <strong>返回数组</strong></li>
<li><code>getDeclaredConstructors</code> 存在就能拿到</li>
<li><code>getConstructor(形参的类型对象)</code> 只有public 拿一个</li>
<li><code>getDeclaredConstructor(形参的类型对象)</code> 存在就能拿到 拿1个</li>
</ul>
<ul>
<li>下面的主调是构造器对象</li>
<li><code>getParameterCount</code>几个参数</li>
<li><code>newInstance(...参数)</code> 返回<code>object</code> 强转为对象，如果私有构造器会报错</li>
<li><code>setAccessible(true)</code> 暴力反射，禁止检查访问权限</li>
</ul>
</li>
<li><p>获取类的成员变量 <code>Field</code> 对象</p>
<ul>
<li><code>getFields</code> <code>getDeclaredFields</code> </li>
<li><code>getField(name)</code> <code>getDeclaredField(name)</code></li>
<li>下面主调是<code>Field</code>对象</li>
<li><code>set(对象, 值)</code> <code>get(对象)</code> 赋值 取值</li>
<li><code>setAccessible</code> 暴力反射</li>
</ul>
</li>
<li><p>获取类的成员方法 <code>Method</code> 对象</p>
<ul>
<li><code>getMethods</code> <code>getDeclaredMethods</code></li>
<li><code>getMethod(name, String.class, int.class) </code>返回值</li>
<li>下面主调是<code>method</code></li>
<li><code>getName getParameterConut getReturnType</code></li>
<li><code>invoke(对象, 参数)</code> 返回object 强转为返回值类型</li>
<li><code>setAccesible</code></li>
</ul>
</li>
</ol>
<h2 id="作用、应用场景"><a href="#作用、应用场景" class="headerlink" title="作用、应用场景"></a>作用、应用场景</h2><ul>
<li>得到类的全部成分</li>
<li>做框架、解耦代码、提高通用性</li>
<li>支持注解处理、AOP</li>
<li>IDE代码分析、断点调试依赖反射</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920001226903.png" alt="image-20240920001226903"></p>
<p>接收任意对象，接到对象，用反射获取class对象，获取全部成员变量，遍历他们，把他们的属性写出到文件中</p>
<p>劣势：</p>
<ul>
<li>破坏封装性+反射代码需更高权限，可能引发安全漏洞（如通过反射调用<code>System.exit</code>）</li>
<li>性能开销大，反射调用涉及动态解析类型和方法，比直接调用慢数倍</li>
<li>代码可读性差，逻辑通常冗长且难以静态分析，增加维护成本。</li>
<li>编译时检查失效：错误（如方法名拼写错误）在运行时才暴露，增加调试难度。</li>
</ul>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>框架的核心技术，一个类有很多方法，需要加载资源，而代理可以代替类执行这些操作。</p>
<p>Spring AOP技术使用了JDK动态代理和CGLIB动态代理两种方式，在不改变原始方法的前提下对功能进行增强。</p>
<h2 id="JDK-动态代理——反射"><a href="#JDK-动态代理——反射" class="headerlink" title="JDK 动态代理——反射"></a>JDK 动态代理——反射</h2><ul>
<li>JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>（兄弟两个拜把子模式），目标对象和代理对象是平等地位的。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920112517946.jpg" alt="image-20240920112517946"></p>
<p>对于一个UserServiceImpl，要生成它的代理对象，为了能创建一个跟UserServiceImpl拥有同名方法的代理Proxy，<mark>这个类必须实现一个接口UserService，并且拥有Impl的全部方法<mark>，然后把Impl传给生成代理的方法。</p>
<p>接口能将原来的实现对象的方 法抽象化（或者部分抽象） 方便代理进行重写，代理重写完具体的执行逻辑，返回的还是这个接口的实现对象，相当于是把原来的实现对象包装了一下，完美地把对象的职责转移到了代理身上，业务对象。减少代码冗余和多余的资源调用</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023232822938.png" alt="image-20241023232822938"></p>
<h2 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h2><p>通过<strong>继承被代理的目标类</strong>（认干爹模式）实现代理，所以不需要目标类实现接口。</p>
<p><strong>CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，并在子类中采用方法拦截的技术拦截父类所有的方法调用，进而织入横切逻辑，</strong> 目标对象是代理对象的父类。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib-nodeps<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023232711967.png" alt="image-20241023232711967"></p>
<h1 id="Hutool-Usage"><a href="#Hutool-Usage" class="headerlink" title="Hutool Usage"></a>Hutool Usage</h1><h2 id="BeanUtil"><a href="#BeanUtil" class="headerlink" title="BeanUtil"></a>BeanUtil</h2><h3 id="bean和Map转换"><a href="#bean和Map转换" class="headerlink" title="bean和Map转换"></a>bean和Map转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt;BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                 CopyOptions.create().setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));</span><br><span class="line"></span><br><span class="line">BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(),<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="JSONUtil"><a href="#JSONUtil" class="headerlink" title="JSONUtil"></a>JSONUtil</h2><h3 id="JSON和对象互转"><a href="#JSON和对象互转" class="headerlink" title="JSON和对象互转"></a>JSON和对象互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line"></span><br><span class="line">shop = JSONUtil.toBean(jsonStr,Shop.class);</span><br></pre></td></tr></table></figure>

<h3 id="JSON和数组互转"><a href="#JSON和数组互转" class="headerlink" title="JSON和数组互转"></a>JSON和数组互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonArrayStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(list);</span><br><span class="line"></span><br><span class="line"><span class="type">JSONArray</span> <span class="variable">jsonArray</span> <span class="operator">=</span> JSONUtil.parseArray(jsonArrayStr);</span><br><span class="line">shopTypeList = JSONUtil.toList(jsonArray, ShopType.class);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/01/spring-boot-starter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/01/spring-boot-starter/" class="post-title-link" itemprop="url">自定义 starter</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-01T00:00:00+08:00">2024-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 13:06:00" itemprop="dateModified" datetime="2025-04-27T13:06:00+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><mark>在 Spring Boot 生态中，“Starter” 本质上就是一组依赖的“捆绑包”，它的目标是让使用方 <strong>一行依赖</strong> 就把启动一个完整的 Spring Boot 应用所需的所有东西都拉过来。</mark> </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/10/01/spring-boot-starter/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/default/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/9/">9</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
