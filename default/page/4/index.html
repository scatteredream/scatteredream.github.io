<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/4/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/02/MySQL%20%E8%BF%9B%E9%98%B6%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/02/MySQL%20%E8%BF%9B%E9%98%B6%E7%AF%87/" class="post-title-link" itemprop="url">MySQL 进阶篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-02 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-02T00:00:00+08:00">2024-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:28:16" itemprop="dateModified" datetime="2025-05-05T11:28:16+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>度数：一个节点上面最大的指针数</p>
<p>度数为5，最多5个指针，4个key</p>
<p>当一个节点上面key数超过4，中间节点向上分裂，其余两段分成两个节点，连到上面</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008185901845-1728392950452-1.png" alt="image-20241008185901845"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008185828031-1728392950452-2.png" alt="image-20241008185828031"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008185947095-1728392950452-4.png" alt="image-20241008185947095"></p>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>只有叶子节点存储数据。非叶子节点只有索引的作用</p>
<p>中间节点向上分裂，并且中间节点保留在叶子节点，其余两段分成两个节点连到上面，节点与节点之间通过链表进行连接</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191613613-1728392950452-3.png" alt="image-20241008191613613"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191730054-1728392950453-5.png" alt="image-20241008191730054"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191755751-1728392950453-7.png" alt="image-20241008191755751"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191802276-1728392950454-9.png" alt="image-20241008191802276"></p>
<p>两个索引中间的指针指向的节点位于这两个索引之间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008192952009-1728392950453-6.png" alt="image-20241008192952009"></p>
<p>MySQL优化B+Tree<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008193116742-1728392950453-8.png" alt="image-20241008193116742"></p>
<p>段-区-页-行</p>
<h4 id="B-Tree-vs-B-Tree"><a href="#B-Tree-vs-B-Tree" class="headerlink" title="B+Tree vs. B-Tree"></a>B+Tree vs. B-Tree</h4><ul>
<li>都比二叉树层级更少，搜索效率高</li>
<li>B+树因为只有叶子节点能够存储数据，所以非叶子节点能够储存的key和指针数量更多，key和指针数量增多，指向的节点数目也会更多，相同数据量的情况下，需要的层数就比较少，节点数目少了，磁盘IO减少</li>
<li>B树 因为一个节点中存储的指针数目少，所以一个节点只能指向很少的一个节点，相同数据量下需要更多的节点储存指针，层级较深</li>
<li>B+树搜索效率很稳定（数据全在叶子节点上）相比Hash索引，支持了范围匹配和排序操作</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>聚集索引</strong>（key是主键or唯一键or自动隐式生成的rowid）通常键的值以升序排列 底部存储一整行的数据（对应的键值）</p>
<p><strong>二级索引</strong> 通常键的值以字典序排列 底部存储行号（聚集索引的键值 也就是主键值）</p>
<p>select * from tb_user where name = ‘Arm’;</p>
<p>查询时先根据<strong>二级索引</strong>找到对应的行的索引key（主键/唯一键/rowid），然后再根据聚集索引拿到行数据（回<strong>表查询</strong>）</p>
<p>主键查询不需要回表.</p>
<p>InnoDB主键索引的B+树高度：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241011162420695.png" alt="image-20241011162420695"></p>
<p>根据一页数据的大小能够得出一页中能储存几个指针，树高度为2，指向1171个节点，1171个节点一共有1171*16行数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241011162503825.png" alt="image-20241011162503825"></p>
<p>create index on</p>
<p>show index from</p>
<p>drop index on</p>
<h3 id="SQL优化-性能指标"><a href="#SQL优化-性能指标" class="headerlink" title="SQL优化 性能指标"></a>SQL优化 性能指标</h3><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>可以设置 <code>long_query_time</code> 参数，定义什么算作“慢查询”。</p>
<p>输出到文件或者表中</p>
<h4 id="profiles"><a href="#profiles" class="headerlink" title="profiles"></a>profiles</h4><p>通过启用 <code>PROFILE</code>，可以获取查询的执行时间和资源消耗，包括 CPU 使用、锁等待、IO 等信息。</p>
<h4 id="explain-语句-执行计划"><a href="#explain-语句-执行计划" class="headerlink" title="explain +语句 执行计划"></a>explain +语句 执行计划</h4><ul>
<li>const：主键或者唯一索引查询</li>
<li>ref：非唯一索引查询</li>
<li>index，all 性能差</li>
</ul>
<h3 id="索引使用规则"><a href="#索引使用规则" class="headerlink" title="索引使用规则"></a>索引使用规则</h3><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ol>
<li><strong>联合索引</strong>：跳过某个，后边的全部失效，使用&gt;=否则后边的失效</li>
<li><strong>函数</strong>：不要对索引的字段用字符串，否则失效</li>
<li><strong>字符串要括起来</strong>：否则失效</li>
<li><strong>模糊</strong>：前面不能模糊，否则失效</li>
<li><strong>OR</strong>：其中一个没索引，剩下的都失效</li>
<li><strong>数据库自行判断：</strong>如果走全表查询比走索引还快，优化器会直接走全表索引</li>
</ol>
<h4 id="覆盖查询（联合索引）"><a href="#覆盖查询（联合索引）" class="headerlink" title="覆盖查询（联合索引）"></a>覆盖查询（联合索引）</h4><p>覆盖查询，联合索引查到了对应的键，也能查到对应的主键值，只查这几列不需要回表，如果多查其他的列就需要到聚集索引处回表查询，性能较慢</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>搜索文本时对一些长字符数据没有必要把他们全部都创建索引，而只是截取一部分</p>
<p>算出他们的选择性数据，方法：对email截取不同的长度，去重count再除以总数count</p>
<p>前缀索引，查询字符串先截取前缀，根据前缀进行辅助查询，查到主键id就回表查询拿到整行数据，拿到整行数据以后再进行核实，看字段后半部分是否匹配。一定需要回表查询</p>
<h4 id="单列or联合索引"><a href="#单列or联合索引" class="headerlink" title="单列or联合索引"></a>单列or联合索引</h4><p>or 其中一个没有索引，肯定全都不走索引</p>
<p>都有索引，但是全是单列查询，则只会选择其中一个效率最高进行查询</p>
<p>所以多条件的查询用联合索引，减少回表</p>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ul>
<li>什么样的表要建立索引：数据量超过百万，且查询很频繁</li>
<li>哪些字段建立索引：where group by order by  并且尽量是唯一的，区分度要高</li>
<li>尽量使用联合索引，联合索引很多时候能够覆盖索引，避免回表查询</li>
<li>控制索引数量</li>
<li>如果索引列不能存null，要用非空约束字段</li>
</ul>
<h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="SQL-优化-插入"><a href="#SQL-优化-插入" class="headerlink" title="SQL 优化 - 插入"></a>SQL 优化 - 插入</h3><ol>
<li>一条insert插入多条（insert）<ol>
<li>手动控制事务（事务较为耗费资源）</li>
<li>主键顺序插入</li>
</ol>
</li>
<li>load</li>
</ol>
<h3 id="SQL-优化-主键"><a href="#SQL-优化-主键" class="headerlink" title="SQL 优化 - 主键"></a>SQL 优化 - 主键</h3><ol>
<li>主键顺序插入</li>
<li>主键自增</li>
<li>主键长度尽量小一些，不要用uuid或者身份证号</li>
<li>避免在业务操作时修改主键</li>
</ol>
<h3 id="SQL-优化-order-by"><a href="#SQL-优化-order-by" class="headerlink" title="SQL 优化 - order by"></a>SQL 优化 - order by</h3><ol>
<li>多个条件，使用联合索引，最左前缀</li>
<li>一升一降，需要额外创建独立的索引</li>
<li>覆盖查询，不然仍回表</li>
<li>增大sort_buffer_size(256k default)（不可避免使用filesort时，大数据量）</li>
</ol>
<h3 id="SQL-优化-group-by"><a href="#SQL-优化-group-by" class="headerlink" title="SQL 优化 - group by"></a>SQL 优化 - group by</h3><ol>
<li>多个条件，使用联合索引，最左前缀，需要都出现</li>
<li>肯定是覆盖查询，不然报错</li>
</ol>
<h3 id="SQL-优化-limit"><a href="#SQL-优化-limit" class="headerlink" title="SQL 优化 - limit"></a>SQL 优化 - limit</h3><ol>
<li>覆盖索引加子查询，先覆盖查询主键，根据返回的数据进行select *  </li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241015190857506.png" alt="image-20241015190857506"></p>
<p>不支持in后加limit，就可以联合两张表查询，只返回满足id相同条件的数据</p>
<ol>
<li><strong>延迟关联 (INNER JOIN)</strong>: 使用 <code>INNER JOIN</code> 将分页操作转移到主键索引上，减少回表次数。相比子查询，延迟关联的性能更优，适合大数据量的分页查询。</li>
<li><strong>覆盖索引</strong>: 通过索引直接获取所需字段，避免回表操作，减少 IO 开销，适合查询特定字段的场景。但当结果集较大时，MySQL 可能会选择全表扫描。</li>
</ol>
<h3 id="SQL-优化-count-优化"><a href="#SQL-优化-count-优化" class="headerlink" title="SQL 优化 - count 优化"></a>SQL 优化 - count 优化</h3><ul>
<li><p>MyISAM：可以直接读取</p>
</li>
<li><p>InnoDB：只能逐行读取，只能借助Redis等</p>
</li>
</ul>
<ul>
<li><p>count(字段)会判断是否为非空，如果没有非空约束，会把每一行的字段值都取出来，服务器判断是否为null，不为null计数累加。如果有非空约束，不用判断null直接累加。如果是主键，直接累加</p>
</li>
<li><p>count(1) count(*) 都是遍历整张表但是不取值，按照行进行累加</p>
</li>
</ul>
<h3 id="SQL-优化-update-优化"><a href="#SQL-优化-update-优化" class="headerlink" title="SQL 优化 - update 优化"></a>SQL 优化 - update 优化</h3><p>update利用了索引，行锁</p>
<p>如果没有利用索引，就要加表锁，因为行锁是根据索引加的，而且索引不能失效</p>
<h2 id="视图、存储过程、触发器"><a href="#视图、存储过程、触发器" class="headerlink" title="视图、存储过程、触发器"></a>视图、存储过程、触发器</h2><p>视图就是给子查询起了个名字，然后作为对象存储到数据库中</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>整个数据库的锁，用于全库备份</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>释放：事务提交</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>特点：手动开关</p>
<h5 id="S-共享读锁"><a href="#S-共享读锁" class="headerlink" title="S 共享读锁"></a>S 共享读锁</h5><p>​    所有事务都能读，但都不能写</p>
<h5 id="X-独占写锁"><a href="#X-独占写锁" class="headerlink" title="X 独占写锁"></a>X 独占写锁</h5><p>​    只有当前事务能读写，其他事务都不能读写 </p>
<h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>特点：自动</p>
<p>执行DML, DQL语句会自动加共享SHARED READ/WRITE锁，</p>
<p>执行DDL语句会自动加EXCLUSIVE锁，与上述的锁不兼容。</p>
<p><strong>锁的兼容性</strong>指的是不同类型的锁在同一数据对象（如表或行）上是否可以同时存在的特性，即两个或多个事务能否同时持有某种锁类型，而不会发生冲突或阻塞。</p>
<p>一个事务进行读操作，自动给表加上了共享读锁，另一个事务要改变表结构，此时这个事务想加上独占写的元数据锁，但是因为互相不兼容，所以只能阻塞等待直到另一个事务提交</p>
<h4 id="意向锁-解决行锁表锁冲突"><a href="#意向锁-解决行锁表锁冲突" class="headerlink" title="意向锁 解决行锁表锁冲突"></a>意向锁 解决行锁表锁冲突</h4><p>某个事务DML加行锁，另一个事务来加表锁的时候，要逐行扫描是否有行锁才能加上，性能较低。</p>
<p>因此引入了意向锁，DML加行锁同时对表加了意向写锁(IX)，另一个事务想加表锁，但是IX和常规的表锁不兼容，所以会阻塞等待。</p>
<p><strong>Intention Lock</strong></p>
<h5 id="IX"><a href="#IX" class="headerlink" title="IX"></a><u>IX</u></h5><ul>
<li><code>insert</code>、<code>update</code>、<code>delete </code>(DML自动添加)</li>
<li><code>select...for update</code> (表示查询加行级排他锁)</li>
</ul>
<h5 id="IS"><a href="#IS" class="headerlink" title="IS"></a><u>IS</u></h5><ul>
<li><code>select ... lock in share mode</code>(表示查询加行级共享锁)</li>
</ul>
<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>IX：加行锁的同时会自动加IX</p>
<p>IS：DQL后边加<code>Lock in share mode</code>表示手动加了IS</p>
<h4 id="表锁兼容性矩阵"><a href="#表锁兼容性矩阵" class="headerlink" title="表锁兼容性矩阵"></a>表锁兼容性矩阵</h4><table>
<thead>
<tr>
<th></th>
<th>共享锁 (S)</th>
<th>独占锁 (X)</th>
<th>意向共享锁 (IS)</th>
<th>意向独占锁 (IX)</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>O</td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>IS</td>
<td>O</td>
<td>X</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>IX</td>
<td>X</td>
<td>X</td>
<td>O</td>
<td>O</td>
</tr>
</tbody></table>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>InnoDB存储引擎，并发度高</p>
<p>行级锁是针对索引对行加的锁，事务提交后会释放</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017194645333.png" alt="image-20241017194645333"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017194802298.png" alt="image-20241017194802298"></p>
<p>DML自动加行级排他锁，自动加表级意向排他锁(IX)</p>
<p>DQL+<code>for update</code> 加行级排他锁，自动加IX</p>
<p>DQL+<code>lock in share mode</code> 加共享锁，自动加IS</p>
<p>IX 和 IS 就是行锁在表级锁中的一种呈现形式</p>
<ul>
<li><p>默认可重复读(RR)，使用 Next-Key 锁 进行搜索和索引扫描，防止幻读。</p>
</li>
<li><p>针对唯一索引进行检索，对已存在的记录等值匹配，自动优化为行锁（详见下文）</p>
<ul>
<li><p>当你执行以下查询时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span> <span class="string">&#x27;example@example.com&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>数据库会使用唯一索引快速找到这条记录。</li>
<li>然后，它会在找到的记录上加上行锁，确保其他事务无法修改或删除该行，直到当前事务提交。</li>
<li>由于只锁定了这一行，而不是整个表，其他事务仍然可以并发读取或修改表中的其他记录。</li>
</ul>
</li>
</ul>
</li>
<li><p><u>行锁是针对索引</u>加的，<strong>如果定位数据时不使用索引，</strong>如果此时加锁(除了普通的select查询都会加)那么会对表中所有记录都加上锁，此时<strong>升级为表锁</strong> </p>
</li>
</ul>
<p>由于锁的兼容性，行锁会影响另一个事务的DML以及加后缀的DQL。同时也会影响普通的DQL，除非使用RU隔离级别，否则另一个事务的普通DQL也会阻塞</p>
<h4 id="间隙、临键锁"><a href="#间隙、临键锁" class="headerlink" title="间隙、临键锁"></a>间隙、临键锁</h4><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁（Gap Lock）</strong>：锁定一个记录之前的范围，不包括记录本身。防止其他事务<strong>插入</strong>间隙，间隙锁之间可以共存</li>
<li><strong>临键锁（Next-Key Lock）</strong>：Record Lock + Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p>在 InnoDB 默认的隔离级别 <strong>REPEATABLE-READ</strong> 下，行锁默认使用的是 <strong>Next-Key Lock</strong>。但是，如果操作的索引是唯一索引或主键的等值查询，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock 或 Gap Lock。</p>
<p><strong>省流</strong>：</p>
<ul>
<li><p>查找过程中访问到的才会被加锁，遍历停止时访问的那个不符合条件的行也要加锁，默认加NextKeyLock。</p>
</li>
<li><p><strong>唯一索引的等值查询</strong>，存在加RecordLock，不存在加右边界的GapLock</p>
</li>
<li><p><strong>唯一索引的范围查询</strong> 或者 <strong>普通索引的查询</strong> 这些查询包含向右遍历，如果出现<strong>唯一索引的等值查询</strong>，加对应的RecordLock，其他被遍历到的都是Next-keyLock，出现正无穷加正无穷的Next-KeyLock</p>
</li>
<li><p>特别地，对于 <strong>唯一索引的范围查询</strong> 或者 <strong>普通索引等值查询</strong> ，遍历停止时访问的那个不符合条件的行，这一行的NextKeyLock会退化为GapLock</p>
</li>
</ul>
<h3 id="行级锁-加锁范围验证"><a href="#行级锁-加锁范围验证" class="headerlink" title="行级锁 加锁范围验证"></a>行级锁 加锁范围验证</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017215201503.png" alt="image-20241017215201503"></p>
<p>X 对应 默认的 Next-key Lock</p>
<p>X, REC_NOT_GAP 对应 Record Lock</p>
<p>X, GAP 对应 Gap Lock </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_t_a <span class="keyword">on</span> t(a);</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> INDEX_NAME, LOCK_MODE,LOCK_STATUS,LOCK_DATA <span class="keyword">from</span> performance_schema.data_locks;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;  <span class="comment">-- 主键等值查询 存在</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">9</span> <span class="keyword">for</span> <span class="keyword">update</span>;   <span class="comment">-- 主键等值查询 不存在</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 主键范围查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;   <span class="comment">-- 普通索引等值查询</span></span><br></pre></td></tr></table></figure>



<h4 id="主键等值查询-——-数据存在"><a href="#主键等值查询-——-数据存在" class="headerlink" title="主键等值查询 —— 数据存在"></a>主键等值查询 —— 数据存在</h4><p>查询 id = 10 REC_NOT_GAP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017223439818.png" alt="image-20241017223439818"></p>
<p>对主键等值加锁，且值存在，临键锁退化为Record，锁住10这条记录</p>
<h4 id="主键等值查询-——-数据不存在"><a href="#主键等值查询-——-数据不存在" class="headerlink" title="主键等值查询 —— 数据不存在"></a>主键等值查询 —— 数据不存在</h4><p>查询 id = 9 GAP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017223354241.png" alt="image-20241017223354241"></p>
<p>对主键等值加锁，值不存在，临键锁退化为Gap，锁住了10之前的间隙</p>
<h4 id="主键范围查询"><a href="#主键范围查询" class="headerlink" title="主键范围查询"></a>主键范围查询</h4><ol>
<li>查找id&gt;=10 有10,11,12,15,20满足条件</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017224916640.png" alt="image-20241017224916640"></p>
<p>10是等值查询，会退化成Record，其他都是NextKey，还有一个正无穷的NextKey</p>
<ol start="2">
<li>查找id在[10,15) 之间 </li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017230538715.png" alt="image-20241017230538715"></p>
<p>10是等值查询，退化Record，其他都是临键，查到15的时候不符合, 15退化为Gap</p>
<h4 id="普通索引等值查询"><a href="#普通索引等值查询" class="headerlink" title="普通索引等值查询"></a>普通索引等值查询</h4><p>查询 a = 10 一共三条符合的记录 id = 10,11,12 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017222539070.png" alt="image-20241017222539070"></p>
<ul>
<li>对于idx_t_a这个索引，加了四把锁，其中符合条件的3行都是nextKey(也就是默认的行锁)，检索到第一个不符合条件的行 （15,15）nextKey退化成GAP间隙</li>
<li>对于主键，所有的nextKey都退化成Record Lock</li>
</ul>
<p>不存在：查询 a = 9 只有Gap</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017235509444.png" alt="image-20241017235509444"></p>
<h4 id="普通索引范围查询"><a href="#普通索引范围查询" class="headerlink" title="普通索引范围查询"></a>普通索引范围查询</h4><p>查询 a &gt;= 10</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018000157308.png" alt="image-20241018000157308"></p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Mindmap.png" alt="MindMap"></p>
<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>在事务开始前和结束后，数据库的状态必须一致。InnoDB 在事务提交时会检查所有约束（如外键、唯一性约束），确保数据的完整性和<strong>一致性</strong>。</p>
<h4 id="RedoLog-持久性"><a href="#RedoLog-持久性" class="headerlink" title="RedoLog - 持久性"></a>RedoLog - 持久性</h4><ul>
<li>产生：更新数据之后，事务提交之时</li>
<li>销毁：数据成功刷新到磁盘之时</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029174344508-1730195209915-1.png" alt="image-20241029174344508"></p>
<ul>
<li><p>BufferPool中的脏页会定期刷新到磁盘中，如果写入磁盘失败，则会导致事务提交了，磁盘中的数据却没改变。</p>
</li>
<li><p>BufferPool首先把当次事务的<u>修改存入</u>RedoLogBuffer，RedoLogBuffer会刷新到磁盘中的RedoLogFile，然后过一段时间会将BP中的脏页刷新到磁盘中，如果写入失败，可以通过磁盘中的RedoLogFile恢复数据。</p>
</li>
</ul>
<p><strong>为什么不直接刷新到磁盘中</strong>？因为磁盘随机IO太慢，而日志文件是顺序IO，快得多（Write-Ahead Logging）先写日志，再刷新，并且WAL能够防止还没有刷盘就崩溃的情况。</p>
<p>重做日志记录的是数据页的具体变化<u>（物理修改）</u>，而不是 SQL 语句或逻辑操作，例如页的写入、删除或更新。这种方式确保了在崩溃恢复时，能够准确地重放这些操作，从而恢复数据到一致的状态。物理修改在执行时通常更高效。</p>
<p><mark>物理日志<mark></p>
<h4 id="UndoLog-原子性"><a href="#UndoLog-原子性" class="headerlink" title="UndoLog - 原子性"></a>UndoLog - 原子性</h4><ul>
<li>产生：事务执行具体SQL语句时</li>
<li>销毁：事务未提交时可以用于回滚，事务提交以后也不会立即删除，<strong>用于MVCC</strong> </li>
</ul>
<ul>
<li><mark>逻辑日志<mark>，是具体的SQL语句（反向）</li>
<li>事务Rollback时会从UndoLog读取逻辑语句并执行</li>
</ul>
<ul>
<li>存储在 表空间的 rollback segment 段中</li>
</ul>
<p>表空间TableSpaces-&gt;段Segment-&gt;区Extent-&gt;页Page-&gt;行Row</p>
<h3 id="MVCC-隔离性"><a href="#MVCC-隔离性" class="headerlink" title="MVCC - 隔离性"></a>MVCC - 隔离性</h3><p><strong>M</strong>ulti<strong>V</strong>ersion <strong>C</strong>oncurrency <strong>C</strong>ontrol</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取数据的当前版本（最新版本），读取时要加锁</p>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>读取的是记录数据的可见版本，不加锁</p>
<ul>
<li>Read Committed：每次select都生成一个快照读</li>
<li>Repeatable Read：开启事务以后的首个select才是快照读</li>
<li>Serializable：快照读退化为当前读</li>
</ul>
<p>MySQL用MVCC实现了一致性非锁定读，读操作只读该事务开始前的数据库的快照，也就是快照读（与当前读相对）</p>
<p>事务隔离级别越低，对应的锁就越少，MySQL用MVCC减少了高并发情况下锁的数量，也就是说默认的RR对性能没有影响</p>
<h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><p>TRX_ID 最后一次事务ID</p>
<p>ROLL_PTR 指向undolog</p>
<p>ROW_ID 如果没有主键会对每一行生成rowID</p>
<h4 id="利用-UndoLog"><a href="#利用-UndoLog" class="headerlink" title="利用 UndoLog"></a>利用 UndoLog</h4><h5 id="生成UndoLog"><a href="#生成UndoLog" class="headerlink" title="生成UndoLog"></a>生成UndoLog</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018150130329.png" alt="image-20241018150130329"></p>
<h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>事务对记录进行修改，会在Undolog生成对应的undo备份，事务对同一条记录进行修改，会在Undolog中生成一条版本链，链表尾部是最早的旧版本，链表头部是最新的旧版本，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018151050435.png" alt="image-20241018151050435"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018151107149.png" alt="image-20241018151107149"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018151128340.png" alt="image-20241018151128340"></p>
<h4 id="ReadView-amp-数据可见性算法"><a href="#ReadView-amp-数据可见性算法" class="headerlink" title="ReadView &amp; 数据可见性算法"></a>ReadView &amp; 数据可见性算法</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018161558601.png" alt="image-20241018161558601"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/trans_visible-ekj9bMvL.png" alt="trans_visible"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018205730125.png" alt="image-20241018205730125"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018161738996.png" alt="image-20241018161738996"></p>
<h4 id="RC-amp-RR-解决并发事务引发的问题"><a href="#RC-amp-RR-解决并发事务引发的问题" class="headerlink" title="RC &amp; RR 解决并发事务引发的问题"></a>RC &amp; RR 解决并发事务引发的问题</h4><p><mark><u>1. MVCC 通过 ReadView 的数据可见性算法 只会读取其他事务已提交的信息，完全避免了脏读</u><mark> </p>
<p><strong>RC</strong>：避免脏读（读已提交）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018155530221.png" alt="image-20241018155530221"></p>
<p><code>mIDs</code>包含活跃事务，<code>maxID</code>当前最大事务ID+1，<code>minID</code>最小活跃事务ID，<code>trxID</code>当前所浏览版本所属的事务ID</p>
<ol>
<li><code>trxID</code> =<code> create_trxID</code>  自己改的的肯定能读</li>
<li><code>trxID </code>&gt;= <code>maxID</code> 说明事务在快照创建之后才修改的，数据没有参考价值，不能读。</li>
<li><code>trxID </code>&lt;<code>maxID</code>说明事务在快照创建之前修改的，有参考价值，不在活跃列表中的就是已提交了</li>
<li><code>trxID</code> &lt; <code>minID</code>  肯定不在活跃列表，读<strong>已提交</strong>。</li>
<li><code>trxID</code>∈[<code>minID</code>,<code>maxID</code>) 说明事务在快照创建之前修改的，但不知道提交了没有。<ul>
<li>在<code>mIDs</code>中，说明还活跃着没有提交，不能读    </li>
<li>不在<code>mIDs</code>中，说明<strong>已提交</strong></li>
</ul>
</li>
<li><code>mIDs</code>为空，可读</li>
</ol>
<p><code>Read View</code>在SQL执行结束后自动销毁，下次生成新的</p>
<p><mark><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html#mvcc-%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%97%AE%E9%A2%98">2. MVCC 通过设置同一事务复用 ReadView 完全避免了不可重复读问题 </a><mark> </p>
<p><strong>RR</strong>：注意——RR是可以读已提交的，RR是用来解决不可重复读的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018155805136.png" alt="image-20241018155805136"></p>
<p>同一个事务的<code>Read View</code>相同，后开启的事务修改肯定不会去读，只会按照同一个<code>Read View</code>读版本链</p>
<ul>
<li>事务5第一次读，事务3修改了但还没提交，最后选择事务2的版本，生成的<code>Read View</code>不会马上销毁</li>
<li>事务5第二次读，复用之前的<code>Read View</code>，最重要的是记录了<strong>活跃事务列表</strong> <code>mIds</code>，即使事务3提交了，</li>
</ul>
<p><u><mark>3. MVCC 如何解决幻读问题？<mark></u> </p>
<ol>
<li>执行普通select语句，MVCC会使用快照读。RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。</li>
<li>对于当前读，通过设置Next-Key Lock，将间隙也锁住，阻塞其他事务插入数据，防止插入，幻读也就不会出现。</li>
</ol>
<p>没法防止的幻读：</p>
<p>事务A第一次查询id=5没查到，事务B此时插入了id=5并提交了，事务A为了维持可重复读第二次依然查不到5，但是此时事务A插入5会失败，update id = 5会成功，试图select for update也会成功，好像出现了幻觉，只能改变隔离模式为 Serializable </p>
<p>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生，</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/01/java-se/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/01/java-se/" class="post-title-link" itemprop="url">Java SE</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-01T00:00:00+08:00">2024-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:49:32" itemprop="dateModified" datetime="2025-05-05T11:49:32+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向对象、基本语法"><a href="#面向对象、基本语法" class="headerlink" title="面向对象、基本语法"></a>面向对象、基本语法</h1><p>一个java文件内只能有1个public class 且public class名字需与文件名相同</p>
<p>生成类文件的名字=class名，几个类几个名字</p>
<p>运行的时候是按照类运行的，因此一个java文件里不同的类可以有不同的main</p>
<h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><p>在刷算法题时，Java 的常用包可以帮助你解决各种问题。以下是一些常见的包：</p>
<ol>
<li><p><strong>基础包</strong>（默认无需导入，属于 <code>java.lang</code>，直接使用）：</p>
<ul>
<li><code>java.lang</code>：包含基础类如 <code>String</code>, <code>Math</code>, <code>Integer</code>, <code>System</code>，它们是自动导入的，不需要显式导入。</li>
</ul>
</li>
<li><p><strong>集合框架</strong>：</p>
<ul>
<li><code>java.util.*</code>：包括大多数数据结构和集合类，常用于算法题：<ul>
<li><code>ArrayList</code>, <code>LinkedList</code>：动态数组和链表。</li>
<li><code>HashMap</code>, <code>TreeMap</code>, <code>LinkedHashMap</code>：哈希表和有序映射。</li>
<li><code>HashSet</code>, <code>TreeSet</code>：哈希集合和有序集合。</li>
<li><code>PriorityQueue</code>：优先队列（常用于堆排序、最小堆、最大堆）。</li>
<li><code>Stack</code>：栈结构。</li>
<li><code>Deque</code>, <code>ArrayDeque</code>：双端队列。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>并发包</strong>：</p>
<ul>
<li><code>java.util.concurrent.*</code>：多线程工具和并发数据结构。</li>
</ul>
</li>
<li><p><strong>数学计算</strong>：</p>
<ul>
<li><code>java.math.BigInteger</code> 和 <code>java.math.BigDecimal</code>：用于处理大整数和高精度小数。</li>
<li><code>java.util.Random</code>：生成随机数。</li>
</ul>
</li>
<li><p><strong>输入输出</strong>（用于处理大规模输入输出）：</p>
<ul>
<li><code>java.io.*</code>：包括 <code>BufferedReader</code>、<code>InputStreamReader</code> 等，常用于高效输入读取。</li>
<li><code>java.util.Scanner</code>：常用于简单的控制台输入。</li>
</ul>
</li>
<li><p><strong>时间处理</strong>：</p>
<ul>
<li><code>java.time.*</code>：处理日期和时间类（如果题目涉及日期计算）。</li>
</ul>
</li>
</ol>
<h3 id="常用导入："><a href="#常用导入：" class="headerlink" title="常用导入："></a>常用导入：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">// 通用集合框架</span></span><br><span class="line"><span class="keyword">import</span> java.math.*;  <span class="comment">// 高精度数学计算</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;    <span class="comment">// 文件、输入输出</span></span><br></pre></td></tr></table></figure>

<p>这些包涵盖了绝大多数算法题目需要的工具和数据结构。如果你有特定类型的题目或需求，也可以进一步讨论合适的导入包。</p>
<h2 id="基本数据类型-2024-9-9"><a href="#基本数据类型-2024-9-9" class="headerlink" title="基本数据类型 2024.9.9"></a>基本数据类型 2024.9.9</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>char <strong>2</strong> byte</p>
<p>路径 \\ 转义字符</p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>0x hex 、 0 oct    byte short int long </p>
<p>整数全部是int型，数字超出int范围后面要加L <code>long number = 666666666666L  </code></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>4e3 ⇔ 4000 这是一个浮点数 默认为double </p>
<p>float 32  double 64 </p>
<p>浮点数全部是double型，数字如果是float型后边必须要加上f</p>
<p>double类型不能给float类型赋值。 char 型可以兼容整型，也可以看成16位整型</p>
<table>
<thead>
<tr>
<th align="left"><strong>数据类型</strong></th>
<th align="left"><strong>默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">0L</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0.0f</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0.0d</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\u0000’</td>
</tr>
<tr>
<td align="left">String (or any object)</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">false</td>
</tr>
</tbody></table>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><ul>
<li><p>隐式(自动) 基本数据类型中除了boolean其他都兼容</p>
<ul>
<li>byte, short, char -&gt;int-&gt;long-&gt;float-&gt;double</li>
<li>byte+short 在表达式中参与运算自动提升为int 小类型自动转换成大类型</li>
<li></li>
</ul>
</li>
<li><p>强制转换</p>
<ul>
<li><p>小数转换成整数，保留整数部分 <code>double a = 1.2 </code> <code>int b = (int) a</code>  </p>
</li>
<li><p>四舍五入</p>
</li>
</ul>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI;</span><br><span class="line">pi = pi * <span class="number">10000</span> + <span class="number">0.5</span>;</span><br><span class="line">pi = (<span class="type">int</span>)pi;</span><br><span class="line">pi = pi / <span class="number">10000</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">pi_2</span> <span class="operator">=</span> Math.PI;</span><br><span class="line"><span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> Math.round(pi_2 * <span class="number">10000</span>);</span><br><span class="line">pi_2 = i / <span class="number">10000.0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>比较运算符 H <strong>instanceof</strong> Human H是否属于Human类型</li>
</ul>
<ul>
<li><p><strong>位运算符</strong> （整数） &gt;&gt;&gt; </p>
</li>
<li><p><strong>自增自减</strong>  i++ 的值等于i      ++i的值等于i+1</p>
</li>
<li><p><strong>取模</strong> 值只跟被模数有关 </p>
</li>
<li><p><strong>扩展赋值运算符</strong>：包含强制类型转换</p>
</li>
<li><p><strong>逻辑运算符</strong> </p>
<ul>
<li><p>&amp;&amp; 第一个false 不会判断 优先级较高</p>
</li>
<li><p>||  第一个true不会判断剩下的</p>
</li>
<li><p>^ 异或 相同false 不同true</p>
</li>
</ul>
</li>
</ul>
<h2 id="API-from-JDK"><a href="#API-from-JDK" class="headerlink" title="API from JDK"></a>API from JDK</h2><h3 id="Switch语句简化"><a href="#Switch语句简化" class="headerlink" title="Switch语句简化"></a>Switch语句简化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dayName</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> -&gt; <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> -&gt; <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> -&gt; <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span> -&gt; <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span> -&gt; <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span> -&gt; <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span> -&gt; <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid day: &quot;</span> + day);</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(dayName); <span class="comment">// 输出: Wednesday</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JDK12开始引入的写法，可以避免贯穿效应，并能直接在后面执行一个语句或者返回一个值</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;asd&quot;</span> <span class="comment">//常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(字符数组、字节数组)<span class="comment">//一般的堆</span></span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>str.toCharArray()</code>  返回一个字符数组</p>
<p><code>str.charAt(2)</code>   返回str[2]的字符</p>
<p><code>str1.equals(str2)</code> s1与s2是否相同</p>
<p><code>str1.equalsIgnoreCase(str2)</code> s1与s2是否相同 <strong>忽略大小写</strong> </p>
<p><code>str.substring(0,8)</code> 字符串截断</p>
<p><code>str.replace(x,y)</code> 将x替换成y</p>
<p><code>str.contains(&quot;Java&quot;)</code> 是否包含Java</p>
<p><code>str.startsWith(&quot;A&quot;)</code> 是否以A开头</p>
<p><code>str.split(&#39;,&#39;)</code> Split with PERIOD ‘,’</p>
<p><code>int compareToIgnoreCase(String str)</code> 按照字典顺序比较两个字符串，忽略大小写</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>用str = “aaa” 的方式，会把字符串存在<strong>字符常量池</strong>，内容相同只存储一份</p>
</li>
<li><p>用str = new String(“aaa”)的方式，每一次都new一个新对象存在堆中</p>
</li>
<li><p><strong>String是不可变对象</strong>，不可变性（Immutability）的含义 </p>
</li>
<li><p>只要对String进行操作，就要<u>创建新的字符串对象</u>，而非修改原有字符串。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot; World&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>str + &quot; World&quot;</code> 实际上创建了一个新的 <code>String</code> 对象，包含 “Hello World”，而原来的 <code>&quot;Hello&quot;</code> 对象仍然存在于内存中，并没有被修改。<code>str</code> 变量此时指向了这个新的对象。为什么 <code>String</code> 是不可变的？</p>
<ol>
<li><p><strong>安全性（Security）</strong>：不可变的对象可以避免在多个线程之间共享数据时的并发问题。由于 <code>String</code> 的值不会被改变，因此可以安全地在多个地方或多个线程中使用，而不必担心被其他代码修改。</p>
</li>
<li><p><strong>性能优化（String Pool）</strong>：Java 中有一个叫做 <strong>字符串常量池（String Pool）</strong> 的机制，当你创建一个 <code>String</code> 对象时，如果该字符串值已经存在于常量池中，那么不会重新创建对象，而是复用已有的对象。不可变性确保了这个机制的有效性，因为相同的 <code>String</code> 实例永远不会被修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>s1</code> 和 <code>s2</code> 实际上引用了常量池中的同一个 <code>String</code> 对象。</p>
<p><strong>3.  哈希值缓存</strong>：由于 <code>String</code> 对象不可变，它的哈希值只需要计算一次，可以缓存下来以提高哈希表操作的效率（如在 <code>HashMap</code> 中用作键）。如果 <code>String</code> 是可变的，那么它的哈希值也会随之变化，影响哈希表的正确性。 </p>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910180312621.png" alt="image-20240910180312621"></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>大小可变的 <strong>容器</strong>，auto extension </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910193135775.png" alt="image-20240910193135775"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>add 方法可重载 <code>add(Object o);</code> </p>
<p>注意 remove 方法会让整体左移，元素对应的索引会变化，会影响遍历的索引</p>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>)  <span class="comment">//0-9</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>,<span class="number">31</span>)  <span class="comment">// [10,31) 不包含31</span></span><br></pre></td></tr></table></figure>

<h3 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> sc.nextInt();</span><br></pre></td></tr></table></figure>

<h2 id="数组-2024-9-10"><a href="#数组-2024-9-10" class="headerlink" title="数组 2024.9.10"></a>数组 2024.9.10</h2><h3 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] data1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] data2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//简化写法</span></span><br></pre></td></tr></table></figure>

<p>引用数据类型 引用相当于是对象的地址</p>
<h3 id="动态数组（非动态长度）"><a href="#动态数组（非动态长度）" class="headerlink" title="动态数组（非动态长度）"></a>动态数组（非动态长度）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] data1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p><code>double 0.0</code> <code>int 0 </code> <code>boolean false </code> <code>String null</code> (<u>引用数据类型</u>) </p>
<p>new一个对象，就会在堆上创建空间，然后将空间的地址传给栈中的引用</p>
<h3 id="引用数据类型做参数"><a href="#引用数据类型做参数" class="headerlink" title="引用数据类型做参数"></a>引用数据类型做参数</h3><p>引用相当于封装好的指针，只能指向对象，可以通过它对<strong>对象</strong>进行操作，引用数据类型做参数，实际上是一个引用的拷贝，通过它可以操作对象，但是不能通过修改它来让真实的引用指向一个新的对象。修改对象就行了，没事修改人家引用干啥呢！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Personnel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyPerson</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        person = <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">// 修改引用，指向新的对象  不可以</span></span><br><span class="line">        person.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        modifyPerson(p);</span><br><span class="line">        System.out.println(p);  <span class="comment">// 仍然输出 &quot;Bob&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java的参数都是值传递，也就是副本传递。main 中 p的值始终不变， 进入modify方法之后，一开始person也是p的值，但是无法通过更改person的指向 来 更改p的指向</p>
<h3 id="方法的重载："><a href="#方法的重载：" class="headerlink" title="方法的重载："></a><strong>方法的重载</strong>：</h3><p>必须要有不同的<strong>参数列表</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">function</span><span class="params">(String... args)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">function</span><span class="params">(String [] args)</span>;</span><br></pre></td></tr></table></figure>

<p>这两种方法是等价的</p>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><ul>
<li><p>类名大写</p>
</li>
<li><p>不用赋初值</p>
</li>
<li><p>xx.java 中只能有一个public class 且名字必须叫xx 可以有多个class</p>
</li>
<li><p>对象失去引用，将成为垃圾无法被操作</p>
</li>
<li><p>this 用在<strong>方法内</strong> 用于拿到当前的对象 调用方法的时候this会自动接收当前对象的引用(防止对象的成员变量和方法内部的变量名称相同产生冲突)</p>
</li>
</ul>
<h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><p>构造函数，可重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">double</span> score)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建对象的同时完成初始化赋值</li>
<li>不写构造函数会自动生成无参构造</li>
<li>如果定义了有参构造，<strong>不会自动生成</strong>无参构造了</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>合理隐藏，合理暴露，考虑安全性</p>
<p>public(any)&gt;protected(继承类)&gt;friendly(同一package的类)&gt;private(只有当前类才有资格访问)</p>
<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><ul>
<li>变量私有，方法公开（get set 右键快捷生成）</li>
<li>必有公开的无参构造</li>
<li><strong>实体类</strong>负责数据存取，处理数据交给<strong>业务类</strong>来完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperator</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student student;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">StudentOperator</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.student = student;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaBean-vs-POJO"><a href="#JavaBean-vs-POJO" class="headerlink" title="JavaBean vs. POJO"></a>JavaBean vs. POJO</h3><p>JavaBean 和 POJO 的区别主要在于它们的用途和规范化程度：</p>
<ol>
<li><p><strong>JavaBean</strong>：</p>
<ul>
<li><strong>定义</strong>：JavaBean 是一种特殊的 Java 类，通常遵循严格的规范。它主要用于开发可复用的组件，尤其是在 Java EE 应用程序中，JavaBean 被广泛用于数据传输对象（DTO）、表单数据和企业级应用中。</li>
<li><strong>规范</strong>：<ul>
<li>必须有一个<strong>无参构造函数</strong>。</li>
<li>所有的属性（成员变量）必须是<strong>私有的</strong>（<code>private</code>），并通过<strong>getter</strong> 和 <strong>setter</strong> 方法进行访问。</li>
<li>必须实现 <strong>Serializable</strong> 接口（可选，但常见）。</li>
</ul>
</li>
<li><strong>应用场景</strong>：JavaBean 常用于 Java EE（例如 JSP、Servlet）中与视图层交互的数据封装，也可用于一些持久层框架如 Hibernate 和 Spring。</li>
</ul>
</li>
<li><p>**POJO (Plain Old Java Object)**：</p>
<ul>
<li><strong>定义</strong>：POJO 是一个普通的 Java 对象，没有任何特殊的要求或规范。它是最普通的 Java 类，通常只用来封装数据，避免依赖特定的框架或库。</li>
<li><strong>规范</strong>：没有严格的要求，可以有构造函数、任意修饰符的属性，甚至没有 getter 和 setter 方法。</li>
<li><strong>应用场景</strong>：POJO 被广泛用于各种场景中，特别是作为轻量级的数据承载类。它不依赖于任何框架的 API，目的是使代码更加简洁和易于维护。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>JavaBean</strong> 是一种受规范约束的 POJO，适合组件开发和框架集成。</li>
<li><strong>POJO</strong> 是一个没有任何限制或依赖的 Java 类，更加灵活自由。</li>
</ul>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>局部变量：方法内 一般在栈中</p>
<p>成员变量：一般在类的声明中表现</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910144323152.png" alt="image-20240910144323152"></p>
<p>out</p>
<h2 id="OOP-Advanced-2024-9-11"><a href="#OOP-Advanced-2024-9-11" class="headerlink" title="OOP Advanced 2024.9.11"></a>OOP Advanced 2024.9.11</h2><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><h4 id="修饰成员变量：类变量"><a href="#修饰成员变量：类变量" class="headerlink" title="修饰成员变量：类变量"></a>修饰成员变量：类变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> String name;<span class="comment">//所有类共享 （类变量）</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接通过类名访问：<code>Student.name = &quot;袁华&quot;</code> 只有一份 </p>
<ul>
<li>应用场景：某个数据只要一份（记住自己创建了多少个用户对象了）希望能够被共享、修改</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911105822932.png" alt="image-20240911105822932"></p>
<h4 id="类方法：属于类的方法"><a href="#类方法：属于类的方法" class="headerlink" title="类方法：属于类的方法"></a>类方法：属于类的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHelloworld</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line">Student.printHelloworld();</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911110754007.png" alt="image-20240911110754007"></p>
<ul>
<li>应用场景：工具类 提高代码复 用率</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911111331657.png" alt="image-20240911111331657"></p>
<h4 id="其他注意"><a href="#其他注意" class="headerlink" title="其他注意"></a>其他注意</h4><ul>
<li>static 方法 可以直接访问 static 成员变量 ，<u>不能访</u>问实例变量，不能有<strong>this</strong> </li>
<li>实例 方法 可以直接访问 static 成员变量和实例变量、方法，可以有<strong>this</strong> </li>
</ul>
<h5 id="应用：静态代码块-实例代码块"><a href="#应用：静态代码块-实例代码块" class="headerlink" title="应用：静态代码块 实例代码块"></a>应用：<strong>静态代码块 实例代码块</strong></h5><p>静态代码块：<mark>类加载的同时<mark>会加载静态代码块但只有一次，适用于静态变量的初始化</p>
<p>实例代码块：<mark>创建对象的时候<mark>执行，并在构造器<mark>之前<mark>执行，适用于非静态变量的初始化</p>
<h4 id="设计模式：单例"><a href="#设计模式：单例" class="headerlink" title="设计模式：单例"></a>设计模式：单例</h4><ul>
<li><p>一个类有且只有一个对象，创建对象之前就自己有了11:112311</p>
</li>
<li><p>私有构造器</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//自有，记住一个对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;&#125;<span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911114322070.png" alt="image-20240911114322070"> 上图为拿到一个<strong>对象</strong> <strong>以后</strong>才开始创建对象</p>
<h3 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h3><p>关键字：extends<code>public class B extends A</code> B能继承A的非私有成员和方法</p>
<h4 id="子类的访问"><a href="#子类的访问" class="headerlink" title="子类的访问"></a>子类的访问</h4><ul>
<li>子类不能直接访问父类的私有成员，但是他们<strong>仍然存在于子类对象中</strong>，父类的私有成员子类用get set方法可以完成访问或修改 /  (或者用父类的构造器)</li>
<li>父亲的私人物品儿子不能直接动，但是儿子能通过父亲认可的方法接触</li>
<li>子类方法中同名变量\方法的处理：优先调用方法中声明 的变量，<strong>this</strong>可以调用子类在方法外声明的，<strong>super</strong>可以调用父类声明的</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911115852654.png" alt="image-20240911115852654"></p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>本类</th>
<th>同一包的其他类(包括同一包的子类)</th>
<th>其他包的子类</th>
<th>其他包的其他类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>OK</td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>缺省</td>
<td>OK</td>
<td>OK</td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>protected</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>public</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
</tbody></table>
<ul>
<li><p>注意这些都是在对应的类 <strong>内部</strong> 才起作用 </p>
</li>
<li><p>java 单继承 ， 多层继承 ， 不支持多继承</p>
</li>
<li><p>所有类默认继承自<code>Object</code>类</p>
</li>
</ul>
<h4 id="子类的方法重写"><a href="#子类的方法重写" class="headerlink" title="子类的方法重写"></a>子类的方法重写</h4><ul>
<li><p>子类将父类的方法保持参数列表相同进行重写</p>
</li>
<li><p>用<code>@Override</code> 注解</p>
</li>
<li><p>子类的访问权限必须大于父类</p>
</li>
<li><p><code>private</code> 和 <code>static</code> 不能重写 </p>
</li>
<li><p>应用：println(A) 默认调用的是<code>A.toString()</code> 这是一个Object类的函数，返回地址信息，如果在A类重写toString函数就能改变,可以使用右键快捷生成toString函数</p>
</li>
</ul>
<h4 id="子类的构造器"><a href="#子类的构造器" class="headerlink" title="子类的构造器"></a>子类的<u>构造器</u></h4><ul>
<li><p>调用子类的构造器之前，自动调用父类的无参构造，默认存在<code>super()</code> </p>
</li>
<li><p>如果父类没有无参构造（有了有参构造），子类的构造器无法调用<code>super()</code> 就会报错，所以要在子类的构造器中手动调用 <code>super(name)</code>有参构造 </p>
</li>
<li><p>原因：子类中虽然不能直接操作父类的private成员，但是同样也是要有这些成员的，而且要避免一直调用父类的get set方法，那么子类构造时就要用<strong>父类的构造器</strong> 对父类的private成员进行初始化，再回来把对象里包含子类这部分数据赋值。</p>
</li>
<li><p>有参构造的重载：本来有三个参数，如果只接受两个参数，对其余的一个参数进行缺省设定，<code>this()</code> 就能调用本类的无参构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>(name, age, <span class="string">&quot;heima&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>(name, age);</span><br><span class="line">	<span class="built_in">this</span>.schoolName = schoolName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>this()和super()不能同时出现在构造器中，都必须放在第一行</p>
</li>
</ul>
<h3 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态 polymorphism"></a>多态 polymorphism</h3><ul>
<li><p><strong>对象多态</strong>：父类的引用类型变量 可以指向子类的对象</p>
</li>
<li><p><strong>行为多态</strong>：子类中和父类<strong>同名(重写)的方法</strong>，在多态调用时采用子类的方法(new的是Teacher的无参构造)</p>
</li>
<li><p>编译看的是左边引用的类型，但是实际运行起来看的是右边的构造函数，但是多态 <strong>不包括</strong> 成员变量 Person p = new Student() </p>
</li>
<li><p>右边对象是解耦合的，比如前面用的是Student后边想换成Person可以直接换掉</p>
</li>
<li><p>用父类的引用形参能接受一切子类的对象</p>
<ul>
<li>多态下不能使用子类的 <strong>独有功能</strong>  <ul>
<li>Method1 父类中定义一个抽象方法</li>
<li>Method2 instanceof判定ifelse</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多态的类型转换"><a href="#多态的类型转换" class="headerlink" title="多态的类型转换"></a><strong>多态的类型转换</strong></h4><p><strong>auto</strong> : <code>People p = new Teacher();</code> 小的自动转成大的</p>
<p><strong>force</strong>: <code>Teacher t = (Teacher)p;</code>大的必须强制才能转成小的 </p>
<p>编译阶段有继承或者实现关系就不会报错，但是运行会报<code>ClassCastException</code></p>
<p>Teacher有<code>teach() </code>Student 有<code>test()</code> ， 一个父类的引用person是无法调用他们的，必须类型转换</p>
<ul>
<li><p>但是如果p实际上是Student类，是无法强制转换成Teacher类的，引出 <code>instanceof</code> 运算符，结果是一个boolean类型的变量。</p>
</li>
<li><p>用父类的引用形参接受子类的对象，p instanceof Teacher = true 那么调用Teacher的独有功能，否则调用Student的独有功能</p>
</li>
</ul>
<h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>final 加在class上 类不能被继承， final加在方法上不能被重写，加在变量上 变量必须且仅能赋值一次   </p>
<p>static final 修饰的成员变量 String SCHOOL_NAME = “HEIMA” 相当于是 <strong>常量</strong></p>
<p>常量和直接用字面量性能一样</p>
<h3 id="抽象类-abstract-关键字"><a href="#抽象类-abstract-关键字" class="headerlink" title="抽象类 abstract 关键字"></a>抽象类 abstract 关键字</h3><ul>
<li><strong>抽象方法</strong> 只有方法签名，不能有具体的方法实现</li>
<li><strong>不能创建对象</strong> 只能作为父类让子类继承</li>
<li>如果一个类从抽象父类继承而来，除非重写完所有上一代的抽象方法，否则这个类也必须是抽象类</li>
<li>更好支持多态，父类知道子类都要做某个行为，但每个子类做的情况又不一样，父类就定义抽象方法，交给子类重写实现</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911172104015.png" alt="image-20240911172104015"></li>
</ul>
<h4 id="设计模式：模版方法"><a href="#设计模式：模版方法" class="headerlink" title="设计模式：模版方法"></a>设计模式：模版方法</h4><p>解决了什么问题：两个类的方法有大量的重复代码，仅仅有部分不同。</p>
<p>老师和学生都要写同一片作文，开头结尾相同，正文部分不一样，A B都需要<code>write()</code>且大量重复，抽象父类Father可以在<code>write()</code>写好重复的部分，插入抽象方法<code>body()</code>  并且父类的<code>write()</code>可以加<code>final</code>关键字，保证不被继承</p>
<h3 id="接口-interface-关键字"><a href="#接口-interface-关键字" class="headerlink" title="接口 interface 关键字"></a>接口 interface 关键字</h3><p>实现类 实现 接口  重写所有抽象方法</p>
<ul>
<li><p>方法 默认 <code>public</code> <code>abstract</code> </p>
</li>
<li><p>变量 默认 <code>public</code> <code> static</code> <code>final</code>（常量）</p>
</li>
<li><p>接口 不能 实例化，不能被类继承，可被类实现，可被接口继承</p>
</li>
<li><p>弥补单继承，可实现多接口(类似多继承)，一个类可以拥有更多的 能力(某专业方面的能力)</p>
</li>
<li><p>面向接口编程，业务实现的切换灵活，解耦，AB都实现了接口Driver Driver某一天想换人，直接new B就可以，AB都实现了drive方法。你是司机，你就必须会开车，这样的话想换司机只需要换人就可以，不需要额外增加方法 <code>Driver driver = new A();</code> <code>Driver driver = new B();</code> </p>
</li>
<li><p>同一个功能的多套方案：建立一个接口，用接口的抽象方法表示要实现的功能，然后分别做多个接口的实现类，把抽象方法具体化</p>
</li>
<li><p>JDK 8 new:  均非抽象方法，</p>
<ul>
<li>默认方法 default 接口 <strong>实现类的对象</strong> 才可以调用 用public修饰</li>
<li>私有方法 private 只有在接口 <strong>内部</strong> 才能访问</li>
<li>静态方法 static   只能通过 <strong>接口名调用</strong> 用public修饰 </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911221630071.png" alt="image-20240911221630071"></li>
</ul>
<p>外部软件包访问本包接口，需要将接口设置为public</p>
</li>
</ul>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法(同一个类)</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可以修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可以修改</td>
<td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">可以修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h3 id="内部类-9-12"><a href="#内部类-9-12" class="headerlink" title="内部类 9.12"></a>内部类 9.12</h3><ul>
<li><p>创建内部类对象：<code>Outer.Inner in = new Outer().new Inner();</code> 外部类.内部类</p>
<ul>
<li>内部类的方法访问内部类的成员变量 <code>this</code></li>
<li>Outer.this 返回外部类对象</li>
</ul>
</li>
<li><p>JDK16开始 可以定义内部类的静态成员</p>
</li>
<li><p>静态内部类：<code>public static class</code></p>
<ul>
<li><code>Outer.Inner in = new Outer.Inner();</code> </li>
<li>不需要创建外部对象就能获得内部类</li>
<li>可以访问外部类的静态成员</li>
</ul>
</li>
</ul>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul>
<li>本质上是一个子类，会立即创建出一个子类对象出来</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.cry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Animal这个抽象类不能实例化，在后面加一个大括号，然后在其中实现抽象方法，这样就创建了一个子类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Swimming</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Swim!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    go(s1); <span class="comment">//输出 Swim！</span></span><br><span class="line">    go(<span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Swim!2nd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)<span class="comment">//输出Swim！2nd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Swimming s)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Go!&quot;</span>);</span><br><span class="line">	s.swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimming</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用：快速创建子类对象，用于（interface）实现类对象作形参的情况 一般是被动去用</li>
<li>JFrame API: <code>button.addActionListener(ActionListener act)</code> <code>ActionListener</code> is an interface</li>
</ul>
<h3 id="枚举-enum-关键字"><a href="#枚举-enum-关键字" class="headerlink" title="枚举 enum 关键字"></a>枚举 enum 关键字</h3><ul>
<li><p> 特殊的class ，私有的构造器，只能创建固定数量的实例(对象)</p>
</li>
<li><p>如果有抽象方法，对象必须实现方法</p>
</li>
<li><p>遍历 for-each语句 没有索引，不能修改元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> number: numbers)&#123;</span><br><span class="line">	System.out.prinln(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912125835772.png" alt="image-20240912125835772"></p>
</li>
</ul>
<p>枚举变量实际是常对象，用public static final 修饰，创建了X,Y,Z三个常对象，调用的是无参的构造器，也可以自己写有参构造器， </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912130046257.png" alt="image-20240912130046257"></p>
<h4 id="设计模式：单例-1"><a href="#设计模式：单例-1" class="headerlink" title="设计模式：单例"></a>设计模式：单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">C</span>&#123;X;&#125;<span class="comment">//单例</span></span><br></pre></td></tr></table></figure>

<h4 id="信息标注"><a href="#信息标注" class="headerlink" title="信息标注"></a>信息标注</h4><p>常量输入的信息不受约束，用枚举做信息标注更好</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912131648801.png" alt="image-20240912131648801"></p>
<p>枚举做形参，方法内直接写出对应的枚举即可</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><p>相当于是类做参数</p>
</li>
<li><p><code>ArrayList</code> 没有指出泛型，默认是<code>Object</code>对象</p>
</li>
<li><p><code>ArrayList&lt;String&gt;</code> 只能接受<code>String</code>类型的数据</p>
</li>
<li><p><code>ArrayList&lt;T extends Animal&gt;</code> 只能接受<code>Animal</code>子类</p>
</li>
<li><p><code>ArrayList&lt;T implements Driver&gt;</code> 只能接受<code>Driver</code>实现类</p>
</li>
<li><p>把数据类型作为参数传递给类型变量，相当于缺省，然后对类的成员进行赋值</p>
</li>
<li><p><em>使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组(<code>Object[] arr</code>)排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</em> </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Data</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>;</span><br><span class="line">	ArrayList&lt;T&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Teacher&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Teacher teacher)</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ArrayList&lt;Teacher&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//泛型接口</span></span><br></pre></td></tr></table></figure>

<ul>
<li>泛型方法 用<code>&lt;E&gt;</code>修饰，表明方法中存在缺省<strong>类型</strong> class E，可能在参数列表中，也可能在返回值中，也可能在具体的实现中 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span>&#123;</span><br><span class="line">      <span class="comment">// 输出数组元素            </span></span><br><span class="line">    <span class="keyword">for</span> ( E element : inputArray )&#123;     </span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">    &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912141719516.png" alt="image-20240912141719516"></p>
<ul>
<li><p>定义的时候在返回值前加泛型，单纯使用可以在ArrayList加通配符</p>
<ul>
<li><code>public static &lt;T&gt; void go (ArrayList&lt;T&gt; cars)</code> </li>
<li><code>public static void go (ArrayList&lt;?&gt; cars)</code> </li>
<li><code>&lt;?&gt;</code>表示能接收一切类型的ArrayList </li>
<li><code>&lt;? extends Car&gt;</code>表示能接收Car以及Car子类的ArrayList，也叫上限</li>
<li><code>&lt;? super Car&gt;</code>表示能接收Car以及Car父类的ArrayList ，也叫下限</li>
</ul>
</li>
<li><p><strong>泛型擦除：</strong> 编译阶段工作，class字节码文件中并不存在泛型，都是将 Object 对象 强转为 E 类型</p>
</li>
<li><p>泛型<strong>不支持基本数据类型</strong>，Integer Double 类型解决</p>
</li>
</ul>
<h2 id="API-from-JDK-2024-9-12"><a href="#API-from-JDK-2024-9-12" class="headerlink" title="API from JDK 2024.9.12"></a>API from JDK 2024.9.12</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul>
<li><p>Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，<strong>子类可以使用 Object 的所有方法</strong>。</p>
</li>
<li><p>Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。</p>
</li>
<li><p><code>toString() 返回字符串形式</code> 可重写,以返回对象的内容</p>
</li>
<li><p><code>equals(Object o) 返回boolean </code>   判断对象是否相等 默认比较 <strong>地址</strong> 可重写成 比较两个的内容是否一样</p>
<ul>
<li>先判断地址是否一样</li>
<li>再判断是不是null/是不是同一个类</li>
<li>再判断变量是否相等 <code>return this.age == student.age &amp;&amp; Objects.equals(this.name,student.name)</code>  </li>
</ul>
</li>
<li><p><code>protected o clone()</code> 复制一个完全相同的Object对象，内容相同，属于<strong>浅拷贝</strong> 调用子类方法需要强转 。我们用的类跟Object源文件不在一个包下，所以子类要用<code>clone()</code>必须要重写，通过子类<code>super</code>间接调用父类Object的<code>clone()</code>。并且子类必须是接口<code>Cloneable</code>的实现类.</p>
</li>
<li><p>浅拷贝：<strong>对象中包含的其他对象</strong>，依然指向同一个对象(相当于直接把对象的地址也复制过去了) </p>
</li>
<li><p>深拷贝：浅拷贝+对象中包含的对象单独浅拷贝<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912230730643.png" alt="image-20240912230730643"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> (Animal)<span class="built_in">super</span>.clone();</span><br><span class="line">        a.arr = a.arr.clone();<span class="comment">//数组内部没有其他的对象，</span></span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912233304677.png" alt="image-20240912233304677"></p>
</li>
<li><p>equals方法是为了避免空指针异常，s1.equals()，s1 = null 会报NullPointerException</p>
</li>
<li><p>```<br>public static boolean equals(Object a, Object b){</p>
<pre><code>return (a==b)||(a != null &amp;&amp; a.equals(b))
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 包装类 </span><br><span class="line"></span><br><span class="line">int -&gt; Integer      char -&gt;Character</span><br><span class="line"></span><br><span class="line">泛型和集合不支持基本数据类型，用包装类替代，有自动装箱和自动拆箱机制</span><br><span class="line"></span><br><span class="line">- `Integer.toString()` 将Integer对象转换成字符串 i.toString();</span><br><span class="line">- `Integer.toString(int i)` 将23这个数字转换成字符串 静态方法 </span><br><span class="line">  - arr[i] + &quot;&quot; 数字+空串也可以转换成字符串</span><br><span class="line">- `Double.parseDouble(String str)` 将str转换成 double 静态方法</span><br><span class="line">- `Double.valueOf(String str)` 将str转换成 double 静态方法</span><br><span class="line">- println 能加则加，不能加就一起输出</span><br><span class="line"></span><br><span class="line">### StringBuilder</span><br><span class="line"></span><br><span class="line">![image-20240913000059749](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913000059749.png)</span><br><span class="line"></span><br><span class="line">- StringBuilder重写了toString()  </span><br><span class="line">- append返回对象本身，可以链式调用，s.append(1).append(2).append(&quot;!23213&quot;);</span><br><span class="line">- reverse、length</span><br><span class="line">- 操作字符串建议使用StringBuilder 是可变对象 效率更高</span><br><span class="line">- 线程不安全。</span><br><span class="line"></span><br><span class="line">### StringBuffer</span><br><span class="line"></span><br><span class="line">- 线程安全</span><br><span class="line"></span><br><span class="line">### StringJoiner</span><br><span class="line"></span><br><span class="line">- 格式化拼接，方便快捷</span><br><span class="line"></span><br><span class="line">![image-20240913001740989](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913001740989.png)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static String getArr(int[] arr)&#123; //返回数组</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.append(&quot;[&quot;);</span><br><span class="line">        for(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            sb.append(arr[i]);</span><br><span class="line">            if(i!=arr.length-1)&#123;</span><br><span class="line">                sb.append(&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&quot;]&quot;);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">public static String getArr(int[] arr)&#123; //返回数组</span><br><span class="line">        StringJoiner sj = new StringJoiner(&quot;,&quot;,&quot;[&quot;,&quot;]&quot;);</span><br><span class="line">		for(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            sj.add(arr[i]+&quot;&quot;);</span><br><span class="line">        &#125;       </span><br><span class="line">        return sj.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Math-2024-9-13"><a href="#Math-2024-9-13" class="headerlink" title="Math 2024.9.13"></a>Math 2024.9.13</h3><p>工具类，静态方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913134448095.png" alt="image-20240913134448095"></p>
<p>abs ceil floor round</p>
<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>工具类 静态方法</p>
<p><code>System.exit(0) </code> 人为停机</p>
<p><code>System.currentTimeMillis()</code> 返回毫秒值 统计程序时间</p>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><ul>
<li>java程序所在的运行环境</li>
<li><strong>单例类</strong> 构造器私有，声明一个public static final</li>
<li>exit exec</li>
</ul>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul>
<li><p><code>public BigDecimal(String val)</code>构造器 将double转成String类型然后付给BigDecimal</p>
</li>
<li><p><code>public static BigDecimal valueOf(double val)</code> 直接接一个double，据此创建一个BigDecimal对象（推荐）</p>
</li>
<li><p>divide(另一个BD对象，精确位数，舍入模式)</p>
<ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913140854393.png" alt="image-20240913140854393"></p>
</li>
<li><table>
<thead>
<tr>
<th>UP</th>
<th>DOWN</th>
<th>CEILING</th>
<th>FLOOR</th>
<th>HALF_UP</th>
<th>HALF_DOWN</th>
</tr>
</thead>
<tbody><tr>
<td>远离0方向</td>
<td>接近0方向</td>
<td>向上取整</td>
<td>向下取整</td>
<td>四舍五入</td>
<td>五舍六入</td>
</tr>
</tbody></table>
</li>
<li><p>HALF_EVEN 若（<strong>舍入位大于</strong>5）或者（<strong>舍入位等于</strong>5<strong>且前一位为奇数</strong>），则对舍入部分的前一位数字加1；若（<strong>舍入位小于</strong>5）或者（<strong>舍入位等于</strong>5且前一位为偶数），则直接舍弃。</p>
</li>
</ul>
</li>
<li><p>转成<code>double d =  bigdecimal.doubleValue()</code></p>
</li>
</ul>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913164633885.png" alt="image-20240913164633885"></p>
<h5 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h5><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><ul>
<li><p><code>toString([] arr)</code> 返回一个数组字符串，每个元素调用<code>toString()</code>转换成字符串，用<code>[,,,]</code>拼接成一个总字符串</p>
</li>
<li><p> <code>copyOfRange([] arr, from, to)</code> 返回值为数组， 内容为arr中索引 <strong>[from, to)</strong> 的部分</p>
</li>
<li><p><code>copyOf([] arr, int newlength)</code> 返回值为数组，内容为arr的内容，长度为newlength，不够的用0补齐，索引超出的截断</p>
</li>
<li><p><code>setAll</code>  第二个参数是接口<code>IntToDoubleFunction</code>的实现对象，重写了<code>applyAsDouble(int value)</code>方法，value是数组的索引，返回对数组中内容进行操作的结果，图中是将数组内容乘以0.8。这个对象传进来以后，对数组进行遍历，都用<code>applyAsDouble</code>的方法进行操作。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913170741004.png" alt="image-20240913170741004"></p>
</li>
<li><p><code>sort([] arr)</code> 对arr升序排序(默认升序)</p>
</li>
<li><p><code>asList()</code>:只能加<strong>引用类型</strong>，基本数据类型需要改成包装类，并且返回的<code>List</code>是不能运用<code>add remove clear</code>方法的，这个<code>list</code>是<code>AbstractList</code>的子类，如果要访问<code>utils</code>只能将返回的这个<code>List</code>添加到<code>new ArrayList&lt;&gt;()</code>作为有参构造</p>
</li>
</ul>
<h4 id="对象数组如何排序？-Comparable-Comparator-—匿名内部类实现函数式接口"><a href="#对象数组如何排序？-Comparable-Comparator-—匿名内部类实现函数式接口" class="headerlink" title="对象数组如何排序？ Comparable Comparator —匿名内部类实现函数式接口"></a>对象数组如何排序？ Comparable Comparator —匿名内部类实现函数式接口</h4><p><strong>自己指定比较规则</strong> </p>
<ul>
<li><p>方法1：对象类实现<code>Comparable&lt;E&gt;</code>这个泛型接口，类中重写<code>int compareTo(E e)</code> 方法，将E改为自己的对象类型。</p>
<ul>
<li>约定，左边大于右边 return 正整数，小于 return 负整数，等于 return 0;（升序排序）</li>
<li><code>return this.age - o.age</code>  注意返回值是int double可以调用<code>Double.compare(o1.height, o2.height)</code></li>
<li>调用<code>Arrays.sort(students)</code>即可</li>
</ul>
</li>
<li><p>方法2：实现<code>Comparator</code>这个泛型接口，运用</p>
<ul>
<li><p>sort有一个重载函数，第一个参数是对象数组<code>T[] arr</code>，第二个参数是<code>Comparator&lt;? super T&gt; comparator</code></p>
</li>
<li><p>泛型接口做参数用匿名内部类实现，类中重写<code>int compare(T o1,T o2)</code>方法，同时注意返回的是int</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Students&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1.height,o2.height);<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>ArrayList有自己的sort方法，实现同Comparator，可以免去泛型的指定</li>
</ul>
<h4 id="Lambda-表达式—简化匿名内部类"><a href="#Lambda-表达式—简化匿名内部类" class="headerlink" title="Lambda 表达式—简化匿名内部类"></a><strong>Lambda 表达式—简化匿名内部类</strong></h4><ul>
<li>简化匿名内部类的写法，并且只能简化函数式接口(只有一个抽象方法的接口)，表示该接口的一个实现</li>
<li>@FunctionalInterface</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Swimming</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		System.out.println(name + <span class="string">&quot;is a swimmer~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Swimming</span> <span class="variable">s</span> <span class="operator">=</span> (name) -&gt; &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;is a swimmer~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913220402634.png" alt="image-20240913220402634"></p>
</li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913220414015.png" alt="image-20240913220414015"></p>
</li>
<li><p>参数类型可省略不写，无参数也要空括号</p>
</li>
<li><p>如果只有一个参数，参数列表的括号可以省略不写</p>
</li>
<li><p>如果实现的抽象方法只有一行代码，可以省略大括号，同时也要省略<code>;</code>，若这一行是<code>return</code>语句，return也不能写</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1.age(),o2.age());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Arrays.sort(students, (Student o1,Student o2)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(o1.age(),o2.age());</span><br><span class="line">&#125;);</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;&#123;<span class="keyword">return</span> Double.compare(o1.age(),o2.age());&#125;);</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;Double.compare(o1.age(),o2.age());</span><br></pre></td></tr></table></figure>

<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ShuSheng0007/article/details/107562812">秒懂Java之方法引用（method reference）详解-CSDN博客</a></p>
<p>Lambda的简化 对于参数列表和返回值相同的情况</p>
<h5 id="类的静态方法引用-类的实例方法引用（对象本身并不作为参数）"><a href="#类的静态方法引用-类的实例方法引用（对象本身并不作为参数）" class="headerlink" title="类的静态方法引用/类的实例方法引用（对象本身并不作为参数）"></a>类的静态方法引用/类的实例方法引用（对象本身并不作为参数）</h5><ul>
<li><p>静态方法引用: 调用静态方法，不需要实例，前缀是类名</p>
</li>
<li><p>实例方法引用: 调用已经存在的对象的实例方法，对象本身并不是参数，方法引用前缀是具体的对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;E&gt;&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(E o1, E o2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompareByData</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareByAge</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Double.compare(o1.getAge(),o2.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareByAgeDesc</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Double.compare(o2.getAge(),o1.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> compareBy</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;CompareByData.compareByAge(o1,o2));<span class="comment">//lambda</span></span><br><span class="line">Arrays.sort(students, CompareByData::compareByAge);<span class="comment">//静态方法引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">CompareByData</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompareByData</span>();</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;com.compareByAgeDesc(o1,o2));<span class="comment">//lambda</span></span><br><span class="line">Arrays.sort(students, com::compareByAgeDesc);<span class="comment">//实例方法引用,com并不是参数</span></span><br></pre></td></tr></table></figure>

<h5 id="类的实例方法引用-对象本身作为参数"><a href="#类的实例方法引用-对象本身作为参数" class="headerlink" title="类的实例方法引用(对象本身作为参数)"></a>类的实例方法引用(对象本身作为参数)</h5><ul>
<li>调用实例方法，对象本身作为参数传进来，方法引用前缀为类名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(names, (String o1,String o2)-&gt;o1.compareToIgnoreCase(o2));</span><br><span class="line">Arrays.sort(names, String::compareToIgnoreCase);<span class="comment">//compareToIgnoreCase本身是String的一个实例方法</span></span><br><span class="line">    </span><br><span class="line">lqw.lt((User o1)-&gt;o1.getAge());</span><br><span class="line">lqw.lt(User::getAge, <span class="number">10</span>);<span class="comment">//getAge是User的一个实例方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>传入的对象o1是实例方法的调用者，其余的参数都是这个方法的参数</li>
</ul>
<h5 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h5><ul>
<li>Lambda表达式如果只是在创建一个对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Student <span class="title function_">getStudent</span><span class="params">(String name, <span class="type">int</span> age, BiFunction&lt;String, Integer, Student&gt; biFunction)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biFunction.apply(name, age);</span><br><span class="line">&#125;</span><br><span class="line">BiFunction&lt;String, Integer, Student&gt; s1 = <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;String, Integer, Student&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">apply</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(name, age);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//lambda表达式</span></span><br><span class="line">    BiFunction&lt;String, Integer, Student&gt; s2 = (name, age) -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>(name, age);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//对应的方法引用</span></span><br><span class="line">    BiFunction&lt;String, Integer, Student&gt; s3 = Student::<span class="keyword">new</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h5 id="方法引用-Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性"><a href="#方法引用-Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性" class="headerlink" title="方法引用/Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性"></a>方法引用/Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(names, (Comparator&lt;? <span class="built_in">super</span> String&gt;) String::compareToIgnoreCase);</span><br><span class="line">Arrays.sort(names, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>



<h2 id="Regex-正则表达式"><a href="#Regex-正则表达式" class="headerlink" title="Regex 正则表达式"></a>Regex 正则表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">qqCode</span> <span class="operator">=</span> <span class="string">&quot;12812415&quot;</span>;</span><br><span class="line">System.out.println(qqCode.matches(<span class="string">&quot;[1-9]\\d&#123;5-19&#125;&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="Exception-异常处理"><a href="#Exception-异常处理" class="headerlink" title="Exception 异常处理"></a>Exception 异常处理</h2><p><code>Error</code>属于严重异常</p>
<p>运行时异常<code>RuntimeException</code></p>
<p>编译时异常，不解决是无法运行的</p>
<h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914213155516.png" alt="image-20240914213155516"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时异常</span></span><br><span class="line"><span class="comment">//自定义异常对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeIllegalRuntimeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(....) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalRuntimeException</span>(<span class="string">&quot;Your age is illegal!&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//抛出一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        saveAge(<span class="number">123</span>);<span class="comment">//函数执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//catch 用来接受可能抛出的异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译时异常 强烈提醒检查</span></span><br><span class="line"><span class="comment">//自定义异常对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> AgeIllegalException&#123;<span class="comment">//接收方法内部可能抛出的异常</span></span><br><span class="line">    <span class="keyword">if</span>(....) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalException</span>(<span class="string">&quot;Your age is illegal!&quot;</span>);<span class="comment">//一开始会报错,throws抛出</span></span><br><span class="line">    &#125;<span class="comment">//抛出一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        saveAge(<span class="number">183</span>);<span class="comment">//函数执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//catch 用来接受可能抛出的异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>throws</code>:用于方法的声明当方法内部抛出指定类型的异常时，该异常会被传递给<strong>调用该方法的代码</strong>，并在该代码中处理异常</p>
<p><code>try-catch</code>:试图接收并处理异常</p>
<p><code>throw</code>:用于在当前方法中抛出一个异常，当代码执行到某个条件下无法继续正常执行时，可以使用 <strong>throw</strong> 关键字抛出异常，以告知调用者当前代码的执行状态</p>
<ul>
<li>底层异常往外抛,最外层接受并记录,响应给用户</li>
<li>最外层接收,并在底层尝试修复<ul>
<li><code>sc.nextDouble()</code>接收一个<code>double</code>类型,如果乱输aafads就会在运行时自动抛出错误给外层</li>
<li>只需要将外层调用的<code>try-catch</code>块用<code>while(true)</code>围起来即可</li>
</ul>
</li>
</ul>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><h3 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h3><p>file&amp;directory</p>
<ul>
<li><code>File(String pathname)</code>:有参构造, <code>pathname</code>路径分隔符<code> / \\ File.separator</code> <ul>
<li>绝对路径</li>
<li>相对路径：默认起始位置是工程目录<code>(模块)file-io-app\\src\\itheima.txt</code></li>
</ul>
</li>
<li><code>f1.length()</code>:返回文件,文件夹大小 字节数 文件夹是存储文件夹内部的一些文件信息</li>
<li><code>f3.exists()</code>:是否存在</li>
<li><code>f3.isFile()</code>:是否是文件</li>
<li><code>f3.isDirectory()</code>:是否是文件夹</li>
<li><code>f3.getName()</code>:获取文件名称，包含后缀</li>
<li><code>f3.lastModified()</code>:返回long 最后修改的时间</li>
<li><code>f1.getPath()</code>获取创建对象时输入的路径</li>
<li><code>f1.getAbsolutePath()</code>获取文件的绝对路径</li>
</ul>
<ul>
<li><code>f1.createNewFile()</code>:不存在才创建，存在就创建失败，返回<code>false</code>  没找到路径会报错</li>
<li><code>f1.mkdir()</code>:不存在才创建，存在就创建失败，返回<code>false</code> 只能创建一级目录</li>
<li><code>f1.mkdirs()</code>:可以创建多级目录，返回结果</li>
<li><code>f1.delete()</code>:删除文件、空文件夹，返回结果</li>
</ul>
<ul>
<li><code>f1.list()</code>:当前<strong>文件夹</strong>内的<strong>一级文件名称</strong>返回<code>String[]</code> 也包含文件夹</li>
<li><code>f1.listFiles()</code>:返回当前<strong>文件夹</strong>内的<strong>一级文件对象</strong>，返回文件对象数组<code>File[]</code>，也包含文件夹<ul>
<li>文件、路径不存在、无权限访问的文件夹 <code>return null</code></li>
<li>空文件夹返回长度为0的File数组</li>
<li>隐藏文件也显示</li>
</ul>
</li>
<li><code>renameTo(new File(file.getParent(), newName))</code> 改名，file是目录下子文件,<code>substring(from,to)</code>是截取<code>[from,to)</code>,<code>substring(from)</code>是截取<code>[from,最后]</code></li>
</ul>
<h4 id="文件搜索、非空文件夹删除"><a href="#文件搜索、非空文件夹删除" class="headerlink" title="文件搜索、非空文件夹删除"></a>文件搜索、非空文件夹删除</h4><p>递归，数学问题最好写出表达式</p>
<p>eg 猴子一天吃一半还要再吃一个，10天剩余1个。前9天各自吃了多少？</p>
<p>$f(x)$代表第x天的桃子数量，题干可得出$f(x)/2+1 = f(x+1), f(10)=1$ 直接写递归函数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNumberOfPeach</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*getNumberOfPeach(n+<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="C:\Users\Lenovo\IdeaProjects\MyFirstProject\src\com\it\IOtest\FileTestDemo.java">文件搜索、非空文件夹删除</a> </p>
<p><a href="C:\Users\Lenovo\IdeaProjects\MyFirstProject\src\com\it\IOtest\RecursiveDemo.java">递归练习</a> </p>
<h3 id="字符集（前置）"><a href="#字符集（前置）" class="headerlink" title="字符集（前置）"></a>字符集（前置）</h3><p>ASCII: 首位是0，使用1个字节存储英文数字</p>
<p>GBK: 1个中文字符编码成2个字节，兼容ASCII，并且对汉字规定第一个字节的第一位必须是1，与ASCII字符做区分</p>
<p>Unicode: </p>
<ul>
<li><p>UTF-32 4个字节表示一个字符</p>
</li>
<li><p>UTF-8 </p>
<ul>
<li>可变长编码方案 可以有1B 2B 3B 4B 四种长度 </li>
<li>兼容ASCII，汉字字符占3B</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916165638204.png" alt="image-20240916165638204"></li>
</ul>
</li>
<li><p>Encode Decode Identical</p>
</li>
<li><p>String提供了一些API，为字符串提供了编码和解码操作，以字节数组的形式<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916170250587.png" alt="image-20240916170250587"></p>
</li>
</ul>
<h3 id="IO流-字节流-amp-字符流"><a href="#IO流-字节流-amp-字符流" class="headerlink" title="IO流:字节流&amp;字符流"></a>IO流:字节流&amp;字符流</h3><ul>
<li><code>InputStream</code>:字节输入流:以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流</li>
<li><code>OutputStream</code>:字节输出流:以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流</li>
<li><code>Reader</code>:字符输入流:以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流，</li>
<li><code>Writer</code>:字符输出流:以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916171717591.png" alt="image-20240916171717591"></p>
<h4 id="FileInputStream-字节流"><a href="#FileInputStream-字节流" class="headerlink" title="FileInputStream 字节流"></a>FileInputStream 字节流</h4><ul>
<li>从文件一个字节一个字节地读取数据到内存中</li>
<li><code>InputStream is = new FileInputStream(&quot;........&quot;)</code></li>
<li><code>FileInputStream(String name)</code>:打开实际文件的连接创建文件字节输入流，也可用<code>File file</code>做形参，<code>String</code>重载会自动帮你转成file对象。</li>
<li>一次读取一个 <code>int read()</code> 读取一个字节并返回，无数据返回-1 <ul>
<li>改进：循环<code>(b=is.read())!=-1</code></li>
<li>调用系统硬件资源，性能较差</li>
<li>一次读一个，无法解决非ASCII的乱码</li>
<li>流使用系统资源，使用完记得关闭！<code>is.close()</code></li>
</ul>
</li>
<li>一次读取多个 <code>int read(byte[] buffer)</code> 用<code>buffer</code>字节数组装字节，字节数组的长度代表每次读取的字节数，返回每次读取的字节数（<code>buffer</code>可能会装不满）无数据返回-1<ul>
<li><code>buffer</code>字节数组要转换成字符串，转成<code>String</code>可以设定转的部分，<code>String(buffer, 0, len)</code>确保如实把<strong>这次</strong>读到的内容转为字符串 <code>len</code>为<code>read</code>的返回值 </li>
<li>性能得到了提升，汉字仍然乱码，会强行截断汉字</li>
</ul>
</li>
<li>一次读取全部<ul>
<li><code>int read(byte[] buffer)</code>buffer大小和文件的大小字节数相同</li>
<li><code>byte[] readAllBytes()</code> <code>is.readAllBytes()</code> </li>
<li>文件过大会导致内存溢出，字节数组过大，所以字节流不适合读文本，更适合做数据转移，比如文件复制</li>
</ul>
</li>
</ul>
<h4 id="FileOutputStream-字节流"><a href="#FileOutputStream-字节流" class="headerlink" title="FileOutputStream 字节流"></a>FileOutputStream 字节流</h4><ul>
<li>从内存一个字节一个字节地输出到文件中，目标文件自动生成</li>
<li><code>OutputStream os = new FileOutputStream(&quot;........&quot;)</code> 写文件（覆盖）</li>
<li><code>OutputStream os = new FileOutputStream(&quot;........&quot;, true)</code> 写文件（追加）<ul>
<li>换行：<code>&quot;\r\n&quot;</code> 将其转换成<code>bytes[]</code> 再<code>write</code></li>
</ul>
</li>
<li><code>os.write(int b)</code>把b写入文件 还是以字节形式</li>
<li><code>os.write(byte[] b)</code>把字节数组b写入文件</li>
<li><code>os.write(byte[] b,int off,int len)</code>把b写入文件, <code>off</code>表示起始的字节数组索引，<code>len</code>表示要写入的字节长度，3个汉字一共9字节</li>
</ul>
<h5 id="case-文件复制"><a href="#case-文件复制" class="headerlink" title="case: 文件复制"></a>case: 文件复制</h5><p>总结：字节流适合拷贝一切文件，因为一切文件的内容都是以字节形式存储的，一字不漏地转移所有字节，就不会出现问题</p>
<h4 id="释放资源的方式"><a href="#释放资源的方式" class="headerlink" title="释放资源的方式"></a>释放资源的方式</h4><p>原来：中间出现异常，就无法释放资源（关闭字节流）</p>
<h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论try是否正常执行，一定执行finally，除非JVM终止<code>System.exit(0)</code></p>
<p>finally可以无视<code>return</code>语句 一定执行一次，如果finally是return，原函数接受的就一定是finally里边的值，所以最好不要在finally里面return</p>
<p>在程序执行完成后进行资源的释放操作，finally不能访问try块里面的内容</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916200213214.png" alt="image-20240916200213214">先在try块外定义流，然后try块内对流进行操作，finally块内关闭流，关闭流因为系统不知道之前是否开流会报错，用try catch块包围起来即可<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916200719319.png" alt="image-20240916200719319"></p>
<p><strong>臃肿</strong></p>
<h5 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>（</span><br><span class="line">	<span class="comment">//资源的定义;</span></span><br><span class="line">	<span class="comment">//资源的定义;</span></span><br><span class="line">）&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能放置资源对象, 资源都会实现AutoClosable接口，资源放进去会自动调用close方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916201402673.png" alt="image-20240916201402673"></p>
<h4 id="FileReader-字符流"><a href="#FileReader-字符流" class="headerlink" title="FileReader 字符流"></a>FileReader 字符流</h4><ul>
<li>把文件数据以字符形式读到内存中去</li>
<li>构造器与<code>FileInputStream</code>类似 <code>Reader fr = new FileReader(String filename)</code></li>
<li><code>int read() </code>每次读取一个字符并返回</li>
<li><code>int read(char[] buffer) </code>每次读取多个字符并返回，返回此次读取字符的个数</li>
</ul>
<h4 id="FileWriter-字符流"><a href="#FileWriter-字符流" class="headerlink" title="FileWriter 字符流"></a>FileWriter 字符流</h4><ul>
<li>把字符数据写到文件中去,目标文件自动生成</li>
<li>构造器与<code>FileOutputStream</code>类似 <code>Writer fw = new FileWriter(String filename)</code>可以参数后加true表示追加</li>
<li><code>void write(int c)</code>写一个字符出去</li>
<li><code>void write(String str)</code>写一个字符串出去</li>
<li><code>void write(String str,int pos,int len)</code> 写字符串从<code>pos</code>开始长度为<code>len</code></li>
<li><code>void write(char[] buffer)</code>写一个字符数组</li>
<li><code>void write(char[] buffer,int pos,int len)</code>写字符数组从<code>pos</code>开始长度为<code>len</code></li>
<li>注意事项<ul>
<li>字符输出流写出数据以后，必须刷新流或者关闭流（包含刷新）才能生效。<code>flush() close()</code> 因为对文件操作比较耗费系统资源，所以都是先从管道写到缓冲区，写完之后一次性写到文件中去。</li>
</ul>
</li>
</ul>
<h3 id="IO流-缓冲流"><a href="#IO流-缓冲流" class="headerlink" title="IO流:缓冲流"></a>IO流:缓冲流</h3><p>对原始流进行包装，提高原始流读写数据的性能</p>
<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>开辟缓冲区，不用一次一次写 <strong>8KB缓冲池</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916231524970.png" alt="image-20240916231524970"></p>
<p>减少调用系统资源的次数</p>
<p><code>InputStream bis = new BufferedInputStream(InputStream is)</code></p>
<p><code>OutputStream bos = new BufferedOutputStream(OutputStream os)</code></p>
<p>方法和原始类一样，性能有所提高，有参构造可以自定义缓冲区大小，默认8192</p>
<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p>自带8K的字符缓冲池</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916232037970.png" alt="image-20240916232037970"></p>
<p><code>BufferedReader br = new BufferedReader(Reader r)</code> </p>
<p>不使用多态写法：新增了独有的功能</p>
<p>新增功能 <code>String readLine()</code> 读一整行，直到换行符，返回这行的内容，没有返回<code>null</code></p>
<p><code>BufferedWriter bw = new BufferedWriter(Writer r)</code> </p>
<p>新增功能：<code>void newLine()</code>换行</p>
<h3 id="原始-amp-缓冲流对比"><a href="#原始-amp-缓冲流对比" class="headerlink" title="原始&amp;缓冲流对比"></a>原始&amp;缓冲流对比</h3><ul>
<li>低级字节流一个一个字节的赋值，慢的简直让人无法忍受，直接淘汰! X</li>
<li>低级字节流一个一个字节数组的形式复制，速度较慢! </li>
<li>缓冲流按照一个一个字节的形式复制，速度较慢 X</li>
<li>缓冲流按照一个一个字节数组的形式复制，速度极快，推荐使用!</li>
<li>性能与字节数组的大小强相关，32MB最大，用空间换时间</li>
<li>与缓冲区的大小也有关</li>
</ul>
<p>并行&amp;多线程 异步IO 内存映射技术 减少系统调用 不要一个字节一个字节地输入</p>
<h3 id="字符转换流"><a href="#字符转换流" class="headerlink" title="字符转换流"></a>字符转换流</h3><h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><p><code>Reader isr = new InputStreamReader(InputStream is, String charset)</code> 把<strong>原始<mark>字节流<mark>is</strong>按照charset设定转换成对应字符输入流</p>
<p>新的字符输入流可以继续用<code>BufferedReader</code>包装</p>
<h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><p>控制写出去的字符集编码</p>
<ul>
<li><code>str.getBytes(&quot;GBK&quot;)</code></li>
<li>字符输出转换流</li>
</ul>
<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>PrintStream：是<strong>字节输出流</strong>的实现类</p>
<p>PrintWriter：是<strong>字符输出流</strong>的实现类 内部包装缓冲流</p>
<p><strong>方便高效</strong>，所见即所得</p>
<p>构造器：</p>
<ul>
<li><code>PrintStream(OutputStream os/File file/String filename)</code> 直接链接+包装原始流</li>
<li><code>PrintStream(String filename, Charset charset)</code> <code>Charset.forName(&quot;GBK&quot;)</code>能返回GBK的Charset</li>
<li><code>PrintStream(OutputStream os, boolean autoFlush, String charset)</code> 字符集可有可无</li>
<li><strong><code>ps.println()</code>:打印一行东西</strong></li>
<li><code>ps.write()</code>写int字节 字节数组 字节数组的一部分</li>
</ul>
<p>自身没有追加功能，只能包装<code>true输出流</code>:</p>
<p><code>PrintStream ps = PrintStream(new FileOutputStream(filename,true))</code> </p>
<p><code>PrintWriter pw = PrintWriter(new FileWriter(filename,true))</code>  </p>
<h4 id="拓展：Redirecting-PrintStream-PrintWriter"><a href="#拓展：Redirecting-PrintStream-PrintWriter" class="headerlink" title="拓展：Redirecting PrintStream/PrintWriter"></a>拓展：Redirecting PrintStream/PrintWriter</h4><p><code>System.out.println()</code> out实际上就是一个打印流，是指向控制台的</p>
<p><code>System.setOut(PrintStream ps)</code> 把系统的out设定到指定的打印流ps中</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917153902713.png" alt="image-20240917153902713"></p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><code>DataInputStream</code>:字节输入流的实现</p>
<p>构造器：包装低级的字节输入流 </p>
<p><code>dos.writeInt(int a)</code> 写出去a，包括数据类型</p>
<p><code>dis.readUTF()</code> 读进来字符串并返回 UTF-8</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154727844.png" alt="image-20240917154727844"></p>
<h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><p>序列化 见 serialization.md</p>
<p> 字节流实现类<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154853819.png" alt="image-20240917154853819"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154908066.png" alt="image-20240917154908066"></p>
<p><strong>First Step</strong> 创建对象字节输出流 包装原始字节输出流:</p>
<p><code>ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream)</code></p>
<p><strong>Second Step</strong> 调用 writeObject(具体对象)方法 </p>
<p>对象的类要**<code>implements</code> <code>Serializable</code>** 接口！</p>
<p><strong>Third Step</strong> 创建对象字节输入流 包装原始字节输入流</p>
<p><code>ObjectInputStream ois = new ObjectInputStream(new FileInputStream)</code> </p>
<h4 id="拓展：对象中某些变量不想参与序列化"><a href="#拓展：对象中某些变量不想参与序列化" class="headerlink" title="拓展：对象中某些变量不想参与序列化"></a>拓展：对象中某些变量不想参与序列化</h4><p><code>private </code> <code>transient</code> <code> String password;</code> transient关键字</p>
<h4 id="拓展：一次序列化多个对象"><a href="#拓展：一次序列化多个对象" class="headerlink" title="拓展：一次序列化多个对象"></a>拓展：一次序列化多个对象</h4><p>将对象存入ArrayList中，对ArrayList进行序列化</p>
<h3 id="IO框架"><a href="#IO框架" class="headerlink" title="IO框架"></a>IO框架</h3><p>框架：把编写好的类和接口编译成class形式，压缩成.jar结尾的文件发行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917162151321.png" alt="image-20240917162151321"></p>
<h2 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h2><p>存储有关系的数据作为系统的配置文件</p>
<h3 id="properties-属性文件"><a href="#properties-属性文件" class="headerlink" title=".properties 属性文件"></a>.properties 属性文件</h3><ul>
<li>存储键值对数据</li>
<li>键不重复</li>
</ul>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917163605651.png" alt="image-20240917163605651"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建属性对象，加载文件内容</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filename));</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建字符串集合，接收属性对象返回的键集合</span></span><br><span class="line">Set&lt;String&gt; keys = properties.stringPropertyNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历键集合，通过属性对象和键找到value</span></span><br><span class="line"><span class="keyword">for</span>(String key : keys)&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">	properties.forEach((k,v)-&gt;System.out.println(k + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917164532330.png" alt="image-20240917164532330"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;dfg&quot;</span>,<span class="string">&quot;213&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;hjk&quot;</span>,<span class="string">&quot;321&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">comments</span> <span class="operator">=</span> <span class="string">&quot;I have saved many users!!!&quot;</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filename), comments);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>



<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>E<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage</p>
<p>根标签 只有一个</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170133400.png" alt="image-20240917170133400"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170306289.png" alt="image-20240917170306289"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170346202.png" alt="image-20240917170346202"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170514649.png" alt="image-20240917170514649"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917185127560.png" alt="image-20240917185127560"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917185753893.png" alt="image-20240917185753893">好</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li>系统执行信息方便记录到指定的位置（控制台，文件，数据库）</li>
<li>随时用开关控制日志启停，不需要修改源代码</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917191534986.png" alt="image-20240917191534986"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917191744756.png" alt="image-20240917191744756"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192232262.png" alt="image-20240917192232262"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192328808.png" alt="image-20240917192328808"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192715641.png" alt="image-20240917192715641"></p>
<p><code>&lt;pattern&gt; &lt;/pattern&gt;</code> 日志格式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192956963.png" alt="image-20240917192956963"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193034517.png" alt="image-20240917193034517"></p>
<p>文件拆分规则，保证每个不超过1MB，过去的压缩成1MB的gz文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193427486.png" alt="image-20240917193427486"></p>
<p>控制日志输出情况</p>
<p>日志级别 trace&lt; <strong>debug</strong> &lt; info &lt; warn &lt; error </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193721056.png" alt="image-20240917193721056"></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><ul>
<li><code>java.net.*</code></li>
</ul>
<p>CS BS架构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918155511067-1726751033487-55.png" alt="image-20240918155511067"></p>
<h2 id="网络通信基本概念"><a href="#网络通信基本概念" class="headerlink" title="网络通信基本概念"></a>网络通信基本概念</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>设备在网络的地址，唯一标识</p>
<p><strong>IPv4:</strong> 32bit 点分十进制表示法    <strong>IPv6:</strong> 128bit 冒号分16进制表示法</p>
<p><strong>域名</strong>代表IP，<strong>DNS服务器</strong>会记录域名的真实IP</p>
<p><strong>公网IP</strong>：链接互联网 <strong>内网IP</strong>：局域网，内部使用</p>
<p>**<code>localhost = 127.0.0.1</code>**：代表本机IP，只会寻找当前所在的主机</p>
<p><strong><code>ping IP地址</code></strong> </p>
<h4 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h4><p>常用方法：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918160540846-1726751033487-56.png" alt="image-20240918160540846"></p>
<p><code>getByName()</code>: 根据主机名 返回IP地址对象</p>
<p><code>isReachable(int ms)</code> 相当于ping命令</p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>端口，应用程序在设备的地址，唯一标识</p>
<p>16bit 0-65535</p>
<p>0-1023: 预定义占用，周知端口</p>
<p>1024-49151: 注册端口</p>
<p>49152-65535: 动态分配</p>
<p>同一设备不能有两个程序的端口号一样</p>
<h3 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h3><p>协议，应用程序之间进行通信的规则</p>
<p>OSI 网络参考模型</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161423219-1726751033487-57.png" alt="image-20240918161423219"></p>
<p>TCP/IP 事实上的国际标准</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p><strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161816467-1726751033487-58.png" alt="image-20240918161816467"></p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p><strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161923650-1726751033487-59.png" alt="image-20240918161923650"></p>
<h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>第一次握手：客户端发消息，服务器收到消息，服务器知道客户端发消息没问题。</p>
<p>第二次握手：服务端发消息，客户端收到消息，客户端知道服务端收消息没问题，发消息也没问题。</p>
<p>第三次握手：客户端根据上一次握手的内容再次发出确认信息，服务器端收到信息，说明客户端收消息没问题。</p>
<p>全双工：双方都要确认对方同时具备收发信息的能力</p>
<p>不可靠信道上实现可靠的传输</p>
<p><strong>B 收到了 A 发来的消息，B 因此判断 A 具备发送能力</strong>：</p>
<ul>
<li>这个理解是正确的。当 B 收到 A 发送的 <code>SYN</code> 报文时，B 可以判断 A 具有发送消息的能力。A 通过发送 <code>SYN</code> 表示自己希望建立连接，并告诉 B 自己的初始序列号。</li>
<li>但需要注意的是，B 仅能判断 A 能发送数据，尚无法确定 A 能正确接收 B 发送的消息（即 A 的接收能力）。</li>
</ul>
<p><strong>A 收到了 B 发回的消息，A 判断 B 具备收发信息能力</strong>：</p>
<ul>
<li><strong>发送能力</strong>：正确。当 A 收到 B 发回的 <code>SYN-ACK</code> 消息后，A 可以确认 B 具备发送能力，因为 B 能够发送 <code>SYN-ACK</code> 报文。</li>
<li><strong>接收能力</strong>：A 也可以推断 B 具备接收能力，因为 B 不仅发送了 <code>SYN-ACK</code>，还包含了对 A 的 <code>SYN</code> 的确认（<code>ACK</code>），说明 B 成功接收了 A 的 <code>SYN</code> 报文。</li>
<li>因此，通过 B 的 <code>SYN-ACK</code> 报文，A 可以确认 B 既能够发送，也能够接收消息。</li>
</ul>
<p><strong>B 收到了 A 发回的信息，B 因此判断 A 具备接收能力，连接建立</strong>：</p>
<ul>
<li>这个理解也基本正确。当 B 收到 A 的 <code>ACK</code> 报文后，B 可以确认 A 的接收能力，因为 A 收到了 B 的 <code>SYN-ACK</code> 并发回了 <code>ACK</code>。如果 A 无法接收数据，就无法正确回应 B 的 <code>SYN-ACK</code> 报文。</li>
<li>至此，B 确定 A 既能发送也能接收，双方通信能力都得到确认，连接可以正式建立。</li>
</ul>
<ul>
<li>在 TCP 三次握手过程中，双方都通过序列号和确认号来确认彼此的发送和接收能力，确保连接是双向可靠的。</li>
<li>三次握手的过程确保了双方的<strong>发送能力</strong>和<strong>接收能力</strong>都正常，连接才会被建立。</li>
<li>你对各个步骤的理解是对的，只需要记住，每一步都不仅仅是确认对方的发送能力，还需要通过确认号和响应确认对方的接收能力。</li>
</ul>
<h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><ol>
<li>客户端发完数据，发出断连请求</li>
<li>服务器还没处理完最后的数据，先发一个消息，让客户端稍等</li>
<li>处理完数据后，服务器再发一个消息确认断开连接</li>
<li>客户端正式断开连接</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918213236026-1726751033487-61.png" alt="image-20240918213236026"></p>
<h2 id="Java-UDP"><a href="#Java-UDP" class="headerlink" title="Java UDP"></a><a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=com.it.netTest.UDP.Client">Java UDP</a></h2><ul>
<li><code>java.net.DatagramSocket</code> <code>java.net.DatagramPacket</code> </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918213602137-1726751033487-60.png" alt="image-20240918213602137"></li>
<li>创建DS对象，创建DP对象用于封装数据，DP对象里有字节数组，字节数组长度，目标IP,目标端口，客户端调用send方法发送数据包。</li>
<li>创建DS对象(端口号)，创建DP对象用于接收数据，DP对象里的数组长度64KB，然后服务段调用receive方法接收数据包。数据包调用getLength方法获取实际接收数据包的大小，以便正确输出数据包内数组的内容。</li>
<li>getAddress()可以拿到客户端IP地址</li>
<li>getPort()可以拿到客户端端口</li>
</ul>
<h2 id="Java-TCP"><a href="#Java-TCP" class="headerlink" title="Java TCP"></a><a href="jetbrains://idea/navigate/reference?project=MyFirstProject&path=com/JavaSE/netTest/tcp/Server.java">Java TCP</a></h2><p><code>java.net.Socket</code> <code>java.net.ServerSocket</code></p>
<p>服务端和客户端通过<code>socket</code>对象之间建立的管道进行通信，数据通过管道也就是流进行传输，而UDP是通过发送单个<code>datagram</code>数据报的形式，不需要建立联系，不需要建立稳定的管道</p>
<ul>
<li><p>客户端：    </p>
<ul>
<li>创建<code>Socket sk = new Socket(hostname, port)</code> 数据目的地的端口号</li>
<li><code>OutputStream os = sk.getOutputStream();</code> 把<code>socket</code>的流拿到</li>
<li><code>DataOutputStream dos = new DataOutputStream(os)</code> 对原始的流进行包装</li>
<li><code>dos.writeUTF(&quot;String sth&quot;)</code> </li>
<li>关闭<code>dos</code> 关闭<code>socket</code> </li>
</ul>
</li>
<li><p>服务端</p>
<ul>
<li>创建 <code>ServerSocket ss = new ServerSocket( port)</code> 注册端口，跟客户端里面的端口一样</li>
<li><code>Socket socket = ss.accept()</code> 等待客户端发来socket连接请求，端到端，这两个socket内容其实是一样的。</li>
<li><code>DataInputStream dis = new DataInputStream(socket.getInputStream());</code>用数据流包装原始的输入流</li>
<li><code>dis.readUTF().sout</code></li>
</ul>
</li>
</ul>
<p>支持一发一收 多发多收，因为只能是一个socket对应一个socket，是端到端的，要实现跟其他socket的通信只能断开连接，所以引入多线程，接到socket就开一个新线程，继续监听socket，用while循环实现。</p>
<p>要实现群聊，服务器可以用一个集合储存socket，如果某个socket收到了消息，就遍历集合发给所有socket（同客户端的发送代码）客户端建立socket对象之后，在while循环内部出不来，要监听</p>
<p>BrowserServer架构 Server要提供的内容必须符合HTTP规范</p>
<h1 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919211712463.png" alt="image-20240919211712463"></p>
<p>检测抛出异常</p>
<h2 id="断言机制"><a href="#断言机制" class="headerlink" title="断言机制"></a>断言机制</h2><p>Assert.assertEquals() bug提示 <strong>期望值</strong> 实际值 </p>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>可以一键进行所有测试，一键自动化测试</p>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>@Test 测试方法</p>
<p>@Before(BeforeEach) 每个测试前要跑的方法</p>
<p>@BeforeClass(All) 修饰静态方法，所有测试方法之前，最先 这两个是初始化</p>
<p>@After(AfterEach) 每个测试执行完要跑的方法</p>
<p>@AfterClass(All) 修饰静态方法，所有测试方法之后，最后 这两个是释放资源</p>
<p>如果是每一个测试方法都需要一个独立的资源，就用before</p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h2><p>让其他程序根据注解来决定怎么执行该程序</p>
<p><code>@Override</code>:让IDE判断方法是否重写成功 </p>
<p><code>@Test</code>: 让测试框架知道这个是测试方法</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest1&#123;</span><br><span class="line">    String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">    String[] ccc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value 属于特殊属性，可以只写值</span></span><br><span class="line"><span class="comment">//有 default 可以不用赋值</span></span><br><span class="line"><span class="comment">//没 default 必须赋值，带变量名和等号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyTest1</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span>&#123;<span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">true</span>;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String[] ccc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质是接口，都继承了Annotation接口</p>
<p><code>@MyTest1(aaa=&quot;123&quot;,bbb=false, ccc=&#123;&quot;str&quot;,&quot;asd&quot;&#125;)</code> 是一个实现类对象</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>修饰注解的注解, 在自定义注解的上面 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919214219300.png" alt="image-20240919214219300"></p>
<h2 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919214508991.png" alt="image-20240919214508991"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>模拟框架 解析注解，然后执行 模拟<a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=org.JavaSE.AdvancedTest.Annotation.JUnitSimulator">JUnitSimulator(Toolbox 引用)</a>识别并执行有特定注解的方法</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>加载类，允许用编程的方式，解剖类中的各种成分（万物皆对象）</p>
<p>比如ide中创建一个对象，对象引用后加一个点就能显示可以调用的方法，说明这个类实现的方法已经提前加载好了</p>
<h2 id="加载方法"><a href="#加载方法" class="headerlink" title="加载方法"></a>加载方法</h2><ol>
<li><p>加载类，获取 <code>Class</code> 对象</p>
<ul>
<li><code>Class c = 类名.class</code> </li>
<li><code>Class.forName(全名)</code>  </li>
<li><code>Class c = 对象.getClass()</code> </li>
<li><code>getName() 全名带包名 getSimpleName() 简名</code></li>
<li><code>getMethod() getConstructor() getField()</code> </li>
</ul>
</li>
<li><p>获取类的构造器 <code>Constructor</code> 对象，主调是 <code>Class 对象</code></p>
<ul>
<li><code>getConstructors</code> 只有 public <strong>返回数组</strong></li>
<li><code>getDeclaredConstructors</code> 存在就能拿到</li>
<li><code>getConstructor(形参的类型对象)</code> 只有public 拿一个</li>
<li><code>getDeclaredConstructor(形参的类型对象)</code> 存在就能拿到 拿1个</li>
</ul>
<ul>
<li>下面的主调是构造器对象</li>
<li><code>getParameterCount</code>几个参数</li>
<li><code>newInstance(...参数)</code> 返回<code>object</code> 强转为对象，如果私有构造器会报错</li>
<li><code>setAccessible(true)</code> 暴力反射，禁止检查访问权限</li>
</ul>
</li>
<li><p>获取类的成员变量 <code>Field</code> 对象</p>
<ul>
<li><code>getFields</code> <code>getDeclaredFields</code> </li>
<li><code>getField(name)</code> <code>getDeclaredField(name)</code></li>
<li>下面主调是<code>Field</code>对象</li>
<li><code>set(对象, 值)</code> <code>get(对象)</code> 赋值 取值</li>
<li><code>setAccessible</code> 暴力反射</li>
</ul>
</li>
<li><p>获取类的成员方法 <code>Method</code> 对象</p>
<ul>
<li><code>getMethods</code> <code>getDeclaredMethods</code></li>
<li><code>getMethod(name, String.class, int.class) </code>返回值</li>
<li>下面主调是<code>method</code></li>
<li><code>getName getParameterConut getReturnType</code></li>
<li><code>invoke(对象, 参数)</code> 返回object 强转为返回值类型</li>
<li><code>setAccesible</code></li>
</ul>
</li>
</ol>
<h2 id="作用、应用场景"><a href="#作用、应用场景" class="headerlink" title="作用、应用场景"></a>作用、应用场景</h2><ul>
<li>得到类的全部成分</li>
<li>破坏封装性</li>
<li>做框架</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920001226903.png" alt="image-20240920001226903"></p>
<p>接收任意对象，接到对象，用反射获取class对象，获取全部成员变量，遍历他们，把他们的属性写出到文件中</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>框架的核心技术，一个类有很多方法，需要加载资源，而代理可以代替类执行这些操作。</p>
<p>Spring AOP技术使用了JDK动态代理和CGLIB动态代理两种方式，在不改变原始方法的前提下对功能进行增强。</p>
<h2 id="JDK-动态代理——反射"><a href="#JDK-动态代理——反射" class="headerlink" title="JDK 动态代理——反射"></a>JDK 动态代理——反射</h2><ul>
<li>JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>（兄弟两个拜把子模式），目标对象和代理对象是平等地位的。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920112517946.jpg" alt="image-20240920112517946"></p>
<p>对于一个UserServiceImpl，要生成它的代理对象，为了能创建一个跟UserServiceImpl拥有同名方法的代理Proxy，<mark>这个类必须实现一个接口UserService，并且拥有Impl的全部方法<mark>，然后把Impl传给生成代理的方法。</p>
<p>接口能将原来的实现对象的方 法抽象化（或者部分抽象） 方便代理进行重写，代理重写完具体的执行逻辑，返回的还是这个接口的实现对象，相当于是把原来的实现对象包装了一下，完美地把对象的职责转移到了代理身上，业务对象。减少代码冗余和多余的资源调用</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023232822938.png" alt="image-20241023232822938"></p>
<h2 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h2><p>通过<strong>继承被代理的目标类</strong>（认干爹模式）实现代理，所以不需要目标类实现接口。</p>
<p><strong>CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，并在子类中采用方法拦截的技术拦截父类所有的方法调用，进而织入横切逻辑，</strong> 目标对象是代理对象的父类。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib-nodeps<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023232711967.png" alt="image-20241023232711967"></p>
<h1 id="Hutool-Usage"><a href="#Hutool-Usage" class="headerlink" title="Hutool Usage"></a>Hutool Usage</h1><h2 id="BeanUtil"><a href="#BeanUtil" class="headerlink" title="BeanUtil"></a>BeanUtil</h2><h3 id="bean和Map转换"><a href="#bean和Map转换" class="headerlink" title="bean和Map转换"></a>bean和Map转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt;BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                 CopyOptions.create().setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));</span><br><span class="line"></span><br><span class="line">BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(),<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="JSONUtil"><a href="#JSONUtil" class="headerlink" title="JSONUtil"></a>JSONUtil</h2><h3 id="JSON和对象互转"><a href="#JSON和对象互转" class="headerlink" title="JSON和对象互转"></a>JSON和对象互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line"></span><br><span class="line">shop = JSONUtil.toBean(jsonStr,Shop.class);</span><br></pre></td></tr></table></figure>

<h3 id="JSON和数组互转"><a href="#JSON和数组互转" class="headerlink" title="JSON和数组互转"></a>JSON和数组互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonArrayStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(list);</span><br><span class="line"></span><br><span class="line"><span class="type">JSONArray</span> <span class="variable">jsonArray</span> <span class="operator">=</span> JSONUtil.parseArray(jsonArrayStr);</span><br><span class="line">shopTypeList = JSONUtil.toList(jsonArray, ShopType.class);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/01/spring-boot-starter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/01/spring-boot-starter/" class="post-title-link" itemprop="url">自定义 starter</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-01T00:00:00+08:00">2024-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 13:06:00" itemprop="dateModified" datetime="2025-04-27T13:06:00+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><mark>在 Spring Boot 生态中，“Starter” 本质上就是一组依赖的“捆绑包”，它的目标是让使用方 <strong>一行依赖</strong> 就把启动一个完整的 Spring Boot 应用所需的所有东西都拉过来。</mark> </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/10/01/spring-boot-starter/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/30/MySQL%20%E5%9F%BA%E7%A1%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/30/MySQL%20%E5%9F%BA%E7%A1%80%E7%AF%87/" class="post-title-link" itemprop="url">MySQL 基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-30T00:00:00+08:00">2024-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:50:10" itemprop="dateModified" datetime="2025-05-05T11:50:10+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>DB</strong>: organized data</p>
<p><strong>DBMS</strong>: manage system</p>
<p><strong>RDBMS</strong>: SQLite PostgreSQL MySQL Oracle Microsoft SQL Server (relational)</p>
<p><strong>SQL</strong>: programming language</p>
<p><strong>数据模型</strong>：管理系统：数据库：表：数据</p>
<p><strong>RDBMS</strong>: 表结构格式统一</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920142153024.png" alt="image-20240920142153024"></p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923202742353.png" alt="image-20240923202742353"></p>
<p>auto_increment 从零开始自动增长 (列是数字的类型，并且是UNIQUE约束)</p>
<p> 这一列不指定id，或者id赋值null 不影响自增</p>
<h3 id="非空，唯一，主键，默认，检查约束"><a href="#非空，唯一，主键，默认，检查约束" class="headerlink" title="非空，唯一，主键，默认，检查约束"></a>非空，唯一，主键，默认，检查约束</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220639875.png" alt="image-20240923220639875"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220734860.png" alt="image-20240923220734860"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220750052.png" alt="image-20240923220750052"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220711866.png" alt="image-20240923220711866"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154832392.png" alt="image-20241005154832392"></p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>数据一致性 完整性</p>
<p>外键：连接两个表的数据</p>
<ul>
<li>（<strong>constraint</strong> foreKeyCons）<strong>foreign key</strong>(dept_id) <strong>references</strong> dept(id) 建表时</li>
<li>给当前表中的dept_id列定义了一个 名为 foreKeyCons 的外键约束，外键引用dept表的id列，dept_id就是外键</li>
<li>dept就是主表，必须存在，并且id是主键</li>
<li>因为有外键约束，所以不能直接删除主表的内容，</li>
</ul>
<p>建表以后对外键的操作：添加和删除。外键属于表的属性</p>
<ul>
<li><strong>alter table</strong> emp <strong>drop foreign key</strong> foreKeyCons</li>
<li><strong>alter table</strong> emp <strong>add constraint</strong> foreKeyCons <strong>foreign key</strong>(dept_id) <strong>references</strong> dept(id)</li>
</ul>
<h4 id="外键的删除、更新行为"><a href="#外键的删除、更新行为" class="headerlink" title="外键的删除、更新行为"></a>外键的删除、更新行为</h4><p>on update 更新   on delete 删除</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005155438576.png" alt="image-20241005155438576"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005155543394.png" alt="image-20241005155543394"></p>
<p>NOACTION RESTRICT 默认</p>
<p>CASCADE 主表变了，子表跟着变，主表删了，子表跟着没</p>
<p><strong>ON DELETE</strong> SET NULL 主表删了，子表把对应的值设为null，只支持删除操作，并且要求外键可以为null</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224354382.png" alt="image-20240923224354382"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224409160.png" alt="image-20240923224409160"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224759437.png" alt="image-20240923224759437"></p>
<p>1-M 多的一方建立外键，少的一方作为主表，连接起来</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923225452261.png" alt="image-20240923225452261"></p>
<p>M-N 一起连到一张中间表，中间表做从表，建立外键，连到两张表的主键上</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923225514320.png" alt="image-20240923225514320"></p>
<p>一个商品可能属于不同订单，一个订单也可能有不同商品，所以用类似坐标的方式</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>管理DML语句，InnoDB引擎才支持事务</p>
<p>MySQL默认设置事务自动提交，也就是执行完自动COMMIT.</p>
<p>如果要显式开启事务要SET AUTOCOMMIT = 0;（以后的事务都需要手动提交）</p>
<p>或者 START Transaction /  BEGIN （临时开启一条事务）</p>
<p>COMMIT 提交事务 如果没有问题就提交</p>
<p>ROLLBACK 回滚事务 出现异常就要回滚事务到BEGIN处，即更改前</p>
<h3 id="四大特征-acid"><a href="#四大特征-acid" class="headerlink" title="四大特征 acid"></a>四大特征 acid</h3><p>一致性依赖于应用层，开发者。</p>
<p><strong>A</strong>tomic <strong>C</strong>onsistency <strong>I</strong>solation <strong>D</strong>urability</p>
<p>最小操作单位，不可分割；</p>
<p>完成时必须让所有数据都前后一致，由开发者指定，比如转账，金钱总额不能变化；</p>
<p>多个事务是互相隔离的，排除其他事务对本事务的影响（解决并发问题）；</p>
<p>事务对数据库的修改是持久的；</p>
<p>一什么是隔离性？</p>
<p>隔离性是数据库事务的四个基本属性之一，即 <strong>ACID</strong> 特性中的 “I”（Isolation）。隔离性保证了一个事务在未完成之前，它的操作对其他事务是不可见的，或者说部分可见（取决于隔离级别）。这样可以防止因并发执行而导致的数据问题。</p>
<h3 id="高并发下可能遇到的问题："><a href="#高并发下可能遇到的问题：" class="headerlink" title="高并发下可能遇到的问题："></a>高并发下可能遇到的问题：</h3><ol>
<li><p><strong>脏读</strong>（Dirty Read）：一个事务读取了另一个事务<strong>开始了但未提交</strong>的数据。如果另一个事务回滚或者提交，这些数据将无效，导致第一个事务读取了错误数据。</p>
<ol>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005213034469.png" alt="image-20241005213034469"></li>
</ol>
</li>
<li><p><strong>不可重复读</strong>（Non-repeatable Read）：在同一个事务中，前后两次读取相同的数据时，数据值发生了变化，因为另一个事务在两次读取之间<strong>修改并提交了该数据</strong>。</p>
<ol>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005213018573.png" alt="image-20241005213018573"></li>
</ol>
</li>
<li><p><strong>幻读</strong>（Phantom Read）：一个事务内，连续两次执行相同的查询（select）时，再次进行查询的时候真实的数据集已经发生了变化，但是A却查询不出来这种变化，因此产生了幻读。</p>
<ol>
<li>如果已经解决了12，将会发现：第一次查询没有结果，随后另一个事务插入数据并进行了提交，试图插入数据，会报错，提示不能有重复的主键，但是在第二次查询仍然没有结果，读不到别人已经提交的数据（repeatable read）但是别人提交的数据还在影响。</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005214729161.png" alt="image-20241005214729161"></li>
</ol>
</li>
</ol>
<h3 id="通过隔离性解决高并发问题："><a href="#通过隔离性解决高并发问题：" class="headerlink" title="通过隔离性解决高并发问题："></a>通过隔离性解决高并发问题：</h3><p>数据库系统通常提供多种<strong>事务隔离级别</strong>，每个级别可以解决一部分或全部并发问题。这些隔离级别定义了事务之间可见性规则，数据库可以根据应用场景选择适当的隔离级别来权衡性能与数据一致性。</p>
<p><code>select @@transaction_isolation</code> 查看当前的隔离级别</p>
<p><code>set session transaction isolation level read uncommitted</code>设置当前会话的隔离级别，</p>
<h3 id="SQL-标准定义的四种隔离级别"><a href="#SQL-标准定义的四种隔离级别" class="headerlink" title="SQL 标准定义的四种隔离级别"></a>SQL 标准定义的四种隔离级别</h3><ol>
<li><strong>读未提交（Read Uncommitted）</strong>：<ul>
<li><strong>脏读</strong>、<strong>不可重复读</strong> 和 <strong>幻读</strong> 都可能发生。</li>
<li>最低的隔离级别，事务可以读取未提交的数据。</li>
<li>使用场景：极高并发要求且对数据一致性要求不高的场景。</li>
</ul>
</li>
<li><strong>读已提交（Read Committed）</strong>：Oracle 默认<ul>
<li>解决脏读问题，但仍然可能出现不可重复读和幻读。</li>
<li>一个事务只能读取已提交的数据，保证不会读取到未提交的修改。</li>
<li>使用场景：大多数数据库系统的默认隔离级别，较好的性能和数据一致性的平衡。</li>
</ul>
</li>
<li><strong>可重复读（Repeatable Read）</strong>：MySQL 默认<ul>
<li>解决脏读和不可重复读问题，但幻读仍然可能发生。</li>
<li>在同一事务中，事务两次读取相同的数据，保证两次读取的结果一定相同。不会读取其他事务已经提交的数据，但是仍然无法避免其他事务的影响（比如重复插入相同主键失败但是查不到这条主键的数据）</li>
<li>使用场景：需要保证数据一致性、避免更新数据不一致的场景。</li>
<li>普通的select快照读不会受到其他事务update、insert的影响，但是自己执行update时会进行当前读，会把其他事务update、insert的数据更新成自己的版本号，下一次读取就会读到了。</li>
<li>幻读：尽管B事务在A事务还未结束的时候，增加了表中的数据，但是为了维护可重复读，A事务中不管怎么查询，是查询不到新增的数据的。但是对于真实的表而言，表中的数据是的的确确增加了，所以插入重复的主键会报错。</li>
</ul>
</li>
<li><strong>串行化（Serializable）</strong>：<ul>
<li>解决脏读、不可重复读和幻读问题。</li>
<li>最高的隔离级别，所有事务串行执行，完全避免并发导致的数据问题。要等先开始的事务执行完提交或者回滚，后开始的事务才能开始执行，完全放弃并发性。</li>
<li>使用场景：极端数据一致性要求的场景，但代价是性能较低，容易出现锁等待甚至死锁。</li>
</ul>
</li>
</ol>
<h3 id="隔离性和并发控制的关系"><a href="#隔离性和并发控制的关系" class="headerlink" title="隔离性和并发控制的关系"></a>隔离性和并发控制的关系</h3><ul>
<li><strong>锁机制</strong>：隔离性通常通过锁机制（例如行锁、表锁）实现。在高隔离级别下（如可串行化），数据库会使用更严格的锁定策略，确保其他事务在未提交前不能读取或修改被锁定的数据。</li>
<li>**多版本并发控制 (MVCC)**：有些数据库（如 PostgreSQL、MySQL 的 InnoDB 存储引擎）采用了多版本并发控制，允许在较高隔离级别下提高性能。MVCC 通过保存数据的多个版本，允许读取操作无需阻塞写入操作，从而在高并发下仍然能够提供一致的数据读取。</li>
</ul>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="通用语法"><a href="#通用语法" class="headerlink" title="通用语法"></a>通用语法</h3><ul>
<li>可以多行书写，分号结尾</li>
<li>可用空格和缩进增强可读性</li>
<li>MySQL的SQL语句不区分大小写，关键字建议大写</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>DDL definition 定义数据库对象(表、db，字段)</p>
<p>DML manipulation 操作数据，增删改</p>
<p>DQL query 查询</p>
<p>DCL control 创建用户，控制访问权限</p>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>control 控制数据库访问权限和管理数据库用户</p>
<h4 id="DCL-用户管理"><a href="#DCL-用户管理" class="headerlink" title="DCL-用户管理"></a>DCL-用户管理</h4><p>use mysql;</p>
<p>select * from user;</p>
<ul>
<li><p>创建用户 <strong>create user</strong> ‘itcast‘<strong>@</strong>‘localhost’ <strong>identified by</strong> ‘123456’ 密码123456用户名itcast 主机localhost</p>
</li>
<li><p>创建用户 <strong>create user</strong> ‘heima‘<strong>@</strong>‘%’ <strong>identified by</strong> ‘123456’ 密码123456用户名heima  任意主机均可访问</p>
</li>
<li><p>改密码 alter user ‘heima‘<strong>@</strong>‘%’ <strong>identified with</strong> mysql_native_password by ‘1234’ 改成1234</p>
</li>
<li><p>drop user ‘heima‘<strong>@</strong>‘%’  删除用户</p>
</li>
</ul>
<h4 id="DCL-控制权限"><a href="#DCL-控制权限" class="headerlink" title="DCL - 控制权限"></a>DCL - 控制权限</h4><ul>
<li>查询有什么权限：SHOW GRANTS FOR 用户@主机</li>
<li>授予用户权限：grant all on 数据库名.表名 to 用户@主机</li>
<li>撤销用户权限：revoke all on 数据库名.表名 from 用户@主机</li>
</ul>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="数据库操作-database"><a href="#数据库操作-database" class="headerlink" title="数据库操作-database"></a>数据库操作-database</h4><ul>
<li><code>SHOW DATABASES;</code> 查询所有数据库（展示）</li>
<li><code>SELECT DATABASE();</code> 查询当前数据库（展示）</li>
<li><code>CREATE DATABASE if not exists name;</code>如果不存在则创建一个名为 name 的数据库，后面可以加<code>default charset + 字符集</code> <code>COLLATE 排序规则</code></li>
<li><code>DROP DATABASE IF EXISTS;</code> 如果存在则删除</li>
<li><code>USE name;</code> 使用名为name的数据库</li>
</ul>
<h4 id="表操作-查询-table"><a href="#表操作-查询-table" class="headerlink" title="表操作-查询 table"></a>表操作-查询 table</h4><ul>
<li><code>SHOW TABLES; </code> </li>
<li><code>DESC 表名;</code> 查询表结构</li>
<li><code>SHOW CREATE TABLE 表名;</code> 查询建表时候的信息</li>
</ul>
<h4 id="表操作-创建-table"><a href="#表操作-创建-table" class="headerlink" title="表操作-创建 table"></a>表操作-创建 table</h4><ul>
<li><p>```sql<br>use itcast;<br>create table tb_user(</p>
<pre><code>id int comment &#39;编号&#39;,
name varchar(50) comment &#39;姓名&#39;,
age int comment &#39;年龄&#39;,
gender varchar(1) comment &#39;性别&#39;
) comment &#39;用户表&#39;;
</code></pre>
<p>desc tb_user;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 表操作- 数据类型</span><br><span class="line"></span><br><span class="line">##### 数值类型：</span><br><span class="line"></span><br><span class="line">TINYINT-byte   SMALLINT-short MEDIUMINT-3 bytes INT/INTEGER-int </span><br><span class="line"></span><br><span class="line">BIGINT-long  FLOAT DOUBLE DECIMAL </span><br><span class="line"></span><br><span class="line">TINYINT UNSIGNED(0-255) 无符号的tinyint</span><br><span class="line"></span><br><span class="line">DOUBLE(4,1)4代表总位数 1代表小数部分的位数 </span><br><span class="line"></span><br><span class="line">##### 字符串类型：</span><br><span class="line"></span><br><span class="line">![image-20240920183842122](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920183842122.png)</span><br><span class="line"></span><br><span class="line">|          | char(10)     | varchar(10) |</span><br><span class="line">| -------- | ------------ | ----------- |</span><br><span class="line">| 最小长度 | 10           | 0           |</span><br><span class="line">| 最大长度 | 10           | 10          |</span><br><span class="line">| eg       | 性别、手机号 | 用户名      |</span><br><span class="line"></span><br><span class="line">##### 日期类型</span><br><span class="line"></span><br><span class="line">![image-20240920184425055](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920184425055.png)</span><br><span class="line"></span><br><span class="line">![image-20240926153912988](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926153912988.png)</span><br><span class="line"></span><br><span class="line">![image-20240926153925471](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926153925471.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 表操作-修改表属性</span><br><span class="line"></span><br><span class="line">**alter table** employee **add** nickname varchar(20) [comment] [约束]; **添加属性**</span><br><span class="line"></span><br><span class="line">**alter table** employee **modify** nickname char(20); **修改数据类型**</span><br><span class="line"></span><br><span class="line">**alter table** employee **change** nickname idCard char(18) [comment] [约束]; **改名字+数据类型** </span><br><span class="line"></span><br><span class="line">**alter table** employee **drop** nickname; **删除** </span><br><span class="line"></span><br><span class="line">**alter table** employee **rename to** emp; **改表名**  </span><br><span class="line"></span><br><span class="line">#### 表操作-删除</span><br><span class="line"></span><br><span class="line">**drop table** [if exists] 表名;   **删除整个表**</span><br><span class="line"></span><br><span class="line">**truncate table** 表名; **删除数据不删表结构**</span><br><span class="line"></span><br><span class="line">#### MySQL GUI</span><br><span class="line"></span><br><span class="line">SQLyog Navicat DataGrip</span><br><span class="line"></span><br><span class="line">### DML</span><br><span class="line"></span><br><span class="line">INSERT UPDATE DELETE </span><br><span class="line"></span><br><span class="line">#### 添加数据</span><br><span class="line"></span><br><span class="line">**insert into** 表名(属性1，属性2....) **values**（v1,v2...）指定属性</span><br><span class="line"></span><br><span class="line">**insert into** 表名 **values**（v1,v2...）所有</span><br><span class="line"></span><br><span class="line">字段和值一一对应，字符串和日期在单引号中</span><br><span class="line"></span><br><span class="line">**多条数据**: **values**</span><br><span class="line"></span><br><span class="line">​		（v1,v2...）,</span><br><span class="line"></span><br><span class="line">​		(v1,v2....) 不同条数据用逗号隔开</span><br><span class="line"></span><br><span class="line">#### 修改数据</span><br><span class="line"></span><br><span class="line">**update** employee **set** name = &#x27;itheima&#x27; **where** id=1;</span><br><span class="line"></span><br><span class="line">#### 删除数据</span><br><span class="line"></span><br><span class="line">**delete from** 表名 [where 条件] 无条件会删除整张表格的数据</span><br><span class="line"></span><br><span class="line">### DQL</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line"></span><br><span class="line">#### 基本查询</span><br><span class="line"></span><br><span class="line">##### 查询多个字段 </span><br><span class="line"></span><br><span class="line">**select** 字段1，字段2........ **from** 表名</span><br><span class="line"></span><br><span class="line">**select * from** 表名       通配符</span><br><span class="line"></span><br><span class="line">##### 设置别名</span><br><span class="line"></span><br><span class="line">**select** 字段1[**as** 别名1]，字段2[**as** 别名2].... **from** 表名 as可省略</span><br><span class="line"></span><br><span class="line">##### 去重</span><br><span class="line"></span><br><span class="line"> **select distinct** ........</span><br><span class="line"></span><br><span class="line">#### 条件查询 WHERE</span><br><span class="line"></span><br><span class="line">![image-20240920211218098](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920211218098.png)</span><br><span class="line"></span><br><span class="line">**select * from** employ where age **in**(12,45,43);</span><br><span class="line"></span><br><span class="line">**select * from** employ where name **like &#x27;__&#x27;**; 名字是两个字符  模糊查询 模糊匹配</span><br><span class="line"></span><br><span class="line">##### sql 模糊查询</span><br><span class="line"></span><br><span class="line">通配符：</span><br><span class="line"></span><br><span class="line">- %: %网% 查询含有网字的数据</span><br><span class="line"></span><br><span class="line">  ​     %网    查询以网字结尾的数据</span><br><span class="line"></span><br><span class="line">  ​      %网%车    查询含有 网 和 车的数据 有先后顺序</span><br><span class="line"></span><br><span class="line">- _ :   网_ 网开头 长度为2个字</span><br><span class="line"></span><br><span class="line">  ​	_ _ 网 长度为3个字 最后一个字是网</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">between and </span><br><span class="line"></span><br><span class="line">in </span><br><span class="line"></span><br><span class="line">is null </span><br><span class="line"></span><br><span class="line">#### 聚合函数 </span><br><span class="line"></span><br><span class="line">![image-20240920212134476](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920212134476.png)</span><br><span class="line"></span><br><span class="line">count(*)所有行 count(age)age非空的行数</span><br><span class="line"></span><br><span class="line">作用在列数据，**null不参与运算~**</span><br><span class="line"></span><br><span class="line">select count(age) from emp where workAddress = &#x27;西安&#x27;; </span><br><span class="line"></span><br><span class="line">位于select关键字之后 可以加where条件</span><br><span class="line"></span><br><span class="line">#### 分组查询 GROUP BY &amp; HAVING</span><br><span class="line"></span><br><span class="line">group by xxx 将具有相同xxx值的行归为一组，每一组执行聚合count  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**select** gender, count(*) **from** emp **&lt;u&gt;group by&lt;/u&gt;** gender;  计算行的数量，并按照gender分组</span><br><span class="line"></span><br><span class="line">- where 分组之前过滤 </span><br><span class="line">- **having** 对分组之后的结果进行过滤</span><br><span class="line">- where 不能对聚合函数判断， having可以，要判断聚合函数就要分完组</span><br><span class="line">- 执行顺序：where&gt;聚合函数&gt;having</span><br><span class="line">- 先用where筛选个体，然后分组，再对组内执行聚合函数，执行的结果可以再用having筛选</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 排序查询 ORDER BY</span><br><span class="line"></span><br><span class="line">ASC:ascending 默认</span><br><span class="line"></span><br><span class="line">DESC:descending</span><br><span class="line"></span><br><span class="line">- 语句的最后，添加 **order by** age **asc**;</span><br><span class="line">- **order by** age **desc** , entryDate; 先按照age降序，如果age相同在按照entryDate升序</span><br><span class="line"></span><br><span class="line">#### 分页查询 LIMIT</span><br><span class="line"></span><br><span class="line">查询xx页码</span><br><span class="line"></span><br><span class="line">LIMIT 起始索引，查询记录数</span><br><span class="line"></span><br><span class="line">每页是20条，第一页的起始数据是0，第二页的20</span><br><span class="line"></span><br><span class="line">limit 0,5 第一页，一页5条记录</span><br><span class="line"></span><br><span class="line">**limit** 5 **offset** 0 第一页 limit 5 offset 20 第五页</span><br><span class="line"></span><br><span class="line">#### 执行顺序</span><br><span class="line"></span><br><span class="line">先执行from 再用where过滤，然后用group by和having指定分组以及过滤，然后执行字段的select，接着是排序，最后分页</span><br><span class="line"></span><br><span class="line">在字段名，表名后加别名，看是否报错，验证上述顺序</span><br><span class="line"></span><br><span class="line">### 多表查询</span><br><span class="line"></span><br><span class="line">#### 表关系</span><br><span class="line"></span><br><span class="line">多对多：同一个学生可以选择多门课程，同一个课程也可以被多名学生选择，如果要描述他们之间的关系，添加一张中间表，里面的外键分别对应两张表的主键。</span><br><span class="line"></span><br><span class="line">一对多：多的一方建立外键，关联到少的主键。</span><br><span class="line"></span><br><span class="line">一对一：任意一方建立外键（UNIQUE），关联到另外的主键。</span><br><span class="line"></span><br><span class="line">![image-20241005161911780](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005161911780.png)</span><br><span class="line"></span><br><span class="line">#### 链接查询 JOIN</span><br><span class="line"></span><br><span class="line">##### 消除笛卡尔积</span><br><span class="line"></span><br><span class="line">![image-20241005162327168](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005162327168.png)</span><br><span class="line"></span><br><span class="line">##### 内连接</span><br><span class="line"></span><br><span class="line">只查询A和B相交的部分</span><br><span class="line"></span><br><span class="line">**select** *e*.name,*e*.gender,*d*.dname **from** *emp e*,*dept d* ... **where**    条件 (隐式) </span><br><span class="line"></span><br><span class="line">**select** * **from** *emp* **join** *dept* on     条件（显式）</span><br><span class="line"></span><br><span class="line">##### 外连接</span><br><span class="line"></span><br><span class="line">![image-20241005163112728](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163112728.png)</span><br><span class="line"></span><br><span class="line">e.* emp的全部数据 </span><br><span class="line"></span><br><span class="line">from *A* left join B 查询*A* ∪ (A∩B)</span><br><span class="line"></span><br><span class="line">from *A* right join B 查询*B* ∪ (A∩B)</span><br><span class="line"></span><br><span class="line">##### 自链接</span><br><span class="line"></span><br><span class="line">一定要起别名</span><br><span class="line"></span><br><span class="line">![image-20241005163553452](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163553452.png)</span><br><span class="line"></span><br><span class="line">没有必要专门搞一张领导表出来，如果要实现需求就要把一张表分成两张看，a的经理id等于b的id</span><br><span class="line"></span><br><span class="line">![image-20241005163805094](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163805094.png)</span><br><span class="line"></span><br><span class="line">##### 外键？连接查询？</span><br><span class="line"></span><br><span class="line">在多表查询中，**连接查询**（JOIN）并不强制要求外键的存在。外键的作用是维护表之间的**参照完整性**，确保一张表中的某些值对应另一张表中的有效值。但在进行连接查询时，只要有可以用于关联两个表的字段（如主键和某个相应的列），就可以进行查询，而不需要一定设置外键。</span><br><span class="line"></span><br><span class="line">#### 联合查询</span><br><span class="line"></span><br><span class="line">把两条单表查询结果联合起来，字段数量必须一致</span><br><span class="line"></span><br><span class="line">UNION：自动根据主键去重</span><br><span class="line"></span><br><span class="line">UNION ALL: 不去重</span><br><span class="line"></span><br><span class="line">#### 子查询 按返回值分类</span><br><span class="line"></span><br><span class="line">##### **单行单列**：只返回一个**值** </span><br><span class="line"></span><br><span class="line">- ![image-20241005165024271](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165024271.png)</span><br><span class="line"></span><br><span class="line">##### **单行多列**：返回的是一行数据</span><br><span class="line"></span><br><span class="line">- ![image-20241005S171121759](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005171121759.png)![image-20241005171132602](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005171132602.png)</span><br><span class="line"></span><br><span class="line">- 第一步返回的是**一行两列**的数据（salary，managerid），第二步的条件可以用where (salary, managerid) = 第一行的结果</span><br><span class="line"></span><br><span class="line">- &lt;a href=&quot;#extension&quot;&gt;多行多列扩展&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### **多行单列**：子查询返回的是多行单列的数据</span><br><span class="line"></span><br><span class="line">也就是同一个字段的值的集合，用括号括起来，最后查询可以如下操作符（操作对象是同一字段的值的集合）</span><br><span class="line"></span><br><span class="line">- in **等于**集合内部的某一个值</span><br><span class="line"></span><br><span class="line">- any/some **大于** any 只需大于最小值 小于any只需小于最大值**相当于存在量词∃** </span><br><span class="line">- all **相当于全称量词∀**</span><br><span class="line"></span><br><span class="line">- ![image-20241005165513314](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165513314.png)</span><br><span class="line">- ![image-20241005165204726](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165204726.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **多行多列**： 虚拟表</span><br><span class="line"></span><br><span class="line">子查询返回的是多行多列数据，也就是虚拟表，从这张虚拟表中再和其他表进行连接查询。</span><br><span class="line"></span><br><span class="line">- **虚拟表**: 查询入职日期 在2011-11-11之后的员工信息和部门信息：先查入职在2011-11-11之后的员工信息，根据这些信息（虚拟表,也叫临时表）和部门表 连接查询</span><br><span class="line"></span><br><span class="line">  - ```sql</span><br><span class="line">    SELECT * FROM (select * from emp where join_date&gt;&#x27;2011-11-11&#x27;)e JOIN dept on e.dep_id = dept.id</span><br></pre></td></tr></table></figure></li>
<li><p><span id="extension"><strong>也可以作为单行多列的扩展</strong></span> in 关键字</p>
<ul>
<li>查询第一步返回的是<strong>多行多列</strong>的数据（salary，managerid），第二步的条件可以用where (salary, managerid) in 第一行的结果</li>
</ul>
</li>
</ul>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可以直接被另一段程序调用的程序或代码——-常见MySQL内置函数</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>concat substring TRIM upper </p>
<p>LPAD(STR, 6, ‘0’) 左对齐，6位补0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154345722.png" alt="image-20241005154345722"></p>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>ceil floor round rand（0-1随机数）mod</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154156390.png" alt="image-20241005154156390"></p>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>date_add now curdate curtime datediff</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154146380.png" alt="image-20241005154146380"></p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153559225.png" alt="image-20241005153559225"></p>
<p><code>if(expr, caseTrue, caseFalse) expr = true</code> 返回caseTrue</p>
<p><code>ifnull(v1,v2)</code> v1=null 返回v2 空字符串不是null，null必须是什么都没有，v1不为null，则返回v1</p>
<p>case when</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153230584.png" alt="image-20241005153230584"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153515232.png" alt="image-20241005153515232"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/20/408-%E8%AE%A1%E7%BB%84-CPU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/20/408-%E8%AE%A1%E7%BB%84-CPU/" class="post-title-link" itemprop="url">数的运算 CPU 指令系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-20T00:00:00+08:00">2024-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 12:43:11" itemprop="dateModified" datetime="2025-05-05T12:43:11+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数和运算"><a href="#数和运算" class="headerlink" title="数和运算"></a>数和运算</h1><h2 id="无符号和有符号数"><a href="#无符号和有符号数" class="headerlink" title="无符号和有符号数"></a>无符号和有符号数</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>寄存器位数就等于无符号数的位数</p>
<h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><p>符号位+数值位</p>
<p>机器数是机器中的表示方法，真值就是真实的值。比如真值为+1，机器数就是00001(四位二进制+符号位)</p>
<h4 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706213908812.png" alt="image-20240706213908812"></p>
<p>7的原码 0111 真值共3位</p>
<p>-5的原码先取反5即101，再加2^3^ 1101，n是数据位数</p>
<p>本质是带符号的绝对值，符号被数字化，小数如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706220258001.png" alt="image-20240706220258001"></p>
<p>问题：<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706220732148.png" alt="image-20240706220732148"></p>
<p>能否找到一个与负数等价的正数，代替这个负数，使的加这个负数就等于加她的等价正数？</p>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>补的概念</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706221056891.png" alt="image-20240706221056891"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706221538615.png" alt="image-20240706221538615"></p>
<p>加负数等于加他的补数</p>
<p>两个互为补数的数加<strong>模</strong>仍然互为补数</p>
<p>所以正数的补数就是他本身</p>
<p>但是此时有一个问题，没法区分是正还是负，所以再加一个符号位，用32为模</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706221948440.png" alt="image-20240706221948440"></p>
<p>-1011+100000 = 1 0101</p>
<p>1011+ 100000 = 0 0101</p>
<p>-1011加一个模变成0101，但区分不出来，所以再加一个模，变成1 0101 能区分了</p>
<p>==定义：== <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706222619681.png" alt="image-20240706222619681">  </p>
<p>x表示真值。n是整数的位数，踢去符号位。</p>
<p>原码表示2+（-2）:0,0000010+1,0000010=1,0000100 得-4，显然不对</p>
<p>如果用反码表示，还是不对，但是离正确结果很近了，只需要加1</p>
<p>所以-2应该是11111111的写法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707145106425.png" alt="image-20240707145106425"></p>
<p>整数的补码：0只有1种表示形式，所以补码能多表示一个-8</p>
<p>小数的补码：0只有1种表示形式，所以补码能多表示一个-1</p>
<h4 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h4><p>只是符号位和补码不同</p>
<h2 id="定点数和浮点数"><a href="#定点数和浮点数" class="headerlink" title="定点数和浮点数"></a>定点数和浮点数</h2><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><p>约定小数点位置</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707151032925.png" alt="image-20240707151032925"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707154943326.png" alt="image-20240707154943326"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707155019121.png" alt="image-20240707155019121"></p>
<p>记住一点：补码就是能比原码多表示一个数，用四位举例，原码1111=-0.875，变成补码就是1001了，此时还剩下一个1000没有对应的，那就让他对应-1好了。四位的整数同理，原码只能表示-7到7，因为由正零和负零，如果变成补码就能多表示一个，就让多出来的1000表示-8</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><strong>为什么</strong></p>
<p>相差太大需要很长的机器字长</p>
<p><strong>表示方法</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707151550652.png" alt="image-20240707151550652"></p>
<p>定点数(尾数) + 阶码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707151813019.png" alt="image-20240707151813019"></p>
<p><strong>表示范围</strong></p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707164938752.png" alt="image-20240707164938752"></p>
<p>下溢：0，上溢：错误</p>
<p>表示±3w的十进制数，阶符数符各一位，要搞清楚，尾数就是0.xxxxx，绝对值永远是小于1的，那么要想让N表示±3w，r^j^ 必须是3w+ 所以j阶码长度占4位，保证最大精度，剩下的全是尾数</p>
<p><strong>规格化</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707170216760.png" alt="image-20240707170216760"></p>
<p>为什么规格化？</p>
<p>r=2时，尾数如果最高位是0，就不算最简，通过阶码的变动仍然能让其变成更简</p>
<p>r=4时，尾数如果最高位是00，通过阶码变动仍然能让其变得更加简单</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707170942873.png" alt="image-20240707170942873"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707171601554.png" alt="image-20240707171601554"></p>
<p>二进制定点：整数在最后，小数在第一位后面</p>
<p>二进制浮点：规格化形式，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707172237122.png" alt="image-20240707172237122"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707152838351.png" alt="image-20240707152838351"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707153900149.png" alt="image-20240707153900149"></p>
<p>Explicit </p>
<p>符号位+ Exponent（阶码） +尾数</p>
<p><strong>机器0</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707172436375.png" alt="image-20240707172436375"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47713503/article/details/108699001">IEEE 754</a><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707172703934.png" alt="image-20240707172703934"></p>
<p>r=2,所以把1隐含掉</p>
<p>8位移码：0~128~255 分别对应真值-128~0~127 </p>
<p>7位<strong>补码</strong>尾数：补码0只有一个，多出来的一个就变成-1</p>
<p>正数：2^7^   ~   1-2^7^  </p>
<p>负数：-1   ~   -2^7^</p>
<h2 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h2><h3 id="定点移位运算"><a href="#定点移位运算" class="headerlink" title="定点移位运算"></a>定点移位运算</h3><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><p>移位：数据相对于小数点移动</p>
<p>左移：绝对值变大</p>
<p>右移：绝对值变小</p>
<p>与加减配合实现加减乘除</p>
<h5 id="算数移位规则"><a href="#算数移位规则" class="headerlink" title="算数移位规则"></a>算数移位规则</h5><p>符号位不变</p>
<table>
<thead>
<tr>
<th></th>
<th>码制</th>
<th>添补代码</th>
</tr>
</thead>
<tbody><tr>
<td>正数</td>
<td>原反补</td>
<td>0</td>
</tr>
<tr>
<td>负数</td>
<td>原码</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>反码</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>==补码==</td>
<td>左移，右侧空出来添0</td>
</tr>
<tr>
<td></td>
<td>==补码==</td>
<td>右移，左侧空出来添1</td>
</tr>
</tbody></table>
<p>对于原码（包括正数的原反补和负数的原码）来说，1是有意义的，左移丢1，误差很大，相当于丢了权重最大的一位，补了个0。右移丢1，误差较小，丢了权重最小的一位。</p>
<p>对于负数的补码来说，根据补码的规律，最右边的“1”的右边的数与原码一致，左边的数与反码相同，所以左移丢1对数据没有影响，右移丢1，误差较小</p>
<p>对于负数的反码来说，1是没有意义的，0才有意义，所以丢1对数据没有影响。</p>
<p>反码加1变成补码，加1会导致进位，最右边的1就是进位的最终结果，补码这部分是100的原因：原来是这部分是100，取反以后变成011，加1必然导致进位变成100，这部分就跟原码一样了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/d6ej2vfibs2cw_0e3e13be2c8747bca5abc8a7b8cbd77d.webp" alt="d6ej2vfibs2cw_0e3e13be2c8747bca5abc8a7b8cbd77d"></p>
<p>-26<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707201312846.png" alt="image-20240707201312846"></p>
<h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><p>把整个数看成一个无符号数，右移，高位补0低位舍弃，左移高位舍弃低位补0</p>
<h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><p>顾名思义</p>
<h3 id="定点加减法"><a href="#定点加减法" class="headerlink" title="定点加减法"></a>定点加减法</h3><p>补码加减法公式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707211623774.png" alt="image-20240707211623774"></p>
<p>补码 负数跟正数 遵循模32规则，所以能进行加减</p>
<p>5-3⇔5+负三补码，此时算出来的补码就是一个正数，正数可以理所当然参与运算，并且是每一位都可以，</p>
<p><strong>溢出？</strong></p>
<p><strong>一位符号位</strong>：两个操作数符号相同，结果符号与原来不同</p>
<p>最高有效位进位⊕符号位进位 = 1</p>
<p><strong>两位符号位：</strong> </p>
<p>两个符号位异或</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707215559303.png" alt="image-20240707215559303"></p>
<ol>
<li><p>正数加正数：</p>
<p>如00，1111➕00，1000，此时的运算结果就为01，0111。</p>
<p>很明显，这发生了正溢出，因为在数值位只有4位，能表示的最大数值为1111，而运算结果显然超出了该范围，于是产生了像符号位的进位，造成上溢出。</p>
</li>
<li><p>负数加负数：</p>
<p>如11，1111➕11，1000，此时的运算结果就为11，0111。</p>
<p>显然，这没有发生了溢出，其原因是在负数补码中，高位的1相当于原码的0，于是如果两个操作数的数值位最高位都是1的话，是一定不会引起操作数溢出的，与正数两个最高位为0相加，不会发生溢出是一样的。如果，有其中一个为0的话，如果次高位传来进位，依旧可以保证对符号位的进位，也就是保证符号位不会发生变化，从而避免了溢出。</p>
</li>
</ol>
<p>如果最高位为0就要小心溢出</p>
<p>低位必须产生进位，低位不进位肯定溢出</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707221233780.png" alt="image-20240707221233780"></p>
<h3 id="定点乘除法"><a href="#定点乘除法" class="headerlink" title="定点乘除法"></a>定点乘除法</h3><ul>
<li><p>原码一位乘：先加后右移，加4次移4次</p>
<p>看最后一位，1加的是原数，0不加</p>
</li>
<li><p>补码一位乘：先加后右移，加5次移4次</p>
<p>看最后两位，01加X补码，10加(-X)补码，11和00不加</p>
</li>
<li><p>原码定点除：先加后左移，加4次移4次</p>
<p>先加(-X)补码，差值正上1，加(-X)补码得到新差值；差值负上0，加X补码得到新差值，直到商有效位够4位</p>
</li>
<li><p>补码定点除：先看同号否，同号r为x-y，异号r为x+y，</p>
<p>ry同号上1，同时左移，加-y补得到新r，ry异号上0，同时左移，加y补得到新r，再比较同号否</p>
<p>加，上商，左移</p>
<p>上了四次商之后，同时左移，商末位恒为1</p>
<p>加4移5</p>
</li>
</ul>
<h3 id="原码定点一位乘"><a href="#原码定点一位乘" class="headerlink" title="原码定点一位乘"></a>原码定点一位乘</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708143456210.png" alt="image-20240708143456210"></p>
<h3 id="补码定点一位乘（Booth）"><a href="#补码定点一位乘（Booth）" class="headerlink" title="补码定点一位乘（Booth）"></a>补码定点一位乘（Booth）</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708143522928.png" alt="image-20240708143522928"></p>
<h3 id="原码定点除法"><a href="#原码定点除法" class="headerlink" title="原码定点除法"></a>原码定点除法</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708143557760.png" alt="image-20240708143557760"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708143611525.png" alt="image-20240708143611525"></p>
<h3 id="补码定点除法"><a href="#补码定点除法" class="headerlink" title="补码定点除法"></a>补码定点除法</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708143628562.png" alt="image-20240708143628562"></p>
<p>加4移5</p>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><h3 id="浮点加减法"><a href="#浮点加减法" class="headerlink" title="浮点加减法"></a>浮点加减法</h3><h4 id="S1-对阶"><a href="#S1-对阶" class="headerlink" title="S1:对阶"></a>S1:对阶</h4><p>大阶对小阶，大阶左移丢1，如果是正数的话就是数据错误所以小对大</p>
<p>求阶差</p>
<p><strong>小阶对大阶，小阶右移丢1影响较小</strong> 尾数右移1位，阶码加1.</p>
<h4 id="S2-尾数求和"><a href="#S2-尾数求和" class="headerlink" title="S2:尾数求和"></a>S2:尾数求和</h4><p>对阶移位完的尾数进行求和，按照定点补码加减法规则进行求和</p>
<h4 id="S3-尾数规格化"><a href="#S3-尾数规格化" class="headerlink" title="S3:尾数规格化"></a>S3:尾数规格化</h4><p>r=2 尾数绝对值0.5~1</p>
<p>r=4 0.25~1</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708145911043.png" alt="image-20240708145911043"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708150126481.png" alt="image-20240708150126481"></p>
<p>-1/2要进行左规</p>
<h5 id="左规-相当于乘2"><a href="#左规-相当于乘2" class="headerlink" title="左规 相当于乘2"></a>左规 相当于乘2</h5><p>当尾数出现00.0𝑥𝑥⋯𝑥或11.1𝑥𝑥⋯𝑥时，尾数左移，阶码减1，直到数符(正负号)和第一有效数位不同</p>
<h5 id="右规-相当于除2"><a href="#右规-相当于除2" class="headerlink" title="右规 相当于除2"></a>右规 相当于除2</h5><p>尾数右移，阶码加1，直到数符(正负号)和第一有效数位不同</p>
<p>尾数溢出(&gt;1)的时候需要右规</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708150440008.png" alt="image-20240708150440008"></p>
<h4 id="S4-舍入"><a href="#S4-舍入" class="headerlink" title="S4:舍入"></a>S4:舍入</h4><p>对阶和右规过程中，可能会出现尾数末位丢1的情况，影响精度，考虑舍入。简单截断可以</p>
<p>1)0舍1入：即在尾数右移时，被移去的最高数值位为0，则舍去;被移去的最高数值位为1，则在尾数的末位加1。这样做可能会使尾数又溢出，此时需再做一次右规。</p>
<p>2)末位恒置“1”：尾数右移时，不论丢掉的最高数值位是“1”还是“O”，都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708151934259.png" alt="image-20240708151934259"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708151949418.png" alt="image-20240708151949418"></p>
<h4 id="S5-溢出判断"><a href="#S5-溢出判断" class="headerlink" title="S5:溢出判断"></a>S5:溢出判断</h4><p> 与定点数加减法一样，浮点数加减运算最后一步也需判断溢出。</p>
<p>在浮点数规格化中已指出，当尾数之和（差）出现01.×××或10.xxx时，<strong>并不表示溢出，</strong>只能将此数右规后，再根据阶码来判断浮点数运算结果是否溢出。</p>
<p>浮点数的溢出与否是由阶码的符号决定的。以双符号位补码为例，当阶码的符号位出现“01”时，即阶码大于最大阶码时，表示上溢，进入中断处理;当阶码的符号位出现“10”时，即阶码小于最小阶码时，表示下溢，按机器零处理。实际上原理还是阶码符号位不同表示溢出，且真实符号位和高位符号位一致。 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708153404896.png" alt="image-20240708153404896"></p>
<p>最大负数：11.1000…..0 表示-1/2但它不是规格化数，11.0111…..1,应该变小一点,减去2^-n^。尾数原来是-1/2，最后尾数变成-(1/2+2^-n^)</p>
<p>负数的补码应该是100000加到111111，越加越大，所以要从110000变成101111就要减去一个最小单位</p>
<h4 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h4><p>尾数溢出，右规丢1会引起误差</p>
<p>对阶，小对大，右移丢1会引起误差</p>
<h3 id="ALU-算数逻辑单元"><a href="#ALU-算数逻辑单元" class="headerlink" title="ALU-算数逻辑单元"></a><span id="jump">ALU-算数逻辑单元</span></h3><p><strong>A</strong>rithmetic <strong>L</strong>ogic <strong>U</strong>nit</p>
<h4 id="ALU电路"><a href="#ALU电路" class="headerlink" title="ALU电路"></a>ALU电路</h4><p>组合逻辑电路 74181 控制端 CLA</p>
<p>需要寄存器保存结果</p>
<p>M=0，M=1 算数运算和逻辑运算</p>
<p>S3~S0 不同取值 可以做不同运算</p>
<h4 id="快速进位"><a href="#快速进位" class="headerlink" title="快速进位"></a>快速进位</h4><h5 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h5><p>A和B两个数可以同时加进来，然后进行运算，四个位各自算各自的e</p>
<p>很多全加器接在一起</p>
<h5 id="串行进位-Ripple-Carry"><a href="#串行进位-Ripple-Carry" class="headerlink" title="串行进位 Ripple Carry"></a>串行进位 Ripple Carry</h5><p>Propagate &amp; Generate</p>
<p>P<del>i</del> = A<del>i</del>⊕B<del>i</del> , G<del>i</del> = A<del>i</del>B<del>i</del></p>
<p>C<del>i</del> = A<del>i</del>B<del>i</del> + C<del>i-1</del>(A<del>i</del>⊕B<del>i</del>) </p>
<p>​    =G<del>i</del> + P<del>i</del>C<del>i-1</del>    ，C<del>-1</del> = 0 </p>
<p>S<del>i</del> = A<del>i</del>⊕B<del>i</del>⊕C<del>i</del> </p>
<h5 id="并行进位（超前进位）-LookAhead-Carry"><a href="#并行进位（超前进位）-LookAhead-Carry" class="headerlink" title="并行进位（超前进位） LookAhead Carry"></a>并行进位（超前进位） LookAhead Carry</h5><p>C<del>i</del> =G<del>i</del> + P<del>i</del>C<del>i-1</del> ，C<del>-1</del> = 0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708162300561.png" alt="image-20240708162300561"></p>
<p>用电路复杂度换取速度</p>
<p>按照公式可以计算出C0到C3的结果</p>
<p>S<del>i</del> = A<del>i</del>⊕B<del>i</del>⊕C<del>i</del> </p>
<h5 id="单重分组跳跃进位链"><a href="#单重分组跳跃进位链" class="headerlink" title="单重分组跳跃进位链"></a>单重分组跳跃进位链</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708162814971.png" alt="image-20240708162814971"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708170057566.png" alt="image-20240708170057566"></p>
<p>折中的办法，组内先行进位，组外采用串行进位，C0-C3同时产生</p>
<h5 id="双重分组跳跃进位链"><a href="#双重分组跳跃进位链" class="headerlink" title="双重分组跳跃进位链"></a>双重分组跳跃进位链</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708163024193.png" alt="image-20240708163024193"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708171039868.png" alt="image-20240708171039868"></p>
<p>小组的最高位进位并行产生，大组之间采用串行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708165658159.png" alt="image-20240708165658159"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708163546185.png" alt="image-20240708163546185"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708165732848.png" alt="image-20240708165732848"></p>
<p>这种电路称为成组先行进位电路（BCLA)。利用这种4位的 BCLA电路及进位产生与传递电路和求和电路可以构成4位BCLA加法器。16位的两级先行进位加法器可由4个BCLA加法器和1个CLA电路构成，如图2.18所示。</p>
<p>这种方法可以扩展到多于两级的先行进位加法器，如用三级先行进位结构设计64位加法器这种加法器的优点是字长对加法时间影响甚小;缺点是造价较高。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708174638709-1720432067641-1.png" alt="image-20240708174638709"></p>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><p>指令系统连接软件和硬件</p>
<h2 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h2><p>指令= 操作码+地址码</p>
<p><strong>操作码长度</strong>可以固定，用于指令字长比较长的情况，也可以变化比如X86</p>
<p>为了使操作码扩展，可以让操作码的位数随地址码的减少而增加。</p>
<p>在设计扩展操作码指令格式时，必须注意以下两点:</p>
<ol>
<li><p>不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。</p>
</li>
<li><p>各指令的操作码一定不能重复。通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。</p>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708183944205.png" alt="image-20240708183944205"></p>
<p>按照<strong>操作数地址码个数可</strong>以分为：</p>
<p>操作数地址码的长度一般是一样的,如果长度为8,寻址范围就是2^8^ 个.</p>
<p>零地址:  OP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708183415639.png" alt="image-20240708183415639"></p>
<p>3)让(ACC)OP-&gt;(ACC) ACC自加</p>
<p>一地址: OP+A1</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708183401932.png" alt="image-20240708183401932"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708184734580.png" alt="image-20240708184734580"></p>
<p>二地址: OP+A1+A2</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708183546042.png" alt="image-20240708183546042"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708184553805.png" alt="image-20240708184553805"></p>
<p>ACC代替A1/A2,</p>
<p>三地址:OP+A1+A2+A3(结果)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708183600178.png" alt="image-20240708183600178"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708184345766.png" alt="image-20240708184345766"></p>
<p>四地址: OP+A1+A2+A3(结果)+A4(下个地址)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708183706661.png" alt="image-20240708183706661"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708184255485.png" alt="image-20240708184255485"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708184358949.png" alt="image-20240708184358949"></p>
<p>寻址范围从上到下逐渐降低</p>
<p><strong>指令字长</strong></p>
<p>指令长度和机器字长没有必然联系，指令长度等于机器字长 单子长指令，等于半个机器字长 半字长指令， 等于2个机器字长 双字长指令</p>
<p>指令长度相等，<strong>定长指令字</strong>，长度因功能而异，称为<strong>变长指令字</strong>结构，通常都是按照字节的倍数变化</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>用硬件资源(ACC)代替指令字中的地址码字段：</p>
<ul>
<li>扩大指令寻址范围（指令长度固定，地址码长度增加，能够操作的地址长度变多）</li>
<li>缩短指令字长（地址码长度不变，指令长度固定，但是地址码的个数变少，能够缩短整体的字长）</li>
<li>减少访<strong>存</strong>次数 ACC代替操作数，ACC代替结果，都能减少访存次数</li>
</ul>
<p>指令的地址字段为寄存器：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708185921002.png" alt="image-20240708185921002"></p>
<ul>
<li>指令执行阶段，可以不访存</li>
</ul>
<h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><h3 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h3><p>地址：无符号整数</p>
<p>数字：定点数、浮点数、十进制数</p>
<p>字符：ASCII</p>
<p>逻辑数：逻辑运算</p>
<h3 id="存放数据的方式"><a href="#存放数据的方式" class="headerlink" title="存放数据的方式"></a>存放数据的方式</h3><p>前提：按照字节编址每一个地址能存放一个字节</p>
<p>机器字长=CPU寄存器位数</p>
<p>存放一个机器字的存储单元，通常称为字存储单元，相应的单元地址称为字地址。而存放一字节的单元，称为字节存储单元，相应的地址称为字节地址。</p>
<p>编址方式是存储器地 址的组织方式，一般在设计处理器时就已经确定了。如果计算机中编址的<u>最小单位</u>是字存储单元，则该计算机称为<u>按字编址</u>的计算机。如果计算机中编址的最小单位是字节，则该 计算机称为<u>按字节编址</u>的计算机。一个机器字可以包含数字节，所以<u>一个存储单元也可占用数个能够单独编址的字节地址。</u> </p>
<h5 id="高地址和低地址"><a href="#高地址和低地址" class="headerlink" title="高地址和低地址"></a>高地址和低地址</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708190353466.png" alt="image-20240708190353466"></p>
<h5 id="高字节和低字节"><a href="#高字节和低字节" class="headerlink" title="高字节和低字节"></a>高字节和低字节</h5><p>如int a=16777220，化为十六进制是0x 01 23 45 67，<strong>则04属于低字节，01属于高字节</strong> 是按照字节的位置区分的</p>
<h5 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708190959696.png" alt="image-20240708190959696"></p>
<p>低字节存在高地址 大端，字地址在高字节的地址</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>字节数据</th>
</tr>
</thead>
<tbody><tr>
<td>0x0004</td>
<td>67</td>
</tr>
<tr>
<td>0x0003</td>
<td>45</td>
</tr>
<tr>
<td>0x0002</td>
<td>23</td>
</tr>
<tr>
<td>0x0001</td>
<td>01</td>
</tr>
</tbody></table>
<p>低字节存在低地址 小端，字地址在低字节的地址</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>字节数据</th>
</tr>
</thead>
<tbody><tr>
<td>0x0004</td>
<td>01</td>
</tr>
<tr>
<td>0x0003</td>
<td>23</td>
</tr>
<tr>
<td>0x0002</td>
<td>45</td>
</tr>
<tr>
<td>0x0001</td>
<td>67</td>
</tr>
</tbody></table>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708191237400.png" alt="image-20240708191237400"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708191301932.png" alt="image-20240708191301932"></p>
<p><strong>边界对准</strong> </p>
<p><strong>按照字节编址</strong>，寻址时可以按照字，半字，字节。一个字是4个字节，字的地址就是4的倍数，半字的地址就是2的倍数，字节随便存。</p>
<p>存储字长：一个存储单元中存储的位数。要提高访存速度，就要在一个存储字长放入尽可能多且完整的的存储单位。</p>
<p>一个存储字中最多容纳4个地址，分别指向4个字节，半字只能存到字的开始或中间，全字必须独占一个存储单元。浪费了一些空间，但是不会造成同一个数据的分散，能够提高存取速度。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708192833186.png" alt="image-20240708192833186"></p>
<p>边界不对齐就会导致同一个字会存储到不同的存储单元中，导致访存次数增多，还要进行数据拼接等繁冗工作。</p>
<p><strong>存储单元：每个存储单元 存放一串 二进制代码</strong></p>
<p>存储单元 和 内存单元 是不一样的，内存单元是 存储单元的 子集。多个 内存单元 可以组成 一个 存储单元。</p>
<p><strong>存储字（word）：存储单元中 二进制代码的组合</strong> </p>
<p><strong>存储字长：存储单元中 二进制代码的 位数。</strong> </p>
<p><strong>存储元：即存储一个二进制数的电子元件，每个存储元可以存储 1 bit。多个存储元 就可以 构成一个 内存单元。（由电容原理 制作出来的东西，因为电容可以 存储电荷呀 ~）</strong> </p>
<p>在这里 我们说的 存储字和存储字长，实际上 说的是 MDR 这个东西。<br>也就是这个 寄存器。它能存储 多大的数据。</p>
<p>所以我们也常说，存储字长 在 不同的硬件上 会 不一样。</p>
<h3 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h3><p>数据传送，算术和逻辑运算，移位操作，转移操作(JMP,CALL,RET<del>turn</del>,TRAP)，输入输出操作与外部IO交换数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708213502481.png" alt="image-20240708213502481"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708213509455.png" alt="image-20240708213509455"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708213516901.png" alt="image-20240708213516901"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708213527974.png" alt="image-20240708213527974"></p>
<h2 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h2><p>确定<u>本条指令的数据地址</u>和<u>下条待执行指令</u>的地址。</p>
<p>可以通过<strong>指令寻址</strong>，也可以通过<strong>数据寻址</strong>。 </p>
<p>操作码之后是<strong>寻址特征位</strong>，共采用的特征总和，分别编码表示即可。<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/20210515135546230.png" alt="20210515135546230"></p>
<p>指令中的地址码字段并不代表操作数的真实地址，这种地址称为 形式地址形式地址 (A)。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为 有效地址有效地址 （EA)。</p>
<p>注意，(A)表示地址为A的数值，A既可以是寄存器编号，也可以是内存地址。对应的(A)就是寄存器中的数值，或相应内存单元的数值。例如，EA=(A)意思是有效地址是地址A中的数值。</p>
<h3 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h3><h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><p><strong>累加寄存器 ACC</strong>：它是一个同通用寄存器，其功能是：当 ALU 执行算术或逻辑运算时，为 ALU 提供一个工作区，ACC 暂时存放 ALU 运算的结果信息。显然，运算器中至少要有一个累加寄存器</p>
<p><span id = "jump4"><strong>PC</strong></span>寄存器用来存储<strong>指向下一条指令的地址</strong>，当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器IR中，此过程称为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。</p>
<p><span id="jump5">IR</span>用来保存<strong>当前正在执行的一条指令。</strong> 当执行一条指令时，先把它从内存取到数据寄存器（DR，Data Register）中，然后再传送至IR。</p>
<p>GR 通用寄存器可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。除此之外，它们还各自具有一些特殊功能。通用寄存器的长度取决于机器字长，汇编语言程序员必须熟悉每个寄存器的一般用途和特殊用途，只有这样，才能在程序中做到正确、合理地使用它们。</p>
<p>PC+ “1” -&gt; PC , 指令长度是4个字节，“1”就是4，指令长度是8个字节，“1”就是8，自动形成下一条指令的地址(这里是指指令的纵向长度) </p>
<h4 id="跳跃"><a href="#跳跃" class="headerlink" title="跳跃"></a>跳跃</h4><p> 通过转移类指令实现。所谓跳跃，是指下条指令的地址码不由程序计数器给出，而由本条指令给出下条指令地址的计算方式。注意，是否跳跃可能受到状态寄存器和操作数的控制，而跳跃到的地址分为绝对地址（由标记符直接得到)和相对地址（相对于当前指令地址的偏移量)，跳跃的结果是当前指令修改PC值，所以下一条指令仍然通过程序计数器（PC）给出。 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708200915099.png" alt="image-20240708200915099"></p>
<h3 id="数据寻址方式"><a href="#数据寻址方式" class="headerlink" title="数据寻址方式"></a>数据寻址方式</h3><p><strong>EA</strong>地址存放了操作数</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708201119571.png" alt="image-20240708201119571"></p>
<ol>
<li><p>立即寻址 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708201151183.png" alt="image-20240708201151183"></p>
<p>指令执行时间最短，但是A的位数限制了立即数的范围</p>
</li>
<li><p>直接寻址 EA=A </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708201407246.png" alt="image-20240708201407246"></p>
<p>A就是地址，A的范围决定了寻址范围。</p>
</li>
<li><p>隐含寻址 A是一个操作数的地址 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708201701155.png" alt="image-20240708201701155"></p>
<p>这里规定硬件ACC是第二操作数的地址，对于这种一地址指令，访存1次，零地址指令操作数是默认保存在一个寄存器中的。</p>
</li>
<li><p>间接寻址 指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即 EA =(A) 还可以通过多次简介寻址 EA=((A))</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708210033847.png" alt="image-20240708210033847"></p>
<p>主存字第一位为1时，表示取出的仍不是操作数的地址，即多次间址;主存字第一位为0时，表示取得的是操作数的地址。</p>
</li>
<li><p>寄存器寻址 EA=R<del>i</del> </p>
<p>指令字中给出操作数所在的寄存器编号R<del>i</del> ,操作数存在寄存器Ri内。</p>
<p>不用访存，速度快，但是价格昂贵，寄存器数量有限</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708211427010.png" alt="image-20240708211427010"></p>
</li>
<li><p>寄存器间接寻址 EA = (Ri)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708211440882.png" alt="image-20240708211440882"> 需要访问主存</p>
</li>
<li><p>相对寻址 EA = (PC)+A</p>
<p>A是相对于当前指令地址的地址，相对寻址的优点是操作数的地址不是固定的，它随PC值的变化而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动。相对寻址广泛应用于转移指令，比如JMP。 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708212522800.png" alt="image-20240708212522800"></p>
<p>执行一条指令就是读取(PC)然后PC+”1”，那么运用相对寻址的时候，取完这条指令就已经+”1”了，相对位移量是A，所以转移到的地址是(PC)+”1”+A</p>
</li>
<li><p>基址寻址 EA =(BR)+ A</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708215640792.png" alt="image-20240708215640792"></p>
<p>面向操作系统，由操作系统确定(BR), 一般是不可变的,A可变</p>
</li>
<li><p>变址寻址 EA = (IX)+A</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708215930568.png" alt="image-20240708215930568"></p>
<p>面向用户，(IX)可变，A不可变</p>
</li>
</ol>
<p>不需要访存的：</p>
<ul>
<li>立即寻址 （A就是操作数）</li>
<li>隐含寻址（操作数可以隐含保存在特定寄存器中）</li>
<li>寄存器寻址（操作数保存在寄存器中）</li>
</ul>
<p>需要访存2次：</p>
<ul>
<li>一次间接寻址（EA=(A) A先访存1次，然后根据(A)再访存1次）</li>
</ul>
<p>以上不包含为了取本条指令而做的访存</p>
<ol start="10">
<li>堆栈寻址</li>
</ol>
<blockquote>
<p>堆栈是存储器（或专用寄存器组）中一块特定的、按后进先出（LIFO）原则管理的存储区，该存储区中读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针(SP)。 堆栈堆栈 可分为 硬堆栈硬堆栈 与 软堆栈软堆栈 两种。</p>
</blockquote>
<blockquote>
<p>寄存器堆栈又称硬堆栈。寄存器堆栈的成本较高，不适合做大容量的堆栈;而从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为软堆栈。</p>
</blockquote>
<blockquote>
<p>在采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP。通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。</p>
</blockquote>
<p>Example</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708222527779.png" alt="image-20240708222527779"></p>
<p>1）寄存器-存储器（R-S）指令格式：操作码OPcode+寄存器位R+特征位+形式地址A</p>
<p>32个寄存器，编号需要5位，64种操作-&gt;操作码6位000000-111111，特征位由于只有直接或间接寻址，所以只要1位特征位即可，剩下即为形式地址。</p>
<p>OP(6)+R(5)+特征位(1)+A(20)</p>
<p>20位形式地址，最多直接寻址的空间为1M存储字，</p>
<p>如果是间接寻址就可以扩大寻址空间，最多到2^32^=4G字</p>
<p>2）通用寄存器，寻址方式多了一种基址方式，基址寄存器中的内容是特定不变的，OP(6)+R(5)+特征位(2)+A(19)？但是应该指明用哪一个通用寄存器作为基址寄存器</p>
<p>OP(6)+R(5)+特征位(2)+BR(5)+A(14)</p>
<p>通用寄存器有32位，所以使用基址寻址的最大寻址空间=2^32^=4G字，仅仅与基址位数有关 </p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708221826452.png" alt="image-20240708221826452"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708222151040.png" alt="image-20240708222151040"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708222202564.png" alt="image-20240708222202564"></p>
<h2 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h2><p><strong>R</strong>educed <strong>I</strong>nstruction <strong>S</strong>et <strong>C</strong>omputer 精简指令集计算机</p>
<p>与C<del>(omplex)</del>ISC相对</p>
<p>二八定律</p>
<p><strong>RISC:</strong> </p>
<ul>
<li>指令长度固定，指令格式种类少，寻址方式少；</li>
<li>只使用LOAD STORE访存，通用寄存器较多；</li>
<li>流水线技术，一个时钟周期内完成一条指令；</li>
<li>控制器运用组合逻辑。</li>
</ul>
<p><strong>CISC:</strong> </p>
<ul>
<li>指令庞杂，指令使用频度相差较大，长度不固定，种类多</li>
<li>很多指令可以访存</li>
<li>CPU有专用寄存器</li>
<li>大部分指令都需要多个时钟周期完成</li>
<li>采用微程序控制器</li>
</ul>
<p>值得注意的是，从指令系统兼容性看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但RISC简化了指令系统，指令条数少，格式也不同于老机器，因此大多数RISC机不能与老机器兼容。由于 RISC具有更强的实用性，因此应该是未来处理器的发展方向。但事实上，当今时代Intel 几乎一统江湖，且早期很多软件都是根据CISC 设计的，单纯的RISC将无法兼容。此外，现代CISC结构的CPU已经融合了很多RISC的成分，其性能差距已经越来越小。CISC可以提供更多的功能，这是程序设计所需要的。</p>
<p>RISC利用VLSI芯片的面积，便于设计，降低成本，提高可靠性，但是不容易实现指令系统的兼容</p>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708235618670.png" alt="image-20240708235618670"></p>
<p>指令控制 PC IR </p>
<p>操作控制、时间控制 CU 时序电路</p>
<p>数据加工 ALU (运算器) + 寄存器</p>
<p>中断处理 中断系统</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708235920709.png" alt="image-20240708235920709"></p>
<h3 id="CPU的寄存器"><a href="#CPU的寄存器" class="headerlink" title="CPU的寄存器"></a>CPU的寄存器</h3><h4 id="用户可见寄存器"><a href="#用户可见寄存器" class="headerlink" title="用户可见寄存器"></a>用户可见寄存器</h4><p>通用寄存器 <strong>G</strong>eneral <strong>R</strong>egister</p>
<ul>
<li>存放操作数</li>
<li>作为某种寻址方式所需要的专用寄存器</li>
</ul>
<p>数据寄存器 <strong>D</strong>ata <strong>R</strong>egister</p>
<ul>
<li>存放多种操作数（多种数据类型）</li>
<li>两个寄存器拼接存放双倍字长的数据[ACC和MQ]</li>
</ul>
<p>地址寄存器</p>
<ul>
<li>存放地址，位数满足最大的地址的范围，用于特殊的寻址方式，段基值，栈指针</li>
</ul>
<p>条件码寄存器 </p>
<ul>
<li>存放条件码，作为程序分支的依据，入如正负零，溢出，进位</li>
</ul>
<h4 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h4><p>控制寄存器</p>
<ul>
<li><a href="#jump4">PC</a>-&gt;<strong>MAR</strong>-&gt;M-&gt;<strong>MDR</strong>-&gt;<strong><a href="#jump5">IR</a></strong> 加粗为用户不可见，PC用户可以读到</li>
<li>MAR用于存储地址</li>
<li>MDR用于暂存数据</li>
</ul>
<p>状态寄存器</p>
<ul>
<li>存放条件码</li>
<li>PSW 存放程序状态字，中断服务程序或者子程序，为了保存运行现场和断点。</li>
</ul>
<h4 id="控制单元CU和中断系统"><a href="#控制单元CU和中断系统" class="headerlink" title="控制单元CU和中断系统"></a>控制单元CU和中断系统</h4><p><a href="#jump2">CU</a></p>
<ul>
<li>产生全部指令的微操作命令序列</li>
<li>组合逻辑(RISC) 硬连线逻辑</li>
<li>微程序设计 存储逻辑</li>
</ul>
<p><a href="#jump3">中断系统</a></p>
<h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a><a href="#jump">ALU</a></h4><h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><ul>
<li>指令周期=取址周期</li>
<li>指令周期=取址周期+执行周期(等长)</li>
<li>指令周期=取址周期+执行周期(长一些)</li>
<li>间接寻址的指令周期=取址周期+<u>间址周期</u>+执行周期</li>
<li>中断周期的指令周期=取址周期+<u>间址周期</u>+执行周期+中断周期</li>
</ul>
<p>流程：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709132917427.png" alt="image-20240709132917427"></p>
<p>CPU访存有4种性质</p>
<ul>
<li>取 指令         取指周期</li>
<li>取 地址         间址周期</li>
<li>存取 操作数  执行周期</li>
<li>存 程序断点  中断周期</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709134249611.png" alt="image-20240709134249611"></p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><h4 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h4><p>PC寄存器存的是下一条指令的地址，CU通过控制总线，控制地址通过MAR传到地址总线，（读命令）地址总线传到存储器，控制存储器将对应的数据（指令）通过数据总线传到MDR，最后保存到CPU的IR寄存器中。CU控制PC寄存器的值+“1” </p>
<h4 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h4><p>假设取完指令以后将形式地址A保存到了MDR，此时A的值传给MAR，通过地址总线传给存储器，CU控制总线让存储器取出A中保存的数据(A)也就是EA，EA保存到MDR，操作数的真实地址EA最后保存到了IR的地址码部分</p>
<h4 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h4><h4 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709151019317.png" alt="image-20240709151019317"></p>
<p>保存断点，形成中断服务程序的入口地址（中断向量），硬件关中断</p>
<p>保存程序<strong>断点</strong>，CU来确定将程序断点保存到内存的哪个地址，传给MAR，存储器，CU再控制总线操控存储器进行写入断点的操作，由于响应中断一定是在执行完一条指令之后，所以下一条指令还没有取到，下一条指令的地址就是(PC)，将PC存储的值送到MDR，再通过数据总线写入存储器。</p>
<p>形成中断服务程序的<strong>入口地址</strong>：CU给出送到PC</p>
<p>(关中断)</p>
<h3 id="指令流水"><a href="#指令流水" class="headerlink" title="指令流水"></a>指令流水</h3><h4 id="提高机器速度？"><a href="#提高机器速度？" class="headerlink" title="提高机器速度？"></a>提高机器速度？</h4><p>提高访存速度：Cache 多体并行</p>
<p>提高IO和主机的传送速度：</p>
<ul>
<li>中断，部分时间并行</li>
<li>DMA，几乎全部并行</li>
<li>通道，I/O处理机</li>
<li>多总线</li>
</ul>
<p>提高运算速度：</p>
<ul>
<li>高速芯片，改进算法，快速进位链</li>
</ul>
<p>提高并行性</p>
<h4 id="系统并行"><a href="#系统并行" class="headerlink" title="系统并行"></a>系统并行</h4><p>并行：并发 / 同时。多个事件在同一时间段或同一时刻，并行发生</p>
<p>并行性的等级：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709152238952.png" alt="image-20240709152238952"></p>
<h4 id="指令流水原理"><a href="#指令流水原理" class="headerlink" title="指令流水原理"></a>指令流水原理</h4><p>CU中取指和执行部件完全独立的两个部件。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709153256508.png" alt="image-20240709153256508"></p>
<p>二级流水，执行的时候同时取第二条指令</p>
<p><strong>影响因素：</strong></p>
<p>取指时间快的话，指令2的执行就要空等。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709153630873.png" alt="image-20240709153630873"></p>
<p>“分支预测” 猜测？</p>
<p><strong>六级流水</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709153945994.png" alt="image-20240709153945994"></p>
<h4 id="影响性能因素"><a href="#影响性能因素" class="headerlink" title="影响性能因素"></a>影响性能因素</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709154501154.png" alt="image-20240709154501154"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709155432711.png" alt="image-20240709155432711"></p>
<p>WAW R3不知道是谁写入的</p>
<p>解决办法 后推、旁路技术</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709160540537.png" alt="image-20240709160540537"></p>
<p>EX阶段就已经给出了结果值，不必待某条指令的执行结果送回到寄存器后，再从寄存器中取出结果。作为下一条指令的源操 作数，而是直接将执行结果送到其他指令所需要的地方</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709160922557.png" alt="image-20240709160922557"></p>
<p>转移指令直到EI结束才知道是否要转移</p>
<h3 id="流水线多发"><a href="#流水线多发" class="headerlink" title="流水线多发"></a>流水线多发</h3><p>一条流水线实现了时间并行性</p>
<p>多条流水线还能体现空间并行性</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709161132636.png" alt="image-20240709161132636"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709161651786.png" alt="image-20240709161651786"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709161912171.png" alt="image-20240709161912171"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709174419116.png" alt="image-20240709174419116"></p>
<h3 id="流水线结构"><a href="#流水线结构" class="headerlink" title="流水线结构"></a>流水线结构</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709162228545.png" alt="image-20240709162228545"></p>
<p>运算过程比较复杂的可以使用运算流水线</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709162356672.png" alt="image-20240709162356672"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709163719074.png" alt="image-20240709163719074"></p>
<p>一个任务分割为多个子任务，原则上要求时间上等分，子任务由不同的部件完成，如果不等分，指令1执行过程中取到了指令2，但是指令2必须等到1执行完才开始执行，这就造成了任务的空窗期，造成了时间的浪费</p>
<h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统 "></a><span id= "jump3">中断系统 </span></h2><h3 id="引起中断的因素"><a href="#引起中断的因素" class="headerlink" title="引起中断的因素"></a>引起中断的因素</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709165141178.png" alt="image-20240709165141178"></p>
<h4 id="中断系统解决的问题"><a href="#中断系统解决的问题" class="headerlink" title="中断系统解决的问题"></a>中断系统解决的问题</h4><h5 id="中断请求处理"><a href="#中断请求处理" class="headerlink" title="中断请求处理"></a>中断请求处理</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709165435315.png" alt="image-20240709165435315"></p>
<h5 id="中断判优逻辑"><a href="#中断判优逻辑" class="headerlink" title="中断判优逻辑"></a>中断判优逻辑</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709165718469.png" alt="image-20240709165718469"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709165806996.png" alt="image-20240709165806996"></p>
<h4 id="中断服务程序入口地址"><a href="#中断服务程序入口地址" class="headerlink" title="中断服务程序入口地址"></a>中断服务程序入口地址</h4><p>硬件向量法，速度快，但不灵活</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709165927865.png" alt="image-20240709165927865"></p>
<p>软件查询法，使用中断识别程序</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709170616972.png" alt="image-20240709170616972"></p>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><h5 id="响应条件"><a href="#响应条件" class="headerlink" title="响应条件"></a>响应条件</h5><ul>
<li>允许中断触发器 EINT=1</li>
<li>一条指令执行结束时由CPU发查询信号</li>
</ul>
<h5 id="中断隐指令-硬件实现，并不在指令集中"><a href="#中断隐指令-硬件实现，并不在指令集中" class="headerlink" title="中断隐指令(硬件实现，并不在指令集中)"></a>中断隐指令(硬件实现，并不在指令集中)</h5><ul>
<li><p>保护程序断点</p>
<ul>
<li>断点保存到特定地址</li>
<li>断点进栈</li>
</ul>
</li>
<li><p>寻找服务程序入口地址</p>
<ul>
<li>硬件向量</li>
<li>中断识别程序M-&gt;PC 软件</li>
</ul>
</li>
<li><p>关中断 EINT = 0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709171350563.png" alt="image-20240709171350563"></p>
</li>
</ul>
<h4 id="保护、恢复现场"><a href="#保护、恢复现场" class="headerlink" title="保护、恢复现场"></a>保护、恢复现场</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709171616344.png" alt="image-20240709171616344"></p>
<h4 id="多重中断"><a href="#多重中断" class="headerlink" title="多重中断"></a>多重中断</h4><ul>
<li><p>提前设置 开中断 指令</p>
</li>
<li><p>优先级高可以打断优先级低的处理程序</p>
</li>
</ul>
<h5 id="中断屏蔽技术"><a href="#中断屏蔽技术" class="headerlink" title="中断屏蔽技术"></a>中断屏蔽技术</h5><p><strong>MASK 触发器</strong> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709172308296.png" alt="image-20240709172308296"></p>
<p>屏蔽字<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709172343892.png" alt="image-20240709172343892"></p>
<p><u>响应</u>优先级不可以改变，<u>处理</u>优先级可以改变<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709172459205.png" alt="image-20240709172459205"></p>
<p>中断源响应之后会设置各个中断源的屏蔽字MASK[]</p>
<p><strong>应用</strong>：可以人为屏蔽某个中断源</p>
<p><strong>设置新屏蔽字</strong>：保护现场之后，置屏蔽字，然后开中断（为了实现多重中断），进行中断服务，恢复现场和恢复屏蔽字之前要关中断，确保正确恢复，最后开中断，中断返回</p>
<h5 id="断点保护"><a href="#断点保护" class="headerlink" title="断点保护"></a>断点保护</h5><ul>
<li><p>断点进栈</p>
</li>
<li><p>断点存入“0”地址</p>
<ul>
<li><p>CU将“0”地址写入MAR，准备写操作，PC的值写入MDR然后再进入存储器</p>
<p>出现了断点覆盖的问题</p>
</li>
</ul>
</li>
</ul>
<p>保护断点的做法，不同的服务程序将断点保存到不同的地址<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709173920685.png" alt="image-20240709173920685"></p>
<p>STA(Store Accmulator) SAVE 将ACC原来的值保存到SAVE中</p>
<p>LDA(Load Accumulator) 0将0地址的内容(程序断点)保存到ACC</p>
<p>STA RETURN 将0地址保存到RETURN中</p>
<p>JMP @ RETURN 无条件跳转到RETURN保存的地址</p>
<p>每个SERVE程序 都有不同的RETURN 把0地址的内容转存到各自的RETURN即可</p>
<h1 id="控制单元-CU"><a href="#控制单元-CU" class="headerlink" title="控制单元 CU"></a><span id="jump2">控制单元 CU</span></h1><h2 id="微操作命令分析"><a href="#微操作命令分析" class="headerlink" title="微操作命令分析"></a>微操作命令分析</h2><p>解释指令的过程中，CU发出的操作就叫微操作，比如加法指令，还能继续往下细分。</p>
<p>完成一条指令：取指，间址，执行，中断4个周期</p>
<h5 id="取指周期-1"><a href="#取指周期-1" class="headerlink" title="取指周期"></a><strong>取指周期</strong></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709180027699.png" alt="image-20240709180027699"></p>
<h5 id="间址周期-1"><a href="#间址周期-1" class="headerlink" title="间址周期"></a><strong>间址周期</strong></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709180154460.png" alt="image-20240709180154460"></p>
<h5 id="执行周期-1"><a href="#执行周期-1" class="headerlink" title="执行周期"></a><strong>执行周期</strong></h5><p><strong>非访存指令</strong>(取指+执行)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709180420712.png" alt="image-20240709180420712"></p>
<p><strong>访存指令</strong>(取指+执行)/(取指+间址+执行)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709180826769.png" alt="image-20240709180826769"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709180927583.png" alt="image-20240709180927583"></p>
<p><strong>转移指令</strong>(取指+执行)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709180948619.png" alt="image-20240709180948619"></p>
<p><strong>间接转移</strong>(取指+间址+执行)</p>
<h4 id="中断周期-1"><a href="#中断周期-1" class="headerlink" title="中断周期"></a>中断周期</h4><p>0地址：</p>
<ul>
<li>0地址保存到MAR</li>
<li>1-&gt;W 写</li>
<li>PC -&gt; MDR</li>
<li>MDR-&gt;M(MAR)</li>
<li>向量地址-&gt;PC  /  中断识别程序 M-&gt;PC</li>
<li>0-&gt;EINT</li>
</ul>
<p>断点进栈：</p>
<ul>
<li><p>(SP)-1-&gt;MAR</p>
</li>
<li><p>1-&gt;W 写</p>
</li>
<li><p>PC -&gt; MDR</p>
</li>
<li><p>MDR-&gt;M(MAR)</p>
</li>
<li><p>向量地址-&gt;PC  /  中断识别程序 M-&gt;PC</p>
</li>
<li><p>0-&gt;EINT</p>
</li>
</ul>
<h2 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a>控制单元</h2><p>发出各种微指令</p>
<h3 id="外特性"><a href="#外特性" class="headerlink" title="外特性"></a>外特性</h3><h4 id="输入信号"><a href="#输入信号" class="headerlink" title="输入信号"></a>输入信号</h4><ol>
<li>时钟 受到clk控制</li>
<li>指令寄存器 控制信号和OPcode有关 用于译码</li>
<li>标志 受标志控制，上一条指令运行结果的标志，能够让CU决定这次运行是否跳转</li>
<li>外来信号 INTR 中断请求、HRQ总线请求</li>
</ol>
<h4 id="输出信号"><a href="#输出信号" class="headerlink" title="输出信号"></a>输出信号</h4><ol>
<li>CPU内的控制信号<ol>
<li>Ri-&gt;Rj</li>
<li>PC+1 -&gt; PC</li>
<li>ALU进行什么运算</li>
</ol>
</li>
<li>送到控制总线的信号<ol>
<li>访存控制信号$\overline{MREQ}$</li>
<li>访IO/存储器控制信号$\overline{IO}/M$</li>
<li>读写命令$\overline{RD}$ $\overline{WR}$</li>
<li>中断响应 INTA</li>
<li>总线响应 HLDA</li>
</ol>
</li>
</ol>
<h3 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h3><h4 id="不采用总线"><a href="#不采用总线" class="headerlink" title="不采用总线"></a>不采用总线</h4><p>C0-C8均为门电路的控制</p>
<p>ADD @X</p>
<p>C0: 将PC存储的地址送到MAR</p>
<p>C1: 将MAR的内容送到地址线，发出读命令</p>
<p>C2: 将存储器发回的数据存到MDR</p>
<p>C3: 将MDR保存的指令传到IR</p>
<p>C4: 将IR的操作码部分OP(IR)传到CU,进行译码  取到指令之后寻址特征位发挥作用，如果让IND触发器置1，那么就变成要进入间址周期</p>
<p>C5: 将MDR中保存的形式地址A传到MAR Ad(IR)-&gt; MAR</p>
<p>C1 C2 执行完之后MDR中保存了EA</p>
<p>C3 : EA-&gt;OP(IR)</p>
<p>C5: MDR中地址EA传到MAR</p>
<p>C1 C2 执行完之后MDR中保存了数据X</p>
<p>C6C7: 两个操作数x和acc分别送到ALU中，ALU再接收来自CU的加法信号</p>
<p>C8: ALU的运算结果保存到ACC中</p>
<h4 id="采用总线"><a href="#采用总线" class="headerlink" title="采用总线"></a>采用总线</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709202341142.png" alt="image-20240709202341142"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709203641379.png" alt="image-20240709203641379"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709203902002.png" alt="image-20240709203902002"></p>
<h3 id="多级时序系统"><a href="#多级时序系统" class="headerlink" title="多级时序系统"></a>多级时序系统</h3><h4 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h4><p>定义：所有指令执行过程的一个基准时间</p>
<p>因素：指令的执行<strong>步骤</strong>，步骤花费的<strong>时间</strong></p>
<p>基准：以完成<strong>最复杂</strong>指令功能的时间为准，以<strong>访问一次存储器</strong>的时间为基准</p>
<p>指令字长=存储字长 -&gt; 取指周期=机器周期</p>
<h4 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h4><p>一个机器周期完成若干微操作，等分为若干个时钟周期，一个时钟周期能够产生一个或多个(并行)的微操作。最小的时间单位</p>
<h4 id="多级时序"><a href="#多级时序" class="headerlink" title="多级时序"></a>多级时序</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709204627725.png" alt="image-20240709204627725"></p>
<h4 id="主频和速度的关系"><a href="#主频和速度的关系" class="headerlink" title="主频和速度的关系"></a>主频和速度的关系</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709204732300.png" alt="image-20240709204732300"></p>
<p>流水线同样能加快速度</p>
<h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><p>产生微操作命令序列的时序控制方式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709204902523.png" alt="image-20240709204902523"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709204952863.png" alt="image-20240709204952863"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709205235679.png" alt="image-20240709205235679"></p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h4><p>用复杂的组合逻辑门电路和一些触发器构成</p>
<p>在列出微操作时间表后，综合分析之后，可以将微操作信号的逻辑表达式写出来，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709211508947.png" alt="image-20240709211508947"></p>
<h4 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h4><p>微操作是计算机中最小的不可再分的操作，微命令作为微操作的控制信号，微命令之间有相容和相斥两种关系，微命令组成微指令，微指令组成微程序，一条机器指令转化成一个微程序并存入一个专门的存储器，微程序控制器通过取微程序存储器中的微指令并执行</p>
<p>微指令编码方式：直接编码、字段直接编码、字段间接编码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709232334388.png" alt="image-20240709232334388"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/20/designing-pattern-singleton/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/20/designing-pattern-singleton/" class="post-title-link" itemprop="url">单例模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-20T00:00:00+08:00">2024-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 13:10:52" itemprop="dateModified" datetime="2025-04-27T13:10:52+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h1><h2 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="keyword">return</span> instance;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全，但是可能造成资源的浪费</p>
<h2 id="懒汉-双重校验锁-DCL"><a href="#懒汉-双重校验锁-DCL" class="headerlink" title="懒汉 双重校验锁 DCL"></a><u><strong>懒汉 双重校验锁 DCL</strong></u></h2><ol>
<li>懒汉（延迟初始化） 要素：无参构造私有，进行判断<strong>「线程不安全」</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原来的实现容易出现线程安全问题，改进：<code>getInstance()</code>变成 <code>synchronized</code> 方法。<ul>
<li><p><strong>锁范围太大</strong>：性能差，同步开销大。正常的执行路径不需要同步，只需要在创建实例的时候进行锁定即可。</p>
<ul>
<li><p>锁对象的选择：<strong>两个不相关的方法不要使用同一把锁</strong>。<strong>并且要注意不能出现死锁互相等待</strong>。</p>
</li>
<li><p>class：适用于保护静态变量或者类级别的共享资源，如果是为了保护某个对象的状态，就应该使用this。</p>
</li>
<li><p>this可能的问题：这边在内部使用this调用task.dosth()，另一边一个完全无关的业务使用 task做锁。</p>
</li>
<li><p>死锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Friend</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bow</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在向 &quot;</span> + other.name + <span class="string">&quot; 鞠躬&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟执行延迟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            other.bowBack(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bowBack</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在回礼 &quot;</span> + other.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 死锁：a和b同时向对方bow，先都锁住了自己，bowBack的时候就会造成互相等待</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>未二次判空</strong>：线程 A 通过了条件判断，获取了锁，开始创建实例，就在同时，线程B也通过判断等待锁释放，在线程 A 出来之后线程B又进去创建了一次。</p>
</li>
<li><p><strong>指令重排序</strong>：Java 允许指令重排序，创建对象可以分为 1. 分配内存地址 2. 在这块内存地址创建对象 3. 将 对象的引用 instance 指向这块地址。如果2 3的顺序颠倒，线程 A 进去之后在完全创建对象之前就将 instance 置为 非null，线程B就会以为别人已经创建好了，直接返回 instance 引用，线程B拿到以后就开始使用，其中就会随机发生空指针或者状态异常等其他难以复现调试的bug。引入 volatile，表示这个变量不允许指令重排，且线程对它的写入会立刻对其他线程可见。避免发生拿到错误对象的情况</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// 1. 禁止指令重排序</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;<span class="comment">// 2. 锁的范围缩小</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;<span class="comment">// 3. 二次判空</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用场景：</p>
<ul>
<li><strong>单例模式</strong>：延迟初始化全局唯一的对象。</li>
<li><strong>高并发资源初始化</strong>：如数据库连接池、线程池等。</li>
<li><strong>框架中的扩展点加载</strong>：如 Dubbo 的 <code>ExtensionLoader</code> 按需加载扩展类。</li>
</ul>
<h2 id="双重校验锁-与类解耦"><a href="#双重校验锁-与类解耦" class="headerlink" title="双重校验锁 (与类解耦)"></a><u>双重校验锁 (与类解耦)</u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> T instance;</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;T&gt; supplier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">(Supplier&lt;T&gt; supplier)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = supplier.get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T instance;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>&#123;</span><br><span class="line">        instance = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 在外部实现</span></span><br></pre></td></tr></table></figure>



<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a><u><strong>枚举 enum</strong></u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>天然线程安全，并且能够防止反射攻击</p>
<h2 id="Holder-静态内部类-（利用类加载机制）"><a href="#Holder-静态内部类-（利用类加载机制）" class="headerlink" title="Holder 静态内部类 （利用类加载机制）"></a><u><strong>Holder 静态内部类 （利用类加载机制）</strong></u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Holder 在 Singleton 加载时并不会被加载，只有第一次调用 <code>getInstance()</code> 才会加载 Holder，然后创建单例。</p>
<h2 id="CAS-自旋"><a href="#CAS-自旋" class="headerlink" title="CAS 自旋"></a>CAS 自旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;Singleton&gt; instance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">current</span> <span class="operator">=</span> instance.get();</span><br><span class="line">            <span class="keyword">if</span> (current != <span class="literal">null</span>) <span class="keyword">return</span> current;</span><br><span class="line">            current = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">if</span> (instance.compareAndSet(<span class="literal">null</span>, current)) &#123; <span class="comment">// 期望值为 null，设置值为 current</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无锁，非阻塞，线程安全。实现较为复杂，追求极致性能才考虑</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/18/408-%E8%AE%A1%E7%BB%84-PC%20IO%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/18/408-%E8%AE%A1%E7%BB%84-PC%20IO%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">PC IO 结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-18 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-18T00:00:00+08:00">2024-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 12:44:01" itemprop="dateModified" datetime="2025-05-05T12:44:01+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Prototypical-Architecture"><a href="#Prototypical-Architecture" class="headerlink" title="Prototypical Architecture"></a>Prototypical Architecture</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241216183418923-1734346411610-1.png" alt="image-20241216183418923"></p>
<p>CPU通过专用的内存总线连接到内存，通过通用I/O总线(如PCI)连接到显卡等高性能设备，通过外围总线连接到低速的设备(USB Flash, 磁盘驱动器 )，因为光速的限制以及各种物理因素，越快的总线越短，造价也贵，因此离CPU越远的设备性能越低。</p>
<h1 id="Modern-Architecture"><a href="#Modern-Architecture" class="headerlink" title="Modern Architecture"></a>Modern Architecture</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241216185046235.png" alt="image-20241216185046235"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1024px-Motherboard_diagram.svg-1734348489593-5.png" alt="undefined"></p>
<p>在现代系统架构中，有更多的点对点连接到 CPU，PCIe 显卡总线和内存专用总线速度相近，以提供更高的显示性能，CPU通过 <strong>DMI</strong> 连接到一颗 I/O 芯片，所有其他外设通过各种总线连接到这颗I/O芯片。</p>
<h2 id="CPU-Socket"><a href="#CPU-Socket" class="headerlink" title="CPU Socket"></a>CPU Socket</h2><ul>
<li>用于安装中央处理器 (CPU)。</li>
<li>支持不同接口类型（如 LGA、PGA 或 BGA）。</li>
<li>插槽周围有供电模块（VRM）提供稳定电压。</li>
</ul>
<p>不同CPU系列使用不同插槽。后期CPU插槽，数字多数与针脚数量相同：</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LGA_1155">LGA 1155</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LGA_1366">LGA 1366</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LGA_2066">LGA 2066</a>  <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LGA_1700">LGA 1700</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Socket_AM4">Socket AM4</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Socket_TR4">Socket TR4</a> </p>
<h2 id="Chipset"><a href="#Chipset" class="headerlink" title="Chipset"></a>Chipset</h2><p>管理数据传输和硬件通信，负责连接 CPU、内存、显卡、存储等设备</p>
<p><strong>芯片组</strong>(Chipset)负责将电脑的处理器和和其它部分连接，以便能互传数据。芯片组在它所诞生的1980年代时是由多颗微芯片组成的，但是随着科技的进步，芯片组先是从2000年代开始简化为南桥和北桥两颗芯片，再于2010年代简化为单独一颗的南桥芯片，北桥芯片内置在CPU中，目前世界上的芯片组均以单南桥芯片为主流。  </p>
<ul>
<li><strong>南桥</strong>(Southbridge): 主要处理低速信号，后来演变成 ICH-&gt;PCH</li>
<li><strong>北桥</strong>(Northbridge): 主要处理高速信号，同时也负责与南桥的通信，IOH-&gt;MCH，集成进CPU</li>
<li><strong>DMI</strong>：连接南北桥的串行总线</li>
<li><strong>FSB</strong>：前端总线，负责 CPU 和北桥的数据传递。现在的x86 CPU 内部整合了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%A8%98%E6%86%B6%E9%AB%94%E6%8E%A7%E5%88%B6%E5%99%A8&action=edit&redlink=1">北桥</a>。FSB 已被Intel <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/QPI">QPI</a>和AMD <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HyperTransport">HyperTransport</a>取代</li>
</ul>
<h3 id="Memory-Controller-Hub-Northbridge"><a href="#Memory-Controller-Hub-Northbridge" class="headerlink" title="Memory Controller Hub (Northbridge)"></a>Memory Controller Hub (Northbridge)</h3><p>随着技术发展，原来的北桥芯片已直接整合到 <strong>CPU 内部</strong>，减少延迟并提升效率：</p>
<table>
<thead>
<tr>
<th>控制器名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Memory Controller</strong></td>
<td>控制内存访问和管理，负责与 RAM 通信。</td>
</tr>
<tr>
<td><strong>Integrated Graphics Controller</strong></td>
<td>提供基本图形渲染能力，支持视频输出，无需独立显卡。</td>
</tr>
<tr>
<td><strong>PCIe Controller (部分 CPU)</strong></td>
<td>高端 CPU 内部集成部分 PCIe 通道，用于高性能设备的直接通信。</td>
</tr>
<tr>
<td><strong>Power Management Controller</strong></td>
<td>管理电源状态和功耗调节，提高能效。</td>
</tr>
</tbody></table>
<h4 id="Memory-Slots"><a href="#Memory-Slots" class="headerlink" title="Memory Slots"></a>Memory Slots</h4><ul>
<li>用于安装内存模块（RAM）。</li>
<li>常见类型：DDR3、DDR4、DDR5 等。</li>
<li>多通道技术（如双通道、四通道）提高内存带宽。</li>
</ul>
<h5 id="Volatile-Memory-RAM"><a href="#Volatile-Memory-RAM" class="headerlink" title="Volatile Memory (RAM)"></a>Volatile Memory (RAM)</h5><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">易失性存储器</a>(Volatile Memory): 电流中断后，所存储的数据便会消失，一般为 <strong>RAM</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9C%E6%85%8B%E9%9A%A8%E6%A9%9F%E5%AD%98%E5%8F%96%E8%A8%98%E6%86%B6%E9%AB%94">静态随机存储器</a>(<strong>SRAM</strong>, Static RAM): 把信息存储在锁存器中，只要保持通电，存储的数据就可以一直保持，存储密度较低，速度高，功耗低，内部结构也更为复杂。通常作为<strong>cache</strong>(L1, L2, L3)、<strong>寄存器</strong>或 FPGA ASIC 等专用设备的存储器。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8">动态随机存储器</a>(<strong>DRAM</strong>, Dynamic RAM): 根据电容中的电荷多寡来分辨0和1，电容会漏电，不仅要保持通电，还需周期性充电。由于这种需要定时刷新的特性，因此被称为“动态”存储器。存储密度高，速度较低，功耗高，但是成本比 SRAM 低，通常作为 主存 使用，用于存储运行中的程序和数据；也用于 显存。<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SDRAM">同步 DRAM</a>(<strong>SDRAM</strong>, Synchronous DRAM): 在 DRAM 的架构基础上增加同步和双区域（Dual Bank）的功能，使得<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%99%95%E7%90%86%E5%99%A8">微处理器</a>能与 SDRAM 的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%99%82%E8%84%88">时钟</a>同步，所以 SDRAM 执行命令和传输资料时相较于 DRAM 可以节省更多时间。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DDR_SDRAM">双倍数据率 SDRAM</a>(DDR SDRAM, Double Data Rate): DDR SDRAM 在系统时钟的上升沿和下降沿都可以进行数据传输，发展到 DDR5，数据传输率、总线频率逐渐提高<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8A%A8DDR">低功耗 DDR</a>(<strong>LPDDR</strong>, Low Power DDR): 专门用于移动设备，发展到 LPDDR5X</li>
<li>图形 DDR(<strong>GDDR</strong>, Graphics DDR): 为高性能显卡提供显存支持，发展到 GDDR7</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%A0%BB%E5%AF%AC%E8%A8%98%E6%86%B6%E9%AB%94">高带宽内存</a>(HBM, High Bandwidth Memory): 基于3D堆栈工艺的高性能 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DRAM">DRAM</a> 适用于高存储器带宽需求的应用场合，与高性能<strong>显卡</strong>、路由器、交换机、高性能数据中心的AI ASIC结合使用，在 CPU 和 FPGA 中用作包内 RAM 和 Cache</li>
</ul>
</li>
</ol>
<h4 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a>PCIe</h4><p>北桥负责高速传输，因此显卡这种高速设备也需要通过PCIe和北桥(CPU)相连，详见下方PCIe x16</p>
<h3 id="I-O-Controller-Hub-Southbridge"><a href="#I-O-Controller-Hub-Southbridge" class="headerlink" title="I/O Controller Hub (Southbridge)"></a>I/O Controller Hub (Southbridge)</h3><table>
<thead>
<tr>
<th>控制器名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Disk Controller</strong></td>
<td>控制 SATA、SAS 等存储设备的数据传输。</td>
</tr>
<tr>
<td><strong>USB Controller</strong></td>
<td>控制 USB 2.0、3.0、3.1、Type-C 等接口的数据传输。</td>
</tr>
<tr>
<td><strong>PCIe Controller</strong></td>
<td>管理 PCI Express 插槽的通信，用于扩展显卡、网卡等设备。</td>
</tr>
<tr>
<td><strong>Ethernet Controller</strong></td>
<td>控制有线网络通信，通常内置支持千兆或 2.5G 网卡。</td>
</tr>
<tr>
<td><strong>Audio Controller</strong></td>
<td>提供板载音频功能，支持麦克风、扬声器等外设连接。</td>
</tr>
<tr>
<td><strong>SATA Controller</strong></td>
<td>控制 SATA 硬盘和光驱设备的数据传输。</td>
</tr>
<tr>
<td><strong>RAID Controller</strong></td>
<td>支持磁盘阵列（RAID）的数据管理，提高存储性能和安全性。</td>
</tr>
<tr>
<td><strong>Wireless Controller</strong></td>
<td>控制 Wi-Fi 和蓝牙模块的无线通信功能（部分主板内置）。</td>
</tr>
<tr>
<td><strong>Security Controller (TPM)</strong></td>
<td>提供可信平台模块 (TPM) 功能，保障数据安全性和加密管理。</td>
</tr>
</tbody></table>
<h4 id="Storage-Interface-SATA-SAS"><a href="#Storage-Interface-SATA-SAS" class="headerlink" title="Storage Interface (SATA/SAS)"></a>Storage Interface (SATA/SAS)</h4><ul>
<li><strong>IDE</strong>(Integrated Device Electronics): IDE 是一项企图把控制器与盘体集成在一起为主要意图的硬盘接口技术。</li>
<li><strong>ATA</strong>(Advanced Technology Attachment): ATA 技术是一个关于 IDE 的技术规范族，全球标准化协议将 IDE 接口技术自诞生以来使用的技术规范归纳成为全球硬盘标准。<ul>
<li><strong>并行接口 ATA</strong>(Parallel ATA)的电缆属性、连接器和信号协议都表现出了很大的技术瓶颈，而在技术上突破这些瓶颈存在相当大的难度</li>
</ul>
</li>
<li>==<strong>SATA</strong>==(Serial ATA): 并行的 PATA 存在固有的瓶颈——并行信号串扰与同步问题，因此改成了<strong>串行</strong>总线。SATA 既是一种<strong>物理接口</strong>（硬件层连接方式），也是一种<strong>逻辑接口</strong>协议（定义数据通信规则）最初是为传统机械硬盘（HDD）设计的，后来也应用于部分 SSD<ul>
<li><strong>eSATA</strong>(External SATA): 外置 SATA 接口，方便外设的连接，eSATA 不像 USB 那样能同时传输数据和供电，因此需要额外的电源线为外部设备供电，属于物理接口协议。</li>
<li><strong>mSATA</strong>(mini-SATA): 迷你版本SATA接口，外型和电子接口与mini PCI-E完全相同，但电子信号不同，两者互不兼容。多用于固态硬盘，适用于需要尺寸较小的存储器的场合</li>
<li><strong>AHCI</strong>(Advanced Host Controller Interface): 允许软件与 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SATA">SATA</a> 存储设备沟通的硬件机制，激活 SATA 的高级功能，属于逻辑接口协议。AHCI 系统的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%9C%BA%E9%80%82%E9%85%8D%E5%99%A8">主机适配器</a>将CPU/存储器子系统与相对慢得多的、基于旋转<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A3%81%E5%84%B2%E5%AD%98">磁性介质</a>的存储子系统，AHCI 是针对这种悬殊的速度差来进行优化设计的。AHCI 是针对硬盘优化的，不适合固态盘。</li>
</ul>
</li>
<li><strong>SCSI</strong>(Small Computer System Interface): 一种连接主机和外围设备的接口，支持包括硬盘、光驱及扫描仪在内的多种设备。SCSI 总线是一种<strong>并行</strong>总线，其优点是适应面广，性能高；缺点是价格昂贵，安装复杂。</li>
<li>==<strong>SAS</strong>==(Serial Attached SCSI): <strong>串行</strong> SCSI ，跟 SATA 总线类似，都是采用串行技术以获得更高的传输速度。就接口标准而言，SATA 是 SAS 的一个子标准，因此 SAS 控制器可以直接操控SATA 硬盘，但是 SATA 控制器并不能对 SAS 硬盘进行控制。</li>
</ul>
<p>SCSI/SAS 需要专用的控制卡，或者主板另外集成控制芯片，性能更好。PATA/SATA 一般由主板南桥/ICH 芯片直接集成控制器，但接口性能一般比同时期的 SCSI/SAS 要低。目前，服务器流行的硬盘接口类型是 SATA 以及 SAS，两者都是采用串行技术，传输速率都更高。</p>
<h4 id="I-O-Ports-USB-DP-HDMI"><a href="#I-O-Ports-USB-DP-HDMI" class="headerlink" title="I/O Ports(USB, DP, HDMI)"></a>I/O Ports(USB, DP, HDMI)</h4><p><strong>通用外设接口</strong> </p>
<ul>
<li><p><strong>==USB==</strong>(Universal Serial Bus): 串口总线标准，也是一种输入输出接口的技术规范，被广泛地应用于个人电脑和移动设备等信息通讯产品，并扩展至摄影器材、数字电视(机顶盒)、游戏机等其它相关领域。逐渐取代 PS/2 连接键盘与鼠标，取代 COM(串口)与 LPT(并口)</p>
<ul>
<li><p>技术标准</p>
<ul>
<li>USB 2.0: 480 Mbps，半双工</li>
<li>USB 3.0: 5 Gbps，全双工，向下兼容</li>
<li>USB 3.1: 10 Gbps，向下兼容</li>
<li>USB 3.2: 20 Gbps，在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB_Type-C">USB Type-C</a>接口上实现双通道，向下兼容，推荐 Type-C 接口</li>
<li>USB 4: 40 Gbps，只支持 Type-C</li>
<li>USB PD: USB 充电标准</li>
</ul>
</li>
<li><p>接口</p>
<ul>
<li>Mini-USB：弃用</li>
<li>Type-A： <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1920px-USB_3.0_Type-A_receptacle_blue.svg.png" alt="undefined" style="zoom:3%;" />  <img src="C:/Users/Lenovo/Pictures/markdownfile/Everything%20about%20mainboard.assets/2560px-USB_3.0_Type-A_blue.svg.png" alt="undefined" style="zoom:3%;" /></li>
<li>Type-B：<img src="https://upload.wikimedia.org/wikipedia/commons/d/d5/USB_3.0_Type-B_blue.svg" style="zoom:17%;" /> <img src="https://upload.wikimedia.org/wikipedia/commons/8/8c/USB_3.0_Type-B_receptacle_blue.svg" style="zoom:17%;" /></li>
<li>Micro-USB：<img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/USB_Micro-B_receptacle.svg" style="zoom:15%;" /> <img src="https://upload.wikimedia.org/wikipedia/commons/1/15/USB_Micro-B.svg" style="zoom:16%;" /></li>
<li>Type-C：<img src="https://upload.wikimedia.org/wikipedia/commons/e/e8/USB_Type-C_receptacle.svg" style="zoom:15%;" /> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/512px-USB_Type-C_icon.svg.png" alt="img" style="zoom:13%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>雷电</strong>(Thunderbolt): 目的在于当作电脑与其他设备之间的通用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8C%AF%E6%B5%81%E6%8E%92_(%E6%95%B8%E6%93%9A)">总线</a>，第一代与第二代的连接口与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Mini_DisplayPort">Mini DisplayPort</a>集成，第三代至第五代的连接口与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB_Type-C">USB Type-C</a>结合，并且能用于充电。由于采用了PCI Express和DisplayPort架构，雷电可以<strong>高速连接诸如硬盘、RAID阵列、视频采集设备和网络接口等外设</strong> </p>
</li>
</ul>
<p><strong>音视频接口</strong>(HDMI, DP, 雷电)：</p>
<ul>
<li><p><strong>VGA</strong>(视频图形阵列, <strong>V</strong>ideo <strong>G</strong>raphics <strong>A</strong>rray): 使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E8%A8%8A%E8%99%9F">模拟信号</a>的电脑显示标准，在1987年随IBM PS/2系列计算机推出。VGA是大多数PC制造商所遵循的最后一个IBM图形标准，几乎1990年后的所有PC图形硬件都最低支持VGA。当用VGA来表示分辨率时，通常是指640×480。</p>
</li>
<li><p><strong>DVI</strong>(<strong>数字</strong>视频接口, <strong>D</strong>igital <strong>V</strong>isual <strong>I</strong>nterface)：一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A6%96%E8%A8%8A">视频</a>接口标准，设计的目的是用来传输未经压缩的数字化影像。目前广泛应用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LCD">LCD</a>、数字<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8A%95%E5%BD%B1%E6%A9%9F">投影机</a>等显示设备上。</p>
</li>
<li><p><strong>HDMI</strong>(高清媒体接口, <strong>H</strong>igh <strong>D</strong>efinition <strong>M</strong>ultimedia <strong>I</strong>nterface): 是一种全<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D">数字</a>化<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BD%B1%E5%83%8F">影像</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%81%B2%E9%9F%B3">声音</a>发送接口，可以发送未<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E5%A3%93%E7%B8%AE">压缩</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E9%A2%91">音频</a>及<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A6%96%E9%A0%BB">视频</a>信号。HDMI 可以同时发送音频和视频信号。音频和视频信号采用同一条线材的设计大大简化系统线路的安装难度。</p>
</li>
<li><p><strong>DP</strong>(显示端口, <strong>D</strong>isplay <strong>P</strong>ort): 数字式音频/视频接头，此接口的设计是为了取代传统的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/VGA">VGA</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DVI">DVI</a>接口。透过主动或被动转接器，该接口可与传统接口（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HDMI">HDMI</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DVI">DVI</a>）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%91%E4%B8%8B%E7%9B%B8%E5%AE%B9">向下兼容</a>。</p>
</li>
<li><p><strong>雷电</strong>(Thunderbolt): 有接口也有总线，目的在于当作电脑与其他设备之间的通用 <strong>总线</strong>，第一代与第二代的连接口与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Mini_DisplayPort">Mini DisplayPort</a>集成，第三代至第五代的连接口与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB_Type-C">USB Type-C</a>结合，并且能用于充电。由于采用了PCI Express和DisplayPort架构，雷电可以<strong>高速连接诸如硬盘、RAID阵列、视频采集设备和网络接口等外设</strong>。</p>
</li>
</ul>
<h4 id="Peripheral-Card-Slots"><a href="#Peripheral-Card-Slots" class="headerlink" title="Peripheral Card Slots"></a>Peripheral Card Slots</h4><p>外围扩展设备插槽：</p>
<ul>
<li>用于连接显卡、声卡、网卡、固态硬盘 (NVMe SSD) 等扩展设备。</li>
<li>常见标准：PCI Express (PCIe) 3.0、4.0、5.0  M.2 2280</li>
</ul>
<h5 id="PCIe-slots"><a href="#PCIe-slots" class="headerlink" title="PCIe slots"></a>PCIe slots</h5><p>PCIe 可以连到南桥或北桥</p>
<ul>
<li><strong>PCI</strong>(Peripheral Component Interconnect): 常见于现代的个人电脑中，并已取代了 ISA 和 VESA 局部总线，成为了标准扩展总线，是并行的总线。</li>
<li><strong>==PCIe==</strong>(PCI Express): 沿用既有的 PCI 编程概念及信号标准，并且构建了更加高速的串行通信系统标准。只需修改<strong>物理层</strong>而无须修改软件就可将现有 PCI 系统转换为 PCIe，几乎取代了以往所有的内部总线(包括 PCI)。现在英特尔和 AMD 已采用单芯片组(IO Chip)技术，取代原有的南桥和北桥方案。PCIe仅应用于内部互连，没有对外开放的接口。可以连接<strong>显卡</strong>、<strong>网卡</strong>，高性能的持久化存储设备如 NVMe 设备。根据传输通道数量分为 PCIe ×1, PCIe ×4, PCIe ×8, PCIe ×16<ul>
<li><strong>SATA Express</strong>: 物理、逻辑接口标准，使用 PCIe 总线，向下兼容 SATA，支持 PCIe(AHCI 和 NVMe) 设备。后来物理接口被 M.2 和 U.2 取代。</li>
<li><strong>NVMe</strong>(NVM Express, NVMHCIS): 非易失性存储器的接口标准，它是基于设备<strong>逻辑接口</strong>的总线传输协议规范，用于访问通过 PCIe 总线附加的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">非易失性存储器</a>介质（比如 SSD）降低了I/O操作等待时间、提升同一时间内的操作数、更大容量的操作队列等，取代 AHCI 作为新的逻辑接口协议。</li>
</ul>
</li>
</ul>
<h6 id="NVM-Flash-EEPROM"><a href="#NVM-Flash-EEPROM" class="headerlink" title="NVM(Flash/EEPROM)"></a>NVM(Flash/EEPROM)</h6><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">非易失性存储器</a></strong>(<strong>NVM</strong>, Non-Volatile Memory): 电流关掉后，所存储的信息不会消失的存储设备。依存储器内的资料是否能在使用系统时随时改写为标准，可分为三大类产品：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ROM">只读存储器</a>(ROM, Read-only Memory)</p>
<ul>
<li>MROM(Masked ROM): 使用掩模工艺，出厂后不可改变，永久固化</li>
<li>PROM(Programmable ROM): 用户可编程的 ROM，烧断熔丝来改变比特，不可逆</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%93%A6%E9%99%A4%E5%8F%AF%E8%A6%8F%E5%8A%83%E5%BC%8F%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94">EPROM</a>(Erasable PROM): FGMOS 代替熔丝，专用编程器编程，用紫外线擦除，可逆</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E6%8A%B9%E9%99%A4%E5%BC%8F%E5%8F%AF%E8%A4%87%E5%AF%AB%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94">EEPROM</a>(Electrically EPROM): 只需要特定电压就可以擦除</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Flash_memory">闪存</a>(Flash Memory): 与传统的硬盘相比，闪存有更佳的动态抗震性，不会因为剧烈晃动而造成资料丢失。与 SRAM 相比不需要供电，造价相对 EEPROM 较低，使用块抹除。闪存在分类上属于 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EEPROM">EEPROM</a> 的一种，但普通的 EEPROM 使用的是字节抹除。 </p>
<ul>
<li><p>按照 FGMOS 的门电路结构分为：</p>
<ul>
<li>NOR Flash: 抹写时间长，提供完整的寻址总线，可按字节<strong>随机存取</strong>，类似 RAM</li>
<li>NAND Flash: 抹写时间短，次数高，存储密度高，只能按页访问，类似硬盘，应用有 SSD 固态硬盘、SD 卡、U盘等。</li>
</ul>
</li>
<li><p>按照 每存储单元存储 bit 数分为：</p>
<ul>
<li><p>SLC(1) MLC(2) TLC(3) QLC(4) 成本、寿命、写入性能依次降低</p>
</li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-Nand_flash_structure.svg.png" alt="undefined"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%9E%E6%8F%AE%E7%99%BC%E6%80%A7%E9%9A%A8%E6%A9%9F%E5%AD%98%E5%8F%96%E8%A8%98%E6%86%B6%E9%AB%94&action=edit&redlink=1">非易失性随机存储器</a>(NVRAM, Non-volatile RAM)</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/FRAM">FeRAM</a>: 替换介电质为铁电材料</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A3%81%E9%98%BB%E5%BC%8F%E9%9A%A8%E6%A9%9F%E5%AD%98%E5%8F%96%E8%A8%98%E6%86%B6%E9%AB%94">MRAM</a>: 使用磁存储器件存储数据，应用巨磁阻效应</li>
</ul>
</li>
</ol>
<h5 id="M-2-slots"><a href="#M-2-slots" class="headerlink" title="M.2 slots"></a>M.2 slots</h5><ul>
<li><strong>==M.2==</strong>(NGFF): 采用全新物理布局与接口，取代 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PCI_Express">PCIe</a> 及 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SATA#mSATA">mSATA</a> 的物理插槽<ul>
<li>U.2: 2015 年SATA Express发布了一种兼容SAS、PCI Express x4、SATA总线的的U.2连接器界面，U.2更多用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%BA%E6%9C%8D%E5%99%A8">服务器</a>等企业应用场合。U.2支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%86%B1%E6%8F%92%E6%8B%94">热插拔</a>而M.2不支持；U.2可使用3.3V电源和12V电源，M.2只能使用3.3V电源；M.2可应用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98">固态硬盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1">无线网卡</a>等设备，而U.2仅用于2.5英寸固态盘。</li>
<li>支持 SATA、AHCI+PCIe、NVMe+PCIe，同时可以连接网卡等</li>
</ul>
</li>
</ul>
<h4 id="Flash-ROM-BIOS"><a href="#Flash-ROM-BIOS" class="headerlink" title="Flash ROM (BIOS)"></a>Flash ROM (BIOS)</h4><p>大部分的主板的BIOS存储在Flash ROM芯片内，用于对主板作启动的初始化；在启动的过程中包含存储器、周边设备都会被测试以及做初始设置，这个过程称为 加电自检 POST，若是在 POST 的过程中出现错误，则主机会发出”哔”声或是出现错误消息在屏幕上。从2011年起，大部分的零售主板已采用UEFI BIOS，一些厂商（尤其是微星科技、华硕）还率先导入图形界面的UEFI BIOS等技术。</p>
<h4 id="CMOS-Memory"><a href="#CMOS-Memory" class="headerlink" title="CMOS Memory"></a>CMOS Memory</h4><p>CMOS 纽扣电池供电给 CMOS 芯片(RAM)，CMOS 芯片保存系统时间和 BIOS 设置。</p>
<h2 id="Other-Modules"><a href="#Other-Modules" class="headerlink" title="Other Modules"></a>Other Modules</h2><h3 id="Power-Interface"><a href="#Power-Interface" class="headerlink" title="Power Interface"></a>Power Interface</h3><ul>
<li>24 针主电源接口：为主板供电。</li>
<li>8 针或 4+4 针 CPU 辅助电源接口：为 CPU 供电。</li>
</ul>
<h3 id="Cooling-Module"><a href="#Cooling-Module" class="headerlink" title="Cooling Module"></a>Cooling Module</h3><ul>
<li>CPU 散热器接口：供电及控制风扇速度。</li>
<li>芯片组和供电模块上的散热片和风扇，降低温度。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1024px-IO_stack_of_the_Linux_kernel.svg.png" alt="undefined"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/17/408-%E8%AE%A1%E7%BB%84-ROM%20RAM%20Cache%20Bus%20IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/17/408-%E8%AE%A1%E7%BB%84-ROM%20RAM%20Cache%20Bus%20IO/" class="post-title-link" itemprop="url">ROM RAM Cache IO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-17 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-17T00:00:00+08:00">2024-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 12:44:19" itemprop="dateModified" datetime="2025-05-05T12:44:19+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617152721653.png" alt="image-20240617152721653"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617154333462.png" alt="image-20240617154333462"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617160638666.png" alt="image-20240617160638666"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="计算机基本组成"><a href="#计算机基本组成" class="headerlink" title="计算机基本组成"></a>计算机基本组成</h2><h4 id="冯诺依曼"><a href="#冯诺依曼" class="headerlink" title="冯诺依曼"></a>冯诺依曼</h4><p>==calculator== storage controller I/O</p>
<p>instruction data 同等地位</p>
<p>层次化 模块化 明确定义的接口</p>
<p>规则性 容易被重用</p>
<p>取存 加乘 PRINTs STOP</p>
<p>指令格式：操作码+地址码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617213301501.png" alt="image-20240617213301501"></p>
<h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><p>存储单元个数 由MAR决定 存储器地址寄存器，4位能存16个地址</p>
<p>取数指令，运算指令 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617214101456.png" alt="image-20240617214101456"></p>
<p>每个存储单元能够保存的数据长度称为字长，</p>
<p>MAR 4位 能存16个地址</p>
<p>MDR 8位 每个地址能存的字节数</p>
<p>房间号-房间里的床位情况</p>
<h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p>乘法<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621161144203.png" alt="image-20240621161144203"></p>
<h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><h4 id="完成一条指令的过程"><a href="#完成一条指令的过程" class="headerlink" title="完成一条指令的过程"></a>完成一条指令的过程</h4><p>取指令，PC储存要执行指令的地址，应支持计数，存到IR，取完自加</p>
<p>分析指令， IR 存放当前执行的指令，OPCODE操作码给到CU</p>
<p>执行指令 操作数的地址</p>
<ul>
<li>程序计数器（PC，Program counter），用于存放指令的地址。为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称，为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。</li>
<li>指令寄存器（IR，Instruction Register），用来保存当前正在执行的一条指令。是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一条指令。当执行一条指令时，先把它从内存取到数据寄存器（DR，Data Register）中，然后再传送至IR。指令划分为操作码和地址码字段，由二进制数字组成。为了执行任何给定的指令，必须对操作码进行测试，以便识别所要求的操作。指令译码器就是做这项工作的。指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。</li>
</ul>
<h4 id="主机完成一条指令过程"><a href="#主机完成一条指令过程" class="headerlink" title="主机完成一条指令过程"></a>主机完成一条指令过程</h4><p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621171338162.png" alt="image-20240621171338162"></p>
<h4 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h4><p>字长，主频，核数与线程数，指令集执行的时间（静态动态执行频率）</p>
<p>CPI 一条指令所需时钟周期数</p>
<p>IPC 一个时钟周期执行指令数</p>
<p>mips 每秒执行的百万条指令数</p>
<p>flops 每秒浮点运算次数</p>
<p>iops I/O Operations Per Second</p>
<h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>总线： 各部件共享的传输介质，分时，同一时刻只允许一个</p>
<p>传送方式：串行、并行（距离短）</p>
<p>主设备从设备：有无对总线的控制功能</p>
<h3 id="单总线"><a href="#单总线" class="headerlink" title="单总线"></a>单总线</h3><p>延宕严重</p>
<h3 id="双总线"><a href="#双总线" class="headerlink" title="双总线"></a>双总线</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621213833311.png" alt="image-20240621213833311"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621213950031.png" alt="image-20240621213950031"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621221022916.png" alt="image-20240621221022916"></p>
<ol start="3">
<li>通信总线</li>
</ol>
<h3 id="总线通信"><a href="#总线通信" class="headerlink" title="总线通信"></a>总线通信</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iteye_21199/article/details/82200270">同步通信：高度同步，总系长度短</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704200733860.png" alt="image-20240704200733860"></p>
<p>不互锁，半互锁，全互锁</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704200917886.png" alt="image-20240704200917886"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704201135928.png" alt="image-20240704201135928"></p>
<p>从设备准备好数据，WAIT才变成高电平</p>
<p>主模块发地址 命令，占用总线</p>
<p>从模块准备数据，<strong>空闲</strong></p>
<p>从模块向主模块发数据，占用总线</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704201642697.png" alt="image-20240704201642697"></p>
<p>同步方式，不等对方回答</p>
<p>各模块都有权申请占用总线</p>
<p>从模块变成主模块，发完数据以后再次跟总线断开，总线和原来的主模块连接</p>
<p>充分利用总线带宽</p>
<h3 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h3><p>链式查询、计数器定时查询、独立请求</p>
<p>为的是解决多个设备竞争总线控制权</p>
<h2 id="存储器-1"><a href="#存储器-1" class="headerlink" title="存储器"></a>存储器</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a><strong>存储介质</strong></h4><p><strong>半导体</strong>存储器（TTL MOS）</p>
<p><strong>磁</strong>表面 (HDD 磁带)</p>
<p>磁芯存储器(Core memory) 电流磁化以后使其极化</p>
<p><strong>光盘</strong>存储器</p>
<h4 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h4><p>随机访问，和物理地址无关 RAM 可读写，只读存储器ROM只读</p>
<p>串行访问，磁带，顺序存取，磁盘</p>
<h4 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h4><p>主存</p>
<ul>
<li>RAM(SRAM,DRAM)<br>ROM(MROM,PROM,EPROM,EEPROM)</li>
</ul>
<p>闪存 缓冲主存和辅存</p>
<p>高速缓冲存储器Cache sram</p>
<p>辅助存储</p>
<h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p>速度，价格，容量</p>
<p>存储体系：把两种以上的存储器用软&amp;硬件连接成一个整体</p>
<p>缓存和主存之间要的是速度，硬件支持</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704203517251.png" alt="image-20240704203517251"></p>
<p>主辅之间要的是容量，软件硬件相结合，虚拟存储，虚地址</p>
<h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704205102321.png" alt="image-20240704205102321"></p>
<p>GB是千kilo进制 </p>
<p>GiB是千位kilo b<strong>i</strong>nary二进制</p>
<p>计算机一次处理的位数称为字长</p>
<p>16位，1word=16bit=2byte</p>
<p>32位，1word=32bit=4byte</p>
<p>64位，1word=64bit=8byte</p>
<p>字节是计算机处理数据的基本单位，几乎所有计算机操作系统和编程语言都以字节为单位进行数据管理和传输，数据存储是以“字节”（Byte）为单位，数据传输是以大多是以“位”（bit，又名“比特”）为单位，一个位就代表一个0或1（即二进制），每8个位（bit，简写为b）组成一个字节（Byte，简写为B），是最小一级的信息单位。<br>还可以从以下几个方面来理解：<br>1.字节(Byte)是电脑中表示信息含义的最小单位，因为在通常情况下一个ACSII码就是一个字节的空间来存放。而事实上电脑中还有比字节更小的单位，因为一个字节是由八个二进制位组成的，换一句话说，每个二进制位所占的空间才是电脑中最小的单位，我们把它称为位，也称比特（bit）。由此可见，一个字节等于八个位。人们之所以把字节称为电脑中表示信息含义的最小单位，表示最基本的字符，是因为一个位并不能表示我们现实生活中的一个相对完整的信息。另外，内存中运算的最小存储单位是字节，位运算也是在一个字节的存储单位的基础上进行的，所以<strong>存储的最小单位可以理解为字节。</strong> </p>
<p>2.bit是二进制数的一位包含的信息或2个选项中特别指定1个的需要信息量称为一比特，是表示信息的最小单位，只有两种状态：0和1。电脑内部的电路工作有高电平和低电平两种状态.所以就用二进制来表示信号，以便计算机识别。所以计算机能传输的最小单位当然是你信号的单位bit，而不是字节，串口最小也有一位传递的。另外数字信息流的基本单位是bit（比特），时间的基本单位是s（秒），因此bit/s（比特/秒）是描述带宽的单位，1bit/s是带宽的基本单位，所谓的带宽其实指的是传输速度的快慢，也就是指在一个固定的时间内（1秒），能通过的最大位数据。</p>
<p>地址线上是地址信息，一根地址线只能存储2种状态。32根地址线实际上能表示一个32位的二进制数，可以用32个二进制位来表示任意的内存地址或I/O端口地址。</p>
<p>寻址：当CPU<strong>请求数据时获得该数据在内存上的位置的过程</strong>。内存上存储的所有数据都会有一个可以区分的地址，这与其存放的位置相对应，当CPU请求数据时，内存中的电路会根据CPU的地址线上的信号利用数据总线向CPU返回数据。</p>
<p>那么内存是如何编码数据保存的位置的？这里涉及到上文所述的字节的概念。内存每一个存储位置的最小单元都可以储存0或1，即一个位的内容，而内存将8个位设定为一个存储空间的基本单位。而在地址线上每一个地址的编号便对应的是一个存储位置的最小的基本单位。</p>
<p>如何在地址线上用信号表示这个地址，这个问题引出了两个不同的寻址方式：按字节寻址和按字寻址。</p>
<p>如果有30条地址线，一共能表示2^30^ 个字节，能表示2^30^ </p>
<h4 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h4><p>容量大小</p>
<p>速度：</p>
<ul>
<li>存取时间t1<ul>
<li>访问时间（读出时间，写入时间）</li>
</ul>
</li>
<li>存取周期t2<ul>
<li>连续 两次 独立 的存储器操作</li>
<li>读或者写最小的时间间隔</li>
</ul>
</li>
</ul>
<p>t1&lt;t2</p>
<p>带宽 bps</p>
<h4 id="半导体存储芯片"><a href="#半导体存储芯片" class="headerlink" title="半导体存储芯片"></a>半导体存储芯片</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704214511866.png" alt="image-20240704214511866"></p>
<p>4条数据线意味着每个内存单元可以存储4个数据位（通常是4比特）。这意味着每个内存单元可以存储 24=162^4 = 1624=16 个不同的数据值。</p>
<table>
<thead>
<tr>
<th>地址线（单向）</th>
<th>数据线（双向）</th>
<th>芯片容量</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>4</td>
<td>1K*4bit</td>
</tr>
<tr>
<td>14</td>
<td>1</td>
<td>16K*1 bit</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>内存条上有很多芯片，不同的地址范围选的芯片也不一样 ，还有读写控制线</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704215706473.png" alt="image-20240704215706473"></p>
<h5 id="译码驱动"><a href="#译码驱动" class="headerlink" title="译码驱动"></a>译码驱动</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704220128452.png" alt="image-20240704220128452"></p>
<p>4位地址，共16个单元，8条控制线，一个单元是8位，所以存储空间是一个16*8位的矩阵，简单</p>
<p>0000 字线0号激活，0,0~0,7</p>
<p>缺点：线路密集</p>
<p>20个地址线，输出1M条线，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704220753043.png" alt="image-20240704220753043"></p>
<p>只有两边同时激活才能进行数据的输出，20个地址线，译码器输出只用2K条线。</p>
<h4 id="RAM-随机存取"><a href="#RAM-随机存取" class="headerlink" title="RAM 随机存取"></a>RAM 随机存取</h4><h5 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h5><p>保存0-1的原理：用双稳态触发器</p>
<p>六管静态RAM</p>
<h5 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704221726015.png" alt="image-20240704221726015"></h5><p>给出行选信号，列选信号，读有效</p>
<p>T6 T8 然后读出</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704222330938.png" alt="image-20240704222330938"></p>
<p>Intel 2114 读</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704223228647.png" alt="image-20240704223228647"></p>
<h5 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h5><p>保存0-1:电容（需要刷新）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704224121714.png" alt="image-20240704224121714"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704224306390.png" alt="image-20240704224306390"></p>
<p>刷新放大器对电容充电</p>
<p>放大器能够放大电容的电平</p>
<p>刷新和行地址有关，列地址无关</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704225313098.png" alt="image-20240704225313098"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704225840140.png" alt="image-20240704225840140"></p>
<p>刷新安排再指令译码阶段</p>
<h5 id="SRAM-VS-DRAM"><a href="#SRAM-VS-DRAM" class="headerlink" title="SRAM VS DRAM"></a>SRAM VS DRAM</h5><table>
<thead>
<tr>
<th></th>
<th>DRAM（主存）</th>
<th>SRAM（Cache）</th>
</tr>
</thead>
<tbody><tr>
<td>存储原理</td>
<td>电容</td>
<td>触发器</td>
</tr>
<tr>
<td>集成度</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>芯片引脚</td>
<td>少（行列分别传）</td>
<td>多</td>
</tr>
<tr>
<td>功耗</td>
<td>少</td>
<td>多</td>
</tr>
<tr>
<td>价格</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>刷新</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>速度</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody></table>
<h4 id="ROM-只读存储器"><a href="#ROM-只读存储器" class="headerlink" title="ROM 只读存储器"></a>ROM 只读存储器</h4><p>MROM 掩膜ROM Uncustomizable</p>
<p>交叉处有无MOS管 有1无0</p>
<p>PROM 一次性编程 破坏性编程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704230627923.png" alt="image-20240704230627923"></p>
<p>EPROM 多次 紫外线擦写</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704230734230.png" alt="image-20240704230734230"></p>
<p>EEPROM 支持局部擦写</p>
<p>FlashMemory </p>
<h4 id="存储器与CPU连接"><a href="#存储器与CPU连接" class="headerlink" title="存储器与CPU连接"></a>存储器与CPU连接</h4><h5 id="容量扩展"><a href="#容量扩展" class="headerlink" title="容量扩展"></a>容量扩展</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704231244644.png" alt="image-20240704231244644"></p>
<p>两个芯片共用地址线，输入1个十位的地址，2114内相同的地址单元能够同时各自输出自己储存的4位信息，重点：<strong>同时工作</strong> 片选同时激活</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704231832857.png" alt="image-20240704231832857"></p>
<p>11根地址线，多出来的一条用于控制片选，原来10根地址线共用，地址线的目的：每一个二进制数都要表示一个不同的存储单元 片选不同时工作</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704232318234.png" alt="image-20240704232318234"></p>
<p>原来10根地址线共用</p>
<h5 id="连接存储器与CPU"><a href="#连接存储器与CPU" class="headerlink" title="连接存储器与CPU"></a>连接存储器与CPU</h5><p>写出二进制地址码，确认芯片数量和类型，分配地址线，确定片选信号逻辑</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705131119849.png" alt="image-20240705131119849"></p>
<p>CPU-16根地址线-8根数据线</p>
<p>6000H 67FF为系统程序区 2K*8 11根 ROM</p>
<p>6800H 6BFFH为用户程序区 1K*8 10根 RAM</p>
<p>ROM选择2K*8 RAM选择1K*4的两个存储器进行位扩展</p>
<p>A10-A0 连接ROM A9-A0连接RAM</p>
<p>A13-A11 连接138 译码信号连到片选上 100-ROM 101-RAM </p>
<p>A14连到138的G1 A15连接到G2a</p>
<p>MREQ低电平访存控制信号连到G2b</p>
<p>（CPU访问内存，译码器必须工作）</p>
<p>地址要全部用上</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705131919043.png" alt="image-20240705131919043"></p>
<p>注意看 ROM2K空间利用充分，但是Y5和A10同时=0才算RAM空间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705131758051.png" alt="image-20240705131758051"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705135723021.png" alt="image-20240705135723021"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705135733548.png" alt="image-20240705135733548"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705135742847.png" alt="image-20240705135742847"></p>
<p>错误处理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705212942601.png" alt="image-20240705212942601"></p>
<p>低位交叉</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705213711855.png" alt="image-20240705213711855"></p>
<p>看清，是几体并行，4体并行就是低2位为译码器输入。</p>
<p>要求32K * 8 bit 给了4K * 4 bit的芯片 ， 低位交叉四体并行</p>
<p>4K 共12位地址线 需要芯片共16片，一般的做法是用2片4K*4进行位扩展，用8个这样的组合进行字扩展，高3位接译码器，但由于是要求低位4体并行的交叉编址，先用2片4K*4进行位扩展，然后用两组进行字扩展，最后用4个这样的组合进行字扩展。低2位接译码器</p>
<p>读写信号、MREQ、数据输出位D、地址线、片选使能（位扩展使能统一，字扩展看译码器输出）</p>
<h5 id="存储器校验"><a href="#存储器校验" class="headerlink" title="存储器校验"></a>存储器校验</h5><p>检测与纠错能力</p>
<h6 id="前导：奇偶校验"><a href="#前导：奇偶校验" class="headerlink" title="前导：奇偶校验"></a>前导：奇偶校验</h6><ul>
<li><p><strong>奇校验</strong>：如果数据单元中1的数量已经是奇数，则校验位设置为0；否则，校验位设置为1。如果出现错误，1的个数不再是奇数。</p>
<ul>
<li>假设数据单元为8位，并且使用奇校验：</li>
<li>数据 <code>10110011</code> 中有5个1，因此符合奇数要求，校验位为0。</li>
<li>数据 <code>11001010</code> 中有4个1，不符合奇数要求，校验位为1。</li>
</ul>
</li>
<li><p><strong>偶校验</strong>：如果数据单元中1的数量已经是偶数，则校验位设置为0；否则，校验位设置为1。如果出现错误，1的个数不再是偶数。</p>
</li>
<li><p><strong>校验过程</strong></p>
<p>发送方在数据末尾添加校验位，形成校验单元后发送。接收方收到数据后，重新计算校验位，并与接收到的校验位进行比对。如果两者相同，则认为数据传输正确；如果不同，则意味着在传输过程中出现了错误。</p>
</li>
</ul>
<p>2^k^≥n+k+1</p>
<p>K是纠错码位数，一共有2^k^种错误，</p>
<p>一位错，n+k+1</p>
<p>合法代码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705140417990.png" alt="image-20240705140417990"></p>
<p> 编码最小距离：任意两个合法代码二进制位的最少差异数</p>
<p>L-1 = D+C</p>
<p>Length Detected Correction</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a493823882/article/details/109343791">汉明码使用</a> 校验位错了不用纠</p>
<h4 id="提高访存速度"><a href="#提高访存速度" class="headerlink" title="提高访存速度"></a>提高访存速度</h4><p>高速器件、层次结构(Cache)、<strong>调整主存结构</strong></p>
<h5 id="单体多字系统"><a href="#单体多字系统" class="headerlink" title="单体多字系统"></a>单体多字系统</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210133859.png" alt="image-20240705210133859"></p>
<p>数据不连续会影响效率，4个字一起出来</p>
<h5 id="多体并行"><a href="#多体并行" class="headerlink" title="多体并行"></a>多体并行</h5><p><strong>高位交叉</strong>，</p>
<p>数据组织特点：相邻地址的数据处于同一存储体,一个地址寄存器,多模块串行（局部性原理）,性能无提升,扩充容量方便</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210318229.png" alt="image-20240705210318229"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/b5ecff2b7ba843538f083126dfe59653-1720187489744-3.png" alt="b5ecff2b7ba843538f083126dfe59653"></p>
<p><strong>低位交叉</strong>，如果采用分时启动的方法，可以在不改变每个存储体存取周期的前提下，提高整个主存的速度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210508945.png" alt="image-20240705210508945"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210704163.png" alt="image-20240705210704163"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/96e598788488485e97a03a8ff2059885-1720187482260-1.png" alt="96e598788488485e97a03a8ff2059885"></p>
<p>每个存储体均需地址寄存器,模M编址方式 多模块并行（局部性原理）,扩充容量也方便</p>
<p>低位交叉的好处：如果要连续读取，同一个访问周期内，存储器是不能进行下一步读取的，高位交叉会让同一个存储器占用过高，其他用不上，低位就解决了这个问题,流水线访问</p>
<h5 id="存储芯片"><a href="#存储芯片" class="headerlink" title="存储芯片"></a>存储芯片</h5><p>SDRAM 同步DRAM</p>
<p>RDRAM 解决带宽问题</p>
<p>Cache DRAM DRAM访问过的行存入cache 下一次先和这个行地址比较，一样的话直接把列地址输入cache 有利于猝发读取</p>
<h3 id="辅存"><a href="#辅存" class="headerlink" title="辅存"></a>辅存</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704232924331.png" alt="image-20240704232924331"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704233315282.png" alt="image-20240704233315282"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704233745159.png" alt="image-20240704233745159"></p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>高速缓冲存储器，避免CPU空等现象</p>
<h4 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h4><p>时间的局部性：当前的数据，过一会还会用</p>
<p>空间的局部性：当前的数据，相邻的数据也会用</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705224559514.png" alt="image-20240705224559514"></p>
<p>按照块进行传送。 M&gt;&gt;C</p>
<p>命中：主存快调入缓存</p>
<p>命中率：与cache容量和块长有关</p>
<p>访问效率：</p>
<p>$e=\frac{访问\text{Cache时间}}{平均访问时间}$</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225126490.png" alt="image-20240705225126490"></p>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225727823.png" alt="image-20240705225727823"></p>
<h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225811853.png" alt="image-20240705225811853"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225941275.png" alt="image-20240705225941275"></p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>L1 L2 L3缓存</p>
<p>分离缓存 指令数据分离，冯氏结构统一</p>
<h4 id="Cache-主存的地址映射"><a href="#Cache-主存的地址映射" class="headerlink" title="Cache-主存的地址映射"></a>Cache-主存的地址映射</h4><p>方式和级数有关</p>
<h5 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h5><p>xx<strong>x只能装到cache的某一确定</strong>的位置，即使Cache的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。vmax</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705230901918.png" alt="image-20240705230901918"></p>
<p>主存块号的低𝑐位正好是它要装入的Cache行号。给每个Cache行设置一个长为𝑡=𝑚−𝑐的标记(tag),当主存某块替换进Cache后，就将其块号标记位设置在对应Cache行的标记中</p>
<h5 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h5><p>主存中的每一块可以装入Cache 中的<strong>任何</strong>位置，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有Cache行的标记进行比较。全相联映射方式的优点是比较灵活，Cache 块的冲突概率低，空间利用率高，命中率也高;缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射 vmin</p>
<h5 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a><strong>组相联映射</strong></h5><p><strong>组内全相联 组外直接映射</strong></p>
<p>确定组号之后再确定区号，0和2^c-r^ 2^c-r+1^ 都在第0组，组内采用字块号一一对应的方法<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/20210713154218.png" alt="20210713154218"></p>
<h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p>Cache满就要替换栈</p>
<h5 id="FIFO-First-in-first-out"><a href="#FIFO-First-in-first-out" class="headerlink" title="FIFO(First in first out)"></a>FIFO(First in first out)</h5><p>先进先出，违反程序局部性原则</p>
<h5 id="LRU-Last-recently-used"><a href="#LRU-Last-recently-used" class="headerlink" title="LRU(Last recently used)"></a>LRU(Last recently used)</h5><p>近期最少使用</p>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><p>早期：分散连接，串行工作</p>
<p>接口模块和DMA阶段：总线连接，并行工作（中断/DMA）</p>
<p>通道结构阶段：有自己的简单处理器</p>
<p>I/O处理机阶段：高性能微处理器</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705235621421.png" alt="image-20240705235621421"  />

<h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><p>接口\设备</p>
<h4 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706002820937.png" alt="image-20240706002820937"></p>
<p>键盘鼠标显示器，A/D D/A 模数转换，终端，汉字处理。</p>
<h4 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h4><p>选择设备，数据缓冲匹配速度，串并格式转换，电平转换，传送命令</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706121949206.png" alt="image-20240706121949206"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706122640491.png" alt="image-20240706122640491"></p>
<h3 id="主机与I-O的联系方式"><a href="#主机与I-O的联系方式" class="headerlink" title="主机与I/O的联系方式"></a>主机与I/O的联系方式</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705235948953.png" alt="image-20240705235948953"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706000234331.png" alt="image-20240706000234331"></p>
<p> (3)必须要有统一的时间标准</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706000359748.png" alt="image-20240706000359748"></p>
<h3 id="主机与I-O的信息传送控制"><a href="#主机与I-O的信息传送控制" class="headerlink" title="主机与I/O的信息传送控制"></a>主机与I/O的信息传送控制</h3><h4 id="通道方式、IO处理器方式"><a href="#通道方式、IO处理器方式" class="headerlink" title="通道方式、IO处理器方式"></a>通道方式、IO处理器方式</h4><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706000830237.png" alt="image-20240706000830237"></p>
<p>完全由主机执行程序实现，等待数据准备的过程CPU会空转，一直查询状态，串行工作</p>
<p>查询的程序嵌入CPU</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706140313041.png" alt="image-20240706140313041"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706142641037.png" alt="image-20240706142641037"></p>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706001125217.png" alt="image-20240706001125217"></p>
<p>会暂停现行程序 ，部分并行工作。中断会影响正常的程序处理，为了恢复CPU仍然要消耗资源，执行中断服务程序</p>
<h5 id="I-O形成中断请求过程"><a href="#I-O形成中断请求过程" class="headerlink" title="I/O形成中断请求过程"></a>I/O形成中断请求过程</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706001442993.png" alt="image-20240706001442993"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706141207557.png" alt="image-20240706141207557"></p>
<ol>
<li>中断请求触发器+中断屏蔽触发器</li>
</ol>
<p>先决条件：MASK = 0 中断未被屏蔽 + 设备本身已经准备好数据了 -&gt; INTR = 1 设备发出中断请求  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706141710467.png" alt="image-20240706141710467"></p>
<ol start="2">
<li>排队器</li>
</ol>
<p>分为<strong>软件</strong>和<strong>硬件</strong>方式</p>
<p>硬件：链式排队器</p>
<p>优先级最高的没有请求，$\overline {INTP’}$=1，$\overline {INTR}$=1，会导致这些优先级高、无请求的$\overline {INTP’}$=1，低优先级的来了请求，$\overline {INTR}$=0，就会让之后的$\overline {INTP’}$=0, 此时之后的$\overline {INTP’}$都对之后的与非门起了决定性作用，也就是优先级更低的全部禁用。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706145002524.png" alt="image-20240706145002524"></p>
<p>$\overline {INTP’}$，$ {INTR}$全部为1才能发出真正的中断指令INTP</p>
<ol start="3">
<li>中断向量地址形成部件（编码器）</li>
</ol>
<p>不同的设备中断服务程序不同，每一个服务程序都有一个入口地址，CPU要找到这些入口就必须对这些地址进行编码，输入是经过排队器综合以后的中断信号INTP，输出是中断向量（二进制码）仅仅是就这些输入编的码，还要将中断向量地址和存储的中断对应设备的服务程序一一对应，中断向量地址处保存的是服务程序的入口地址的地址</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706154548716.png" alt="image-20240706154548716"></p>
<ol start="4">
<li>接口电路</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706154757761.png" alt="image-20240706154757761"></p>
<h5 id="中断执行过程"><a href="#中断执行过程" class="headerlink" title="中断执行过程"></a>中断执行过程</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706161105095.png" alt="image-20240706161105095"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706212237016.png" alt="image-20240706212237016"></p>
<p>中断请求、中断判优、中断响应、中断服务、中断返回</p>
<p>CPU会在统一的时间，即每条指令执行阶段的最后时刻，进行<strong>中断查询</strong></p>
<p>设备只要准备好了(D=1)并且没有被屏蔽(MASK=0)，查询信号(相当于D触发器的clk信号)就会使得输出INTR=1，此时请求INTR=1也会被送到排队器进行<strong>判优</strong>，</p>
<p>随后CPU根据判优结果进行响应，如果排队选中并且EINT=1，进行CPU的<strong>中断响应</strong> </p>
<ul>
<li>响应条件<ul>
<li>中断源有中断请求, INTR=1 </li>
<li>开中断，使 EINT=1</li>
<li>一条指令执行完毕，且没有更紧迫的任务</li>
</ul>
</li>
</ul>
<p>通过INTR信号线发出的外中断是可屏蔽中断 ，在关中断（EINT=0）的情况下不会被响应</p>
<p>I/O设备的就绪时间是随机的，而CPU在统一的时刻即每条指令执行阶段结束前向接口发出中断查询信号，以获取I/O 的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。这里说的中断仅指外中断，内中断不属于此类情况。</p>
<p><strong>响应</strong>时，先由INTA<del>cknowledge</del>=1激活设备编码器：将排队结果发到编码器，生成向量地址，向量本身是JMP TO  200, 向量地址是JMP TO 200 的地址</p>
<p>根据向量地址进行开始<strong>运行服务程序</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706170143933.png" alt="image-20240706170143933"></p>
<p>多重中断的流程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706172054097.png" alt="image-20240706172054097"></p>
<p>1-3由隐指令完成，单重中断：直到恢复完现场才开中断。多重中断允许嵌套，必须满足下列条件:①在中断服务程序中提前设置开中断②优先级别高的中断源有权中断优先级别低的中断源。</p>
<p>假如D&gt;A&gt;C&gt;B，源A执行中，D来了就要中断A去执行D。每个中断源都有一个 屏蔽触发器屏蔽触发器 ，1 表示 屏蔽该中断源屏蔽该中断源 的请求，0 表示可以 正常申请正常申请 ，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。D的屏蔽字是1111，具有最高优先级，A是1110次之，以此类推</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706170847647.png" alt="image-20240706170847647"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706171244016.png" alt="image-20240706171244016"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706171245893.png" alt="image-20240706171245893"></p>
<p>屏蔽技术</p>
<p>屏蔽触发器和屏蔽字：程序中断接口电路中，完成触发器D，中断请求触发器INTR和屏蔽触发器MASK。</p>
<p>当中断源被屏蔽时（MASK=1），此时即使D=1，中断查询信号到来时刻只能将INTR置“0”，CPU接收不到该中断源的中断请求，即它被屏蔽。</p>
<p>若该中断源未被屏蔽（MASK=0）当设备工作已完成时（D=1），中断查询信号则将INTR置“1”，表示该中断源向CPU发出中断请求，该信号送至排队器进行优先级判断。显然，对于每个中断请求触发器就有一个<strong>屏蔽触发器</strong>，将所有屏蔽触发器组合在一起，便构成了一个<strong>屏蔽寄存器</strong>。屏蔽寄存器的内容称为<strong>屏蔽字</strong>。屏蔽字与中断源的优先级是一一对应的。</p>
<p>屏蔽技术可改变优先等级：严格地说，优先级包含<strong>响应优先级</strong>和<strong>处理优先级</strong>。响应优先级是指CPU响应各中断源请求的优先次序，这种次序往往是硬件线路已设置好的，不便于改动。处理优先级是指CPU实际对各中断源请求的处理优先次序。如果不采用屏蔽技术，响应的优先次序就是处理的优先次序。</p>
<p>eg. 响应L1&gt;L2&gt;L3&gt;L4 处理反过来</p>
<p>几个中断源同时提出中断请求，L1首先响应，开始执行，但是被L2打断，L2开始执行，被L3打断，之后L3被L4打断，L4执行完继续执行L3</p>
<p>ABCD由设备识别电路，A能将</p>
<h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p><strong>I/O direct to Memory</strong></p>
<p><strong>D</strong>irect <strong>M</strong>emory <strong>A</strong>ccess</p>
<h5 id="DMA方式的特点"><a href="#DMA方式的特点" class="headerlink" title="DMA方式的特点"></a>DMA方式的特点</h5><ul>
<li><p>在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p>
</li>
<li><p>主存中要开辟专用缓冲区，及时供给和接收外设的数据。</p>
</li>
</ul>
<h6 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h6><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706172851691.png" alt="image-20240706172851691"></p>
<p>CPU不参与</p>
<h6 id="与主存交换数据方式"><a href="#与主存交换数据方式" class="headerlink" title="与主存交换数据方式"></a>与主存交换数据方式</h6><ol>
<li><p>停止CPU对主存的访问。不能充分发挥CPU对主存的利用率。<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706173212015.png" alt="image-20240706173212015"></p>
</li>
<li><p>窃取周期。存取周期内CPU不能通过总线对内存进行访问，然而CPU指令执行并不是一条条取的，而是预取。并行工作。</p>
<p>CPU未占用总线,DMA/CPU正在占用总线,CPU/DMA、CPU同时发起占用总线的请求，DMA<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706174016933.png" alt="image-20240706174016933"></p>
</li>
<li><p>交替访问 一个原周期分为DMA周期和CPU周期<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706173952420.png" alt="image-20240706173952420"></p>
</li>
</ol>
<h5 id="接口-DMA控制器"><a href="#接口-DMA控制器" class="headerlink" title="接口/DMA控制器"></a>接口/DMA控制器</h5><h6 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h6><p>DMA申请总线控制权/CPU移交总线控制权/DMA管理总线控制传输数据, 确定数据传送首地址和长度, 对传输过程中的数据进行修正/DMA发出操作完成信号</p>
<h6 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h6><p><u>字</u>计数器<strong>W</strong>ord<strong>C</strong>ounter</p>
<p><u>主存地址</u>寄存器<strong>A</strong>ddress<strong>R</strong>egister</p>
<p><u>数据缓冲</u>寄存器<strong>B</strong>uffer<strong>R</strong>egister</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706180228563.png" alt="image-20240706180228563"></p>
<h5 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706180723685-1720260754514-3.png" alt="image-20240706180723685"></p>
<h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>预处理就是CPU的I/O指令</p>
<p>CPU完成准备工作：首先，CPU执行几条I/O 指令，用以测试I/O设备状态，向 DMA 控制器的有关寄存器置初值、设置传送方向、启动该设备等。然后，CPU继续执行原来的程序，直到I/O设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU 发送总线请求（有时将这两个过程统称为DMA请求），用以传输数据。</p>
<h6 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h6><p>传输可以用byte/word为基本单位，也可用block作为基本单位，对于以数据块为单位的传送（如硬盘），DMA占用总线后的数据输入和输出操作都是通过循环来实现的。需要指出的是，这一循环也是由 DMA 控制器（而非通过CPU执行程序）实现的，即数据传送阶段完全由DMA（硬件）控制。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706181444755.png" alt="image-20240706181444755"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706181559135.png" alt="image-20240706181559135"></p>
<p>WC(Word Counter)溢出会发中断请求INTR给中断机构</p>
<h6 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h6><p>DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括**<u>校验</u>送入主存的数据是否正确<strong>、测试传送过程中是否出错（错误则转入诊断程序）及决定是否继续使用DMA传送其他数据块等，</strong>由中断服务程序完成** </p>
<h5 id="DMA和系统连接方式"><a href="#DMA和系统连接方式" class="headerlink" title="DMA和系统连接方式"></a>DMA和系统连接方式</h5><p>公共总线 串联</p>
<p>独立DMA请求 并联</p>
<h5 id="DMA接口类型"><a href="#DMA接口类型" class="headerlink" title="DMA接口类型"></a>DMA接口类型</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706183458104.png" alt="image-20240706183458104"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706183609988.png" alt="image-20240706183609988"></p>
<p>优先级：速度优先</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706184002042.png" alt="image-20240706184002042"></p>
<h4 id="三种方式辨析"><a href="#三种方式辨析" class="headerlink" title="三种方式辨析"></a>三种方式辨析</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706001545500.png" alt="image-20240706001545500"></p>
<h5 id="DMA方式和中断方式的区别"><a href="#DMA方式和中断方式的区别" class="headerlink" title="DMA方式和中断方式的区别"></a>DMA方式和中断方式的区别</h5><ol>
<li>中断方式是程序的切换，需要保护和恢复现场;而DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源。</li>
<li>对中断请求的响应只能发生在每条指令执行完毕时（即指令的执行周期后）;而对DMA请求的响应可以发生在每个机器周期结束时（存储周期、取指周期、间址周期、执行周期后均可），只要CPU不占用总线就可被响应。</li>
<li>中断传送过程需要CPU的干预;而 DMA传送过程不需要CPU 的干预，因此数据传输率非常高，适合于高速外设的成组数据传送。</li>
<li>DMA请求的优先级高于中断请求。</li>
<li>中断方式的中断请求以传送数据的方式，DMA是以后处理的方式</li>
<li>中断方式具有对异常事件的处理能力，而DMA方式仅局限于传送数据块的I/O操作。</li>
<li>从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送。</li>
</ol>
<h4 id="易混淆点"><a href="#易混淆点" class="headerlink" title="易混淆点"></a>易混淆点</h4><p>向量中断、中断向量、向量地址</p>
<ul>
<li>向量中断：用来识别中断源的方式，能够找到对应的中断服务程序的入口地址，即向量地址</li>
<li>向量地址：向量表中每一项的地址，中断服务程序的入口地址</li>
<li>中断服务程序：中断源对应的处理程序</li>
<li>中断向量：中断服务程序的入口地址/中断服务程序的跳转指令</li>
<li>中断向量地址：中断向量的地址</li>
</ul>
<p>中断服务程序、子程序</p>
<ul>
<li>中断服务程序：时间不固定，跟主程序无关，需要另外的硬件电路，嵌套级数完全由中断优先级来决定</li>
<li>子程序：时间固定可预知，和主程序息息相关，为主程序服务，不需要额外硬件，嵌套级数由内存堆栈大小限制决定</li>
</ul>
<p>中断响应优先级、中断处理优先级</p>
<ul>
<li>中断响应优先级：由硬件排队器或中断查询程序的查询顺序决定</li>
<li>中断处理优先级：由中断屏蔽字来改变，反映的是正在处理的中断是否比新发生的中断的处理优先级低（屏蔽位为“0”，对新中断开放），若是，则中止正在处理的中断，转到新中断去处理，处理完后再回到刚才被中止的中断继续处理。</li>
</ul>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/408-%E8%AE%A1%E7%BB%84-Cache%20%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D%20HDD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/408-%E8%AE%A1%E7%BB%84-Cache%20%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D%20HDD/" class="post-title-link" itemprop="url">cache、先行进位、hdd</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:56:48" itemprop="dateModified" datetime="2025-05-05T11:56:48+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>磁道数⇔柱面数</p>
<p>数据传输率 = 单磁道容量 * 转速</p>
<p>单磁盘容量 = 有效盘面数 * 磁道数 * 单磁道容量 </p>
<p>​           = 有效盘面数 * 磁道数 * 扇区数 * 单扇区容量 </p>
<p>平均读取时间 = 平均寻道时间 + 平均寻找扇区时间（0.5T）+ 其他延迟时间 + 传输时间(比如<strong>读取一个扇区的时间 = 读取一个磁道的时间即1/r / 扇区数</strong>  或者 <strong>1s传20MB，那么读取一个4KB的扇区时间=4K*1s/20M</strong>)</p>
<p> 寻道时间一般不变，找扇区时间以及传输时间和转速挂钩。</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>主存物理地址</p>
<p>第一块</p>
<blockquote>
<p>00000000</p>
<p>00000001</p>
<p>00000010</p>
<p>00000011</p>
</blockquote>
<p>第二块</p>
<blockquote>
<p>00000100</p>
<p>00000101</p>
<p>00000110</p>
<p>00000111</p>
</blockquote>
<p>前六位是块号，每块有四个地址，所以要用最后2位来表示块内地址（这个单元位于块的哪个部分）高位全部是块号</p>
<p>块内地址位数的确定：必须要直到一个块内有多少个地址，比如说一个块16个字，每个字4 Byte，按字编址就是16个，需要4位表示块内地址，按字节编址就是64个，需要6位来给块内地址</p>
<p>一块就对应cache一行（一块）</p>
<p>一块一块交换，所以最终是要核对cache中的块号。</p>
<p>写回法，CPU将cache作为目标存储器，写完如果脏位有效才写回主存</p>
<p>写通/写穿，CPU将cache和主存同时写入，如果cache不命中就先写完主存，再从主存写cache</p>
<p>主存物理地址 = 标记tag+ cache地址</p>
<p>cache地址 = 行号/组号/无 + 块内地址</p>
<p>cache行内容 = 标记区 + 数据区</p>
<p>cache地址映射表 = cache标记区</p>
<p>cache标记区 = 有效位1bit + 主存标记tag +（脏位(写回策略)1bit + 替换控制位）</p>
<p>cache数据区大小 = 块容量 一块4B……</p>
<h3 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h3><p>直接一位一位核对块号（tag） </p>
<p>优点：存储块可以放到cache的任意一行，空间利用率高</p>
<p>缺点：查找时间可以很长</p>
<h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>指定1行Cache，只能存间隔固定的存储单元，比如第0行cache只能存每一个区的第0块</p>
<p>优点：查找速度快</p>
<p>缺点：存储块只能放到某一个固定的行，空间利用率低</p>
<p>要知道cache的行数，根据行数确定行号占位，然后再核对剩下的tag内容</p>
<p>如果cache共16行，直接节省了16倍的时间 行号占4位</p>
<h3 id="组相联"><a href="#组相联" class="headerlink" title="组相联"></a>组相联</h3><p>指定某几行Cache，只能存间隔固定的存储单元，比如第0行cache可以存每一个区的第0，2,4，8，是前两种的折中，</p>
<p>如果cache共16行，4路组相联，4个组 组号占2位，节省了4倍时间</p>
<p>先确定组号然后核对tag和有效位，tag匹配，有效位为1即为命中</p>
<h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h3><p>cache行数128，在主存中有102个字，8字为一个块，重复按照0-101顺序读10次，一下读一个字，命中率？</p>
<p>先到cache里寻找，一定是先核对组号和tag内容，再根据块内地址找，0-101分成13块，第一次先核对tag，没有对的上的，所以只需要13次没命中。</p>
<p>第二次，cache已经写入了102个字的内容，并且分块分组保存，先核对tag中的组号，发现能对的上，然后核对tag，块内地址，算命中。</p>
<p>总命中次数 102*10-13 得命中率为98.7%</p>
<h2 id="双重分组跳跃进位加法链-ALU"><a href="#双重分组跳跃进位加法链-ALU" class="headerlink" title="双重分组跳跃进位加法链 ALU"></a>双重分组跳跃进位加法链 ALU</h2><h3 id="小组内先行进位"><a href="#小组内先行进位" class="headerlink" title="小组内先行进位"></a>小组内先行进位</h3><p>已知d3-d0, t3-t0, C<del>-1</del>  同时产生C3-C0 DT也能同时产生 耗时2.5t<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240711163217501.png" alt="image-20240711163217501"></p>
<p>缺点：每组要工作都要知道自己的进位输入位，<strong>不能同时知道自己的进位输入位</strong> </p>
<p>16bit 耗时10t（产生C15-C0的时间）</p>
<p>典型的先行进位4位加法器能够同时产生DT,C3-C0</p>
<h4 id="小组间先行进位"><a href="#小组间先行进位" class="headerlink" title="小组间先行进位"></a>小组间先行进位</h4><p>(只要知道组内dt情况就能立即给出DT，C3-C0)</p>
<p>如果能让他们同时知道自己的进位输入位就能节省时间，此时最高位产生的逻辑只需要知道C<del>-1</del> </p>
<p>已知DT就能马上给出所有最高进位 耗时2.5t ，但是要先得出DT才行，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240711163153788-1720686897748-1.png" alt="image-20240711163153788"></p>
<p>16bit 耗时5t（产生C15-C0的时间）</p>
<p><u>逻辑：同时产生每个组的DT和前三个进位输出，然后再同时产生每个组的最高位进位输出。</u></p>
<p>同时产生每个组的DT和前三个进位输出，倒是也可以同时产生C3，但是此时C3是根据C<del>-1</del> 产生的，后边的C7C11C15要化成C3的形式才能同时产生，反正都是分两步，索性让他们四个按照相同的逻辑产生。</p>
<p>总结，要让DT起作用，就要先知道DT才行，然后让最高位按照统一的逻辑生成。</p>
<h4 id="MSI-ALU"><a href="#MSI-ALU" class="headerlink" title="MSI_ALU"></a>MSI_ALU</h4><p>74182(CLA Generator):Cmin，4DT———3Cout ，D*T* （4个小组）（1个大组） 16bit </p>
<p>74181(4bit CLA Adder):Cmin，4dt——— Cmax，1DT  （1个小组）4bit </p>
<p>4*74181+1*182 = 输入dt，Cmin，到74181和74182，输出D*T*，和4个组最终的进位输出</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240711174412643.png" alt="image-20240711174412643"></p>
<p>74182: 输入Cmin，4D*T*，  输出Cmax、 D**T**（4个大组） 64bit</p>
<p>(4*74181+1*74182)*4 + 1*74182 = 64位 三重分组跳跃进位ALU </p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/408-%E8%AE%A1%E7%BB%84-Link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/408-%E8%AE%A1%E7%BB%84-Link/" class="post-title-link" itemprop="url">符号链接</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 12:43:29" itemprop="dateModified" datetime="2025-05-05T12:43:29+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>文本：源代码 <code>hello.c</code></p>
<p>预处理：修改文本 <code>hello.i file</code></p>
<p>编译器：assembly <code>hello.s file</code></p>
<p>汇编器：binary code <code>hello.o file</code></p>
<p>连接器：hello.o + printf.o -&gt; <code>hello</code> </p>
<p><strong>线程级并行</strong>：指令执行基本单位</p>
<ul>
<li><p>多核心：多个核共享L3缓存，一个核有一个统一的L2缓存，L1缓存分为数据缓存和指令缓存，数据缓存直连CPU寄存器</p>
</li>
<li><p>超线程：可以在单个周期内决定要切换到哪个线程，在一个线程等待数据运过来的过程中，CPU可以去转而执行另一个线程，8核心 16线程，线程并行</p>
</li>
</ul>
<p><strong>指令级并行</strong>：指令间并行</p>
<ul>
<li>流水线</li>
<li>超标量</li>
</ul>
<p>单指令，多数据并行：数据流并行 SIMD 一条指令可以产生多个并行执行的操作</p>
<p>抽象：Disk 代表I/O设备，Memory代表主存</p>
<ul>
<li>Virtual Machine：OS+CPU+Memory+Disk</li>
<li>Process： CPU+Memory+Disk</li>
<li>Virtual Memory：Memory+Disk</li>
<li>File：Disk</li>
<li>CPU：Instruction Set architecture</li>
</ul>
<h1 id="Linker"><a href="#Linker" class="headerlink" title="Linker"></a>Linker</h1><h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p>“目标文件是字节块的集合”这句话通常用来描述目标文件（object file）的本质结构。目标文件是编译器生成的中间文件，包含程序代码和数据，用于后续的链接操作。以下是对这一概念的详细解析：</p>
<h3 id="目标文件的本质：字节块"><a href="#目标文件的本质：字节块" class="headerlink" title="目标文件的本质：字节块"></a>目标文件的本质：字节块</h3><p>目标文件是由一系列字节组成的文件，这些字节可以看作是数据块。这些数据块并不是随意排列的，而是按照一定的格式组织起来，通常包括：</p>
<ul>
<li><strong>代码段</strong>：存储编译后的机器指令。</li>
<li><strong>数据段</strong>：存储已初始化的全局或静态变量。</li>
<li><strong>未初始化数据段（BSS）</strong>：存储未初始化的全局或静态变量，实际大小记录在文件中，但不占用物理空间。</li>
<li><strong>符号表</strong>：记录函数和变量的名字及其在文件中的位置。</li>
<li><strong>重定位信息</strong>：指示链接器如何修改目标文件以适应最终的内存布局。</li>
</ul>
<p>这些内容本质上都是字节序列，每一部分由多个字节块组成。</p>
<hr>
<h3 id="字节块的特点"><a href="#字节块的特点" class="headerlink" title="字节块的特点"></a>字节块的特点</h3><ul>
<li><strong>固定大小或可变大小</strong>：字节块可以是固定长度的单位，例如4字节对齐的机器指令，也可能是不定长的数据块。</li>
<li><strong>有意义的分组</strong>：每个块都有明确的意义，比如某个函数的机器代码、某个变量的初始值等。</li>
<li><strong>易于解析</strong>：链接器、调试器等工具需要能够根据文件的格式解析这些块，因此这些字节块被有序地组织在文件头定义的布局中。</li>
</ul>
<hr>
<h3 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h3><p>目标文件的格式是如何定义这些字节块的重要规则。例如：</p>
<ul>
<li><strong>ELF（Executable and Linkable Format）</strong> 是一种常见的目标文件格式，广泛用于Linux系统。它将字节块分为不同的段（Section），并用段表和符号表记录每个块的起始地址和大小。</li>
<li><strong>COFF（Common Object File Format）</strong> 是Windows等系统常用的格式。</li>
</ul>
<p>这些格式提供了语法规则，使得目标文件的字节块能够被链接器或加载器正确地解读。</p>
<hr>
<h3 id="为什么强调“字节块的集合”？"><a href="#为什么强调“字节块的集合”？" class="headerlink" title="为什么强调“字节块的集合”？"></a>为什么强调“字节块的集合”？</h3><ul>
<li><strong>通用性</strong>：这一描述抽象了目标文件的存储本质。无论是代码段还是数据段，本质上都是按字节存储的数据。</li>
<li><strong>便于理解文件结构</strong>：将目标文件看作字节块集合，可以帮助程序员理解文件的解析方式，特别是分析目标文件格式时。</li>
<li><strong>与内存映射相关</strong>：最终，这些字节块会被加载到内存中，按照相同的结构组织成进程的内存布局。</li>
</ul>
<hr>
<h3 id="深入理解的关键"><a href="#深入理解的关键" class="headerlink" title="深入理解的关键"></a>深入理解的关键</h3><p>为了深入理解，可以通过以下方式进一步探索：</p>
<ul>
<li><strong>查看目标文件结构</strong>：使用工具（如 <code>objdump</code> 或 <code>readelf</code>）解析目标文件，观察各部分的字节分布。</li>
<li><strong>编写简单的C程序并编译</strong>：用编译器生成目标文件，并对比源代码和目标文件中的符号表、代码段。</li>
<li><strong>了解链接过程</strong>：理解这些字节块如何在链接过程中被组合成最终的可执行文件。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>编写简单的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译生成目标文件后，使用 <code>readelf -a</code> 或 <code>objdump -h</code> 查看其字节块分布。你会发现，虽然程序非常简单，但目标文件已经按照格式组织了各种段和数据块。</p>
<h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p><strong>符号解析</strong>是链接过程中一个重要的步骤，用于将目标文件中的符号（如变量名、函数名）解析为具体的内存地址或其他符号的引用地址。它的目的是将代码中使用的符号与其定义进行匹配，以实现正确的程序连接。</p>
<p>以下是详细的解释：</p>
<hr>
<h3 id="什么是符号？"><a href="#什么是符号？" class="headerlink" title="什么是符号？"></a><strong>什么是符号？</strong></h3><p>符号是程序中用来表示变量、函数、常量或其他标识符的名字。它可以包括：</p>
<ul>
<li>全局变量</li>
<li>函数名</li>
<li>静态变量（如果需要）</li>
<li>外部引用的符号（来自其他目标文件或库）</li>
</ul>
<p>在目标文件中，这些符号并不直接对应内存地址，而是保存在<strong>符号表</strong>中，等待链接器解析。</p>
<hr>
<h3 id="符号解析的作用"><a href="#符号解析的作用" class="headerlink" title="符号解析的作用"></a><strong>符号解析的作用</strong></h3><p>符号解析的主要目的是：</p>
<ul>
<li>将<strong>使用符号的地方</strong>（例如函数调用或变量访问）和<strong>定义符号的地方</strong>联系起来。</li>
<li>为符号分配实际的内存地址或引用其他文件中符号的位置。</li>
</ul>
<p>如果符号在当前目标文件中找不到定义，链接器会尝试在其他目标文件或库中找到它。</p>
<hr>
<h3 id="符号解析的过程"><a href="#符号解析的过程" class="headerlink" title="符号解析的过程"></a><strong>符号解析的过程</strong></h3><ol>
<li><p><strong>构建符号表</strong>：链接器首先扫描所有目标文件和库文件，读取它们的符号表，记录所有已定义和未定义的符号。</p>
</li>
<li><p>查找符号定义</p>
<p>：对于每个未定义的符号，链接器会在符号表中搜索其定义。</p>
<ul>
<li>如果找到，链接器会将引用符号的位置更新为定义的位置。</li>
<li>如果找不到，链接器会报错（如“未定义符号”错误）。</li>
</ul>
</li>
<li><p><strong>处理重定位信息</strong>：对于解析后的符号，链接器会根据其地址调整目标文件中的指令或数据。</p>
</li>
</ol>
<hr>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a><strong>常见场景</strong></h3><ul>
<li><strong>内部符号解析</strong>：在同一个目标文件中，一个函数调用另一个函数，链接器只需在这个目标文件内找到符号的定义。</li>
<li><strong>外部符号解析</strong>：一个目标文件调用另一个目标文件或库中的符号，链接器需要跨文件查找。</li>
<li><strong>动态库中的符号解析</strong>：如果链接的是动态库（如 <code>.so</code> 或 <code>.dll</code> 文件），符号解析可能延迟到程序运行时进行。</li>
</ul>
<hr>
<h3 id="符号解析失败的原因"><a href="#符号解析失败的原因" class="headerlink" title="符号解析失败的原因"></a><strong>符号解析失败的原因</strong></h3><p>符号解析失败通常会导致编译或链接错误，比如：</p>
<ul>
<li>未定义符号错误：<ul>
<li>函数或变量的定义缺失。</li>
<li>链接时遗漏了需要的库。</li>
</ul>
</li>
<li>重复定义错误：<ul>
<li>同一个符号在多个目标文件中重复定义。</li>
</ul>
</li>
<li>符号不可见：<ul>
<li>符号被声明为 <code>static</code> 或其他方式限制了可见性，导致无法被外部文件引用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="符号解析工具"><a href="#符号解析工具" class="headerlink" title="符号解析工具"></a><strong>符号解析工具</strong></h3><p>在实际开发中，可以使用一些工具检查符号：</p>
<ul>
<li><code>nm</code>：列出目标文件或库中的符号表。</li>
<li><code>objdump</code>：查看符号和段信息。</li>
<li><code>readelf</code>：分析目标文件的 ELF 格式符号。</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm myfile.o</span><br></pre></td></tr></table></figure>

<p>会输出目标文件 <code>myfile.o</code> 中的所有符号及其状态（已定义或未定义）。</p>
<hr>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>假设有以下代码：</p>
<p>**文件 <code>a.c</code>**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> foo = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>**文件 <code>b.c</code>**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> foo;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>编译</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.c -o a.o</span><br><span class="line">gcc -c b.c -o b.o</span><br></pre></td></tr></table></figure>

<ul>
<li><code>a.o</code> 中定义了符号 <code>foo</code>。</li>
<li><code>b.o</code> 中引用了符号 <code>foo</code>（标记为未定义）。</li>
</ul>
</li>
<li><p><strong>链接</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.o b.o -o program</span><br></pre></td></tr></table></figure>

<ul>
<li>链接器会解析 <code>b.o</code> 中的符号 <code>foo</code>，在 <code>a.o</code> 中找到它的定义，并完成解析。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>符号解析是链接器将程序中的符号引用与定义匹配起来的关键步骤。它确保程序在执行时能够正确访问函数、变量等资源。符号解析的成功与否直接影响程序的正确性，开发中需要注意符号的定义与使用是否一致，以及是否正确链接所需的目标文件或库。</p>
<ul>
<li><code>switch</code>性能是否总是比<code>if-else</code>好？</li>
<li>一个函数调用的开销有多大？</li>
<li><code>while</code>性能是否总是比<code>for</code>好？</li>
<li>指针引用比数组索引更加有效吗？</li>
<li>为什么将循环求和的结果放到本地变量中，比放到一个通过引用传递过来的参数中更加有效？</li>
<li>为什么只是简单将算数表达式中的括号进行重排就能加快运行速度？</li>
</ul>
<p>链接的错误：</p>
<ul>
<li>静态变量与全局变量的区别</li>
<li>不同C文件中定义相同的全局变量</li>
<li>静态库和动态库的区别</li>
<li>命令行上排列库的顺序有什么影响</li>
<li>为什么有些链接错误直到运行时才会出现？</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/default/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/8/">8</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
