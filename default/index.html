<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">168</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/03/DBreview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/03/DBreview/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-03 21:19:50" itemprop="dateCreated datePublished" datetime="2025-05-03T21:19:50+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-10 21:41:46" itemprop="dateModified" datetime="2025-01-10T21:41:46+08:00">2025-01-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[toc]</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>系统结构：</p>
<ul>
<li><p>从最终用户角度看：单用户、主从、分布式、CS、BS</p>
</li>
<li><p>三级模式（Schema）</p>
<ul>
<li><p>模式：是数据库中全体数据的逻辑结构和特征的描述，模式是相对稳定的。</p>
</li>
<li><p>外模式：是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，与某一应用有关的数据的逻辑表示。</p>
</li>
<li><p>内模式：也称存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</p>
</li>
<li><p>实例：模式的一个具体值</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106121603027.png" alt="image-20250106121603027" style="zoom: 33%;" /></li>
<li><p>数据库的二级映象功能数据独立</p>
<ul>
<li>外模式/模式 保证数据与程序的==逻辑独立性==</li>
<li>模式/内模式 定义全局逻辑结构与存储结构之间的对应关系，保证数据与程序的==物理独立性==</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>ACM Stonebreaker 开源</p>
<p>Gray 事务处理</p>
<p>Codd DBMS 关系型数据库</p>
<p>Bachman 网状数据库</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106204101690-1736167278092-1.png" alt="image-20250106204101690"></p>
<p>SQL 嵌入程序设计语言中，被嵌入者称为宿主语言。</p>
<p>ODBC  JDBC</p>
<h1 id="E-R-实体-关系模型"><a href="#E-R-实体-关系模型" class="headerlink" title="E-R 实体-关系模型"></a>E-R 实体-关系模型</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>主键：下划线</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106122028540.png" alt="image-20250106122028540" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106122250317.png" alt="image-20250106122250317" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106122138035.png" alt="image-20250106122138035" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106122144001.png" alt="image-20250106122144001" style="zoom:33%;" />

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="参与度"><a href="#参与度" class="headerlink" title="参与度"></a>参与度</h3><p>M-&gt;N  how many M per N?</p>
<p>N-&gt;M how many N per M?</p>
<p>学生选修课程，对于每个课程，可以有0到100个学生</p>
<p>课程被学生选修，对于每一个学生，可选 3到6门课</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106122640699.png" alt="image-20250106122640699" style="zoom:33%;" />

<p>学生必须参与，所以是全参与，应该画两条线（对面） </p>
<p>课程可以不参与，因此是部分参与，一条线即可</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106123035466.png" alt="image-20250106123035466" style="zoom:33%;" />

<h3 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h3><p>==依附于所有者实体==(必须是一个强实体对应多</p>
<p>个弱实体，弱实体必须全参与)</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106124211529.png" alt="image-20250106124211529" style="zoom:33%;" />

<p>标识弱实体：可选的部分码    </p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106124844068.png" alt="image-20250106124844068" style="zoom:33%;" />



<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106124906692.png" alt="image-20250106124906692" style="zoom:33%;" />

<h3 id="类层次"><a href="#类层次" class="headerlink" title="类层次"></a>类层次</h3><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106130637223.png" alt="image-20250106130637223" style="zoom:33%;" />

<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="实体对应多个属性，属性升级为实体"><a href="#实体对应多个属性，属性升级为实体" class="headerlink" title="实体对应多个属性，属性升级为实体"></a>实体对应多个属性，属性升级为实体</h4><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106125401084.png" alt="image-20250106125401084" style="zoom:33%;" />

<h4 id="联系可能有多个属性，并且需要记录多次，升级为实体"><a href="#联系可能有多个属性，并且需要记录多次，升级为实体" class="headerlink" title="联系可能有多个属性，并且需要记录多次，升级为实体"></a>联系可能有多个属性，并且需要记录多次，升级为实体</h4><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106125429941.png" alt="image-20250106125429941" style="zoom:33%;" />

<p>教授可以在几个学期讲授同一门课程，但仅最近一次的讲授活动需被记录下来：</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106155143183.png" alt="image-20250106155143183" style="zoom: 33%;" />

<p>需要记录每次的讲授活动。</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106155225495.png" alt="image-20250106155225495" style="zoom:33%;" />

<h5 id="多个属性造成过多冗余"><a href="#多个属性造成过多冗余" class="headerlink" title="多个属性造成过多冗余"></a>多个属性造成过多冗余</h5><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106131214391.png" alt="image-20250106131214391" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106131222403.png" alt="image-20250106131222403" style="zoom: 33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106131232913.png" alt="image-20250106131232913" style="zoom: 33%;" />

<h5 id="单个属性不升级"><a href="#单个属性不升级" class="headerlink" title="单个属性不升级"></a>单个属性不升级</h5><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106125724063.png" alt="image-20250106125724063" style="zoom:33%;" />

<h4 id="三元联系"><a href="#三元联系" class="headerlink" title="三元联系"></a>三元联系</h4><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106131609882.png" alt="image-20250106131609882" style="zoom:33%;" />

<ol>
<li>雇员 1对多 保险</li>
<li>保险必须有人买，因此 保险是全参与</li>
<li>而家属跟</li>
</ol>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106132147908.png" alt="image-20250106132147908" style="zoom:33%;" />





<h1 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106204407541.png" alt="image-20250106204407541"></p>
<p>数据模型：对现实世界进行抽象。找到所关心的 数据，并将其组织起来，使之可以存放到数据库中。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106204258670.png" alt="image-20250106204258670"></p>
<p>三要素：数据结构（静态）、数据操作（动态）、约束条件（完整性描述，限定状态和变化，保证正确性）</p>
<p>通常按照**==数据结构==**类型来命名数据模型，它是刻画一个数据模型最重要的一方面。</p>
<h3 id="模式（Schema）"><a href="#模式（Schema）" class="headerlink" title="模式（Schema）"></a>模式（Schema）</h3><p><strong>定义：</strong><br>模式是数据库的<strong>逻辑结构和组织形式</strong>，描述了数据的类型、关系、约束和完整性规则。它是数据库设计的核心蓝图。也称逻辑模式，==是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。==</p>
<p><strong>作用：</strong></p>
<ul>
<li>描述数据库中表的结构、字段类型、约束（主键、外键等）。</li>
<li>==用于数据定义语言（DDL）中创建数据库对象（表、视图、索引等）。==</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> Employee (</span><br><span class="line">    EmpID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    Age <span class="type">INT</span>,</span><br><span class="line">    DeptID <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (DeptID) <span class="keyword">REFERENCES</span> Department(DeptID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上述 SQL 语句定义的表结构就是一种模式描述。</p>
<h3 id="内模式（Internal-Schema）"><a href="#内模式（Internal-Schema）" class="headerlink" title="内模式（Internal Schema）"></a>内模式（Internal Schema）</h3><p><strong>定义：</strong><br>内模式是数据库在<strong>物理存储级别</strong>的描述，表示数据在磁盘上的存储方式和结构。它关注如何<strong>高效地存储和检索数据</strong>。也称==存储模式（Storage Schema）==，它是数据物理结构和存储方式的描述，==是数据在数据库内部的表示方式（例如，记录的存储方式是顺序存储、按照B树结构存储还是按hash方法存储；索引按照什么方式组织；数据是否压缩存储，是否加密；数据的存储记录结构有何规定）。==</p>
<p>模式/内模式 定义全局逻辑结构与存储结构之间的对应关系，保证数据与程序的==物理独立性== </p>
<p>数据库中只有一个模式，也只有一个内模式，所以<strong>模式/内模式映象是唯一的</strong>，它定义了数据全局逻辑结构与存储结构之间的对应关系。 当数据库的存储结构改变了，由数据库管理员对模式内模式映象做响应改变，可以使模式保持不变，从而保证了数据的物理独立性。</p>
<p><strong>特点：</strong></p>
<ul>
<li>描述数据存储的物理细节，例如==文件存储格式、索引机制和数据压缩。==</li>
<li>面向数据库管理系统（DBMS）内部实现，用户不可直接访问。</li>
<li>用于优化存储空间和访问性能。</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li>数据库将表存储为堆文件或 B+ 树索引文件。</li>
<li>使用页或块来存储数据，以便进行高效的磁盘 I/O 操作。</li>
<li>数据压缩、分区和索引设计也是内模式的一部分。</li>
</ul>
<h3 id="外模式（External-Schema）"><a href="#外模式（External-Schema）" class="headerlink" title="外模式（External Schema）"></a>外模式（External Schema）</h3><p><strong>定义：</strong><br>外模式是用户或应用程序能看到的<strong>数据视图</strong>，定义用户访问数据的<strong>逻辑方式</strong>和权限。它是数据库的<strong>用户视图层</strong>。外模式/模式 保证数据与程序的==逻辑独立性== 也称子模式（Subschema）或用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p>
<p><strong>特点：</strong> </p>
<ul>
<li>提供对数据的定制化视图，确保用户只能访问授权的数据。</li>
<li>可以定义不同的外模式来满足不同用户的需求。</li>
<li>提供数据安全性和权限管理机制。</li>
</ul>
<p><strong>示例：</strong></p>
<ol>
<li><p>对于管理员视图：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> AdminView <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> EmpID, Name, Age, DeptID <span class="keyword">FROM</span> Employee;</span><br></pre></td></tr></table></figure></li>
<li><p>对于普通用户视图（隐藏敏感信息）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> UserView <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> EmpID, Name <span class="keyword">FROM</span> Employee;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><ul>
<li>Sailors(sid: integer, sname: string, rating: integer, age: real)</li>
<li>Boats(bid: integer, bname: string, color: string)</li>
<li>Reserves(sid: integer, bid: integer, day: date)</li>
</ul>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106144944948.png" alt="image-20250106144944948" style="zoom:33%;" />

<h3 id="完整性约束-参照完整、实体完整"><a href="#完整性约束-参照完整、实体完整" class="headerlink" title="完整性约束(参照完整、实体完整)"></a>完整性约束(参照完整、实体完整)</h3><p>DBMS 必须支持实体完整性和参照完整性，用户定义完整可以由DBMS提供检验和定义机制</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106213631849.png" alt="image-20250106213631849" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106213442493.png" alt="image-20250106213442493" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106144853205.png" alt="image-20250106144853205" style="zoom:33%;" />

<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p><strong>关系代数（Relational Algebra）</strong>是基于集合论和逻辑运算的数学模型，它将数据库中的数据视为关系，并通过一系列操作符实现数据的检索、组合和处理。</p>
<ul>
<li><strong>基本思想：</strong><br> 将数据查询视为对关系的操作，而操作的结果也是一个新的关系，可以继续被操作，从而形成灵活的数据处理能力。</li>
</ul>
<h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>1. 关系（Relation）：</strong></p>
<ul>
<li>表示实体及其属性，是数据库中的表。</li>
<li>行表示<strong>元组（Tuple）</strong>，列表示<strong>属性（Attribute）</strong>。</li>
</ul>
<p><strong>2. 域（Domain）：</strong></p>
<ul>
<li>属性取值的范围。</li>
</ul>
<p><strong>3. 键（Key）：</strong></p>
<ul>
<li>唯一标识关系中元组的属性或属性组合。</li>
</ul>
<p><strong>4. 笛卡尔积（Cartesian Product）：</strong></p>
<ul>
<li>两个关系的所有组合。</li>
</ul>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106211511410.png" alt="image-20250106211511410" style="zoom:33%;" />

<h3 id="关系代数的基本操作"><a href="#关系代数的基本操作" class="headerlink" title="关系代数的基本操作"></a>关系代数的基本操作</h3><h4 id="选择（Selection，σ）"><a href="#选择（Selection，σ）" class="headerlink" title="选择（Selection，σ）"></a>选择（Selection，σ）</h4><p>从关系中<strong>筛选满足条件的元组</strong>。</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106214303757.png" alt="image-20250106214303757" style="zoom:33%;" />

<p><strong>示例：</strong><br> 选取工资大于 5000 的员工：</p>
<p>$\sigma_{salary &gt; 5000}(Employee)$</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Employee <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure>

<h4 id="投影（Projection，π）"><a href="#投影（Projection，π）" class="headerlink" title="投影（Projection，π）"></a>投影（Projection，π）</h4><p>从关系中<strong>选取特定的属性列</strong> </p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106214243521.png" alt="image-20250106214243521" style="zoom:33%;" />

<p><strong>示例：</strong><br> 选取员工的姓名和工资：</p>
<p>$\pi_{name, salary}(Employee)$</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, salary <span class="keyword">FROM</span> Employee;</span><br></pre></td></tr></table></figure>



<h4 id="并（Union，∪）"><a href="#并（Union，∪）" class="headerlink" title="并（Union，∪）"></a>并（Union，∪）</h4><p>返回两个关系中<strong>所有不重复的元组</strong>。</p>
<p><strong>要求：</strong><br> 两个关系必须具有相同的属性结构（同域、同数目）。</p>
<p><strong>示例：</strong><br> 选取部门 A 和部门 B 的所有员工：</p>
<p>$EmployeeA \cup EmployeeB$</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> EmployeeA) <span class="keyword">UNION</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> EmployeeB);</span><br></pre></td></tr></table></figure>

<h4 id="差（Difference，−）"><a href="#差（Difference，−）" class="headerlink" title="差（Difference，−）"></a>差（Difference，−）</h4><p>返回属于<strong>第一个关系但不属于第二个关系</strong>的元组。</p>
<p><strong>要求：</strong><br> 两个关系必须具有相同的属性结构。</p>
<p><strong>示例：</strong><br> 找出只在部门 A 工作但不在部门 B 工作的员工：</p>
<p>$EmployeeA - EmployeeB$</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> EmployeeA) <span class="keyword">EXCEPT</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> EmployeeB);</span><br></pre></td></tr></table></figure>

<h4 id="笛卡尔积（Cartesian-Product，×）"><a href="#笛卡尔积（Cartesian-Product，×）" class="headerlink" title="笛卡尔积（Cartesian Product，×）"></a>笛卡尔积（Cartesian Product，×）</h4><p>将两个关系中的元组<strong>按所有可能的组合</strong>连接起来。</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106214318888.png" alt="image-20250106214318888" style="zoom:33%;" />

<p><strong>示例：</strong><br> 将员工与部门信息组合：</p>
<p>$Employee \times Department$</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Employee, Department;</span><br></pre></td></tr></table></figure>

<h4 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h4><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106211800662.png" alt="image-20250106211800662" style="zoom:33%;" />

<h5 id="连接（Join，⨝）"><a href="#连接（Join，⨝）" class="headerlink" title="连接（Join，⨝）"></a>连接（Join，⨝）</h5><p>将两个关系通过<strong>相同属性的匹配</strong>组合起来，减少笛卡尔积带来的冗余。</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106211901428.png" alt="image-20250106211901428" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106214352323.png" alt="image-20250106214352323" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106214408551.png" alt="image-20250106214408551" style="zoom: 33%;" />

<p><strong>示例：</strong><br> 将员工与其所在部门的详细信息连接：</p>
<p>$Employee \bowtie_{Employee.deptID = Department.deptID} Department$</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Employee <span class="keyword">JOIN</span> Department <span class="keyword">ON</span> Employee.deptID <span class="operator">=</span> Department.deptID;</span><br></pre></td></tr></table></figure>

<h5 id="象集"><a href="#象集" class="headerlink" title="象集"></a>象集</h5><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106214514721.png" alt="image-20250106214514721" style="zoom:25%;" />

<h5 id="除法（Division，÷）"><a href="#除法（Division，÷）" class="headerlink" title="除法（Division，÷）"></a>除法（Division，÷）</h5><p>从一个关系中找出<strong>与另一个关系相关联的元组</strong>。</p>
<p>比如</p>
<p>设关系R除以关系S所得的结果为关系T，则T包含所有在关系R中但不在关系S中的属性及其值，且T的元组于与S的元组的所有组合都在R中。关系T是关系R在属性X上的投影的子集</p>
<p>**StudentCourse(Student, Course)**：表示学生及对应的一门人文选修课程。</p>
<p>**CulturalCourse(Course)**：表示所有文化素养类的人文选修课。</p>
<p>找出选修全部人文选修课的学生</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250107153700730.png" alt="image-20250107153700730"></p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106214442062.png" alt="image-20250106214442062" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106211836831.png" alt="image-20250106211836831" style="zoom:33%;" />

<p><strong>示例：</strong><br> 找出完成所有项目的员工：</p>
<p>$EmployeeProject \div Project$</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.name</span><br><span class="line"><span class="keyword">FROM</span> EmployeeProject E</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> P.projectID</span><br><span class="line">    <span class="keyword">FROM</span> Project P</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> EP.projectID</span><br><span class="line">        <span class="keyword">FROM</span> EmployeeProject EP</span><br><span class="line">        <span class="keyword">WHERE</span> EP.employeeID <span class="operator">=</span> E.employeeID</span><br><span class="line">          <span class="keyword">AND</span> EP.projectID <span class="operator">=</span> P.projectID</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="自然连接（Natural-Join，⨝）"><a href="#自然连接（Natural-Join，⨝）" class="headerlink" title="自然连接（Natural Join，⨝）"></a>自然连接（Natural Join，⨝）</h5><ul>
<li>¯自然连接是可结合的</li>
<li>自动基于<strong>相同名称的属性</strong>连接两个关系，无需指定条件。</li>
<li>自然连接要求两表中必须存在<strong>同名列</strong>，否则会报错。</li>
<li>自动匹配的列必须是类型一致的，否则会导致匹配失败或错误。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Employee <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> Department;</span><br></pre></td></tr></table></figure>

<p>内连接 inner join</p>
<p><strong>手动指定条件：</strong> 需要明确写出连接条件，如 <code>ON</code> 或 <code>USING</code> 子句。</p>
<p><strong>更灵活：</strong> 可以指定任何条件进行连接，而不局限于列名是否相同。</p>
<p><strong>列可能重复：</strong> 如果匹配列名称相同，结果集中会重复显示这些列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Employee INNER JOIN Department</span><br><span class="line">ON Employee.deptID = Department.deptID;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，通常更推荐使用<strong>普通连接（INNER JOIN）</strong>明确条件，增强可读性和可维护性。</p>
<h5 id="外连接（Outer-Join）"><a href="#外连接（Outer-Join）" class="headerlink" title="外连接（Outer Join）"></a>外连接（Outer Join）</h5><p>处理缺失值的连接方式，分为：</p>
<ul>
<li><p><strong>左外连接（Left Outer Join）：</strong> 保留左表所有元组。</p>
<p><code>SELECT * FROM R LEFT JOIN S ON 条件;</code></p>
</li>
<li><p><strong>右外连接（Right Outer Join）：</strong> 保留右表所有元组。</p>
<p><code>SELECT * FROM R RIGHT JOIN S ON 条件;</code> </p>
</li>
<li><p><strong>全外连接（Full Outer Join）：</strong> 保留两表所有元组。</p>
<p><code>SELECT * FROM R FULL OUTER JOIN S ON 条件;</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>结果集</th>
<th>缺失值处理</th>
</tr>
</thead>
<tbody><tr>
<td><strong>INNER JOIN</strong></td>
<td>只返回两表中匹配的行</td>
<td>不显示缺失的行</td>
</tr>
<tr>
<td><strong>LEFT OUTER JOIN</strong></td>
<td>左表所有行 + 右表匹配行，右表无匹配显示 <code>NULL</code></td>
<td>左表保留，右表缺失显示 <code>NULL</code></td>
</tr>
<tr>
<td><strong>RIGHT OUTER JOIN</strong></td>
<td>右表所有行 + 左表匹配行，左表无匹配显示 <code>NULL</code></td>
<td>右表保留，左表缺失显示 <code>NULL</code></td>
</tr>
<tr>
<td><strong>FULL OUTER JOIN</strong></td>
<td>两表所有行，无匹配的部分显示 <code>NULL</code></td>
<td>两表都保留，缺失显示 <code>NULL</code></td>
</tr>
</tbody></table>
<h5 id="重命名（ρ）"><a href="#重命名（ρ）" class="headerlink" title="重命名（ρ）"></a>重命名（ρ）</h5><p>假设有关系 **Student(SID, Name, Age)**：</p>
<ol>
<li>重命名关系名：<br><strong>ρ(Stud)(Student)</strong> —— 将关系名 <strong>Student</strong> 重命名为 <strong>Stud</strong>。</li>
<li>重命名属性名：<br><strong>ρ(Student(SID, FullName, Age))(Student)</strong> —— 将属性 <strong>Name</strong> 重命名为 <strong>FullName</strong>。</li>
<li>同时重命名关系和属性：<br><strong>ρ(SInfo(ID, FName, Age))(Student)</strong> —— 将关系改为 <strong>SInfo</strong>，属性改为 <strong>ID, FName, Age</strong>。</li>
</ol>
<p>重命名操作不会改变原始关系的数据或结构，只是在查询过程中使用新的名称。</p>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250107220002881.png" alt="image-20250107220002881" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250107220010036.png" alt="image-20250107220010036" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250107220018735.png" alt="image-20250107220018735" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250107220028688.png" alt="image-20250107220028688" style="zoom:33%;" />

<h1 id="E-R-转换为-关系模型"><a href="#E-R-转换为-关系模型" class="headerlink" title="E-R 转换为 关系模型"></a>E-R 转换为 关系模型</h1><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106210646528.png" alt="image-20250106210646528" style="zoom:33%;" />

<h2 id="实体转换"><a href="#实体转换" class="headerlink" title="实体转换"></a>实体转换</h2><h3 id="强实体集"><a href="#强实体集" class="headerlink" title="强实体集"></a>强实体集</h3><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106152734905.png" alt="image-20250106152734905" style="zoom:33%;" />

<p>强实体集直接转换为一个关系模式，包含：</p>
<ul>
<li>实体的所有属性。</li>
<li>选定的主键作为关系的主键。</li>
<li><strong>Student(<u>SID</u>, Name, Age)</strong></li>
</ul>
<h3 id="弱实体集"><a href="#弱实体集" class="headerlink" title="弱实体集"></a>弱实体集</h3><p>弱实体集需要依赖强实体集，因此其转换包含：</p>
<ul>
<li>所有自身属性。</li>
<li>与<strong>强实体集的外键作为依赖关系的标识</strong>。外键需要级联删除</li>
<li><strong>强实体的主键和弱实体的标识符一起构成复合主键。</strong> </li>
</ul>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106160124436.png" alt="image-20250106160124436" style="zoom:33%;" />

<p>如图，pname是弱实体的标识符，用虚线标识，但是还需要结合外键ssn来构成联合主键。外键ssn关联到Emp表，级联删除</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106160110142.png" alt="image-20250106160110142" style="zoom:33%;" />

<h2 id="关系转换"><a href="#关系转换" class="headerlink" title="关系转换"></a>关系转换</h2><h3 id="1对1"><a href="#1对1" class="headerlink" title="1对1"></a>1对1</h3><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106153944488.png" alt="image-20250106153944488" style="zoom:33%;" />

<p>将联系与任意“一”端实体集合并为一个关系表（推荐）</p>
<p> 使用参与实体的主键作为外键，任选一个实体的主键作为主键。</p>
<ul>
<li>联系 <strong>Marriage</strong> 关联 <strong>Husband(HID)</strong> 和 **Wife(WID)**。</li>
<li>转换为关系模式：**Marriage(HID, WID)**，主键：(HID 或 WID)，外键：HID 和 WID。</li>
</ul>
<h3 id="1对多"><a href="#1对多" class="headerlink" title="1对多"></a>1对多</h3><p>将联系与“多”端实体集合并为一个关系表（推荐）</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106153850034.png" alt="image-20250106153850034" style="zoom: 33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106153915801.png" alt="image-20250106153915801" style="zoom: 33%;" />

<ul>
<li>联系 <strong>WorksFor</strong> 关联 <strong>Employee(EID)</strong> 和 **Department(DID)**，假设一个部门有多个员工。</li>
<li>转换为关系模式：**Employee(EID, Name, DID)**，</li>
</ul>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>M:N 需要创建一个独立的关系模式：包含两个实体的主键作为复合主键。将联系转换为一个关系表</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106153544963.png" alt="image-20250106153544963" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106153747995.png" alt="image-20250106153747995" style="zoom:33%;" />

<ul>
<li>联系 <strong>Teaches</strong> 关联 <strong>Teacher(TID)</strong> 和 **Course(CID)**。</li>
<li>关系模式：**Teaches(TID, CID)**，主键：(TID, CID)，外键：TID 和 CID。</li>
</ul>
<p><strong>自关联</strong>将实体自身的主键添加为外键以表示层级关系。联系 <strong>Manage</strong> 表示雇员管理雇员：<strong>Employee(EID, Name, ManagerID)<strong>，外键：</strong>ManagerID</strong> 引用 <strong>EID</strong>。</p>
<h2 id="多值属性转换"><a href="#多值属性转换" class="headerlink" title="多值属性转换"></a>多值属性转换</h2><p>多值属性需要单独创建一个新关系：</p>
<ul>
<li>包含实体的主键和多值属性。</li>
</ul>
<p><strong>示例：</strong><br>实体 **Student(SID, Name, Phone)**，其中 <strong>Phone</strong> 是多值属性。<br>转换为关系模式：</p>
<ol>
<li><strong>Student(SID, Name)</strong></li>
<li>**Phone(SID, Phone)**，主键：(SID, Phone)，SID 是外键。</li>
</ol>
<h2 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h2><h3 id="类层次-1"><a href="#类层次-1" class="headerlink" title="类层次"></a>类层次</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> Hourly_Emps ( ssn   <span class="type">CHAR</span>(<span class="number">20</span>), </span><br><span class="line">hourly_wages  <span class="type">REAL</span>, </span><br><span class="line">hours_worked  <span class="type">INTEGER</span>,</span><br><span class="line"><span class="keyword">PRIMARY KEY</span>(ssn),</span><br><span class="line"><span class="keyword">FOREIGN KEY</span> (ssn) <span class="keyword">REFERENCES</span> Employees <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106160037030.png" alt="image-20250106160037030" style="zoom:33%;" />

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106154230808.png" alt="image-20250106154230808" style="zoom:33%;" />

<p>雇员的小孩，联合主键是雇员的ssn+自己的name，ssn是来自雇员的外键</p>
<p>联系的主键是产生联系的强实体的主键的联合：讲授</p>
<p>联系延展出来的实体主键应该是另外一个约束：学期作为主键：</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106155316178.png" alt="image-20250106155316178" style="zoom:26%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106155627436.png" alt="image-20250106155627436" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106155543495.png" alt="image-20250106155543495" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106155525220.png" alt="image-20250106155525220" style="zoom:33%;" />

<h1 id="SQL-JavaEE-MySQL-MySQL-基础篇-表设计-约束-事务-SQL函数-md"><a href="#SQL-JavaEE-MySQL-MySQL-基础篇-表设计-约束-事务-SQL函数-md" class="headerlink" title="[SQL](.\JavaEE\MySQL\MySQL 基础篇 表设计 约束 事务 SQL函数.md)"></a>[SQL](.\JavaEE\MySQL\MySQL 基础篇 表设计 约束 事务 SQL函数.md)</h1><p>授权 在下方安全性</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106214737494.png" alt="image-20250106214737494"></p>
<h2 id="in-exists"><a href="#in-exists" class="headerlink" title="in exists"></a>in exists</h2><table>
<thead>
<tr>
<th>区别项</th>
<th><code>IN</code></th>
<th><code>EXISTS</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>判断一个值是否存在于指定集合中，存在则为 TRUE。</td>
<td>判断子查询是否返回至少一行数据。如果返回则为 TRUE</td>
</tr>
<tr>
<td><strong>比较对象</strong></td>
<td>直接比较具体值或子查询结果集。</td>
<td>通过条件关联检查数据是否存在。</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td><strong>适合小规模数据集，逐个值进行匹配。</strong></td>
<td><strong>适合大规模数据集，通过布尔判断快速处理。</strong></td>
</tr>
<tr>
<td><strong>空值 (NULL) 处理</strong></td>
<td>如果子查询返回 <code>NULL</code>，结果始终为 <code>FALSE</code>。</td>
<td>子查询中包含 <code>NULL</code> 也不会影响结果。</td>
</tr>
<tr>
<td><strong>执行逻辑</strong></td>
<td>对查询结果集逐条扫描匹配，依赖具体值比较。</td>
<td>遇到第一个匹配结果即停止查询，提高效率。</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> CustomerID <span class="keyword">FROM</span> Orders);</span><br><span class="line"><span class="comment">-- 查询 Customers 表中 CustomerID 存在于 Orders 表中的记录。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Customers C</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> Orders O <span class="keyword">WHERE</span> C.CustomerID <span class="operator">=</span> O.CustomerID);</span><br><span class="line"><span class="comment">-- 查询 Customers 表中存在关联订单的记录。</span></span><br><span class="line"><span class="comment">-- Orders 表中只要找到第一条匹配的记录就停止查询返回TRUE，效率更高。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>in</code> 在查询的时候，首先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。所以相对内表比较小的时候，<code>in</code> 的速度较快。</p>
<p><code>exists</code>指定一个子查询，检测行的存在。遍历循环外表，检查外表中的记录有没有和内表的的数据一致的。匹配得上就放入结果集。</p>
<p>如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用 <code>in</code>， 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用 <code>exists</code>。</p>
<p>其实我们区分 <code>in</code> 和 <code>exists</code> 主要是造成了驱动顺序的改变（这是性能变化的关键），如果是 <code>exists</code>，那么以外层表为驱动表，先被访问，如果是 <code>in</code> ，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系 ，另外 <code>in</code> 是不对 <code>NULL</code> 进行处理。</p>
<p>IN是做外表和内表通过Hash连接，先查询子表，再查询主表，不管子查询是否有数据，都对子查询进行全部匹配。</p>
<p>EXISTS是外表做loop循环，先主查询，再子查询，然后去子查询中匹配，如果匹配到就退出子查询返回true，将结果放到结果集。</p>
<h3 id="not-in-amp-not-exists"><a href="#not-in-amp-not-exists" class="headerlink" title="not in &amp; not exists"></a>not in &amp; not exists</h3><p>如果查询语句使用 <code>not in</code>，那么内外表都进行全表扫描，没有用到索引；</p>
<p>而 <code>not exists</code> 的子查询依然能用到表上的索引。所以无论那个表大，用 <code>not exists</code> 都比<code>not in</code> 要快。</p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>用户身份验证、授权、加密、视图、审计</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106205840589.png" alt="image-20250106205840589" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106205855041.png" alt="image-20250106205855041" style="zoom:33%;" />

<h2 id="用户-CREATE-DROP-USER"><a href="#用户-CREATE-DROP-USER" class="headerlink" title="用户 CREATE/DROP USER"></a>用户 CREATE/DROP USER</h2><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106205624361.png" alt="image-20250106205624361" style="zoom:33%;" />

<h2 id="授权-GRANT…-ON-…-TO"><a href="#授权-GRANT…-ON-…-TO" class="headerlink" title="授权 GRANT… ON … TO"></a>授权 GRANT… ON … TO</h2><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106204630154.png" alt="image-20250106204630154" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106210845304.png" alt="image-20250106210845304" style="zoom:33%;" />

<p>WITH GRANT OPTION 可级联授权</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106204650797.png" alt="image-20250106204650797" style="zoom:33%;" />

<h3 id="授权回收-REVOKE-…-ON-…-FROM"><a href="#授权回收-REVOKE-…-ON-…-FROM" class="headerlink" title="授权回收 REVOKE … ON … FROM"></a>授权回收 REVOKE … ON … FROM</h3><p>级联回收。</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106204713760.png" alt="image-20250106204713760" style="zoom:33%;" />

<h3 id="角色-ROLE"><a href="#角色-ROLE" class="headerlink" title="角色 ROLE"></a>角色 ROLE</h3><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106204746332.png" alt="image-20250106204746332" style="zoom:33%;" />

<h3 id="视图-CREATE-DROP-VIEW-…-AS"><a href="#视图-CREATE-DROP-VIEW-…-AS" class="headerlink" title="视图 CREATE/DROP VIEW … AS"></a>视图 CREATE/DROP VIEW … AS</h3><p>一般是视图和授权配合使用</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106204855701.png" alt="image-20250106204855701" style="zoom:33%;" />

<h1 id="查询处理、优化"><a href="#查询处理、优化" class="headerlink" title="查询处理、优化"></a>查询处理、优化</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>哈希索引</p>
<h2 id="选择运算的查询处理"><a href="#选择运算的查询处理" class="headerlink" title="选择运算的查询处理"></a>选择运算的查询处理</h2><h3 id="select-from-Students"><a href="#select-from-Students" class="headerlink" title="select * from Students"></a><code>select * from Students</code></h3><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106165515736.png" alt="image-20250106165515736" style="zoom:33%;" />

<h3 id="条件查询，主键等值查询（聚集索引）"><a href="#条件查询，主键等值查询（聚集索引）" class="headerlink" title="条件查询，主键等值查询（聚集索引）"></a>条件查询，主键等值查询（聚集索引）</h3><p>主键等值查询，肯定返回单个记录</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106165544206.png" alt="image-20250106165544206" style="zoom:33%;" />

<h3 id="条件查询，非主键"><a href="#条件查询，非主键" class="headerlink" title="条件查询，非主键"></a>条件查询，非主键</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>非主键等值查询，返回了多个记录</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106165705084.png" alt="image-20250106165705084" style="zoom:33%;" />

<h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106170043342.png" alt="image-20250106170043342" style="zoom:33%;" />



<h1 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h1><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式级别判断 题目：U=ABCDE, F={ A-&gt;C, BC-&gt;D, CD-&gt;A, AB-&gt;E} </p>
<p><strong>第一步（求候选码）</strong>：求候选码的过程略去，结果为{(AB), (BC)} </p>
<p><strong>第二步（判断1NF）</strong>：呃，肯定都是1NF，不是的话这题不用出了 </p>
<p><strong>第三步（写出非主属性、候选码）</strong>：这一步是为了方便后续判断。 非主属性是未出现在候选码中的属性，本题为DE。候选码为AB和BC。 </p>
<p>如下列出：</p>
<p>非主属性：DE；候选码：AB、BC </p>
<p>在题干中标记非主属性： F={ A-&gt;C, BC-&gt;==D==, C==D==-&gt;A, AB-&gt;==E==}</p>
<p><strong>第四步（判断2NF）</strong>：<u>2NF的定义为非主属性应完全函数依赖于任一候选码</u>。即看非主属性的左侧的推断条件中是否出现了候选码，也就是 题目中D和E的左侧是否出现了AB或BC（AB或BC必须一起打包出现，不 能只出现单个的A，B之类）。举例来说，假如题目中存在A-&gt;D，D是非 主属性，而左侧只有A，没有和B一起出现，即D不是完全函数依赖于候 选码AB的，它只部分依赖了AB中的A。观察当前题目，非主属性D和E的 左侧均是候选码之一，并不存在这种情况，那么它是满足2NF的。 </p>
<p><strong>第五步（判断3NF）</strong>：在满足2NF的前提下（注意满足2NF之后再看3NF 哦～），<u>3NF的定义为不存在非主属性对任一候选码的传递函数依赖</u>。 举个例子，如果有AB-&gt;D，又有D-&gt;E，即非主属性E通过非主属性D作为 桥梁才能推出，这就是传递依赖。尽管候选码AB能推出D和E，但E是间 接推出的，也不可以出现，达咩。继续观察题目，并没有这种情况， 那么是满足3NF的。 </p>
<p><strong>第六步（判断BCNF）</strong>：在满足3NF的前提下，<u>BCNF的条件是每一个决定因素（即每一个依赖关系的左侧）都包含码</u>。即决定因素必须包含 候选码中的任意一个。即在本题中，每个决定因素要么有AB，要么有 BC。要么A和B成对出现，要么B和C成对出现。该题中，第一个关系A- &gt;C就只出现了A，A没有和B一起出现，所以本题不满足BCNF。注意这里 和2NF的区别，2NF只看针对非主属性的左侧，而BCNF要看所有依赖关 系的左侧。 因此本题为3NF。（玄学：实在不会就写3NF，3NF出现的概率大些）</p>
<h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106143328181.png" alt="image-20250106143328181" style="zoom: 33%;" />

<h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106213208234.png" alt="image-20250106213208234" style="zoom:33%;" />

<p>需要处理多个关系的大量元组的用户事务   以==数据库==为封锁单位</p>
<p>需要处理大量元组的用户事务    以==关系==为封锁单元</p>
<p>只处理少量元组的用户事务       以==元组==为封锁单位</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106213258930.png" alt="image-20250106213258930" style="zoom:33%;" />

<h2 id="N-级封锁协议"><a href="#N-级封锁协议" class="headerlink" title="N 级封锁协议"></a>N 级封锁协议</h2><h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><p><strong>规则：</strong></p>
<ul>
<li>事务在**==修改数据==之前必须加 X 锁<strong>，并且在事务</strong>提交之前不能释放 X 锁**。</li>
</ul>
<p><strong>优点：</strong> 保证事务的<strong>最终一致性</strong>，防止<strong>丢失修改</strong>。</p>
<p><strong>缺点：</strong> <strong>脏读</strong>和<strong>不可重复读</strong> </p>
<p><strong>示例：</strong> 事务 A 修改数据，但事务 B 在事务 A 提交之前无法读取或修改同一数据。</p>
<h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><p><strong>规则：</strong></p>
<ul>
<li>一级</li>
<li>==读取数据==之前必须先对其加 **S 锁，==读完后方可释放 S 锁==**。</li>
</ul>
<p><strong>优点：</strong> 防止<strong>脏读</strong>和<strong>丢失修改</strong>，保证读操作的正确性。</p>
<p><strong>缺点：</strong> <strong>不可重复读</strong>和<strong>幻读</strong>问题。</p>
<h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p><strong>规则：</strong></p>
<ul>
<li>一级</li>
<li>==读取数据==之前必须先对其加 **S 锁，==直到事务结束才释放==**。</li>
</ul>
<p><strong>优点：</strong> </p>
<ol>
<li>保证<strong>可重复读</strong>，防止<strong>脏读</strong>。</li>
<li>遵循更严格的隔离级别。</li>
</ol>
<p><strong>缺点：</strong> 可能出现幻读，性能开销较大，可能出现较多锁竞争，降低并发性能。</p>
<h3 id="饥饿、死锁、活锁"><a href="#饥饿、死锁、活锁" class="headerlink" title="饥饿、死锁、活锁"></a>饥饿、死锁、活锁</h3><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106140653090.png" alt="image-20250106140653090" style="zoom:33%;" />

<p>饥饿：事务T申请对数据项R加M型锁，允许加锁的条件：</p>
<ol>
<li>在R上不存在与M冲突的锁的其他事务</li>
<li>不存在等待对R加锁，且先于T申请加锁的事务</li>
</ol>
<p>活锁：先来先服务</p>
<ol>
<li>封锁管理子系统按请求封锁的先后顺序对事务排队</li>
<li>一旦被申请的数据对象的锁释放，立即批准队列中的一个事务获得锁</li>
</ol>
<p>死锁：</p>
<ol>
<li><p>预防：破坏产生死锁条件</p>
<ol>
<li><p>互斥：CAS、乐观锁（基于时间戳）</p>
<ol>
<li><p>无论是等待-死亡，还是受伤-等待, 回滚( rollback)的事务重启动时：</p>
<p>保留其原来的时标(timestamp) </p>
<p>年长的事务(Older transactions) 优先新的事务，可以避免饥饿现象</p>
</li>
</ol>
</li>
<li><p>循环等待：获取锁顺序固定，不要形成环路</p>
</li>
<li><p><em>非抢占：获取锁之后可以被剥夺，try</em></p>
</li>
<li><p>原子性抢锁：把抢锁过程集中起来，外边加一把锁，一次性把锁都抢到</p>
</li>
</ol>
</li>
<li><p>检测：</p>
<ol>
<li>超时法：如果一个事务等待的时间超过了规定的时间, 就认为发生了死 锁</li>
<li>等待图法：节点表示正在执行的事务, 边表示等待情况，如果存在回路, 系统中发生死锁</li>
</ol>
</li>
<li><p>恢复：</p>
<ol>
<li>选择一个处理死锁代价最小的事务, 将其撤销, 释放锁。该事务计算的时间、使用多少数据项、完成事务还需多少数据项、撤销该事务需要牵涉多少其他事务</li>
<li>决定rollback多远，彻底撤销，或rollback到可以解决死锁为止</li>
<li>避免饥饿：避免由于某个事务rollback的代价最小，而总是rollback该事务。在代价因素中包括rollback的次数</li>
</ol>
</li>
</ol>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><h3 id="两阶段封锁协议（2PL）"><a href="#两阶段封锁协议（2PL）" class="headerlink" title="两阶段封锁协议（2PL）"></a>两阶段封锁协议（2PL）</h3><p>通过<strong>加锁机制</strong>确保事务遵守以下规则：</p>
<ol>
<li><strong>加锁阶段：</strong> 事务在读取或写入数据前先申请锁。在这个阶段，事务可以获得锁定，但不能释放锁定。事务可以继续请求并获得锁定，直到它达到了其锁定点（Lock Point），也就是事务获得最后一个锁定的时间点。一旦事务进入第二阶段，它就不能再获得新的锁定。</li>
<li><strong>解锁阶段：</strong> 事务在提交或回滚后释放所有锁。在这个阶段，事务可以释放已经持有的锁定，但不能再获取新的锁定。这个阶段的目的是确保事务不会在已经进入第二阶段后再次请求锁定</li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li>确保事务的调度是可串行化的。</li>
<li>容易产生<strong>死锁</strong>。</li>
<li>级联撤销</li>
<li>脏读</li>
</ul>
<h3 id="级联撤销（cascading-rollback）"><a href="#级联撤销（cascading-rollback）" class="headerlink" title="级联撤销（cascading rollback）"></a>级联撤销（cascading rollback）</h3><p><strong>T1</strong> 修改了数据 <code>X</code> 为100，并暂时释放X锁，但尚未提交。</p>
<p><strong>T2</strong> 在 T1 释放锁后读取了数据 <code>X</code> 为100。</p>
<p>T1 之后出现了问题，事务回滚，T2读了无效的数据，也只能回滚。</p>
<ul>
<li><strong>事务回滚链式传播：</strong>一个事务的失败可能会触发多个事务回滚，导致性能下降。</li>
<li><strong>复杂性增加：</strong>需要跟踪事务之间的依赖关系，管理回滚过程更加复杂。</li>
<li><strong>资源浪费：</strong>前期已执行的操作可能全部作废，影响效率。</li>
</ul>
<h3 id="严格两阶段封锁协议（Strict-2PL）"><a href="#严格两阶段封锁协议（Strict-2PL）" class="headerlink" title="严格两阶段封锁协议（Strict 2PL）"></a>严格两阶段封锁协议（Strict 2PL）</h3><p>在普通 2PL 的基础上，所有锁直到事务结束时才释放，因为锁未释放，其他事务无法读取未提交的数据，从而避免级联撤销。</p>
<p>在两阶段锁定协议中，存在级联回滚（Cascading Rollback）的可能性。为了避免级联回滚，可以采用一种更严格的协议，称为“<strong>严格两阶段锁定”（Strict Two-Phase Locking）</strong>。在严格两阶段锁定中，事务必须保持其所有<strong>独占锁（Exclusive Locks）（lock_X）</strong>直到事务提交或回滚。</p>
<p><strong>优点：</strong> </p>
<ol>
<li>保证<strong>可串行化调度</strong>，是最严格的封锁协议。</li>
<li>防止<strong>脏读、不可重复读和幻读</strong>等问题。</li>
</ol>
<p><strong>缺点：</strong></p>
<ul>
<li>性能开销较大，容易出现<strong>死锁</strong>问题。</li>
</ul>
<p>还有一个加强2PL，commit之前不释放任何锁</p>
<h3 id="时间戳排序协议-lock-free"><a href="#时间戳排序协议-lock-free" class="headerlink" title="时间戳排序协议 (lock-free)"></a>时间戳排序协议 (lock-free)</h3><p>每个事务分配一个时间戳，事务按时间顺序执行，防止事务操作越界：</p>
<ul>
<li><strong>早的事务优先执行，后来的事务必须等候或中止重试。</strong> </li>
<li>避免了死锁问题，但增加了系统开销。</li>
<li>由于冲突操作是按时标顺序处理的，时标顺序协议能保证调度是可串行化的</li>
<li>由于没有事务处于等待状态，并发调度不会产生死锁</li>
<li>时标顺序协议使调度无级联回退调度</li>
</ul>
<h3 id="多版本并发控制（MVCC）-lock-free"><a href="#多版本并发控制（MVCC）-lock-free" class="headerlink" title="多版本并发控制（MVCC） (lock-free)"></a>多版本并发控制（MVCC） (lock-free)</h3><p>创建数据的多个版本，为每个事务提供一致性视图：</p>
<ul>
<li>读操作不会阻塞写操作，反之亦然。</li>
<li>PostgreSQL 和 MySQL 的 InnoDB 引擎在高并发场景下通过 MVCC 实现 Serializable。</li>
</ul>
<h1 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h1><h2 id="故障种类"><a href="#故障种类" class="headerlink" title="故障种类"></a>故障种类</h2><p>事务故障、系统崩溃、介质故障</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106163706346.png" alt="image-20250106163706346" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106163713742.png" alt="image-20250106163713742" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106163733316.png" alt="image-20250106163733316" style="zoom:33%;" />

<p><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106203655221.png" alt="image-20250106203655221"></p>
<h2 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h2><p><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106203911462.png" alt="image-20250106203911462"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106203757019.png" alt="image-20250106203757019"></p>
<p>日志文件中只有start，==而没有commit或abort==的事务需要被undo，恢复到事务开始时的状态</p>
<p>日志文件中既有start，==又有commit或abort==的事务需要被redo，恢复到事务提交后的状态</p>
<h3 id="检查点恢复"><a href="#检查点恢复" class="headerlink" title="检查点恢复"></a>检查点恢复</h3><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106164112723.png" alt="image-20250106164112723" style="zoom:33%;" />

<p>checkpoint: T2,T3 未提交</p>
<p>故障点：T3，T5 还没提交  Redo T2 T4  Undo T3 T5</p>
<h3 id="WriteAheadLogging-Buffer"><a href="#WriteAheadLogging-Buffer" class="headerlink" title="WriteAheadLogging Buffer"></a>WriteAheadLogging Buffer</h3><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106164356621.png" alt="image-20250106164356621" style="zoom:33%;" />

<p>当系统发现需要将一个日志记录输出到稳定存储器：</p>
<ul>
<li><p>当有足够日志记录被填满，就输出</p>
</li>
<li><p>没有足够日志记录，收集到一个部分填充块，输出</p>
</li>
</ul>
<h2 id="介质故障—数据转储"><a href="#介质故障—数据转储" class="headerlink" title="介质故障—数据转储"></a>介质故障—数据转储</h2><p><img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106203928899.png" alt="image-20250106203928899"></p>
<p>静态/动态：是否允许存取和修改</p>
<p>海量/增量：每次是否转储全部</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106164834685.png" alt="image-20250106164834685" style="zoom:33%;" />

<img src="C:/Users/Lenovo/Pictures/markdownfile/DBreview.assets/image-20250106164840372.png" alt="image-20250106164840372" style="zoom:33%;" />

<p>1.装入==后援副本==</p>
<p>2.装入相应的==日志文件副本== </p>
<p>3==.启动恢复程序按日志恢复== </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/03/C++%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/03/C++%20%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-03 21:19:50" itemprop="dateCreated datePublished" datetime="2025-05-03T21:19:50+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-15 14:56:50" itemprop="dateModified" datetime="2024-11-15T14:56:50+08:00">2024-11-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="C-笔记"><a href="#C-笔记" class="headerlink" title="C++ 笔记"></a>C++ 笔记</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul>
<li><p>如果程序执行错误，就throw一个异常</p>
<p>b是一个int</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> b </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="built_in">catch</span> (<span class="type">int</span> b)&#123;</span><br><span class="line"></span><br><span class="line">cerr &lt;&lt;b&lt;&lt;endl &#125;</span><br></pre></td></tr></table></figure>

<p>throw 一个字符串常量，catch的参数就是一个const char</p>
</li>
<li><p>throw加在函数声明的后边 void fun() throw(A,B,C,D)</p>
<p>表示函数能抛出ABCD四种类型的错误，不加throw表明能抛出任何类型的异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = <span class="built_in">division</span>(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   &#125;<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul>
<li>using namespace XXX<br>如果不写using namespace std的话<br>用cout函数就得加std::cout<br>尽量别用，容易污染<br>xx::a 与 yy::a不是一个东西<br>全局作用域符号，用来区分同名的的全局变量与局部变量<br>::不跟类名，表示全局的</li>
</ul>
<h2 id="动态数组（new-amp-delete）"><a href="#动态数组（new-amp-delete）" class="headerlink" title="动态数组（new&amp;delete）"></a>动态数组（new&amp;delete）</h2><ul>
<li>```c++<br>int *p=NULL;<br>p=new int;<br>*p=2;<br>delete p;char *p=NULL;<br>p=new char[10];<br>delete []p;//对象数组是同样的处理方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  我们在用动态内存分配时，经常是用`new`来定义一块内存空间，比如说 `int* p = new int(1)；`这时会在堆上分配一块内存，当作int类型使用，内存中存储的值为1并将内存地址赋值给在栈中的int*类型的p。（注意：p只是一个变量，就像是int a=1中的a一样，不过a是整形变量，而p是指针变量）当我们不用p指针时，往往需要用delete p将其释放，我们需要注意的是释放一个指针p（delete p;）实际意思是删除了p所指的目标（变量或对象），释放了它所占的堆空间，而不是删除p本身（指针p本身并没有撤销，它自己仍然存在，该指针所占内存空间并未释放，指针p的真正释放是随着函数调用的结束而消失），释放堆空间后，p成了&quot;空指针&quot;。如果我们在delete p后没有进行指针p的制空（p=NULL)的话，其实指针p这时会成为野指针，为了使用的安全，我们一般在delete p之后还会加上p=NULL这一语句。具体怎么成为野指针的，这有一篇非常详细的介绍[点击打开链接](http://https//www.cnblogs.com/uniqueliu/archive/2011/07/18/2109778.html)</span><br><span class="line"></span><br><span class="line">## 重载</span><br><span class="line"></span><br><span class="line">- 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。 </span><br><span class="line"></span><br><span class="line">- 当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</span><br><span class="line"></span><br><span class="line">## 运算符</span><br><span class="line"></span><br><span class="line">- 位运算符（除去“~”都是双目运算符）</span><br><span class="line"></span><br><span class="line">  | &amp;   与   | 只有同时为1才为1         |</span><br><span class="line">  | -------- | ------------------------ |</span><br><span class="line">  | \|    或 | 只有同时为0才为0         |</span><br><span class="line">  | ^  异或  | 一样就是0 不一样就是1    |</span><br><span class="line">  | ~  取反  | 变成负数，1变成0，0变成1 |</span><br><span class="line">  | &lt;&lt; 左移  | 字面意思                 |</span><br><span class="line">  | &gt;&gt; 右移  | 字面意思                 |</span><br><span class="line"></span><br><span class="line">  ​      A = 0011 1100</span><br><span class="line"></span><br><span class="line">  ​      B = 0000 1101</span><br><span class="line"></span><br><span class="line">  A &amp; B = 0000 1100</span><br><span class="line"></span><br><span class="line">  A  |  B = 0011 1101</span><br><span class="line"></span><br><span class="line">  A  ^ B = 0011 0001</span><br><span class="line"></span><br><span class="line">     ~A   = 1100 0011</span><br><span class="line"></span><br><span class="line">  A&lt;&lt;2  = 1111 0000</span><br><span class="line"></span><br><span class="line">  A&gt;&gt;2  = 0000 1111</span><br><span class="line"></span><br><span class="line">- 赋值运算符</span><br><span class="line"></span><br><span class="line">  +=，-=，/=，%=，*=   不做赘述</span><br><span class="line"></span><br><span class="line">  位运算&lt;&lt;=：`a&lt;&lt;=2`   a=a&lt;&lt;2</span><br><span class="line"></span><br><span class="line">  任何数异或 **^0** 得到的值不变:`a^0 = a`</span><br><span class="line"></span><br><span class="line">  任何数异或同一个数两次得到的值不变:`a^b^b = a`</span><br><span class="line"></span><br><span class="line">## 类与对象</span><br><span class="line"></span><br><span class="line">- 访问权限：public private protected</span><br><span class="line"></span><br><span class="line">### 	构造函数</span><br><span class="line"></span><br><span class="line">- 定义一个Line类，有一个length成员变量 初始化列表赋初值</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  Line::Line(int  num0):length (num0)</span><br><span class="line">  Line a(1)</span><br></pre></td></tr></table></figure>

如果声明了任何非默认构造函数、编译器不会提供默认构造函数。构造函数在未指定参数或者提供了一个空初始化器列表，则会调用默认构造函数：<code>vector v1; vector v2&#123;&#125;;</code>引用和const必须被初始化</li>
</ul>
<h3 id="复制构造函数（-amp-引用、const的使用）"><a href="#复制构造函数（-amp-引用、const的使用）" class="headerlink" title="复制构造函数（&amp;引用、const的使用）"></a>复制构造函数（&amp;引用、const的使用）</h3><ul>
<li>```c++<br>Line::Line(const Line&amp;obj)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​		&amp;是引用号作用类似于指针，引用时必须初始化值</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  a=1 ;   </span><br><span class="line">  int &amp;ra =a ;   </span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    相当于起了个别名ra，这样a在用作参数时候使用ra可以不用调用复制构造函数，因此不会造成无限复制构造函数的无限循环。如果引用对象参数为const类型，则不能通过ra修改a，反过来是可以的，但可以修改指针指向的地方。</p>
<p>​    如果对象中有指针，默认复制时指针的值是不会变的，因为他分配的内存是不在对象里面的，在析构    的时候，会出现两次析构相同位置的情况，所以==有指针的情况下最好自己构建一个复制构造函数==，并分配新的内存空间给新对象的指针。并且析构函数中也要额外释放指针，在系统默认的拷贝构造，**对指针的赋值时为==浅拷贝==<strong>，可能会导致直接对位的赋值，从而导致出现野指针情况，</strong>手动处理为==深拷贝==**。</p>
<ul>
<li><p>用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。普通引用在声明时必须用其它的变量进行初始化</p>
</li>
<li><p>引用作为函数参数声明时不进行初始化</p>
</li>
<li><p>传递引用是传递原变量，不需要做变量拷贝，普通的变量做函数参数的时候会开辟内存拷贝数值，而传递引用则不需要开辟内存；</p>
<p>C++ primer p406 ：拷贝构造函数是一种特殊的构造函数，具有单个形参，该形参（常用const修饰）是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显示使用拷贝构造函数。当该类型的对象传递给函数或从函数返回该类型的对象时，将隐式调用拷贝构造函数。</p>
</li>
<li><p>C++支持两种初始化形式：</p>
<ul>
<li><p>拷贝初始化 int a = 5; </p>
</li>
<li><p>直接初始化 int a(5); </p>
</li>
<li><p>对于其他类型没有什么区别，对于类类型直接初始化直接调用实参匹配的构造函数，<u>拷贝初始化总是调用拷贝构造函数</u>，也就是说：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A z;        <span class="comment">//定义，调用无参构造函数</span></span><br><span class="line"><span class="function">A <span class="title">x</span><span class="params">(<span class="number">2</span>)</span></span>;　　 <span class="comment">//直接初始化，调用有参构造函数</span></span><br><span class="line">A y = x;　　<span class="comment">//拷贝初始化，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></li>
<li><p><u>必须定义拷贝构造函数的情况</u>：</p>
<ol>
<li>只包含类类型成员或内置类型（但不是指针类型）成员的类，无须显式地定义拷贝构造函数也可以拷贝；</li>
<li>有的类有一个数据成员是指针，或者是有成员表示在构造函数中分配的其他资源。</li>
</ol>
</li>
<li><p><u>类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：</u></p>
<ol>
<li><p>一个对象以值传递的方式传入函数体；</p>
</li>
<li><p>一个对象以值传递的方式从函数返回；</p>
</li>
<li><p>一个对象需要通过另外一个对象进行初始化。</p>
</li>
</ol>
</li>
<li><p>实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>( <span class="type">int</span> len );             <span class="comment">// 简单的有参构造函数</span></span><br><span class="line">      <span class="built_in">Line</span>( <span class="type">const</span> Line &amp;obj);      <span class="comment">// 拷贝构造函数</span></span><br><span class="line">      ~<span class="built_in">Line</span>();                     <span class="comment">// 析构函数</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 为指针分配内存</span></span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *ptr = len;</span><br><span class="line">&#125;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="type">const</span> Line &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数并为指针 ptr 分配内存&quot;</span>          &lt;&lt; endl;</span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *ptr = *obj.ptr; <span class="comment">// 拷贝值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::~<span class="built_in">Line</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;释放内存&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Line::getLength</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(Line obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;line 大小 : &quot;</span> &lt;&lt; obj.<span class="built_in">getLength</span>() 		         &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Line <span class="title">line1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">   Line line2 = line1; <span class="comment">// 这里也调用了拷贝构造函数</span></span><br><span class="line">   <span class="built_in">display</span>(line1);</span><br><span class="line">   <span class="built_in">display</span>(line2);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数并为指针 ptr 分配内存</span><br><span class="line">调用拷贝构造函数并为指针 ptr 分配内存</span><br><span class="line">line 大小 : 10</span><br><span class="line">释放内存</span><br><span class="line">调用拷贝构造函数并为指针 ptr 分配内存</span><br><span class="line">line 大小 : 10</span><br><span class="line">释放内存</span><br><span class="line">释放内存</span><br><span class="line">释放内存</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul>
<li><p>必须与类同名 再在前部加一个～，删除对象的时候会自动调用</p>
</li>
<li><p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好在销毁类之前显式构造析构函数，释放掉申请的内存空间，避免内存泄漏。</p>
</li>
<li><p><strong>类析构顺序：</strong></p>
<p>1）派生类本身的析构函数；</p>
<p>2）对象成员析构函数；</p>
<p>3）基类析构函数。</p>
</li>
</ul>
<h3 id="友元函数（友元类）"><a href="#友元函数（友元类）" class="headerlink" title="友元函数（友元类）"></a>友元函数（友元类）</h3><ul>
<li>定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。</li>
<li>尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</li>
<li>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，没有this指针，访问非static指针要引入对象做参数</li>
</ul>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><ul>
<li><p>不允许使用switch 与loop 语句</p>
</li>
<li><p>定义必须出现在首次调用之前</p>
</li>
<li><p>较为短小的代码</p>
</li>
</ul>
<h2 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h2><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><h5 id="按权限："><a href="#按权限：" class="headerlink" title="按权限："></a>按权限：</h5><ul>
<li><h5 id="public-保持不变"><a href="#public-保持不变" class="headerlink" title="public  保持不变"></a>public  保持不变</h5></li>
<li><h5 id="protected-原public变成protected"><a href="#protected-原public变成protected" class="headerlink" title="protected  原public变成protected"></a>protected  原public变成protected</h5></li>
<li><h5 id="private-全变成private"><a href="#private-全变成private" class="headerlink" title="private  全变成private"></a>private  全变成private</h5></li>
</ul>
<h5 id="按父类个数："><a href="#按父类个数：" class="headerlink" title="按父类个数："></a>按父类个数：</h5><ul>
<li><h5 id="单继承：只有一个父类"><a href="#单继承：只有一个父类" class="headerlink" title="单继承：只有一个父类"></a>单继承：只有一个父类</h5></li>
<li><h5 id="多继承：有多个父类"><a href="#多继承：有多个父类" class="headerlink" title="多继承：有多个父类"></a>多继承：有多个父类</h5></li>
<li><h5 id="链式继承：一条链，首尾相连"><a href="#链式继承：一条链，首尾相连" class="headerlink" title="链式继承：一条链，首尾相连"></a>链式继承：一条链，首尾相连</h5></li>
<li><h5 id="虚继承：也就是菱形继承"><a href="#虚继承：也就是菱形继承" class="headerlink" title="虚继承：也就是菱形继承"></a><a href="####%E8%99%9A%E7%BB%A7%E6%89%BF">虚继承</a>：也就是菱形继承</h5></li>
</ul>
<h4 id="重载-静态多态"><a href="#重载-静态多态" class="headerlink" title="重载(静态多态)"></a>重载(<strong>静态多态</strong>)</h4><p>静态函数在编译的时候就已经确定运行时机</p>
<h4 id="虚函数-动态多态"><a href="#虚函数-动态多态" class="headerlink" title="虚函数(动态多态)"></a>虚函数(动态多态)</h4><ul>
<li><p>函数只在 code 区存放一份，数据成员则每个对象一份，并按照声明顺序依次存放</p>
</li>
<li><p>在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
</li>
<li><p>类A中有了虚函数就会再类的数据成员的最前面添加一个 vfptr 指针(void** vfptr)，这个指针用来指向一个 vtable 表（一个函数指针数组）（一个类只有一个该表），该表存储着当前类的所有 虚函数 的地址。这样 vfptr 就成为了一个类似成员变量的存在。访问虚函数的时候通过 vfptr 间址找到vtable 表，再间址进而找到要调用的函数。这样就在一定程度上摆脱了类型制约。</p>
<p><img src="https://i.imgloc.com/2023/05/25/VDJKFq.png" alt="people派生出student再派生出vtable"></p>
<p>在虚函数表中，基类的虚函数在 vtable 中的索引（下标）是固定的，不会随着继承层次的增加而改变，派生类新增的虚函数放在 vtable 的最后。如果派生类有同名的虚函数遮蔽（覆盖）了基类的虚函数，那么将使用派生类的虚函数替换基类的虚函数，这样具有遮蔽关系的虚函数在 vtable 中只会出现一次。</p>
<p>只要vptr的值不同，那么访问函数成员的时候使用的vtable表就不同，就可能访问到不同类的函数成员。B类对象中的vptr指向B类自己的vtable。</p>
<p>当B类继承A类的时候，因为A中有虚函数，编译器就自动的给B类添加vfprt指针和vtable表。也可以理解为B类继承来了A类中的那个vptr指针成员。</p>
<p>当A类指针指向B类对象时，发生假切割。要知道这个过程只是切掉A类中没有的那些成员。（即当People类指针指向Student类对象时，切割掉m_score这个People类中没有的成员）<br>由于vptr是从A类中继承来的，所以这个量仍将保留。而对于vptr的值则不会改变，仍然指向B类的vtable表。所以访问F1函数的时候是通过B类的vtable表去寻址的，自然就是使用子类的函数（拿图中的情况举例，子类的Student::display()函数已经覆盖了People::display()函数，此时A类指针访问虚函数display()时也是访问到子类的Student::display()函数）。</p>
<p>当B类的指针指向A类的对象时（当B类存在新增数据成员时可能出错），同理。</p>
<p>而对于普通函数则受类型的制约，（因为没有vptr指针）使用哪个类的指针调用函数，那么所调用的就是那个累的函数。<br>总而言之，普通函数通过对象或指针的类型来找所调用的函数，而虚函数是通过一个指针来找到所要调用的函数的。</p>
<p>***==派生类指针指向基类对象==<em><strong>，这里疑问会比较大。首先是为什么这里不会报错，为什么派生类指针指向基类对象可以成立？理论上指针的可访问范围一定大于对象的大小，会指向一些未知区域导致运行出错，但是要注意的是，</strong>这个题目里面B类不存在新增数据成员，所以不会出错</em>*。还有就是由于是基类对象，还没有发生虚函数掩盖</p>
</li>
<li><p>函数要修改数据必须要传入该数据的地址</p>
<p>实现C++的多态，基类与派生类有同名的函数，派生类在调用这个函数的时候不知道调用哪个，因此就要用虚函数，在基类的这个函数加上virtual前缀。</p>
<p>虚函数必须实现也就是定义，不然会报错，</p>
<p><strong>纯虚函数:virtual xxx xxx()=0</strong></p>
<p>声明纯虚函数就代表这个类成了<strong>抽象类，不能进行实例化</strong></p>
<p>这就是在提醒继承这个类的时候要再次定义这个函数，不然还是抽象类没法实例化</p>
<p>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</p>
<p>定义一个函数为纯虚函数，才代表函数没有被实现。</p>
<p>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为”虚”函数。</p>
<p>虚函数只能借助于指针或者引用来达到多态的效果。</p>
<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0:</p>
<p>那么此时就能<a href="####%E9%80%9A%E8%BF%87%E7%88%B6%E7%B1%BB%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%88%E5%90%8C%E5%90%8D%E5%90%8C%E5%8F%82%EF%BC%89">通过父类的一个指针来调用子类的方法</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> A <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">class</span> B <span class="type">void</span> <span class="title">sow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">A *pa</span>=<span class="literal">NULL</span>;</span><br><span class="line">B b;</span><br><span class="line">pa=＆b;</span><br><span class="line">pa-&gt;<span class="built_in">sow</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><ul>
<li><p>​    A</p>
<p> /      <br>B      C             D继承了两个A，析构时会造成内存泄露<br> \     /              所以BC在继承A的时候必须要 <code>virtual public A</code> 虚继承</p>
<pre><code>D                 
</code></pre>
<p>​        在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A -&gt;B-&gt;D 这条路径，还是来自 A-&gt;C-&gt;D 这条路径。</p>
<p>​        为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。</p>
<p>​        虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为<strong>虚基类（<em>Virtual Base Class</em>）</strong>，本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p>
</li>
</ul>
<h4 id="子类从基类继承的成员限制"><a href="#子类从基类继承的成员限制" class="headerlink" title="子类从基类继承的成员限制"></a>子类从基类继承的成员限制</h4><ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
<li>==子类对象中父类成员初始化必须调用父类的构造函数，初始化列表方式==</li>
<li>子类对象中其他类的成员初始化必须使用初始化列表方式</li>
</ul>
<h4 id="构造函数-析构函数调用顺序"><a href="#构造函数-析构函数调用顺序" class="headerlink" title="==构造函数 析构函数调用顺序=="></a>==构造函数 析构函数调用顺序==</h4><ul>
<li><p>仅考虑实例化派生类对象时的情况</p>
</li>
<li><p>构造函数调用顺序：基类 &gt; 派生类里的对象成员 &gt; 派生类； </p>
</li>
<li><p>多继承派生类： 基类的构造顺序依照基类继承顺序调用</p>
</li>
<li><p>对象成员<a href="%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%8A%8A%E8%AF%A5%E5%AF%B9%E8%B1%A1%E7%A7%B0%E4%B8%BA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E3%80%82%E4%B9%9F%E5%8F%AB%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88">^2</a>：依照在派生类中对象成员的定义顺序 调用成员的构造函数 与初始化列表顺序无关</p>
</li>
<li><p>```c++<br>#include <iostream><br>using namespace std;<br>class Shape // 基类 Shape<br>{<br>public:</p>
<pre><code>Shape() &#123;cout &lt;&lt; &quot;Shape&quot; &lt;&lt; endl;&#125;
~Shape() &#123;cout &lt;&lt; &quot;~Shape&quot; &lt;&lt; endl;&#125;
</code></pre>
<p>};</p>
<p>class PaintCost // 基类 PaintCost<br>{<br>public:</p>
<pre><code>PaintCost() &#123;cout &lt;&lt; &quot;PaintCost&quot; &lt;&lt; endl;&#125;
~PaintCost() &#123;cout &lt;&lt; &quot;~PaintCost&quot; &lt;&lt; endl;&#125;
</code></pre>
<p>};</p>
<p>// 派生类<br>class Rectangle : public Shape, public PaintCost  //基类构造顺序 依照 继承顺序<br>{<br>public:</p>
<pre><code>Rectangle() :b(), a(), Shape(), PaintCost()
&#123;cout &lt;&lt; &quot;Rectangle&quot; &lt;&lt; endl;&#125;
~Rectangle() 
&#123;cout &lt;&lt; &quot;~Rectangle&quot; &lt;&lt; endl;&#125;
PaintCost b;        // 对象成员依照定义顺序
Shape a; 
</code></pre>
<p>};</p>
<p>int main(void)<br>{</p>
<pre><code>Rectangle Rect;
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">Shape</span><br><span class="line">PaintCost</span><br><span class="line">PaintCost</span><br><span class="line">Shape</span><br><span class="line">Rectangle</span><br><span class="line">~Rectangle</span><br><span class="line">~Shape</span><br><span class="line">~PaintCost</span><br><span class="line">~PaintCost</span><br><span class="line">~Shape</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="通过父类指针调用子类对象的成员函数（同名同参）"><a href="#通过父类指针调用子类对象的成员函数（同名同参）" class="headerlink" title="通过父类指针调用子类对象的成员函数（同名同参）"></a>通过父类指针调用子类对象的成员函数（同名同参）</h4><ul>
<li><p>基类指针指向基类对象，简单。只需要通过基类指针简单地调用基类的功能。</p>
</li>
<li><p>派生类指针指向派生类对象，简单。只需要通过派生类指针简单地调用派生类功能。</p>
</li>
<li><p>将基类指针指向派生类对象是安全的，因为派生类对象“是”它的基类的对象。</p>
<p>但是要注意的是，这个指针只能用来调用基类的成员函数。</p>
<p>如果试图通过基类指针调用派生类才有的成员函数，则编译器会报错。</p>
<p>为了避免这种错误，必须将基类指针强制转化为派生类指针。然后派生类指针可以用来调用派生类的功能。这称为向下强制类型转换，这是一种潜在的危险操作。</p>
</li>
</ul>
<p>注意：如果在基类和派生类中定义了虚函数（通过继承和重写），并通过基类指针在派生类对象上调用这个虚函数，则实际调用的是这个函数的派生类版本。</p>
<h5 id="出现同时有虚实函数的情况"><a href="#出现同时有虚实函数的情况" class="headerlink" title="出现同时有虚实函数的情况"></a>出现同时有虚实函数的情况</h5><ol>
<li><p>若全为虚函数，则调用子类的函数</p>
</li>
<li><p>若全为实函数，则调用父类的函数</p>
</li>
<li><p>若一实一虚，则调用他们中的实函数</p>
<p><strong>父类没有定义为虚的时候，子类是没办法多态的，而父类定义为虚函数的时候，子类默认也是个虚函数，会根据指针指向的数据类型来选择函数调用</strong></p>
<p><strong>派生类加不加virtual都是虚函数，只要派生类实现了虚函数就会覆盖基类的虚函数，基类指针pBase指向派生类对象basePlus时会调用派生类的虚函数</strong></p>
</li>
</ol>
<h5 id="虚析构函数（delete）"><a href="#虚析构函数（delete）" class="headerlink" title="虚析构函数（delete）"></a><strong>虚析构函数</strong>（delete）</h5><ol>
<li><p>可能通过基类指针删除派生类对象、</p>
</li>
<li><p>如果你打算允许他人通过基类指针调用对象的析构函数（通过delete这样做是正常的），就需要让基类的析构函数变为虚函数，否则执行delete的结果是不确定的</p>
</li>
<li><p>虚构造函数不合法(有了虚函数就要有虚函数表，调用构造函数就要去找vptr，此时vptr还没初始化)</p>
</li>
<li><p>虚析构函数的实现原理：</p>
<p>在父类中通过virtual 修饰析构函数后，通过 父类指针再去指向子类对象，然后通过delete 接父类指针，就可以 释放掉子类对象了</p>
<p>有了这个前提，如果使用父类的指针通过 <a href="##%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%88new&delete%EF%BC%89">delete</a> 的方式去释放子类的 对象，那么只要能够实现通过父类的指针执行到子类的析构函数即可</p>
<p>如果子类中不写虚析构函数，计算机会默认给你定义一个虚析构函数， 前提是你在父类中得有virtual 来修饰父类的析构函数</p>
<p>在使用时： 如果在main() 函数中通过父类指针指向子类对象，然后通过 delete 接父类指针释放子类对象 此时，虚函数表的工作： 如果在父类中定义了虚析构函数，那么在父类的虚函数表中就会 有一个父类析构函数的函数指针，指向父类的析构函数 而在子类的虚函数表中也会产生一个子类析构函数的函数指针， 指向子类的析构函数（注意：虚析构函数会覆盖） 当 父类的指针指向 子类的对象，通过 delete 接 父类的 指针时，就可以通过子类对象的 虚函数表指针 找到子类的 虚函数表，再通过子类 的虚函数表找到子类的析构函数，从而使得子类的析构函数得以执行，子类的析构函数执行完毕后， 系统会自动执行父类的析构函数（这句是重点）！</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;<span class="comment">//虚析构函数应用举例</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> _a) :<span class="built_in">a</span>(_a) &#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span>  ~<span class="built_in">A</span>() &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;A deleted.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">int</span> _a, <span class="type">int</span> _b) :<span class="built_in">A</span>(_a), <span class="built_in">b</span>(_b) &#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">	~<span class="built_in">B</span>() &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;B deleted.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">B::getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A* pa;<span class="comment">//基类A指针</span></span><br><span class="line">	pa = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//基类A指针指向派生类B</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pa-&gt;<span class="built_in">getValue</span>());</span><br><span class="line">	<span class="keyword">delete</span> pa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">B deleted.A deleted.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">////delete 删除的是指针指向的空间，不代表指针置NULL</span></span><br></pre></td></tr></table></figure>

<h2 id="静态成员、常成员"><a href="#静态成员、常成员" class="headerlink" title="静态成员、常成员"></a>静态成员、常成员</h2><h3 id="静态成员变量："><a href="#静态成员变量：" class="headerlink" title="静态成员变量："></a>静态成员变量：</h3><ul>
<li><p>我们不能把静态成员的初始化放置在类的定义中，它是所有对象共有的</p>
</li>
<li><p>所以应该再类内声明 static int a;</p>
</li>
<li><p>在类外定义 int A::a=0;</p>
</li>
</ul>
<h3 id="静态成员函数："><a href="#静态成员函数：" class="headerlink" title="静态成员函数："></a>静态成员函数：</h3><ul>
<li><p>静态成员函数没有 this 指针，且只能访问静态成员（包括静态成员变量和静态成员函数）</p>
</li>
<li><p>静态成员函数即使在类对象不存在的情况下也能被调用</p>
</li>
</ul>
<h3 id="类中特殊成员变量的初始化问题："><a href="#类中特殊成员变量的初始化问题：" class="headerlink" title="类中特殊成员变量的初始化问题："></a>类中特殊成员变量的初始化问题：</h3><ul>
<li>常量变量：必须通过构造函数参数列表进行初始化。</li>
<li>引用变量：必须通过构造函数参数列表进行初始化。</li>
<li>普通静态变量：要在类外通过”::”初始化。</li>
<li>静态整型常量：可以直接在定义的时候初始化。</li>
<li>静态非整型常量：不能直接在定义的时候初始化。要在类外通过”::”初始化。</li>
</ul>
<h3 id="常成员变量"><a href="#常成员变量" class="headerlink" title="常成员变量"></a>常成员变量</h3><ul>
<li>一经初始化就不能再改变,并且只能通过初始化列表初始</li>
</ul>
<h3 id="常成员函数-常对象"><a href="#常成员函数-常对象" class="headerlink" title="常成员函数/常对象"></a>常成员函数/常对象</h3><ul>
<li>常对象里面的成员变量都不能改变，所以只能用常成员函数</li>
<li>常成员函数只能修改常成员变量，调用同类的常成员函数</li>
<li>不要误认为常对象中的成员函数都是常成员函数，常对象只保证其所有数据成员的值不被修改。</li>
<li>声明时候要把const加在参数表后边，不能加在前边，否则就是返回值是const类型，实现的时候也要把const加上</li>
</ul>
<h3 id="常成员变量的初始化"><a href="#常成员变量的初始化" class="headerlink" title="常成员变量的初始化"></a>常成员变量的初始化</h3><ul>
<li><p>只能通过初始化列表，构造函数里面相当于赋值了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTestBasic</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//常成员：默认初始化</span></span><br><span class="line">	<span class="built_in">CTestBasic</span>() :<span class="built_in">conNum</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		value = <span class="number">-1</span>;</span><br><span class="line">		pValue = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//常成员：重载初始化</span></span><br><span class="line">	<span class="built_in">CTestBasic</span>(<span class="type">int</span> num ) :<span class="built_in">conNum</span>(num) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//常成员函数：又成为只读函数，不能改变成员变量的值</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getsNum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getcNum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get_scNum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getPointerValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	~<span class="built_in">CTestBasic</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//const成员变量不能在类定义处初始化，[ 只能通过构造函数初始化列表进行 ]，并且必须有构造函数</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> conNum;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象.</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sNum;</span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> <span class="type">static</span>  <span class="type">int</span> scNum = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	<span class="type">int</span>* pValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员类外初始化</span></span><br><span class="line"><span class="type">int</span> CTestBasic::sNum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义也必须包含const 关键字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTestBasic::getsNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> sNum;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTestBasic::getcNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> conNum;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTestBasic::get_scNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> scNum;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTestBasic::getPointerValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*pValue = <span class="number">200</span>;</span><br><span class="line">	<span class="comment">//pValue++; Error: pValue的值不能改变</span></span><br><span class="line">	<span class="keyword">return</span> *pValue;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CTestBasic::~<span class="built_in">CTestBasic</span>()&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="一些常用的类"><a href="#一些常用的类" class="headerlink" title="一些常用的类"></a>一些常用的类</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>​            append() – 在字符串的末尾添加字符</p>
<p>​            find() – 在字符串中查找字符串</p>
<p>​            insert() – 插入字符</p>
<p>​            length() – 返回字符串的长度</p>
<p>​            replace() – 替换字符串</p>
<p>​            substr() – 返回某个子字符串</p>
<p>​            eg. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个string类对象</span></span><br><span class="line">    string http = <span class="string">&quot;www.runoob.com&quot;</span>;</span><br><span class="line">   <span class="comment">//打印字符串长度</span></span><br><span class="line">   cout&lt;&lt;http.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//拼接</span></span><br><span class="line">    http.<span class="built_in">append</span>(<span class="string">&quot;/C++&quot;</span>);</span><br><span class="line">    cout&lt;&lt;http&lt;&lt;endl; <span class="comment">//打印结果为：www.runoob.com/C++</span></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="type">int</span> pos = http.<span class="built_in">find</span>(<span class="string">&quot;/C++&quot;</span>); <span class="comment">//查找&quot;C++&quot;在字符串中的位置</span></span><br><span class="line">    cout&lt;&lt;pos&lt;&lt;endl;</span><br><span class="line">    http.<span class="built_in">replace</span>(pos, <span class="number">4</span>, <span class="string">&quot;&quot;</span>);   <span class="comment">//从位置pos开始，之后的4个字符替换为空，即删除</span></span><br><span class="line">    cout&lt;&lt;http&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//找子串runoob</span></span><br><span class="line">    <span class="type">int</span> first = http.<span class="built_in">find_first_of</span>(<span class="string">&quot;.&quot;</span>); <span class="comment">//从头开始寻找字符&#x27;.&#x27;的位置</span></span><br><span class="line">    <span class="type">int</span> last = http.<span class="built_in">find_last_of</span>(<span class="string">&quot;.&quot;</span>);   <span class="comment">//从尾开始寻找字符&#x27;.&#x27;的位置</span></span><br><span class="line">    cout&lt;&lt;http.<span class="built_in">substr</span>(first<span class="number">+1</span>, last-first<span class="number">-1</span>)&lt;&lt;endl; <span class="comment">//提取&quot;runoob&quot;子串并打印</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>几种输入方法的不同</p>
</li>
<li><p><code>cin</code>:遇到tab 空格 enter都结束</p>
</li>
<li><p><code>cin.getline (str,x)</code> x个字符包括反斜杠0 可以有空格</p>
</li>
</ul>
<p>需要&lt;string&gt;头文件：</p>
<ul>
<li><code>getline(cin,str )</code>可以有空格</li>
<li><code>gets(s)</code>可以有空格</li>
</ul>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a><strong>vector</strong></h3><ul>
<li>动态数组——顺序容器——stack（栈）的上位替代</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li><code>vector&lt;int\&gt; obj</code>          创造了一个vector int 类的obj数组</li>
<li><code>vector&lt;int\&gt; obj(10)</code>    创建一个obj数组，最多容纳10个数据</li>
<li><code>vector&lt;int\&gt; obj(10,3)</code>  创建一个obj数组，初始化10个数据为3</li>
<li><code>vector&lt; vector&lt;int\&gt; \&gt;</code> 二维数组</li>
</ul>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul>
<li><code>begin()</code>,<code>end()</code> 获取首地址与尾地址</li>
<li><code>push_back(m)</code> 在最后插入数据m</li>
<li><code>pop_back()</code> 移除最后的数据</li>
<li><code>back()</code> 返回最后一个数据</li>
<li><code>clear()</code> 清除数据但不回收空间</li>
<li><code>size()</code>,<code>capacity()</code> size是当前容量 capacity是真实最大容量 一般来说相等 但是clear后不等</li>
<li><code>empty()</code> 判断是否为空 空返回1</li>
<li><code>insert(\__position\_\_,x)</code>    在指定位置插入x</li>
<li><code>insert(\__position\_\_,N,x)</code> 从指定位置开始插入N个x</li>
<li><code>erase(\__position\_\_)</code>       删除指定位置的元素</li>
<li><code>erase(\_\_positionBegin\_\_,\__positionEnd\_\_)</code>  删除指定区间内的元素</li>
</ul>
<h4 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 (iterator)"></a>迭代器 (iterator)</h4><ul>
<li><p>遍历方法除了用数组之外还可以用迭代器（iterator）类似于指针</p>
<p>声明：vector&lt;int&gt;::iterator it;</p>
<p>具体方法：<code>for(it=obj.begin();it!=obj.end();it++)    </code></p>
<p>​               <code>cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</code> </p>
</li>
<li><p>迭代器实际上是对“遍历容器”这一操作进行了封装。</p>
<p>在编程中我们往往会用到各种各样的容器，但由于这些容器的底层实现各不相同，所以对他们进行遍历的方法也是不同的。例如，数组使用指针算数就可以遍历，但链表就要在不同节点直接进行跳转。</p>
<p>这是非常不利于代码重用的。例如你有一个简单的查找容器中最小值的函数findMin，如果没有迭代器，那么你就必须定义适用于数组版本的findMin和适用于链表版本的findMin，如果以后有更多容器需要使用findMin，那就只好继续添加重载……而如果每个容器又需要更多的函数例如findMax，sort，那简直就是重载地狱……</p>
<p>我们的救星就是迭代器啦！如果我们将这些遍历容器的操作都封装成迭代器，那么诸如findMin一类的算法就都可以针对迭代器编程而不是针对具体容器编程，工作量一下子就少了很多！</p>
<p>至于指针，由于指针也可以用来遍历容器(数组)，所以指针也可是算是迭代器的一种。但是指针还有其他功能，并不只局限于遍历数组。因为使用指针变量数组的操作太深入人心，c++stl中的迭代器就是刻意仿照指针来设计接口的</p>
</li>
</ul>
<h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43899069/article/details/104450000">algorithm头文件函数全集——史上最全，最贴心_算法头文件_来老铁干了这碗代码的博客-CSDN博客</a></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="type">const</span>&amp; <span class="title">Max</span> <span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b:a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">39</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(i, j): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(i, j) &lt;&lt; endl; </span><br><span class="line">    <span class="type">double</span> f1 = <span class="number">13.5</span>; </span><br><span class="line">    <span class="type">double</span> f2 = <span class="number">20.7</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(f1, f2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(f1, f2) &lt;&lt; endl; </span><br><span class="line">    string s1 = <span class="string">&quot;Hello&quot;</span>; </span><br><span class="line">    string s2 = <span class="string">&quot;World&quot;</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(s1, s2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(s1, s2) &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">Max(i, j): 39</span><br><span class="line">Max(f1, f2): 20.7</span><br><span class="line">Max(s1, s2): World</span><br></pre></td></tr></table></figure>



<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Op</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">peocess</span><span class="params">(T v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v * v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Op&lt;<span class="type">int</span>&gt; opInt;</span><br><span class="line">    Op&lt;<span class="type">double</span>&gt; opDouble;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5 * 5 = &quot;</span> &lt;&lt; opInt.<span class="built_in">peocess</span>(<span class="number">5</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;0.5 * 0.5 = &quot;</span> &lt;&lt; opDouble.<span class="built_in">peocess</span>(<span class="number">0.5</span>) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<p><strong>函数模板可以重载，只要它们的形参表不同即可。</strong></p>
<h3 id="C-中-typename-和-class-的区别"><a href="#C-中-typename-和-class-的区别" class="headerlink" title="C++ 中 typename 和 class 的区别"></a>C++ 中 typename 和 class 的区别</h3><p>在 C++ Template 中很多地方都用到了 typename 与 class 这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢?</p>
<p>相信学习 C++ 的人对 class 这个关键字都非常明白，class 用于定义类，在模板引入 c++ 后，最初定义模板的方法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;......</span><br></pre></td></tr></table></figure>

<p>这里 class 关键字表明T是一个类型，后来为了避免 class 在这两个地方的使用可能给人带来混淆，所以引入了 typename 这个关键字，它的作用同 class 一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename</span><br><span class="line">T&gt;......</span><br></pre></td></tr></table></figure>

<p>在模板定义语法中关键字 class 与 typename 的作用完全一样。</p>
<p>typename 难道仅仅在模板定义中起作用吗？其实不是这样，typename 另外一个作用为：使用嵌套依赖类型(nested depended name)，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span>：</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> LengthType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyMethod</span><span class="params">( T myarr )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> T::LengthType LengthType; </span><br><span class="line">    LengthType length = myarr.GetLength; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候 typename 的作用就是告诉 c++ 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候<u>如果前面没有 typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数)</u>，所以编译不能够通过。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="类指针"><a href="#类指针" class="headerlink" title="类指针"></a>类指针</h3><ul>
<li><code>Student *b = new Student；</code>在定义b这个指针变量的时候并没有分配<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>，只有执行new后才会分配内存，且为内存堆。是个永久变量,除非你释放它</li>
<li>是一个内存地址值，指向内存中存放的类对象（包括一些成员变量赋值；类指针可以指向多个不同的对象，这就是多态）</li>
<li>指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数；</li>
</ul>
<h3 id="常指针"><a href="#常指针" class="headerlink" title="常指针"></a>常指针</h3><h4 id="指向-常对象的指针-，指向-对象的常指针"><a href="#指向-常对象的指针-，指向-对象的常指针" class="headerlink" title="指向==常对象的指针==，指向==对象的常指针=="></a>指向==常对象的指针==，指向==对象的常指针==</h4><ul>
<li>```c++<br>class A{<pre><code>A *p0;              //指向对象的指针
const A *p1; //指向常对象的指针，指向常对象的指针只能是这种指针,不能通过此类指针修改A的数据
A *const p2; //指向对象的常指针，p是指针常量，不能改变p的值
    /*主要看const修饰谁，const修饰指针的指向那就是指向常量的指针
</code></pre>
const修饰指针本身*/<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 向上造型（Upcast)</span><br><span class="line"></span><br><span class="line">在C++中，把子类的对象当做父类对象看待，就称为”向上造型“  (upcast)。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class manager: pubilc employee</span><br><span class="line">&#123;</span><br><span class="line">manager();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">manager pett;</span><br><span class="line"></span><br><span class="line">employee *ep = &amp;pett;   //就是upcast</span><br><span class="line"></span><br><span class="line">employee &amp;ep = pett;   //也是upcast</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">把父类的对象当做子类来看待，称为 downcast.</span><br><span class="line"></span><br><span class="line">employee mob;</span><br><span class="line"></span><br><span class="line">manager *lowe = &amp;mob;   //downcast, 将父类对象转换成子类对象</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：向上造型是安全的，向下造型是有风险的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/03/C++%20STL%20Container/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/03/C++%20STL%20Container/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-03 21:19:50" itemprop="dateCreated datePublished" datetime="2025-05-03T21:19:50+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-14 21:28:06" itemprop="dateModified" datetime="2024-01-14T21:28:06+08:00">2024-01-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/542115773">C++ STL 十六大容器 —— 底层原理与特性分析 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/564057584">C++STL【容器】详解 （全站最详细） - 知乎 (zhihu.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/03/%E7%89%A9%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E6%A6%82%E5%86%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/03/%E7%89%A9%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E6%A6%82%E5%86%B5/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-03 21:19:32 / 修改时间：21:19:00" itemprop="dateCreated datePublished" datetime="2025-05-03T21:19:32+08:00">2025-05-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/331782286">物联网专业好就业吗？ - 知乎 (zhihu.com)</a></li>
</ul>
<p>物联网行业很有前景，但不代表<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%89%A9%E8%81%94%E7%BD%91%E4%B8%93%E4%B8%9A&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2767766898%7D">物联网专业</a>好，两者不是一码事。</p>
<p>从实际情况看，物联网不应该也没办法成为一个具体的专业。</p>
<p>物联网涵盖的内容太多，许多大学在本科开设物联网专业确实有点坑。</p>
<p>物联网和人工智能和金融很像，没有具体的、统一的概念，没有具体的指向。就像一个金融业人士自我介绍，如果是对非业内人士一般就说我是做金融的，对业内人士一般会说我是做量化的、做风头的、做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%A7%81%E5%8B%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%223041148568%22%7D">私募</a>的、做基金的、做行研的、做柜员的、做大堂经理、做理财的、做风控的……</p>
<p>人工智能也是这样，对非业内人士一般就说我是做人工智能的的，对业内人士一般会说做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2767766898%7D">算法优化</a>、做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%BF%90%E7%AD%B9%E6%8E%A7%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">运筹控制</a>、做计算机<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2915052959%7D">神经网络</a>、做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">自然语言处理</a>（比如语言识别、自动翻译）、做机器学习（深度学习）、做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BD%B1%E5%83%8F%E5%AD%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">计算机影像学</a>（比如人脸、虹膜和指纹识别）……</p>
<p>物联网也是如此，对非业内人士一般就说我是做物联网的，对业内人士一般会说做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2767766898%7D">嵌入式开发</a>、做信号处理、做传感技术、做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2767766898%7D">网络技术</a>、做RFID技术……</p>
<p>所以物联网能包含的范围太大，而且作为一项新兴科技是不断变化和延伸的，根本不是固有的、静态的。以上任何一个方向、岗位都是博大精深探索无止境的，跟很多岗位都是有密切关系的，很多专业都可以从事的。</p>
<p>所以这些工作根本不是你学了物联网就可以做的，学物联网和做物联网是两码事，学很多专业都可以做物联网，学物联网的反而因为学的多而杂不知道怎么定位自己了。比如你学<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%94%B5%E5%AD%90%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">电子科学与技术</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">电子信息科学与技术</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">网络工程</a>、嵌入式开发、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2915052959%7D">信息工程</a>（信息技术）、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2915052959%7D">电子信息工程</a>、电波传导和天线、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%94%B5%E7%A3%81%E5%9C%BA%E4%B8%8E%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">电磁场与无线技术</a>、自动化都可以从事物联网相关工作，毕竟物联网的范围太大了，涉及的专业、行业、岗位、工种太多了。</p>
<p>一些儿可行性建议：</p>
<p><strong>1.明确正确的技术观</strong>，物联网是一个行业，而不是一个专业。学好物联网里任何一项技术，都可以独当一面，迅速实现个人<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BB%B7%E5%80%BC%E7%A7%AF%E7%B4%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3024228794%7D">价值积累</a>。如果贪多贪快，除了给自己带来无尽的失望和打击，没什么好处。</p>
<p><strong>2.明确正确的发展方向</strong>，物联网涉及软硬件、互联网、App等多个领域，作为个人而言，只可能精其一样。如果是做硬件，那就好好学数电模电、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%BA%94%E7%94%A8%E7%94%B5%E8%B7%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3024228794%7D">应用电路</a>、布线画板、传感器特性等等。如果是做软件，明确方向，一般建议本科阶段学好<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%8D%95%E7%89%87%E6%9C%BA&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2915052959%7D">单片机</a>编程、熟悉一两种传感器或应用，做一两款小产品即可。毕业后，可逐步过渡，学会和其他工程师配合，学会<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%BB%84%E7%BD%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3024228794%7D">组网</a>应用，多出作品练手。</p>
<p><strong>3.实践大于理论</strong>，学物联网或者嵌入式一定要勤上手，多出作品。多出作品，不仅可以增长技术能力、了解物联网构架，最重要的是可以提高自信心。人与人的区别，大部分都在教育，而教育成功与否，自信是非常重要的评估法则。当然，由于物联网一般都是系统产品，建议学习者可以基于成熟的构架去做产品，这样容易成功做出完整产品。</p>
<p><strong>4.毕业后，尽量不要去初创公司</strong>，一定要去中型企业或大企业的核心团队，哪怕打杂都行。无论未来是打算做市场还是做技术，一定要记得毕业招工作的时候，要想办法进企业的核心研发团队，大公司进不了，就进小一点的，再进不了，就再小一点。可能有人会问，人家不一定要我啊。对，人家不一定要你，你本科期间作出的物联网作品，就是敲门砖。</p>
<p><strong>5. 就业后，不要急于成功，闷下心思，跟着团队技术带头人做技术</strong>。有什么做什么，尽多培养不同领域的应用，多结实靠谱的技术朋友。三五年后，某一天，你会发现你自己有技术、有团队，可以做任何产品的时候，你的路也会宽阔起来。</p>
<p>人才有两种，一种是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%BA%94%E7%94%A8%E5%9E%8B%E4%BA%BA%E6%89%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2767766898%7D">应用型人才</a>，把各种技术结合起来，组装成一样东西解决某个问题：例如硬件方面，第一境界是使用各种模块接线；第二境界是使用万用板自己焊接；第三境界是自己画电路图和PCB图打板；软件方面，第一境界，抄别人的代码；第二境界，移植别人的代码然后修改；第三境界，调用库的代码，如果没有就抄；第四境界，熟知各种库的API，自己写代码；应用型人才找工作是最方便的，大公司小公司都会要，只要老板请你做并你愿意做，就会给你开工资。</p>
<p>第二种是是理论型人才，理论知识非常强，数学非常棒，使用<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2767766898%7D">仿真软件</a>验证了一遍，还会拿纸和笔自己再算一遍。一般这样人才不是考研就是去国企等大型企业或<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%A0%94%E7%A9%B6%E6%89%80&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2915052959%7D">研究所</a>从事理论性非常强的工作，比如算法、 <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E9%AB%98%E9%A2%91%E7%94%B5%E8%B7%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3019505700%7D">高频电路</a>、芯片研发、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">信号处理</a>等。</p>
<p>物联网的真正技术，大学是学不完的，它是一个庞大的体系，研究生的话会细分方向，让你更加清晰自己在做什么。大学学习的大多数理论知识，一定要私下多多学点儿东西，没有坏处。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/551003511">物联网工程以后就业前景怎么样? - 知乎 (zhihu.com)</a></li>
</ul>
<p>就业前景很好，跟计算机专业的就业前景差不多。</p>
<p>可以从事纯硬件工作，比如画PCB电路板，画<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%8E%9F%E7%90%86%E5%9B%BE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%222654139657%22%7D">原理图</a>等。可以从事纯软件工作，比如做网页，做APP等。还可以从事嵌入式行业，嵌入式行业分类很多，我所熟悉的是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%222654139657%22%7D">嵌入式软件工程师</a>，该类工程师不仅需要懂硬件原理图，还需要会编程，编写程序来操作硬件。</p>
<p>总之，选<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%89%A9%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%222654139657%22%7D">物联网工程</a>专业，可以从事的行业很多，并不用害怕找不到工作。希望对题主有所帮助。</p>
<p>其实一个行业的前景不代表个人的前景，一个人在这个行业里面发展的怎么样，能走多远看的是个人能力和付出了多少努力。</p>
<p>但是物联网这个领域本身还是可以的，现在万物互联，发展肯定是可以的。</p>
<p>唯一的问题是大学里面学的知识比较乱，也比较基础，加上物联网的市场需求还没有那么高，所以在找工作的时候机会少一些。</p>
<p>物联网也算是计算机的相关专业，你可以选择一门编程语言深入学习之后就业的。</p>
<p>这么跟你说吧，物联网是一个行业不是一个专业，是行业就有很多岗位，所以物联网找工作不上不下的，软件有软工，硬件有电气，学的东西太杂乱，好像什么都会一点，但多数企业要的是一个方面专精的，如果真想读物联网一定要大一就确定一门语言去学精他，真不好找工作</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/64290050">各位前辈，请问一下为什么有的人说物联网工程是个坑，学的杂而不精，然而它的就业平均薪酬还那么高呢？ - 知乎 (zhihu.com)</a></li>
</ul>
<p>简答：物联网工程是坑，行业平均薪资也确实有竞争力</p>
<p>原因：物联网工程其实也属于工程技术，只是它属于近代技术广泛应用，你去学这个。</p>
<p>打个比方你要搞特斯拉，其实这玩意并没有啥高精尖的技术，大部分还是原来传统车积累下来的。真正变更的是类似特斯拉自动驾驶以及电池管理技术：对比物联网中云技术以及射频技术。</p>
<p>如果你在物联网行业，并没有负责核心技术抑或不能有独特竞争力，那么与其他行业没有太多变化。只是公司如果发展好，你的待遇可能会跟上。</p>
<p>现在物联网行业比传统企业待遇个人觉得是会好一点，因为缺口稍微大一点。毕竟搞智能硬件的需要一批新人才，也比传统硬件复杂一点。</p>
<p>而且物联网技术人员是跟互联网大厂抢人，能搞云架构，云安全，语音，嵌入式，前后端这些哪些不是本来就高待遇。</p>
<p>认清物联网本质，这个问题就好理解了。</p>
<p>谢邀，15年某211物联网毕业生，女生，同班同学，包括上一届学长学姐，没有说哪个毕业后是以物联网相关岗位进去工作的，要么硬件工程师要么软件，只要有一项精通的，进去做技术之后再慢慢转，而且国内大部分都是打着物联网的旗号该干嘛还是干嘛，真正做的好的就是小米智能家居，据我所知，没有应届生能进得去，都是个行业的大牛，加油吧</p>
<p>大四二本物联网工程在读，这就是个通信软硬件杂交专业，还是不建议你选择这个专业，目前我们班44人就业选择：Java、C++、前端、测试、运维、嵌入式、大数据、Android，射频工程师，你可以看出就业方向五花八门，但都是互联网计算机岗位，所以薪资还是不错的。这个专业怎么说呢。你只要不是太划水。懂点物联网知识，对于你找你自己选择的方向很有帮助。因为物联网工程归根究底还是属于工科计算机学科，算科班。我自己是选择了Java，拿了3，4个工业软件和物联网方向公司的Java offer</p>
<p>16年电子信息工程专业学生，19年开始北漂，目前在做数字智能化的相关业务。</p>
<p>当时我们的系叫做计算机科学与技术专业，然后分三个通信工程，物联网，和电信。然后上了半学期大家觉得都挺坑的，课程很难且不专一，一开始我认为我是一个很喜欢创造的人，我想借此学习很多知识然后去做一个什么事情，但是我被这一堆课程以及每周日一整天的实验课给干趴下了，到大三还有实验课。然后成绩一般，也少了跟老师做项目的机会，我记得当时系里面有一个电脑鼠竞速比赛的项目，就是一个电子老鼠跑迷宫。算是国际上相对知名的智能电子开发的比赛了。然后很多同学都参与了一开始学校的内选，但是物联的队伍就很突出。</p>
<p>他们的队伍有几个特点，你问的所谓杂而不精，其实在大多数时候，杂与精的距离没那么远，而且一个团队大家可以相互配合，你清楚所有的链路之后就可以衔接各位在各方面有突出的队员去实现一个目标。</p>
<p>而且真正在毕业之后还在做这一行的同学，他们的薪酬影响因素根本就不是专业什么的，就他们的技术能力，对于技术开发的热情，学校时期就一屁股的参赛奖项，他的工资就低不了，老板太清楚什么事人才了。</p>
<p>这些长期坚持的兄弟要么之后自己创业搞个小队伍自己创造去了，要么一早靠着奖项进大厂深造去了，去其他厂的时候面试的时候知识面也足够应对大多数问题了，凭啥薪资不高。</p>
<p>我一开始去干市场，干媒体，最后回到这个行业做解决方案的时候，才后悔，当初要是认真学点技术，现在焊面包板一定比写PPT有趣多了。</p>
<p>选专业什么的不用想那么多，如果奔着薪资去的，那努力就好。</p>
<p>各位学弟，看看up“01星球”的吧，没必要焦虑具体的专业是什么，尽管学习内容有偏差，说实话，计算机类包括计科和互联网在内的许多细分专业，但大学的课都比较水（名校除外），其核心是围绕计算机4大件展开的，只不过有些具体的专业内容更深入（比如计科要学硬件，软件工程主要是软件，很少设计到硬件，除非以后你去人家公司做别的复杂点的项目)，其实本科选什么专业差别对你以后所想去的具体岗位影响不大，关键是看你们在学校有没有好好“自学”（尽早出去实习给自己接触社会的机会）.好好学习热爱技术，把技术学精湛，管你什么专业，只要你给企业带来价值，走什么技术岗位人家都要你的</p>
<p>后端springboot springcloud netty，数据库Redis MySQL influxdb，运维docker Jenkins，嵌入式 rtthread stm32， 4g模组 蓝牙WiFi模组，电源设计，还能画下原理图和pcb，阁下又如何应对呢？</p>
<p>真正在班上拔尖的同学，参加比赛，研究代码年年拿奖学金。软硬件虽说不特别牛逼，但是做项目刚刚好，学完Linux环境编译，<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2630753191%7D">多线程</a>。真的，每次做成功一个属于自己的项目真的特别开心。特别是在硬件和软件结合起来用。</p>
<p>真正看的还是自学能力，难道到了计科就完美了吗，不计科还要拉跨，我有接触过计科的教学大纲和她们也有朋友，毕竟之前还是一个宿舍，换校区就不是了。计科也要学硬件和软件。我们的大纲还重合了很多，只是在某些硬件上更加仔细。<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%89%A9%E7%90%86%E7%BD%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2630753191%7D">物理网</a>工程的话，因为要上云服务，所以还要学习Java，Javaweb，Python。不做网页，所以这些不用特别专业。更加注重是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%BC%80%E5%8F%91%E7%89%88&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2630753191%7D">开发版</a>驱动和传感器方面，是我们核心专业课。还有物联网控制技术，各种组网ZIgbee，wife，蓝牙，也是重点。</p>
<p>往下阅读之前，先问问自己，BATD四大厂，工农建交四大行，快手华为爱奇艺，京东网易拼夕夕，还有哔哩哔哩和滴滴……这些大厂都投完简历了么？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/03/S.M.A.R.T/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/03/S.M.A.R.T/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-03 21:19:32" itemprop="dateCreated datePublished" datetime="2025-05-03T21:19:32+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-03 23:45:30" itemprop="dateModified" datetime="2024-06-03T23:45:30+08:00">2024-06-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、SMART概述"><a href="#一、SMART概述" class="headerlink" title="一、SMART概述"></a>一<strong>、SMART概述</strong></h2><p><a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/yingpan/">硬盘</a>的故障一般分为两种：可预测的（predictable）和不可预测的（unpredictable）。后者偶而会发生，也没有办法去预防它，例如芯片突然失效，机械撞击等。但像电机轴承磨损、盘片磁介质性能下降等都属于可预测的情况，可以在在几天甚至几星期前就发现这种不正常的现象。如果发生这种问题，SMART功能会在开机时响起警报，至少让使用者有足够的时间把重要资料转移到其它储存设备上。</p>
<p>最早期的硬盘监控技术起源于1992年，IBM在AS/400计算机的IBM 0662 SCSI 2代硬盘驱动器中使用了后来被命名为Predictive Failure Analysis（故障预警分析技术）的监控技术，它是通过在固件中测量几个重要的硬盘安全参数和评估他们的情况，然后由监控软件得出两种结果：“硬盘安全”或“不久后会发生故障”。</p>
<p>不久，当时的微机制造商康柏和硬盘制造商希捷、昆腾以及康纳共同提出了名为IntelliSafe的类似技术。通过该技术，硬盘可以测量自身的的健康指标并将参量值传送给操作系统和用户的监控软件中，每个硬盘生产商有权决定哪些指标需要被监控以及设定它们的安全阈值。</p>
<p>1995年，康柏公司将该技术方案提交到Small Form Factor(SFF)委员会进行标准化，该方案得到IBM、希捷、昆腾、康纳和西部数据的支持，1996年6月进行了1.3版的修正，正式更名为S.M.A.R.T.（Self-Monitoring Analysis And Reporting Technology），全称就是“自我检测分析与报告技术”，成为一种自动监控硬盘驱动器完好状况和报告潜在问题的技术标准。</p>
<p>作为行业规范，SMART规定了硬盘制造厂商应遵循的标准，满足SMART标准的条件主要包括：</p>
<p>1）在设备制造期间完成SMART需要的各项参数、属性的设定；</p>
<p>2）在特定系统平台下，能够正常使用SMART；通过BIOS检测，能够识别设备是否支持SMART并可显示相关信息，而且能辨别有效和失效的SMART信息；</p>
<p>3）允许用户自由开启和关闭SMART功能；</p>
<p>4）在用户使用过程中，能提供SMART的各项有效信息，确定设备的工作状态，并能发出相应的修正指令或警告。在硬盘及操作系统都支持SMART技术并且开启的情况下，若硬盘状态不良，SMART技术能够在屏幕上显示英文警告信息：“WARNING：IMMEDIATLY BACKUP YOUR DATA AND REPLACE YOUR HARD DISK DRIVE，A FAILURE MAY BE IMMINENT．”(警告：立刻备份你的数据并更换硬盘，硬盘可能失效。)</p>
<p>SMART功能不断从硬盘上的各个传感器收集信息，并把信息保存在硬盘的系统保留区(service area)内，这个区域一般位于硬盘0物理面的最前面几十个物理磁道，由厂商写入相关的内部管理程序。这里除了SMART信息表外还包括低级格式化程序、加密解密程序、自监控程序、自动修复程序等。用户使用的监测软件通过名为“SMART Return Status”的命令（命令代码为：B0h）对SMART信息进行读取，且不允许最终用户对信息进行修改。</p>
<h2 id="二、SMART的ID代码"><a href="#二、SMART的ID代码" class="headerlink" title="二、SMART的ID代码"></a><strong>二、SMART的ID代码</strong></h2><p>硬盘SMART检测的ID代码以两位十六进制数表示（括号里对应的是十进制数）硬盘的各项检测参数。目前，各硬盘制造商的绝大部分SMART ID代码所代表的参数含义是一致的，但厂商也可以根据需要使用不同的ID代码，或者根据检测项目的多少增减ID代码。一般来说，以下这些检测项是必需的：</p>
<p>01（001） 底层数据读取错误率 Raw Read Error Rate</p>
<p>04（004） 启动/停止计数 Start/Stop Count</p>
<p>05（005） 重映射扇区数 Relocated Sector Count</p>
<p>09（009） 通电时间累计 Power-On Time Count (POH)</p>
<p>0A（010） 主轴起旋重试次数（即硬盘主轴电机启动重试次数） Spin up Retry Count</p>
<p>0B（011） 磁盘校准重试次数 Calibration Retry Count</p>
<p>0C（012） 磁盘通电次数 Power Cycle Count</p>
<p>C2（194） 温度 Temperature</p>
<p>C7（199） ULTRA DMA奇偶校验错误率 ULTRA ATA CRC Error Rate</p>
<p>C8（200） 写错误率 Write Error Rate</p>
<h2 id="三、SMART的描述（Description）"><a href="#三、SMART的描述（Description）" class="headerlink" title="三、SMART的描述（Description）"></a><strong>三、SMART的描述（Description）</strong></h2><p>描述，即某一检测项目的名称，是ID代码的文字解释。对用户而言，不仅要了解描述的含义，重要的是要了解各参数的值如“临界值”、“最差值”的定义，“当前值”与“数据值”的区别等，才能对自己的硬盘状态有一个基本了解。</p>
<h2 id="四、SMART的值"><a href="#四、SMART的值" class="headerlink" title="四、SMART的值"></a><strong>四、SMART的值</strong></h2><h3 id="1、临界值（Threshold）"><a href="#1、临界值（Threshold）" class="headerlink" title="1、临界值（Threshold）"></a><strong>1、临界值（Threshold）</strong></h3><p>临界值是硬盘厂商指定的表示某一项目可靠性的门限值，也称阈值，它通过特定公式计算而得。如果某个参数的当前值接近了临界值，就意味着硬盘将变得不可靠，可能导致数据丢失或者硬盘故障。由于临界值是硬盘厂商根据自己产品特性而确定的，因此用厂商提供的专用检测软件往往会跟Windows下检测软件的检测结果有较大出入。</p>
<p>以参数Raw Read Error Rate（底层数据读取错误率）为例：某型硬盘对该参数的计算公式为“10×log10（主机和硬盘之间所传输数据的扇区数）×512×8／重读的扇区数”。其中“512×8”是把扇区数转化为所传输的数据位(bits)，这个值只在所传输的数据位处于1010～1012范围时才作计算，而当Windows系统启动后，主机和硬盘之间所传输的数据扇区大于或等于1012时，此值将重新复位，所以有些值在不同的操作环境、不同检测程序下时会有较大的波动。</p>
<h3 id="2、当前值（Normalized-value）"><a href="#2、当前值（Normalized-value）" class="headerlink" title="2、当前值（Normalized value）"></a><strong>2、当前值（Normalized value）</strong></h3><p>当前值是各ID项在硬盘运行时根据实测数据通过公式计算的结果，计算公式由硬盘厂家自定。</p>
<p>硬盘出厂时各ID项目都有一个预设的最大正常值，也即出厂值，这个预设的依据及计算方法为硬盘厂家保密，不同型号的硬盘都不同，最大正常值通常为100或200或253，新硬盘刚开始使用时显示的当前值可以认为是预设的最大正常值（有些ID项如温度等除外）。随着使用损耗或出现错误，当前值会根据实测数据而不断刷新并逐渐减小。因此，当前值接近临界值就意味着硬盘寿命的减少，发生故障的可能性增大，所以当前值也是判定硬盘健康状态或推测寿命的依据之一。</p>
<h3 id="3、最差值（Worst）"><a href="#3、最差值（Worst）" class="headerlink" title="3、最差值（Worst）"></a><strong>3、最差值（Worst）</strong></h3><p>最差值是硬盘运行时各ID项曾出现过的最大的非正常值。</p>
<p>最差值是对硬盘运行中某项数据变劣的峰值统计，该数值也会不断刷新。通常，最差值与当前值是相等的，如果最差值出现较大的波动（小于当前值），表明硬盘曾出现错误或曾经历过恶劣的工作环境（如温度）。</p>
<h3 id="4、数据值（Data或Raw-value）"><a href="#4、数据值（Data或Raw-value）" class="headerlink" title="4、数据值（Data或Raw value）"></a><strong>4、数据值（Data或Raw value）</strong></h3><p>数据值是硬盘运行时各项参数的实测值，大部分SMART工具以十进制显示数据。</p>
<p>数据值代表的意义随参数而定，大致可以分为三类：</p>
<p>1）数据值并不直接反映硬盘状态，必须经过硬盘内置的计算公式换算成当前值才能得出结果；</p>
<p>2）数据值是直接累计的，如Start/Stop Count（启动/停止计数）的数据是50，即表示该硬盘从出厂到现在累计启停了50次；</p>
<p>3）有些参数的数据是即时数，如Temperature（温度）的数据值是44，表示硬盘的当前温度是44℃。</p>
<p>因此，有些参数直接查看数据也能大致了解硬盘目前的工作状态。</p>
<h2 id="五、状态-Status"><a href="#五、状态-Status" class="headerlink" title="五、状态(Status)"></a><strong>五、状态(Status)</strong></h2><p>硬盘的每项SMART信息中都有一个临界值（阈值），不同硬盘的临界值是不同的，SMART针对各项的当前值、最差值和临界值的比较结果以及数据值进行分析后，提供硬盘当前的评估状态，也是我们直观判断硬盘健康状态的重要信息。根据SMART的规定，状态一般有正常、警告、故障或错误三种状态。</p>
<p>SMART判定这三个状态与SMART的 Pre-failure/advisory BIT（预测错误/发现位）参数的赋值密切相关，当Pre-failure/advisory BIT=0，并且当前值、最差值远大于临界值的情况下，为正常标志。当Pre-failure/advisory BIT=0，并且当前值、最差值大于但接近临界值时，为警告标志；当Pre-failure/advisory BIT=1，并且当前值、最差值小于临界值时，为故障或错误标志。</p>
<h2 id="六、SMART参数详解"><a href="#六、SMART参数详解" class="headerlink" title="六、SMART参数详解"></a><strong>六、SMART参数详解</strong></h2><p>一般情况下，用户只要观察当前值、最差值和临界值的关系，并注意状态提示信息即可大致了解硬盘的健康状况。下面简单介绍各参数的含义，以红色标出的项目是寿命关键项，蓝色为<a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/gutaiyingpan/">固态硬盘</a>（SSD）特有的项目。</p>
<p>在基于闪存的固态硬盘中，存储单元分为两类：SLC（Single Layer Cell，单层单元）和MLC（Multi-Level Cell，多层单元）。SLC成本高、容量小、但读写速度快，可靠性高，擦写次数可高达100000次，比MLC高10倍。而MLC虽容量大、成本低，但其性能大幅落后于SLC。为了保证MLC的寿命，控制芯片还要有智能磨损平衡技术算法，使每个存储单元的写入次数可以平均分摊，以达到100万小时的平均无故障时间。因此固态硬盘有许多SMART参数是<a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/jixieyingpan/">机械硬盘</a>所没有的，如存储单元的擦写次数、备用块统计等等，这些新增项大都由厂家自定义，有些尚无详细的解释，有些解释也未必准确，此处也只是仅供参考。下面凡未注明厂商的固态硬盘特有的项均为SandForce主控芯片特有的，其它厂商各自单独注明。</p>
<h3 id="01（001）底层数据读取错误率-Raw-Read-Error-Rate"><a href="#01（001）底层数据读取错误率-Raw-Read-Error-Rate" class="headerlink" title="01（001）底层数据读取错误率 Raw Read Error Rate"></a><strong>01（001）底层数据读取错误率 Raw Read Error Rate</strong></h3><p>数据为0或任意值，当前值应远大于与临界值。</p>
<p>底层数据读取错误率是磁头从磁盘表面读取数据时出现的错误，对某些硬盘来说，大于0的数据表明磁盘表面或者读写磁头发生问题，如介质损伤、磁头污染、磁头共振等等。不过对希捷硬盘来说，许多硬盘的这一项会有很大的数据量，这不代表有任何问题，主要是看当前值下降的程度。</p>
<p>在固态硬盘中，此项的数据值包含了可校正的错误与不可校正的RAISE错误（UECC＋URAISE）。</p>
<p>注：RAISE（Redundant Array of Independent Silicon Elements）意为独立硅元素冗余阵列，是固态硬盘特有的一种冗余恢复技术，保证内部有类似RAID阵列的数据安全性。</p>
<h3 id="02（002）磁盘读写通量性能-Throughput-Performance"><a href="#02（002）磁盘读写通量性能-Throughput-Performance" class="headerlink" title="02（002）磁盘读写通量性能 Throughput Performance"></a><strong>02（002）磁盘读写通量性能 Throughput Performance</strong></h3><p>此参数表示硬盘的读写通量性能，数据值越大越好。当前值如果偏低或趋近临界值，表示硬盘存在严重的问题，但现在的硬盘通常显示数据值为0或根本不显示此项，一般在进行了人工脱机SMART测试后才会有数据量。</p>
<h3 id="03（003）主轴起旋时间-Spin-Up-Time"><a href="#03（003）主轴起旋时间-Spin-Up-Time" class="headerlink" title="03（003）主轴起旋时间 Spin Up Time"></a><strong>03（003）主轴起旋时间 Spin Up Time</strong></h3><p>主轴起旋时间就是主轴电机从启动至达到额定转速所用的时间，数据值直接显示时间，单位为毫秒或者秒，因此数据值越小越好。不过对于正常硬盘来说，这一项仅仅是一个参考值，硬盘每次的启动时间都不相同，某次启动的稍慢些也不表示就有问题。</p>
<p>硬盘的主轴电机从启动至达到额定转速大致需要4秒～15秒左右，过长的启动时间说明电机驱动电路或者轴承机构有问题。旦这一参数的数据值在某些型号的硬盘上总是为0，这就要看当前值和最差值来判断了。</p>
<p>对于固态硬盘来说，所有的数据都是保存在半导体集成电路中，没有主轴电机，所以这项没有意义，数据固定为0，当前值固定为100。</p>
<h3 id="04（004）启停计数-Start-Stop-Count"><a href="#04（004）启停计数-Start-Stop-Count" class="headerlink" title="04（004）启停计数 Start/Stop Count"></a><strong>04（004）启停计数 Start/Stop Count</strong></h3><p>这一参数的数据是累计值，表示硬盘主轴电机启动/停止的次数，新硬盘通常只有几次，以后会逐渐增加。系统的某些功能如空闲时关闭硬盘等会使硬盘启动/停止的次数大为增加，在排除定时功能的影响下，过高的启动/停止次数（远大于通电次数0C）暗示硬盘电机及其驱动电路可能有问题。</p>
<p>这个参数的当前值是依据某种公式计算的结果，例如对希捷某硬盘来说临界值为20，当前值是通过公式“100－（启停计数/1024）”计算得出的。若新硬盘的启停计数为0，当前值为100－(0/1024)＝100，随着启停次数的增加，该值不断下降，当启停次数达到81920次时，当前值为100－(81920/1024)＝20，已达到临界值，表示从启停次数来看，该硬盘已达设计寿命，当然这只是个寿命参考值，并不具有确定的指标性。</p>
<p>这一项对于固态硬盘同样没有意义，数据固定为0，当前值固定为100。</p>
<h3 id="05（005）重映射扇区计数-Reallocated-Sectors-Count-退役块计数-Retired-Block-Count"><a href="#05（005）重映射扇区计数-Reallocated-Sectors-Count-退役块计数-Retired-Block-Count" class="headerlink" title="05（005）重映射扇区计数 Reallocated Sectors Count/ 退役块计数 Retired Block Count"></a><strong>05（005）重映射扇区计数 Reallocated Sectors Count/ 退役块计数 Retired Block Count</strong></h3><p>数据应为0，当前值应远大于临界值。</p>
<p>当硬盘的某扇区持续出现读/写/校验错误时，硬盘固件程序会将这个扇区的物理地址加入缺陷表(G-list)，将该地址重新定向到预先保留的备用扇区并将其中的数据一并转移，这就称为重映射。执行重映射操作后的硬盘在Windows常规检测中是无法发现不良扇区的，因其地址已被指向备用扇区，这等于屏蔽了不良扇区。</p>
<p>这项参数的数据值直接表示已经被重映射扇区的数量，当前值则随着数据值的增加而持续下降。当发现此项的数据值不为零时，要密切注意其发展趋势，若能长期保持稳定，则硬盘还可以正常运行；若数据值不断上升，说明不良扇区不断增加，硬盘已处于不稳定状态，应当考虑更换了。如果当前值接近或已到达临界值（此时的数据值并不一定很大，因为不同硬盘保留的备用扇区数并不相同），表示缺陷表已满或备用扇区已用尽，已经失去了重映射功能，再出现不良扇区就会显现出来并直接导致数据丢失。</p>
<p>这一项不仅是硬盘的寿命关键参数，而且重映射扇区的数量也直接影响硬盘的性能，例如某些硬盘会出现数据量很大，但当前值下降不明显的情况，这种硬盘尽管还可正常运行，但也不宜继续使用。因为备用扇区都是位于磁盘尾部（靠近盘片轴心处），大量的使用备用扇区会使寻道时间增加，硬盘性能明显下降。</p>
<p>这个参数在机械硬盘上是非常敏感的，而对于固态硬盘来说同样具有重要意义。闪存的寿命是正态分布的，例如说MLC能写入一万次以上，实际上说的是写入一万次之前不会发生“批量损坏”，但某些单元可能写入几十次就损坏了。换言之，机械硬盘的盘片不会因读写而损坏，出现不良扇区大多与工艺质量相关，而闪存的读写次数则是有限的，因而损坏是正常的。所以固态硬盘在制造时也保留了一定的空间，当某个存储单元出现问题后即把损坏的部分隔离，用好的部分来顶替。这一替换方法和机械硬盘的扇区重映射是一个道理，只不过机械硬盘正常时极少有重映射操作，而对于固态硬盘是经常性的。</p>
<p>在固态硬盘中这一项的数据会随着使用而不断增长，只要增长的速度保持稳定就可以。通常情况下，数据值＝100－（100×被替换块/必需块总数），因此也可以估算出硬盘的剩余寿命。</p>
<p>Intel固态硬盘型号的第十二个字母表示了两种规格，该字母为1表示第一代的50纳米技术的SSD，为2表示第二代的34纳米技术的SSD，如SSDSA2M160G2GN就表示是34nm的SSD。所以参数的查看也有两种情况：</p>
<p>50nm的SSD（一代）要看当前值。这个值初始是100，当出现替换块的时候这个值并不会立即变化，一直到已替换四个块时这个值变为1，之后每增加四个块当前值就＋1。也就是100对应0～3个块，1对应4～7个块，2对应8～11个块……</p>
<p>34nm的SSD（二代）直接查看数据值，数据值直接表示有多少个被替换的块。</p>
<h3 id="06（006）读取通道余量-Read-Channel-Margin"><a href="#06（006）读取通道余量-Read-Channel-Margin" class="headerlink" title="06（006）读取通道余量 Read Channel Margin"></a><strong>06（006）读取通道余量 Read Channel Margin</strong></h3><p>这一项功能不明，现在的硬盘也不显示这一项。</p>
<h3 id="07（007）寻道错误率-Seek-Error-Rate"><a href="#07（007）寻道错误率-Seek-Error-Rate" class="headerlink" title="07（007）寻道错误率 Seek Error Rate"></a><strong>07（007）寻道错误率 Seek Error Rate</strong></h3><p>数据应为0，当前值应远大于与临界值。</p>
<p>这一项表示磁头寻道时的错误率，有众多因素可导致寻道错误率上升，如磁头组件的机械系统、伺服电路有局部问题，盘片表面介质不良，硬盘温度过高等等。</p>
<p>通常此项的数据应为0，但对希捷硬盘来说，即使是新硬盘，这一项也可能有很大的数据量，这不代表有任何问题，还是要看当前值是否下降。</p>
<h3 id="08（008）寻道性能-Seek-Time-Performance"><a href="#08（008）寻道性能-Seek-Time-Performance" class="headerlink" title="08（008）寻道性能 Seek Time Performance"></a><strong>08（008）寻道性能 Seek Time Performance</strong></h3><p>此项表示硬盘寻道操作的平均性能（寻道速度），通常与前一项（寻道错误率）相关联。当前值持续下降标志着磁头组件、寻道电机或伺服电路出现问题，但现在许多硬盘并不显示这一项。</p>
<h3 id="09（009）通电时间累计-Power-On-Time-Count-POH"><a href="#09（009）通电时间累计-Power-On-Time-Count-POH" class="headerlink" title="09（009）通电时间累计 Power-On Time Count (POH)"></a><strong>09（009）通电时间累计 Power-On Time Count (POH)</strong></h3><p>这个参数的含义一目了然，表示硬盘通电的时间，数据值直接累计了设备通电的时长，新硬盘当然应该接近0，但不同硬盘的计数单位有所不同，有以小时计数的，也有以分、秒甚至30秒为单位的，这由磁盘制造商来定义。</p>
<p>这一参数的临界值通常为0，当前值随着硬盘通电时间增加会逐渐下降，接近临界值表明硬盘已接近预计的设计寿命，当然这并不表明硬盘将出现故障或立即报废。参考磁盘制造商给出的该型号硬盘的MTBF（平均无故障时间）值，可以大致估计剩余寿命或故障概率。</p>
<p>对于固态硬盘，要注意“设备优先电源管理功能（device initiated power management，DIPM）”会影响这个统计：如果启用了DIPM，持续通电计数里就不包括睡眠时间；如果关闭了DIPM功能，那么活动、空闲和睡眠三种状态的时间都会被统计在内。</p>
<h3 id="0A（010）主轴起旋重试次数-Spin-up-Retry-Count"><a href="#0A（010）主轴起旋重试次数-Spin-up-Retry-Count" class="headerlink" title="0A（010）主轴起旋重试次数 Spin up Retry Count"></a><strong>0A（010）主轴起旋重试次数 Spin up Retry Count</strong></h3><p>数据应为0，当前值应大于临界值。</p>
<p>主轴起旋重试次数的数据值就是主轴电机尝试重新启动的计数，即主轴电机启动后在规定的时间里未能成功达到额定转速而尝试再次启动的次数。数据量的增加表示电机驱动电路或是机械子系统出现问题，整机供电不足也会导致这一问题。</p>
<h3 id="0B（011）磁头校准重试计数-Calibration-Retry-Count"><a href="#0B（011）磁头校准重试计数-Calibration-Retry-Count" class="headerlink" title="0B（011）磁头校准重试计数 Calibration Retry Count"></a><strong>0B（011）磁头校准重试计数 Calibration Retry Count</strong></h3><p>数据应为0，当前值应远大于与临界值。</p>
<p>硬盘在温度发生变化时，机械部件（特别是盘片）会因热胀冷缩出现形变，因此需要执行磁头校准操作消除误差，有的硬盘还内置了磁头定时校准功能。这一项记录了需要再次校准（通常因上次校准失败）的次数。</p>
<p>这一项的数据量增加，表示电机驱动电路或是机械子系统出现问题，但有些型号的新硬盘也有一定的数据量，并不表示有问题，还要看当前值和最差值。</p>
<h3 id="0C（012）通电周期计数-Power-Cycle-Count"><a href="#0C（012）通电周期计数-Power-Cycle-Count" class="headerlink" title="0C（012）通电周期计数 Power Cycle Count"></a><strong>0C（012）通电周期计数 Power Cycle Count</strong></h3><p>通电周期计数的数据值表示了硬盘通电/断电的次数，即电源开关次数的累计，新硬盘通常只有几次。</p>
<p>这一项与启停计数（04）是有区别的，一般来说，硬盘通电/断电意味着计算机的开机与关机，所以经历一次开关机数据才会加1；而启停计数（04）表示硬盘主轴电机的启动/停止（硬盘在运行时可能多次启停，如系统进入休眠或被设置为空闲多少时间而关闭）。所以大多情况下这个通电/断电的次数会小于启停计数（04）的次数。</p>
<p>通常，硬盘设计的通电次数都很高，如至少5000次，因此这一计数只是寿命参考值，本身不具指标性。</p>
<h3 id="0D（013）软件读取错误率-Soft-Read-Error-Rate"><a href="#0D（013）软件读取错误率-Soft-Read-Error-Rate" class="headerlink" title="0D（013）软件读取错误率 Soft Read Error Rate"></a><strong>0D（013）软件读取错误率 Soft Read Error Rate</strong></h3><p>软件读取错误率也称为可校正的读取误码率，就是报告给操作系统的未经校正的读取错误。数据值越低越好，过高则可能暗示盘片磁介质有问题。</p>
<h3 id="AA（170）坏块增长计数-Grown-Failing-Block-Count（Micron-镁光）"><a href="#AA（170）坏块增长计数-Grown-Failing-Block-Count（Micron-镁光）" class="headerlink" title="AA（170）坏块增长计数 Grown Failing Block Count（Micron 镁光）"></a><strong>AA（170）坏块增长计数 Grown Failing Block Count（Micron 镁光）</strong></h3><p>读写失败的块增长的总数。</p>
<h3 id="AB（171）编程失败块计数-Program-Fail-Block-Count"><a href="#AB（171）编程失败块计数-Program-Fail-Block-Count" class="headerlink" title="AB（171）编程失败块计数 Program Fail Block Count"></a><strong>AB（171）编程失败块计数 Program Fail Block Count</strong></h3><p>Flash编程失败块的数量。</p>
<h3 id="AC（172）擦写失败块计数-Erase-Fail-Block-Count"><a href="#AC（172）擦写失败块计数-Erase-Fail-Block-Count" class="headerlink" title="AC（172）擦写失败块计数 Erase Fail Block Count"></a><strong>AC（172）擦写失败块计数 Erase Fail Block Count</strong></h3><p>擦写失败块的数量。</p>
<h3 id="AD（173）磨损平衡操作次数（平均擦写次数）-Wear-Leveling-Count（Micron-镁光）"><a href="#AD（173）磨损平衡操作次数（平均擦写次数）-Wear-Leveling-Count（Micron-镁光）" class="headerlink" title="AD（173）磨损平衡操作次数（平均擦写次数） / Wear Leveling Count（Micron 镁光）"></a><strong>AD（173）磨损平衡操作次数（平均擦写次数） / Wear Leveling Count（Micron 镁光）</strong></h3><p>所有好块的平均擦写次数。</p>
<p>Flash芯片有写入次数限制，当使用FAT文件系统时，需要频繁地更新文件分配表。如果闪存的某些区域读写过于频繁，就会比其它区域磨损的更快，这将明显缩短整个硬盘的寿命（即便其它区域的擦写次数还远小于最大限制）。所以，如果让整个区域具有均匀的写入量，就可明显延长芯片寿命，这称为磨损均衡措施。</p>
<h3 id="AE（174）意外失电计数-Unexpected-Power-Loss-Count"><a href="#AE（174）意外失电计数-Unexpected-Power-Loss-Count" class="headerlink" title="AE（174）意外失电计数 Unexpected Power Loss Count"></a><strong>AE（174）意外失电计数 Unexpected Power Loss Count</strong></h3><p>硬盘自启用后发生意外断电事件的次数。</p>
<h3 id="B1（177）磨损范围对比值-Wear-Range-Delta"><a href="#B1（177）磨损范围对比值-Wear-Range-Delta" class="headerlink" title="B1（177）磨损范围对比值 Wear Range Delta"></a><strong>B1（177）磨损范围对比值 Wear Range Delta</strong></h3><p>磨损最重的块与磨损最轻的块的磨损百分比之差。</p>
<h3 id="B4（180）未用的备用块计数-Unused-Reserved-Block-Count-Total（惠普）"><a href="#B4（180）未用的备用块计数-Unused-Reserved-Block-Count-Total（惠普）" class="headerlink" title="B4（180）未用的备用块计数 Unused Reserved Block Count Total（惠普）"></a><strong>B4（180）未用的备用块计数 Unused Reserved Block Count Total（惠普）</strong></h3><p>固态硬盘会保留一些容量来准备替换损坏的存储单元，所以可用的预留空间数非常重要。这个参数的当前值表示的是尚未使用的预留的存储单元数量。</p>
<h3 id="B5（181）编程失败计数-Program-Fail-Count"><a href="#B5（181）编程失败计数-Program-Fail-Count" class="headerlink" title="B5（181）编程失败计数 Program Fail Count"></a><strong>B5（181）编程失败计数 Program Fail Count</strong></h3><p>用4个字节显示已编程失败的次数，与（AB）参数相似。</p>
<h3 id="B5（181）非4KB对齐访问数-Non-4k-Aligned-Access（Micron-镁光）"><a href="#B5（181）非4KB对齐访问数-Non-4k-Aligned-Access（Micron-镁光）" class="headerlink" title="B5（181）非4KB对齐访问数 Non-4k Aligned Access（Micron 镁光）"></a><strong>B5（181）非4KB对齐访问数 Non-4k Aligned Access（Micron 镁光）</strong></h3><h3 id="B6（182）擦写失败计数-Erase-Fail-Count"><a href="#B6（182）擦写失败计数-Erase-Fail-Count" class="headerlink" title="B6（182）擦写失败计数 Erase Fail Count"></a><strong>B6（182）擦写失败计数 Erase Fail Count</strong></h3><p>用4个字节显示硬盘自启用后块擦写失败的次数，与（AC）参数相似。</p>
<h3 id="B7（183）串口降速错误计数-SATA-Downshift-Error-Count"><a href="#B7（183）串口降速错误计数-SATA-Downshift-Error-Count" class="headerlink" title="B7（183）串口降速错误计数 SATA Downshift Error Count"></a><strong>B7（183）串口降速错误计数 SATA Downshift Error Count</strong></h3><p>这一项表示了SATA接口速率错误下降的次数。通常硬盘与主板之间的兼容问题会导致SATA传输级别降级运行。</p>
<h3 id="B8（184）I-O错误检测与校正-I-O-Error-Detection-and-Correction（IOEDC）"><a href="#B8（184）I-O错误检测与校正-I-O-Error-Detection-and-Correction（IOEDC）" class="headerlink" title="B8（184）I/O错误检测与校正 I/O Error Detection and Correction（IOEDC）"></a><strong>B8（184）I/O错误检测与校正 I/O Error Detection and Correction（IOEDC）</strong></h3><p>“I/O错误检测与校正”是惠普公司专有的SMART IV技术的一部分，与其他制造商的I/O错误检测和校正架构一样，它记录了数据通过驱动器内部高速缓存RAM传输到主机时的奇偶校验错误数量。</p>
<h3 id="B8（184）点到点错误检测计数-End-to-End-Error-Detection-Count"><a href="#B8（184）点到点错误检测计数-End-to-End-Error-Detection-Count" class="headerlink" title="B8（184）点到点错误检测计数 End to End Error Detection Count"></a><strong>B8（184）点到点错误检测计数 End to End Error Detection Count</strong></h3><p>Intel第二代的34nm固态硬盘有点到点错误检测计数这一项。固态硬盘里有一个LBA（logical block addressing，逻辑块地址）记录，这一项显示了SSD内部逻辑块地址与真实物理地址间映射的出错次数。</p>
<p>B8（184）原始坏块数 Init Bad Block Count（Indilinx芯片）</p>
<p>硬盘出厂时已有的坏块数量。</p>
<h3 id="B9（185）磁头稳定性-Head-Stability（西部数据）"><a href="#B9（185）磁头稳定性-Head-Stability（西部数据）" class="headerlink" title="B9（185）磁头稳定性 Head Stability（西部数据）"></a><strong>B9（185）磁头稳定性 Head Stability（西部数据）</strong></h3><p>意义不明。</p>
<h3 id="BA（186）感应运算振动检测-nduced-Op-Vibration-Detection（西部数据）"><a href="#BA（186）感应运算振动检测-nduced-Op-Vibration-Detection（西部数据）" class="headerlink" title="BA（186）感应运算振动检测 nduced Op-Vibration Detection（西部数据）"></a><strong>BA（186）感应运算振动检测 nduced Op-Vibration Detection（西部数据）</strong></h3><p>意义不明。</p>
<h3 id="BB（187）无法校正的错误-Reported-Uncorrectable-Errors（希捷）"><a href="#BB（187）无法校正的错误-Reported-Uncorrectable-Errors（希捷）" class="headerlink" title="BB（187）无法校正的错误 Reported Uncorrectable Errors（希捷）"></a><strong>BB（187）无法校正的错误 Reported Uncorrectable Errors（希捷）</strong></h3><p>报告给操作系统的无法通过硬件ECC校正的错误。如果数据值不为零，就应该备份硬盘上的数据了。</p>
<p>报告给操作系统的在所有存取命令中出现的无法校正的RAISE（URAISE）错误。</p>
<h3 id="BC（188）命令超时-Command-Timeout"><a href="#BC（188）命令超时-Command-Timeout" class="headerlink" title="BC（188）命令超时 Command Timeout"></a><strong>BC（188）命令超时 Command Timeout</strong></h3><p>由于硬盘超时导致操作终止的次数。通常数据值应为0，如果远大于零，最有可能出现的是电源供电问题或者<a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/shujuxian/">数据线</a>氧化致使接触不良，也可能是硬盘出现严重问题。</p>
<h3 id="BD（189）高飞写入-High-Fly-Writes"><a href="#BD（189）高飞写入-High-Fly-Writes" class="headerlink" title="BD（189）高飞写入 High Fly Writes"></a><strong>BD（189）高飞写入 High Fly Writes</strong></h3><p>磁头飞行高度监视装置可以提高读写的可靠性，这一装置时刻监测磁头的飞行高度是否在正常范围来保证可靠的写入数据。如果磁头的飞行高度出现偏差，写入操作就会停止，然后尝试重新写入或者换一个位置写入。这种持续的监测过程提高了写入数据的可靠性，同时也降低了读取错误率。这一项的数据值就统计了写入时磁头飞行高度出现偏差的次数。</p>
<h3 id="BD（189）出厂坏块计数-Factory-Bad-Block-Count（Micron-镁光芯片）"><a href="#BD（189）出厂坏块计数-Factory-Bad-Block-Count（Micron-镁光芯片）" class="headerlink" title="BD（189）出厂坏块计数 Factory Bad Block Count（Micron 镁光芯片）"></a><strong>BD（189）出厂坏块计数 Factory Bad Block Count（Micron 镁光芯片）</strong></h3><h3 id="BE（190）气流温度-Airflow-Temperature"><a href="#BE（190）气流温度-Airflow-Temperature" class="headerlink" title="BE（190）气流温度 Airflow Temperature"></a><strong>BE（190）气流温度 Airflow Temperature</strong></h3><p>这一项表示的是硬盘内部盘片表面的气流温度。在希捷公司的某些硬盘中，当前值=（100－当前温度），因此气流温度越高，当前值就越低，最差值则是当前值曾经到达过的最低点，临界值由制造商定义的最高允许温度来确定，而数据值不具实际意义。许多硬盘也没有这一项参数。</p>
<h3 id="BF（191）冲击错误率-G-sense-error-rate"><a href="#BF（191）冲击错误率-G-sense-error-rate" class="headerlink" title="BF（191）冲击错误率 G-sense error rate"></a><strong>BF（191）冲击错误率 G-sense error rate</strong></h3><p>这一项的数据值记录了硬盘受到机械冲击导致出错的频度。</p>
<h3 id="C0（192）断电返回计数-Power-Off-Retract-Count"><a href="#C0（192）断电返回计数-Power-Off-Retract-Count" class="headerlink" title="C0（192）断电返回计数 Power-Off Retract Count"></a><strong>C0（192）断电返回计数 Power-Off Retract Count</strong></h3><p>当计算机关机或意外断电时，硬盘的磁头都要返回停靠区，不能停留在盘片的数据区里。正常关机时电源会给硬盘一个通知，即Standby Immediate，就是说主机要求将缓存数据写入硬盘，然后就准备关机断电了（休眠、待机也是如此）；意外断电则表示硬盘在未收到关机通知时就失电，此时磁头会自动复位，迅速离开盘片。</p>
<p>这个参数的数据值累计了磁头返回的次数。但要注意这个参数对某些硬盘来说仅记录意外断电时磁头的返回动作；而某些硬盘记录了所有（包括休眠、待机，但不包括关机时）的磁头返回动作；还有些硬盘这一项没有记录。因此这一参数的数据值在某些硬盘上持续为0或稍大于0，但在另外的硬盘上则会大于通电周期计数（0C）或启停计数（04）的数据。在一些新型节能硬盘中，这一参数的数据量还与硬盘的节能设计相关，可能会远大于通电周期计数（0C）或启停计数（04）的数据，但又远小于磁头加载/卸载计数（C1）的数据量。</p>
<p>对于固态硬盘来说，虽然没有磁头的加载/卸载操作，但这一项的数据量仍然代表了不安全关机，即发生意外断电的次数。</p>
<h3 id="C1（193）磁头加载-卸载计数-Load-Unload-Cycle-Count"><a href="#C1（193）磁头加载-卸载计数-Load-Unload-Cycle-Count" class="headerlink" title="C1（193）磁头加载/卸载计数 Load/Unload Cycle Count"></a><strong>C1（193）磁头加载/卸载计数 Load/Unload Cycle Count</strong></h3><p>对于过去的硬盘来说，盘片停止旋转时磁头臂停靠于盘片中心轴处的停泊区，磁头与盘片接触，只有当盘片旋转到一定转速时，磁头才开始漂浮于盘片之上并开始向外侧移动至数据区。这使得磁头在硬盘启停时都与盘片发生摩擦，虽然盘片的停泊区不存储数据，但无疑启停一个循环，就使磁头经历两次磨损。所以对以前的硬盘来说，磁头起降（加载/卸载）次数是一项重要的寿命关键参数。</p>
<p>而在现代硬盘中，平时磁头臂是停靠于盘片之外的一个专门设计的停靠架上，远离盘片。只有当盘片旋转达到额定转速后，磁头臂才开始向内（盘片轴心）转动使磁头移至盘片区域（加载），磁头臂向外转动返回至停靠架即卸载。这样就彻底杜绝了硬盘启停时磁头与盘片接触的现象，西部数据公司将其称为“斜坡加载技术”。由于磁头在加载/卸载过程中始终不与盘片接触，不存在磁头的磨损，使得这一参数的重要性已经大大下降。</p>
<p>这个参数的数据值就是磁头执行加载/卸载操作的累计次数。从原理上讲，这个加载/卸载次数应当与硬盘的启停次数相当，但对于笔记本内置硬盘以及<a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/taishiji/">台式机</a>新型节能硬盘来说，这一项的数据量会很大。这是因为磁头臂组件设计有一个固定的返回力矩，保证在意外断电时磁头能靠弹簧力自动离开盘片半径范围，迅速返回停靠架。所以要让硬盘运行时磁头保持在盘片的半径之内，就要使磁头臂驱动电机（寻道电机）持续通以电流。而让磁头臂在硬盘空闲几分钟后就立即执行卸载动作，返回到停靠架上，既有利于节能，又降低了硬盘受外力冲击导致磁头与盘片接触的概率。虽然再次加载会增加一点寻道时间，但毕竟弊大于利，所以在这类硬盘中磁头的加载/卸载次数会远远大于通电周期计数（0C）或启停计数（04）的数据量。不过这种加载/卸载方式已经没有了磁头与盘片的接触，所以设计值也已大大增加，通常笔记本内置硬盘的磁头加载/卸载额定值在30～60万次，而台式机新型节能硬盘的磁头加载/卸载设计值可达一百万次。</p>
<h3 id="C2（194）温度-Temperature"><a href="#C2（194）温度-Temperature" class="headerlink" title="C2（194）温度 Temperature"></a><strong>C2（194）温度 Temperature</strong></h3><p>温度的数据值直接表示了硬盘内部的当前温度。硬盘运行时最好不要超过45℃，温度过高虽不会导致数据丢失，但引起的机械变形会导致寻道与读写错误率上升，降低硬盘性能。硬盘的最高允许运行温度可查看硬盘厂商给出的数据，一般不会超过60℃。</p>
<p>不同厂家对温度参数的当前值、最差值和临界值有不同的表示方法：希捷公司某些硬盘的当前值就是实际温度（摄氏）值，最差值则是曾经达到过的最高温度，临界值不具意义；而西部数据公司一些硬盘的最差值是温度上升到某值后的时间函数，每次升温后的持续时间都将导致最差值逐渐下降，当前值则与当前温度成反比，即当前温度越高，当前值越低，随实际温度波动。</p>
<h3 id="C3（195）硬件ECC校正-Hardware-ECC-Recovered"><a href="#C3（195）硬件ECC校正-Hardware-ECC-Recovered" class="headerlink" title="C3（195）硬件ECC校正 Hardware ECC Recovered"></a><strong>C3（195）硬件ECC校正 Hardware ECC Recovered</strong></h3><p>ECC（Error Correcting Code）的意思是“错误检查和纠正”，这个技术能够容许错误，并可以将错误更正，使读写操作得以持续进行，不致因错误而中断。这一项的数据值记录了磁头在盘片上读写时通过ECC技术校正错误的次数，不过许多硬盘有其制造商特定的数据结构，因此数据量的大小并不能直接说明问题。</p>
<h3 id="C3（195）实时无法校正错误计数-On-the-fly-ECC-Uncorrectable-Error-Count"><a href="#C3（195）实时无法校正错误计数-On-the-fly-ECC-Uncorrectable-Error-Count" class="headerlink" title="C3（195）实时无法校正错误计数 On the fly ECC Uncorrectable Error Count"></a><strong>C3（195）实时无法校正错误计数 On the fly ECC Uncorrectable Error Count</strong></h3><p>这一参数记录了无法校正（UECC）的错误数量。</p>
<h3 id="C3（195）编程错误块计数-Program-Failure-block-Count（Indilinx芯片）"><a href="#C3（195）编程错误块计数-Program-Failure-block-Count（Indilinx芯片）" class="headerlink" title="C3（195）编程错误块计数 Program Failure block Count（Indilinx芯片）"></a><strong>C3（195）编程错误块计数 Program Failure block Count（Indilinx芯片）</strong></h3><h3 id="C4（196）重映射事件计数-Reallocetion-Events-Count"><a href="#C4（196）重映射事件计数-Reallocetion-Events-Count" class="headerlink" title="C4（196）重映射事件计数 Reallocetion Events Count"></a><strong>C4（196）重映射事件计数 Reallocetion Events Count</strong></h3><p>数据应为0，当前值应远大于临界值。</p>
<p>这个参数的数据值记录了将重映射扇区的数据转移到备用扇区的尝试次数，是重映射操作的累计值，成功的转移和不成功的转移都会被计数。因此这一参数与重映射扇区计数（05）相似，都是反映硬盘已经存在不良扇区。</p>
<h3 id="C4（196）擦除错误块计数-Erase-Failure-block-Count（Indilinx芯片）"><a href="#C4（196）擦除错误块计数-Erase-Failure-block-Count（Indilinx芯片）" class="headerlink" title="C4（196）擦除错误块计数 Erase Failure block Count（Indilinx芯片）"></a><strong>C4（196）擦除错误块计数 Erase Failure block Count（Indilinx芯片）</strong></h3><p>在固态硬盘中，这一参数记录了被重映射的块编程失败的数量。</p>
<h3 id="C5（197）当前待映射扇区计数-Current-Pending-Sector-Count"><a href="#C5（197）当前待映射扇区计数-Current-Pending-Sector-Count" class="headerlink" title="C5（197）当前待映射扇区计数 Current Pending Sector Count"></a><strong>C5（197）当前待映射扇区计数 Current Pending Sector Count</strong></h3><p>数据应为0，当前值应远大于临界值。</p>
<p>这个参数的数据表示了“不稳定的”扇区数，即等待被映射的扇区（也称“被挂起的扇区”）数量。如果不稳定的扇区随后被读写成功，该扇区就不再列入等待范围，数据值就会下降。</p>
<p>仅仅读取时出错的扇区并不会导致重映射，只是被列入“等待”，也许以后读取就没有问题，所以只有在写入失败时才会发生重映射。下次对该扇区写入时如果继续出错，就会产生一次重映射操作，此时重映射扇区计数（05）与重映射事件计数（C4）的数据值增加，此参数的数据值下降。</p>
<h3 id="C5（197）读取错误块计数（不可修复错误）Read-Failure-block-Count（Indilinx芯片）"><a href="#C5（197）读取错误块计数（不可修复错误）Read-Failure-block-Count（Indilinx芯片）" class="headerlink" title="C5（197）读取错误块计数（不可修复错误）Read Failure block Count（Indilinx芯片）"></a><strong>C5（197）读取错误块计数（不可修复错误）Read Failure block Count（Indilinx芯片）</strong></h3><h3 id="C6（198）脱机无法校正的扇区计数-Offline-Uncorrectable-Sector-Count"><a href="#C6（198）脱机无法校正的扇区计数-Offline-Uncorrectable-Sector-Count" class="headerlink" title="C6（198）脱机无法校正的扇区计数 Offline Uncorrectable Sector Count"></a><strong>C6（198）脱机无法校正的扇区计数 Offline Uncorrectable Sector Count</strong></h3><p>数据应为0，当前值应远大于临界值。</p>
<p>这个参数的数据累计了读写扇区时发生的无法校正的错误总数。数据值上升表明盘片表面介质或机械子系统出现问题，有些扇区肯定已经不能读取，如果有文件正在使用这些扇区，操作系统会返回读盘错误的信息。下一次写操作时会对该扇区执行重映射。</p>
<h3 id="C6（198）总读取页数-Total-Count-of-Read-Sectors（Indilinx芯片）"><a href="#C6（198）总读取页数-Total-Count-of-Read-Sectors（Indilinx芯片）" class="headerlink" title="C6（198）总读取页数 Total Count of Read Sectors（Indilinx芯片）"></a><strong>C6（198）总读取页数 Total Count of Read Sectors（Indilinx芯片）</strong></h3><h3 id="C7（199）Ultra-ATA访问校验错误率-Ultra-ATA-CRC-Error-Rate"><a href="#C7（199）Ultra-ATA访问校验错误率-Ultra-ATA-CRC-Error-Rate" class="headerlink" title="C7（199）Ultra ATA访问校验错误率 Ultra ATA CRC Error Rate"></a><strong>C7（199）Ultra ATA访问校验错误率 Ultra ATA CRC Error Rate</strong></h3><p>这个参数的数据值累计了通过接口循环冗余校验（Interface Cyclic Redundancy Check，ICRC）发现的数据线传输错误的次数。如果数据值不为0且持续增长，表示硬盘控制器→数据线→硬盘接口出现错误，劣质的数据线、接口接触不良都可能导致此现象。由于这一项的数据值不会复零，所以某些新硬盘也会出现一定的数据量，只要更换数据线后数据值不再继续增长，即表示问题已得到解决。</p>
<h3 id="C7（199）总写入页数-Total-Count-of-Write-Sectors（Indilinx芯片）"><a href="#C7（199）总写入页数-Total-Count-of-Write-Sectors（Indilinx芯片）" class="headerlink" title="C7（199）总写入页数 Total Count of Write Sectors（Indilinx芯片）"></a><strong>C7（199）总写入页数 Total Count of Write Sectors（Indilinx芯片）</strong></h3><h3 id="C8（200）写入错误率-Write-Error-Rate-多区域错误率-Multi-Zone-Error-Rate（西部数据）"><a href="#C8（200）写入错误率-Write-Error-Rate-多区域错误率-Multi-Zone-Error-Rate（西部数据）" class="headerlink" title="C8（200）写入错误率 Write Error Rate / 多区域错误率 Multi-Zone Error Rate（西部数据）"></a><strong>C8（200）写入错误率 Write Error Rate / 多区域错误率 Multi-Zone Error Rate（西部数据）</strong></h3><p>数据应为0，当前值应远大于临界值。</p>
<p>这个参数的数据累计了向扇区写入数据时出现错误的总数。有的新硬盘也会有一定的数据量，若数据值持续快速升高（当前值偏低），表示盘片、磁头组件可能有问题。</p>
<h3 id="C8（200）总读取指令数-Total-Count-of-Read-Command（Indilinx芯片）"><a href="#C8（200）总读取指令数-Total-Count-of-Read-Command（Indilinx芯片）" class="headerlink" title="C8（200）总读取指令数 Total Count of Read Command（Indilinx芯片）"></a><strong>C8（200）总读取指令数 Total Count of Read Command（Indilinx芯片）</strong></h3><h3 id="C9（201）脱道错误率-Off-Track-Error-Rate-逻辑读取错误率-Soft-Read-Error-Rate"><a href="#C9（201）脱道错误率-Off-Track-Error-Rate-逻辑读取错误率-Soft-Read-Error-Rate" class="headerlink" title="C9（201）脱道错误率 Off Track Error Rate / 逻辑读取错误率 Soft Read Error Rate"></a><strong>C9（201）脱道错误率 Off Track Error Rate / 逻辑读取错误率 Soft Read Error Rate</strong></h3><p>数据值累积了读取时脱轨的错误数量，如果数据值不为0，最好备份硬盘上的资料。</p>
<h3 id="C9（201）TA-Counter-Detected（意义不明）"><a href="#C9（201）TA-Counter-Detected（意义不明）" class="headerlink" title="C9（201）TA Counter Detected（意义不明）"></a><strong>C9（201）TA Counter Detected（意义不明）</strong></h3><h3 id="C9（201）写入指令总数-Total-Count-of-Write-Command（Indilinx芯片）"><a href="#C9（201）写入指令总数-Total-Count-of-Write-Command（Indilinx芯片）" class="headerlink" title="C9（201）写入指令总数 Total Count of Write Command（Indilinx芯片）"></a><strong>C9（201）写入指令总数 Total Count of Write Command（Indilinx芯片）</strong></h3><h3 id="CA（202）数据地址标记错误-Data-Address-Mark-errors"><a href="#CA（202）数据地址标记错误-Data-Address-Mark-errors" class="headerlink" title="CA（202）数据地址标记错误 Data Address Mark errors"></a><strong>CA（202）数据地址标记错误 Data Address Mark errors</strong></h3><p>此项的数据值越低越好（或者由制造商定义）。</p>
<h3 id="CA（202）TA-Counter-Increased（意义不明）"><a href="#CA（202）TA-Counter-Increased（意义不明）" class="headerlink" title="CA（202）TA Counter Increased（意义不明）"></a><strong>CA（202）TA Counter Increased（意义不明）</strong></h3><h3 id="CA（202）剩余寿命-Percentage-Of-The-Rated-Lifetime-Used（Micron-镁光芯片）"><a href="#CA（202）剩余寿命-Percentage-Of-The-Rated-Lifetime-Used（Micron-镁光芯片）" class="headerlink" title="CA（202）剩余寿命 Percentage Of The Rated Lifetime Used（Micron 镁光芯片）"></a><strong>CA（202）剩余寿命 Percentage Of The Rated Lifetime Used（Micron 镁光芯片）</strong></h3><p>当前值从100开始下降至0，表示所有块的擦写余量统计。计算方法是以MLC擦写次数除以50，SLC擦写次数除以1000，结果取整数，将其与100的差值作为当前值（MLC预计擦写次数为5000，SLC预计擦写次数为100000）。</p>
<h3 id="CA（202）闪存总错误bit数-Total-Count-of-error-bits-from-flash（Indilinx芯片）"><a href="#CA（202）闪存总错误bit数-Total-Count-of-error-bits-from-flash（Indilinx芯片）" class="headerlink" title="CA（202）闪存总错误bit数 Total Count of error bits from flash（Indilinx芯片）"></a><strong>CA（202）闪存总错误bit数 Total Count of error bits from flash（Indilinx芯片）</strong></h3><h3 id="CB（203）软件ECC错误数-Run-Out-Cancel"><a href="#CB（203）软件ECC错误数-Run-Out-Cancel" class="headerlink" title="CB（203）软件ECC错误数 Run Out Cancel"></a><strong>CB（203）软件ECC错误数 Run Out Cancel</strong></h3><p>错误检查和纠正（ECC）出错的频度。</p>
<h3 id="CB（203）校正bit错误的总读取页数-Total-Count-of-Read-Sectors-with-correct-bits-error（Indilinx芯片）"><a href="#CB（203）校正bit错误的总读取页数-Total-Count-of-Read-Sectors-with-correct-bits-error（Indilinx芯片）" class="headerlink" title="CB（203）校正bit错误的总读取页数 Total Count of Read Sectors with correct bits error（Indilinx芯片）"></a><strong>CB（203）校正bit错误的总读取页数 Total Count of Read Sectors with correct bits error（Indilinx芯片）</strong></h3><h3 id="CC（204）软件ECC校正-Soft-ECC-Correction"><a href="#CC（204）软件ECC校正-Soft-ECC-Correction" class="headerlink" title="CC（204）软件ECC校正 Soft ECC Correction"></a><strong>CC（204）软件ECC校正 Soft ECC Correction</strong></h3><p>通过软件ECC纠正错误的计数。</p>
<h3 id="CC（204）坏块满标志-Bad-Block-Full-Flag（Indilinx芯片）"><a href="#CC（204）坏块满标志-Bad-Block-Full-Flag（Indilinx芯片）" class="headerlink" title="CC（204）坏块满标志 Bad Block Full Flag（Indilinx芯片）"></a><strong>CC（204）坏块满标志 Bad Block Full Flag（Indilinx芯片）</strong></h3><h3 id="CD（205）热骚动错误率-Thermal-Asperity-Rate-TAR"><a href="#CD（205）热骚动错误率-Thermal-Asperity-Rate-TAR" class="headerlink" title="CD（205）热骚动错误率 Thermal Asperity Rate (TAR)"></a><strong>CD（205）热骚动错误率 Thermal Asperity Rate (TAR)</strong></h3><p>由超温导致的错误。数据值应为0。</p>
<h3 id="CD（205）最大可编程-擦除次数-Max-P-E-Count（Indilinx芯片）"><a href="#CD（205）最大可编程-擦除次数-Max-P-E-Count（Indilinx芯片）" class="headerlink" title="CD（205）最大可编程/擦除次数 Max P/E Count（Indilinx芯片）"></a><strong>CD（205）最大可编程/擦除次数 Max P/E Count（Indilinx芯片）</strong></h3><h3 id="CE（206）磁头飞行高度-Flying-Height"><a href="#CE（206）磁头飞行高度-Flying-Height" class="headerlink" title="CE（206）磁头飞行高度 Flying Height"></a><strong>CE（206）磁头飞行高度 Flying Height</strong></h3><p>磁头距离盘片表面的垂直距离。高度过低则增加了磁头与盘片接触导致损坏的可能性；高度偏高则增大了读写错误率。不过准确地说，硬盘中并没有任何装置可以直接测出磁头的飞行高度，制造商也只是根据磁头读取的信号强度来推算磁头飞行高度。</p>
<h3 id="CE（206）底层数据写入出错率-Write-Error-Rate"><a href="#CE（206）底层数据写入出错率-Write-Error-Rate" class="headerlink" title="CE（206）底层数据写入出错率 Write Error Rate"></a><strong>CE（206）底层数据写入出错率 Write Error Rate</strong></h3><h3 id="CE（206）最小擦写次数-Erase-Count-Min（Indilinx芯片）"><a href="#CE（206）最小擦写次数-Erase-Count-Min（Indilinx芯片）" class="headerlink" title="CE（206）最小擦写次数 Erase Count Min（Indilinx芯片）"></a><strong>CE（206）最小擦写次数 Erase Count Min（Indilinx芯片）</strong></h3><h3 id="CF（207）主轴过电流-Spin-High-Current"><a href="#CF（207）主轴过电流-Spin-High-Current" class="headerlink" title="CF（207）主轴过电流 Spin High Current"></a><strong>CF（207）主轴过电流 Spin High Current</strong></h3><p>数据值记录了主轴电机运行时出现浪涌电流的次数，数据量的增加意味着轴承或电机可能有问题。</p>
<h3 id="CF（207）最大擦写次数-Erase-Count-Max（Indilinx芯片）"><a href="#CF（207）最大擦写次数-Erase-Count-Max（Indilinx芯片）" class="headerlink" title="CF（207）最大擦写次数 Erase Count Max（Indilinx芯片）"></a><strong>CF（207）最大擦写次数 Erase Count Max（Indilinx芯片）</strong></h3><h3 id="D0（208）主轴电机重启次数-Spin-Buzz"><a href="#D0（208）主轴电机重启次数-Spin-Buzz" class="headerlink" title="D0（208）主轴电机重启次数 Spin Buzz"></a><strong>D0（208）主轴电机重启次数 Spin Buzz</strong></h3><p>数据值记录了主轴电机反复尝试启动的次数，这通常是由于电源供电不足引起的。</p>
<h3 id="D0（208）平均擦写次数Erase-Count-Average（Indilinx芯片）"><a href="#D0（208）平均擦写次数Erase-Count-Average（Indilinx芯片）" class="headerlink" title="D0（208）平均擦写次数Erase Count Average（Indilinx芯片）"></a><strong>D0（208）平均擦写次数Erase Count Average（Indilinx芯片）</strong></h3><h3 id="D1（209）脱机寻道性能-Offline-Seek-Performance"><a href="#D1（209）脱机寻道性能-Offline-Seek-Performance" class="headerlink" title="D1（209）脱机寻道性能 Offline Seek Performance"></a><strong>D1（209）脱机寻道性能 Offline Seek Performance</strong></h3><p>这一项表示驱动器在脱机状态下的寻道性能，通常用于工厂内部测试。</p>
<h3 id="D1（209）剩余寿命百分比-Remaining-Life-（Indilinx芯片）"><a href="#D1（209）剩余寿命百分比-Remaining-Life-（Indilinx芯片）" class="headerlink" title="D1（209）剩余寿命百分比 Remaining Life %（Indilinx芯片）"></a><strong>D1（209）剩余寿命百分比 Remaining Life %（Indilinx芯片）</strong></h3><h3 id="D2（210）斜坡加载值-Ramp-Load-Value"><a href="#D2（210）斜坡加载值-Ramp-Load-Value" class="headerlink" title="D2（210）斜坡加载值 Ramp Load Value"></a><strong>D2（210）斜坡加载值 Ramp Load Value</strong></h3><p>这一项仅见于几年前迈拓制造的部分硬盘。通常数据值为0，意义不明。</p>
<h3 id="D2（210）坏块管理错误日志-BBM-Error-Log（Indilinx芯片）"><a href="#D2（210）坏块管理错误日志-BBM-Error-Log（Indilinx芯片）" class="headerlink" title="D2（210）坏块管理错误日志 BBM Error Log（Indilinx芯片）"></a><strong>D2（210）坏块管理错误日志 BBM Error Log（Indilinx芯片）</strong></h3><h3 id="D3（211）写入时振动-Vibration-During-Write"><a href="#D3（211）写入时振动-Vibration-During-Write" class="headerlink" title="D3（211）写入时振动 Vibration During Write"></a><strong>D3（211）写入时振动 Vibration During Write</strong></h3><p>写入数据时受到受到外部振动的记录。</p>
<h3 id="D3（211）SATA主机接口CRC写入错误计数-SATA-Error-Count-CRC-Write-（Indilinx芯片）"><a href="#D3（211）SATA主机接口CRC写入错误计数-SATA-Error-Count-CRC-Write-（Indilinx芯片）" class="headerlink" title="D3（211）SATA主机接口CRC写入错误计数 SATA Error Count CRC (Write)（Indilinx芯片）"></a><strong>D3（211）SATA主机接口CRC写入错误计数 SATA Error Count CRC (Write)（Indilinx芯片）</strong></h3><h3 id="D4（212）写入时冲击-Shock-During-Write"><a href="#D4（212）写入时冲击-Shock-During-Write" class="headerlink" title="D4（212）写入时冲击 Shock During Write"></a><strong>D4（212）写入时冲击 Shock During Write</strong></h3><p>写入数据时受到受到外部机械冲击的记录。</p>
<h3 id="D4（212）SATA主机接口读取错误计数-SATA-Error-Count-Count-CRC-Read-（Indilinx芯片）"><a href="#D4（212）SATA主机接口读取错误计数-SATA-Error-Count-Count-CRC-Read-（Indilinx芯片）" class="headerlink" title="D4（212）SATA主机接口读取错误计数 SATA Error Count Count CRC (Read)（Indilinx芯片）"></a><strong>D4（212）SATA主机接口读取错误计数 SATA Error Count Count CRC (Read)（Indilinx芯片）</strong></h3><h3 id="DC（220）盘片偏移量-Disk-Shift"><a href="#DC（220）盘片偏移量-Disk-Shift" class="headerlink" title="DC（220）盘片偏移量 Disk Shift"></a><strong>DC（220）盘片偏移量 Disk Shift</strong></h3><p>硬盘中的盘片相对主轴的偏移量（通常是受外力冲击或温度变化所致），单位未知，数据值越小越好。</p>
<h3 id="DD（221）冲击错误率-G-sense-error-rate"><a href="#DD（221）冲击错误率-G-sense-error-rate" class="headerlink" title="DD（221）冲击错误率 G-sense error rate"></a><strong>DD（221）冲击错误率 G-sense error rate</strong></h3><p>与（BF）相同，数据值记录了硬盘受到外部机械冲击或振动导致出错的频度。</p>
<h3 id="DE（222）磁头寻道时间累计-Loaded-Hours"><a href="#DE（222）磁头寻道时间累计-Loaded-Hours" class="headerlink" title="DE（222）磁头寻道时间累计 Loaded Hours"></a><strong>DE（222）磁头寻道时间累计 Loaded Hours</strong></h3><p>磁头臂组件运行的小时数，即寻道电机运行时间累计。</p>
<h3 id="DF（223）磁头加载-卸载重试计数-Load-Unload-Retry-Count"><a href="#DF（223）磁头加载-卸载重试计数-Load-Unload-Retry-Count" class="headerlink" title="DF（223）磁头加载/卸载重试计数 Load/Unload Retry Count"></a><strong>DF（223）磁头加载/卸载重试计数 Load/Unload Retry Count</strong></h3><p>这一项与（C1）项类似，数据值累积了磁头尝试重新加载/卸载的次数。</p>
<h3 id="E0（224）磁头阻力-Load-Friction"><a href="#E0（224）磁头阻力-Load-Friction" class="headerlink" title="E0（224）磁头阻力 Load Friction"></a><strong>E0（224）磁头阻力 Load Friction</strong></h3><p>磁头工作时受到的机械部件的阻力。</p>
<h3 id="E1（225）主机写入数据量-Host-Writes"><a href="#E1（225）主机写入数据量-Host-Writes" class="headerlink" title="E1（225）主机写入数据量 Host Writes"></a><strong>E1（225）主机写入数据量 Host Writes</strong></h3><p>由于闪存的擦写次数是有限的，所以这项是固态硬盘特有的统计。Intel的SSD是每当向硬盘写入了65536个扇区，这一项的数据就＋1。如果用HDTune等软件查看SMART时可以自己计算，Intel SSD Toolbox已经为你算好了，直接就显示了曾向SSD中写入过的数据量。</p>
<h3 id="E2（226）磁头加载时间累计-Load-‘In’-time"><a href="#E2（226）磁头加载时间累计-Load-‘In’-time" class="headerlink" title="E2（226）磁头加载时间累计 Load ‘In’-time"></a><strong>E2（226）磁头加载时间累计 Load ‘In’-time</strong></h3><p>磁头组件运行时间的累积数，即磁头臂不在停靠区的时间，与（DE）项相似。</p>
<h3 id="E3（227）扭矩放大计数-Torque-Amplification-Count"><a href="#E3（227）扭矩放大计数-Torque-Amplification-Count" class="headerlink" title="E3（227）扭矩放大计数 Torque Amplification Count"></a><strong>E3（227）扭矩放大计数 Torque Amplification Count</strong></h3><p>主轴电机试图提高扭矩来补偿盘片转速变化的次数。当主轴轴承存在问题时，主轴电机会尝试增加驱动力使盘片稳定旋转。这个参数的当前值下降，说明硬盘的机械子系统出现了严重的问题。</p>
<h3 id="E4（228）断电返回计数-Power-Off-Retract-Cycle"><a href="#E4（228）断电返回计数-Power-Off-Retract-Cycle" class="headerlink" title="E4（228）断电返回计数 Power-Off Retract Cycle"></a><strong>E4（228）断电返回计数 Power-Off Retract Cycle</strong></h3><p>数据值累计了磁头因设备意外断电而自动返回的次数，与（C0）项相似。</p>
<h3 id="E6（230）GMR磁头振幅-GMR-Head-Amplitude"><a href="#E6（230）GMR磁头振幅-GMR-Head-Amplitude" class="headerlink" title="E6（230）GMR磁头振幅 GMR Head Amplitude"></a><strong>E6（230）GMR磁头振幅 GMR Head Amplitude</strong></h3><p>磁头“抖动”，即正向/反向往复运动的距离。</p>
<h3 id="E7（231）温度-Temperature"><a href="#E7（231）温度-Temperature" class="headerlink" title="E7（231）温度 Temperature"></a><strong>E7（231）温度 Temperature</strong></h3><p>温度的数据值直接表示了硬盘内部的当前温度，与（C2）项相同。</p>
<h3 id="E7（231）剩余寿命-SSD-Life-Left"><a href="#E7（231）剩余寿命-SSD-Life-Left" class="headerlink" title="E7（231）剩余寿命 SSD Life Left"></a><strong>E7（231）剩余寿命 SSD Life Left</strong></h3><p>剩余寿命是基于P/E周期与可用的备用块作出的预测。新硬盘为100；10表示PE周期已到设计值，但尚有足够的保留块；0表示保留块不足，硬盘将处于只读方式以便备份数据。</p>
<h3 id="E8（232）寿命余量-Endurance-Remaining"><a href="#E8（232）寿命余量-Endurance-Remaining" class="headerlink" title="E8（232）寿命余量 Endurance Remaining"></a><strong>E8（232）寿命余量 Endurance Remaining</strong></h3><p>寿命余量是指硬盘已擦写次数与设计最大可擦写次数的百分比，与（CA）项相似。</p>
<h3 id="E8（232）预留空间剩余量-Available-Reserved-Space（Intel芯片）"><a href="#E8（232）预留空间剩余量-Available-Reserved-Space（Intel芯片）" class="headerlink" title="E8（232）预留空间剩余量 Available Reserved Space（Intel芯片）"></a><strong>E8（232）预留空间剩余量 Available Reserved Space（Intel芯片）</strong></h3><p>对于Intel的SSD来说，前边05项提到会保留一些容量来准备替换损坏的存储单元，所以可用的预留空间数非常重要。当保留的空间用尽，再出现损坏的单元就将出现数据丢失，这个SSD的寿命就结束了。所以仅看05项意义并不大，这一项才最重要。这项参数可以看当前值，新的SSD里所有的预留空间都在，所以是100。随着预留空间的消耗，当前值将不断下降，减小到接近临界值（一般是10）时，就说明只剩下10%的预留空间了，SSD的寿命将要结束。这个与（B4）项相似。</p>
<h3 id="E9（233）通电时间累计-Power-On-Hours"><a href="#E9（233）通电时间累计-Power-On-Hours" class="headerlink" title="E9（233）通电时间累计 Power-On Hours"></a><strong>E9（233）通电时间累计 Power-On Hours</strong></h3><p>对于普通硬盘来说，这一项与（09）相同。</p>
<h3 id="E9（233）介质磨耗指数-Media-Wareout-Indicator（Intel芯片）"><a href="#E9（233）介质磨耗指数-Media-Wareout-Indicator（Intel芯片）" class="headerlink" title="E9（233）介质磨耗指数 Media Wareout Indicator（Intel芯片）"></a><strong>E9（233）介质磨耗指数 Media Wareout Indicator（Intel芯片）</strong></h3><p>由于固态硬盘的擦写次数是有限的，当到达一定次数的时候，就会出现大量的单元同时损坏，这时候预留空间也顶不住了，所以这项参数实际上表示的是硬盘设计寿命。Intel的SSD要看当前值，随着NAND的平均擦写次数从0增长到最大的设计值，这一参数的当前值从开始的100逐渐下降至1为止。这表示SSD的设计寿命已经终结。当然到达设计寿命也不一定意味着SSD就立即报废，这与闪存芯片的品质有着很大的关系。</p>
<p>注：Total Erase Count全擦写计数是指固态硬盘中所有块的擦写次数的总和，不同规格的NAND芯片以及不同容量的SSD，其最大全擦写次数均有所不同。</p>
<h3 id="F0（240）磁头飞行时间-Head-Flying-Hours-传输错误率-Transfer-Error-Rate（富士通）"><a href="#F0（240）磁头飞行时间-Head-Flying-Hours-传输错误率-Transfer-Error-Rate（富士通）" class="headerlink" title="F0（240）磁头飞行时间 Head Flying Hours / 传输错误率 Transfer Error Rate（富士通）"></a><strong>F0（240）磁头飞行时间 Head Flying Hours / 传输错误率 Transfer Error Rate（富士通）</strong></h3><p>磁头位于工作位置的时间。</p>
<p>富士通硬盘表示在数据传输时连接被重置的次数。</p>
<h3 id="F1（241）LBA写入总数-Total-LBAs-Written"><a href="#F1（241）LBA写入总数-Total-LBAs-Written" class="headerlink" title="F1（241）LBA写入总数 Total LBAs Written"></a><strong>F1（241）LBA写入总数 Total LBAs Written</strong></h3><p>LBA写入数的累计。</p>
<h3 id="F1（241）写入剩余寿命-Lifetime-Writes-from-Host"><a href="#F1（241）写入剩余寿命-Lifetime-Writes-from-Host" class="headerlink" title="F1（241）写入剩余寿命 Lifetime Writes from Host"></a><strong>F1（241）写入剩余寿命 Lifetime Writes from Host</strong></h3><p>自硬盘启用后主机向硬盘写入的数据总量，以4个字节表示，每写入64GB字节作为一个单位。</p>
<h3 id="F2（242）LBA读取总数-Total-LBAs-Read"><a href="#F2（242）LBA读取总数-Total-LBAs-Read" class="headerlink" title="F2（242）LBA读取总数 Total LBAs Read"></a><strong>F2（242）LBA读取总数 Total LBAs Read</strong></h3><p>LBA读取数的累计。某些SMART读取工具会显示负的数据值，是因为采用了48位LBA，而不是32位LBA。</p>
<h3 id="F2（242）读取剩余寿命-Lifetime-Reads-from-Host"><a href="#F2（242）读取剩余寿命-Lifetime-Reads-from-Host" class="headerlink" title="F2（242）读取剩余寿命 Lifetime Reads from Host"></a><strong>F2（242）读取剩余寿命 Lifetime Reads from Host</strong></h3><p>自硬盘启用后主机从硬盘读取的数据总量，以4个字节表示，每读取64GB字节作为一个单位。</p>
<h3 id="FA（250）读取错误重试率-Read-Error-Retry-Rate"><a href="#FA（250）读取错误重试率-Read-Error-Retry-Rate" class="headerlink" title="FA（250）读取错误重试率 Read Error Retry Rate"></a><strong>FA（250）读取错误重试率 Read Error Retry Rate</strong></h3><p>从磁盘上读取时出错的次数。</p>
<h3 id="FE（254）自由坠落保护-Free-Fall-Protection"><a href="#FE（254）自由坠落保护-Free-Fall-Protection" class="headerlink" title="FE（254）自由坠落保护 Free Fall Protection"></a><strong>FE（254）自由坠落保护 Free Fall Protection</strong></h3><p>现在有些笔记本硬盘具有自由坠落保护功能，当硬盘内置的加速度探测装置检测到硬盘位移时，会立即停止读写操作，将磁头臂复位。这个措施防止了磁头与盘片之间发生摩擦撞击，提高了硬盘的抗震性能。这个参数的数据里记录了这一保护装置动作的次数。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/03/Mermaid%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/03/Mermaid%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-03 21:19:32" itemprop="dateCreated datePublished" datetime="2025-05-03T21:19:32+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-22 19:02:44" itemprop="dateModified" datetime="2023-05-22T19:02:44+08:00">2023-05-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>什么是Mermaid？<ul>
<li>Mermaid是一种基于Javascript的绘图工具，使用类似于Markdown的语法，使用户可以方便快捷地通过代码创建图表。</li>
<li>项目地址：<a target="_blank" rel="noopener" href="https://github.com/mermaid-js/mermaid%EF%BC%88%E9%9C%80%E8%A6%81%E5%B0%86%E6%A2%AF%E5%AD%90%E8%AE%BE%E7%BD%AE%E6%88%90%E5%85%A8%E5%B1%80%E6%A8%A1%E5%BC%8F%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%EF%BC%89">https://github.com/mermaid-js/mermaid（需要将梯子设置成全局模式才能访问）</a></li>
</ul>
</li>
</ul>
<ul>
<li><p>怎么使用Mermaid？</p>
<ul>
<li>使用特定的Mermaid渲染器；</li>
<li><strong>使用集成了Mermaid渲染功能的Markdown编辑器，如<a target="_blank" rel="noopener" href="https://www.typora.io/">Typora</a>。</strong>使用时，需要将代码块的语言选择为Mermaid。</li>
</ul>
<blockquote>
<p>Typora是宇宙第一笔记软件，不接受反驳</p>
</blockquote>
</li>
<li><p>Mermaid能绘制哪些图？</p>
<ul>
<li>饼状图：使用<code>pie</code>关键字，具体用法后文将详细介绍</li>
<li>流程图：使用<code>graph</code>关键字，具体用法后文将详细介绍</li>
<li>序列图：使用<code>sequenceDiagram</code>关键字</li>
<li>甘特图：使用<code>gantt</code>关键字</li>
<li>类图：使用<code>classDiagram</code>关键字</li>
<li>状态图：使用<code>stateDiagram</code>关键字</li>
<li>用户旅程图：使用<code>journey</code>关键字</li>
</ul>
</li>
<li><p>实例：朱元璋家谱简图，圆圈代表皇帝</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">emperor((朱八八))-.子.-&gt;father(朱五四)-.子.-&gt;朱四九-.子.-&gt;朱百六</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">朱雄英--长子--&gt;朱标--长子--&gt;emperor</span><br><span class="line">emperor2((朱允炆))--次子--&gt;朱标</span><br><span class="line">朱樉--次子--&gt;emperor</span><br><span class="line">朱棡--三子--&gt;emperor</span><br><span class="line">emperor3((朱棣))--四子--&gt;emperor</span><br><span class="line">emperor4((朱高炽))--长子--&gt;emperor3</span><br></pre></td></tr></table></figure>

<p>以上是概述，下面详细介绍饼状图和流程图的语法。其他图的语法可访问上文给出的项目地址，自行学习。（记得挂梯子）</p>
<h1 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h1><ul>
<li><p>在线渲染器：<a target="_blank" rel="noopener" href="https://mermaidjs.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoicGllXG5cIkRvZ3NcIiA6IDQyLjk2XG5cIkNhdHNcIiA6IDUwLjA1XG5cIlJhdHNcIiA6IDEwLjAxIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifX0">Online FlowChart &amp; Diagrams Editor</a>（需要梯子）</p>
</li>
<li><p>语法</p>
<ul>
<li>从<code>pie</code>关键字开始图表</li>
<li>然后使用<code>title</code>关键字及其在字符串中的值，为饼图赋予标题。（这是<strong>可选的</strong>）</li>
<li>数据部分<ul>
<li>在<code>&quot; &quot;</code>内写上分区名。</li>
<li>分区名后使用<code>:</code>作为分隔符</li>
<li>分隔符后写上数值，最多支持2位小数——数据会以百分比的形式展示</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title 为什么总是宅在家里？</span><br><span class="line">    &quot;喜欢宅&quot; : 15</span><br><span class="line">    &quot;天气太热或太冷&quot; : 20</span><br><span class="line">    &quot;穷&quot; : 500</span><br></pre></td></tr></table></figure>

<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><ul>
<li>在线渲染器：<a target="_blank" rel="noopener" href="https://mermaidjs.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoiZ3JhcGggVERcbiAgICBBW0hhcmRdIC0tPnxUZXh0fCBCKFJvdW5kKVxuICAgIEIgLS0-IEN7RGVjaXNpb259XG4gICAgQyAtLT58T25lfCBEW1Jlc3VsdCAxXVxuICAgIEMgLS0-fFR3b3wgRVtSZXN1bHQgMl0iLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9fQ">Online FlowChart &amp; Diagrams Editor</a>（需要挂梯子）</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Start] --&gt; B&#123;Is it?&#125;;</span><br><span class="line">    B -- Yes --&gt; C[OK];</span><br><span class="line">    C --&gt; D[Rethink];</span><br><span class="line">    D --&gt; B;</span><br><span class="line">    B -- No ----&gt; E[End];</span><br></pre></td></tr></table></figure>

<h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>用于开头，声明流程图的方向。</p>
<ul>
<li><code>graph</code>或<code>graph TB</code>或<code>graph TD</code>：从上往下</li>
<li><code>graph BT</code>：从下往上</li>
<li><code>graph LR</code>：从左往右</li>
<li><code>graph RL</code>：从右往左</li>
</ul>
<h2 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h2><ul>
<li>无名字的结点：直接写内容，此时结点边框为方形；节点内容不能有空格</li>
<li>有名字的结点：节点名后书写内容，内容左右有特定符号，结点边框由符号决定；节点内容可以有空格</li>
</ul>
<blockquote>
<p>下面的实例中，没有为graph指定方向，因此默认是从上往下的。但是由于各个结点之前没有箭头，所以他们都处于同一排。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph</span><br><span class="line">    默认方形</span><br><span class="line">    id1[方形]</span><br><span class="line">    id2(圆边矩形)</span><br><span class="line">    id3([体育场形])</span><br><span class="line">    id4[[子程序形]]</span><br><span class="line">    id5[(圆柱形)]</span><br><span class="line">    id6((圆形))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph</span><br><span class="line">	id1&#123;菱形&#125;</span><br><span class="line">	id2&#123;&#123;六角形&#125;&#125;</span><br><span class="line">	id3[/平行四边形/]</span><br><span class="line">	id4[\反向平行四边形\]</span><br><span class="line">	id5[/梯形\]</span><br><span class="line">	id6[\反向梯形/]</span><br></pre></td></tr></table></figure>

<h2 id="连线样式"><a href="#连线样式" class="headerlink" title="连线样式"></a>连线样式</h2><ul>
<li>实线箭头：分为无文本箭头和有文本箭头，有文本箭头有2种书写格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a--&gt;b--文本1--&gt;c--&gt;|文本2|d</span><br></pre></td></tr></table></figure>

<ul>
<li>粗实线箭头：分为无文本箭头和有文本箭头</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a==&gt;b==文本==&gt;c</span><br></pre></td></tr></table></figure>

<ul>
<li>虚线箭头：分为无文本箭头和有文本箭头</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a-.-&gt;b-.文本.-&gt;c</span><br></pre></td></tr></table></figure>

<ul>
<li>无箭头线：即以上三种连线去掉箭头后的形式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a---b</span><br><span class="line">b--文本1---c</span><br><span class="line">c---|文本2|d</span><br><span class="line">d===e</span><br><span class="line">e==文本3===f</span><br><span class="line">f-.-g</span><br><span class="line">g-.文本.-h</span><br></pre></td></tr></table></figure>

<ul>
<li>其他连线：需要将<code>graph</code>关键字改为<code>flowchart</code>，除了新增加的连线形式外，上面三种线的渲染效果也会不同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A o--o B</span><br><span class="line">    B &lt;--&gt; C</span><br><span class="line">    C x--x D</span><br><span class="line">    </span><br><span class="line">    旧连线 --文本--&gt; 也会不同</span><br></pre></td></tr></table></figure>

<ul>
<li>延长连线：增加相应字符即可，如下图中的B到E，连线中增加了一个<code>-</code>。字符可多次添加。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Start] --&gt; B&#123;Is it?&#125;;</span><br><span class="line">    B --&gt;|Yes| C[OK];</span><br><span class="line">    C --&gt; D[Rethink];</span><br><span class="line">    D --&gt; B;</span><br><span class="line">    B ---&gt;|No| E[End];</span><br></pre></td></tr></table></figure>



<h2 id="连线形式"><a href="#连线形式" class="headerlink" title="连线形式"></a>连线形式</h2><ul>
<li>直链</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">   D[Rethink1&lt;br/&gt;Rethink2] -- text --&gt; B -- text2 --&gt; C</span><br></pre></td></tr></table></figure>

<ul>
<li>多重链：可以使用<code>&amp;</code>字符，或单个描述</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">   a --&gt; b &amp; c--&gt; d</span><br><span class="line">   </span><br><span class="line">   A &amp; B--&gt; C &amp; D</span><br><span class="line">   </span><br><span class="line">    X --&gt; M</span><br><span class="line">    X --&gt; N</span><br><span class="line">    Y --&gt; M</span><br><span class="line">    Y --&gt; N</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>子图：需要将<code>graph</code>关键字改为<code>flowchart</code>，在代码段的开始加入<code>subgraph</code>，尾部加入<code>end</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">    c1--&gt;a2</span><br><span class="line">    subgraph one</span><br><span class="line">    a1--&gt;a2</span><br><span class="line">    end</span><br><span class="line">    subgraph two</span><br><span class="line">    b1--&gt;b2</span><br><span class="line">    end</span><br><span class="line">    subgraph three</span><br><span class="line">    c1--&gt;c2</span><br><span class="line">    end</span><br><span class="line">    one --&gt; two</span><br><span class="line">    three --&gt; two</span><br><span class="line">    two --&gt; c2</span><br></pre></td></tr></table></figure>

<ul>
<li>注释：在行首加入<code>%%</code>即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">%%这是一条注释，在渲染图中不可见</span><br><span class="line">    A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">    B --&gt; C&#123;Decision&#125;</span><br><span class="line">    C --&gt;|One| D[Result one]</span><br><span class="line">    C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/03/80%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/03/80%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-03 21:19:32" itemprop="dateCreated datePublished" datetime="2025-05-03T21:19:32+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-23 11:31:38" itemprop="dateModified" datetime="2024-11-23T11:31:38+08:00">2024-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>80端口占用问题</p>
<p>找到占用者，其pid为4</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241025203515838.png" alt="image-20241025203515838"></p>
<p>根据pid找到其名为System，不能直接taskKill</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241025203538420.png" alt="image-20241025203538420"></p>
<p>netsh http show servicestate</p>
<p>发现是defaultAppPool在占用，控制器进程的pid为4671</p>
<p>任务管理器中找到4671，发现是iis Publishing 服务，禁用</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/02/03/rpc-interpretation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/03/rpc-interpretation/" class="post-title-link" itemprop="url">基于 Netty 的 RPC 框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-03 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-03T00:00:00+08:00">2025-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-02 00:57:46" itemprop="dateModified" datetime="2025-05-02T00:57:46+08:00">2025-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基于-Netty-的-RPC-框架"><a href="#基于-Netty-的-RPC-框架" class="headerlink" title="基于 Netty 的 RPC 框架"></a>基于 Netty 的 RPC 框架</h1><p>实现要点： </p>
<ul>
<li>实现了 Netty <a href="#%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6">心跳机制</a>，保持连接。客户端<a href="#%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF">指数退避</a>重试连接，服务端用线程池处理请求。可选 HTTP 和 Socket。</li>
<li>实现了自定义 RPC <a href="#protocol">通信协议</a>，<a href="#codec">自定义编解码器和拆包解码器</a>解决粘包和半包，实现了 Kryo 等5种<a href="#serialization">序列化方式</a>。</li>
<li><a href="#center">注册中心</a>支持 Nacos 与 Zookeeper，服务发现支持本地缓存、实时监听。除利用健康检查机制外，下线服务还会主动通知注册中心注销，实现优雅下线。支持一致性哈希等3种<a href="#loadbalance">负载均衡</a>算法。</li>
<li>集成 SpringBoot。通过<a href="#annotation">自定义注解</a>，提供者自动扫描并注册服务 Bean，消费者自动注入<a href="#proxy">代理对象</a>。自定义 starter 实现<a href="#autoconfig">自动装配</a>。</li>
<li>参考 Dubbo 实现 <a href="#spi">SPI</a>，支持<a href="#spi1">序列化</a>、<a href="#spi2">服务发现</a>等的动态扩展，实现与类型解耦的<a href="#cache">单例缓存</a>，减少大量冗余的对象创建。</li>
</ul>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/项目架构图.png" alt="项目架构图" style="zoom:67%;" />

<p><code>consumer</code>模块：服务的消费者，依赖于 <code>rpc-client-spring-boot-starter</code> 模块；</p>
<p><code>provider-api</code>模块：服务提供者暴露的API；</p>
<p><code>provider</code>模块：服务的提供者，依赖于 <code>rpc-server-spring-boot-starter</code> 模块：</p>
<p><code>rpc-client-spring-boot</code>模块：rpc 客户端模块，封装客户端发起的请求过程，提供服务发现、动态代理，网络通信等功能；</p>
<p><code>rpc-client-spring-boot-stater</code>模块：是<code>rpc-client-spring-boot</code>的stater模块，负责引入相应依赖进行自动配置；</p>
<p><code>rpc-framework-core</code>模块：是rpc核心依赖，提供负载均衡、服务注册发现、消息协议、消息编码解码、序列化算法；</p>
<p><code>rpc-server-spring-boot</code>模块：rpc 服务端模块，负责启动服务，接受和处理RPC请求，提供服务发布、反射调用等功能；</p>
<p><code>rpc-server-spring-boot-stater</code>模块：是<code>rpc-server-spring-boot</code>的stater模块，负责引入相应依赖进行自动配置；</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/02/03/rpc-interpretation/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/24/OSTEP%20Concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/24/OSTEP%20Concurrency/" class="post-title-link" itemprop="url">并发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-24 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-24T00:00:00+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 21:08:55" itemprop="dateModified" datetime="2025-05-03T21:08:55+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><h2 id="Thread-A-New-Executor"><a href="#Thread-A-New-Executor" class="headerlink" title="Thread: A New Executor"></a>Thread: A New Executor</h2><h3 id="Different-from-Process"><a href="#Different-from-Process" class="headerlink" title="Different from Process"></a>Different from Process</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241221230956042.png" alt="image-20241221230956042"></p>
<p>线程和进程最大的区别是，线程之间可以共享地址空间，因此线程的上下文切换不需要切换页表，但是每个线程都有独立的执行栈，它们分散在整个地址空间中，任何有关线程执行相关的信息都存在线程的执行栈——线程本地存储(TLS, Thread Local Storage)中。</p>
<ol>
<li><strong>进程是容器</strong>：一个进程可以包含<strong>一个或多个线程</strong>。线程依赖于进程，不能独立存在。</li>
<li><strong>线程属于进程</strong>：线程是进程的一部分，所有线程共享该进程的资源，如代码段、数据段和打开的文件等。</li>
<li><strong>进程管理资源，线程执行任务</strong>：进程管理资源和环境，而线程负责实际计算和操作。</li>
</ol>
<h3 id="Why-Threads"><a href="#Why-Threads" class="headerlink" title="Why Threads?"></a>Why Threads?</h3><p>事实证明，您应该使用线程至少有两个主要原因。</p>
<p>第一个很简单：==并行性==。想象一下，您正在编写一个对非常大的数组执行操作的程序，例如，将两个大数组相加，或者将数组中每个元素的值增加一定量。如果仅在单个处理器上运行，则任务很简单：只需执行每个操作即可完成。 如果在具有多个处理器的系统上执行程序，则可以通过使用每个处理器执行一部分工作来显著加快此过程。将标准单线程程序转换为在多个 CPU 上执行此类工作的程序的任务称为并行化，并且使用每个 CPU 的线程来执行此工作是使程序运行的自然而典型的方法在现代硬件上速度更快。</p>
<p>第二个原因有点微妙：避免由于 I/O 缓慢而**==阻塞程序进度==**。想象一下，您正在编写一个执行不同类型 I/O 的程序：等待发送或接收消息、等待显式磁盘 I/O 完成，甚至（隐式）等待页面错误完成。您的程序可能不想等待，而是希望做其他事情，包括利用 CPU 执行计算，甚至发出进一步的 I/O 请求。使用线程是避免阻塞的自然方法；当程序中的一个线程等待时（即被阻塞等待 I/O），CPU 调度程序可以切换到其他线程，这些线程已准备好运行并执行一些有用的操作。线程允许 I/O 与单个程序中的其他活动重叠，就像多道程序设计对跨程序的进程所做的那样；因此，许多现代基于服务器的应用程序（Web 服务器、数据库管理系统等）在其实现中都使用了线程。</p>
<p>当然，在上述任何一种情况下，您都可以使用多个进程而不是线程。然而，**==线程共享地址空间==<strong>，因此可以轻松共享数据，因此是构建这些类型的程序时的自然选择，</strong>==线程更加轻量==**，切换成本没有那么高。对于逻辑上独立的任务来说，进程是一个更合理的选择，因为这些任务几乎不需要共享内存中的数据结构。</p>
<h3 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h3><p>一、不可控调度引发的问题：</p>
<ol>
<li>临界区(critical section): 多个任务共享的一片区域</li>
<li>竞态条件(race condition): 多个任务几乎同时读取一片区域，并做了修改，结果不符合预期</li>
<li>不确定性(indeterminate)：多个竞态条件组成程序，导致结果不确定</li>
<li>解决方案：注重原子性<ul>
<li>线程使用互斥(mutex exclusion)原语，保证同时只有一个任务进入临界区修改，避免竞态</li>
<li>原语：若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断</li>
<li>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192?fromModule=lemma_inlink">操作系统</a>中，某些被进程调用的操作，如队列操作、对信号量的操作、检查启动外设操作等，一旦开始执行，就不能被中断，否则就会出现操作错误，造成系统混乱。</li>
</ul>
</li>
</ol>
<p>二、任务之间应该如何唤醒对方？</p>
<h2 id="POSIX-Thread-API"><a href="#POSIX-Thread-API" class="headerlink" title="POSIX Thread API"></a>POSIX Thread API</h2><h3 id="Structured-“fork-join”-Parallelism"><a href="#Structured-“fork-join”-Parallelism" class="headerlink" title="Structured (“fork-join”) Parallelism"></a>Structured (“fork-join”) Parallelism</h3><h4 id="Compile-and-Run-pthread"><a href="#Compile-and-Run-pthread" class="headerlink" title="Compile and Run: -pthread"></a>Compile and Run: <code>-pthread</code></h4><p>在链接行上，您还必须通过添加 <code>-pthread</code> 标志来显式动态链接 pthreads 库。</p>
<p><code>prompt&gt; gcc -o thread thread.c -Wall -pthread</code> </p>
<p><code>prompt&gt; gcc thread.c -o thread -lpthread</code> </p>
<p>并且要在源码中加入 <code>pthread.h</code></p>
<h4 id="Creation-pthread-create"><a href="#Creation-pthread-create" class="headerlink" title="Creation: pthread_create()"></a>Creation: <code>pthread_create()</code></h4><p><code>create</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine)(<span class="type">void</span>*),</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数说明</strong>：<ul>
<li><code>thread</code> 是一个 <code>pthread_t</code> 类型的指针，也就是待初始化的线程指针</li>
<li><code>attr</code> 用来配置这个线程的属性，比如栈大小，线程调度优先级，默认可以为 <code>NULL</code></li>
<li><code>start_routine</code> 是函数指针,,前面是返回值类型，后面是参数类型及个数</li>
<li><code>void *</code> 可以代表任何类型的参数/返回值， <code>arg</code> 和 <code>start_routine</code> 参数类型一致</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; <span class="type">myarg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mythread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">myarg_t</span> *args = (<span class="type">myarg_t</span> *) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, args-&gt;a, args-&gt;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p;</span><br><span class="line">    <span class="type">myarg_t</span> args = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rc = pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, &amp;args);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只是创建一个传递两个参数的线程，并将其打包成我们自己定义的单个类型（<code>myarg t</code>）</p>
<p>线程一旦创建，就可以简单地将其参数转换为它期望的类型，从而根据需要解压参数。</p>
<p>创建线程后，您实际上拥有另一个实时的执行实体，具有自己的调用堆栈，与程序中所有当前现有线程在同一地址空间中运行。 </p>
<h4 id="Completion-pthread-join"><a href="#Completion-pthread-join" class="headerlink" title="Completion: pthread_join()"></a>Completion: <code>pthread_join()</code></h4><p><strong><code>join</code></strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **value_ptr)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数说明</strong>：<ul>
<li> <code>thread</code> 用于指定要等待哪个线程。该变量由线程创建例程初始化（当您将指向它的指针作为参数传递给 <code>pthread_create()</code> 时）；如果保留，则可以使用它等待线程终止。</li>
<li><code>value_ptr</code> 是指向 指向期望返回值的指针 的二级指针，因为还没返回，只能传进去一个指针变量，<code>join</code>修改指针就需要传二级指针</li>
</ul>
</li>
</ul>
<p>Usage: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">int</span> a; <span class="type">int</span> b; &#125; <span class="type">myarg_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">int</span> x; <span class="type">int</span> y; &#125; <span class="type">myret_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mythread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里用的是包装函数，首字母大写，用来应对可能发生的异常</span></span><br><span class="line">    <span class="type">myret_t</span> *rvals = Malloc(<span class="keyword">sizeof</span>(<span class="type">myret_t</span>));</span><br><span class="line">    rvals-&gt;x = <span class="number">1</span>;</span><br><span class="line">    rvals-&gt;y = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) rvals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p;</span><br><span class="line">    <span class="type">myret_t</span> *rvals;</span><br><span class="line">    <span class="type">myarg_t</span> args = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line">    <span class="comment">// 这里用的是包装函数，首字母大写，用来应对可能发生的异常</span></span><br><span class="line">    Pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, &amp;args);</span><br><span class="line">    Pthread_join(p, (<span class="type">void</span> **) &amp;rvals);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;returned %d %d\n&quot;</span>, rvals-&gt;x, rvals-&gt;y);</span><br><span class="line">    <span class="built_in">free</span>(rvals);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，再次创建单个线程，并通过 <code>myarg_t</code> 结构传递几个参数。要返回值，请使用 <code>myret_t</code> 类型。一旦线程完成运行，一直在 <code>pthread_join()</code> 例程1内等待的主线程就会返回，我们可以访问从线程返回的值，即 <code>myret_t</code> 中的任何内容。 </p>
<p>关于这个例子有几点需要注意：</p>
<ol>
<li><p>首先，很多时候我们不必进行所有这些痛苦的参数打包和拆包。例如，如果我们只是创建一个不带参数的线程，则可以在创建线程时将 <code>NULL</code> 作为参数传入。类似地，如果我们不关心返回值，我们可以将 <code>NULL</code> 传递给 <code>pthread_join()</code>。</p>
</li>
<li><p>```c<br>void *mythread(void *arg) {</p>
<pre><code>long long int value = (long long int) arg;
printf(&quot;%lld\n&quot;, value);
return (void *) (value + 1);
</code></pre>
<p>}<br>int main(int argc, char *argv[]) {</p>
<pre><code>pthread_t p;
long long int rvalue;
Pthread_create(&amp;p, NULL, mythread, (void *) 100);
Pthread_join(p, (void **) &amp;rvalue);
printf(&quot;returned %lld\n&quot;, rvalue);
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   如上图，如果我们只是传递单个值（例如，`long long int`），则不必将其打包为参数。在这种情况下，我们不必将参数和返回值打包在结构体内部。  </span><br><span class="line"></span><br><span class="line">3. ```c</span><br><span class="line">   void *mythread(void *arg) &#123;</span><br><span class="line">       myarg_t *args = (myarg_t *) arg;</span><br><span class="line">       printf(&quot;%d %d\n&quot;, args-&gt;a, args-&gt;b);</span><br><span class="line">       myret_t oops; // ALLOCATED ON STACK: BAD!</span><br><span class="line">       oops.x = 1;</span><br><span class="line">       oops.y = 2;</span><br><span class="line">       return (void *) &amp;oops;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如上图，必须非常小心线程的返回值，永远不要**<u>返回指向线程栈上分配的内容的指针</u>**，因为栈随着函数返回，空间也会自动释放，<code>oops</code>返回的指针指向的是一片不确定区域。</p>
</li>
<li><p>这种 fork-join 式的多线程编程方式是较为普遍的结构化编程方法。但我们应该注意，并非所有多线程代码都使用 <code>join</code> 例程。例如，多线程 Web 服务器可能会创建多个工作线程，然后使用主线程无限期地接受请求并将它们传递给工作线程。因此，此类长期计划可能不需要加入。然而，创建线程来执行特定任务（并行）的并行程序可能会使用 <code>join</code> 来确保所有此类工作在退出或进入下一个计算阶段之前完成。</p>
</li>
</ol>
<h4 id="Mutex-lock-unlock"><a href="#Mutex-lock-unlock" class="headerlink" title="Mutex: lock() unlock()"></a>Mutex: <code>lock()</code> <code>unlock()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;  <span class="comment">// lock is here</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);  <span class="comment">// LOCK</span></span><br><span class="line">... <span class="comment">// critical section</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);<span class="comment">// UNLOCK</span></span><br></pre></td></tr></table></figure>

<p>整体结构如上，但是缺乏正确的初始化和各种细节：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;<span class="comment">// 宏，设置为默认的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rc = pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">assert(rc == <span class="number">0</span>); <span class="comment">// always check success!</span></span><br><span class="line">Pthread_mutex_lock(lock);</span><br><span class="line">...</span><br><span class="line">Pthread_mutex_unlock(lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keeps code clean; only use if exit() OK upon failure 包装</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rc = pthread_mutex_lock(mutex);</span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t)</code>: <ul>
<li><code>pthread_mutexattr_t</code>: 具体的参数设置，可以使用 <code>NULL</code> 作为缺省选项</li>
</ul>
</li>
<li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex)</code>: <ul>
<li>销毁一个已经初始化但未上锁的互斥锁是安全的。</li>
<li>使用完锁资源需要释放 (RAII 的思想) ，只能是被释放，不再被争抢，不再被需要时才可以</li>
</ul>
</li>
</ul>
<p>改进：增加适当的检测错误机制，健壮的程序需要能够应对调用失败的情况（断言）</p>
<p><strong>还有其他与锁交互的例程</strong>：</p>
<ul>
<li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex)</code> 只尝试一次，non-blocking</li>
<li><code>int pthread_mutex_timedlock(pthread_mutex_t *mutex, timespec *tsptr)</code> 尝试一段时间，如果等一段时间获取不到锁就直接返回 <code>ETIMEOUT</code> </li>
</ul>
<h4 id="Condition-Variables-wait-signal"><a href="#Condition-Variables-wait-signal" class="headerlink" title="Condition Variables: wait() signal()"></a>Condition Variables: <code>wait()</code> <code>signal()</code></h4><h5 id="Thread-Interaction"><a href="#Thread-Interaction" class="headerlink" title="Thread Interaction"></a>Thread Interaction</h5><p><code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)</code></p>
<ul>
<li>使调用的线程休眠，等待唤醒(通常是在程序中的某些内容发生更改，使某个条件发生了变化，而使得 wait 处于的 while 循环条件发生了变化)</li>
<li>您可能会注意到等待调用将 <code>mutex</code> 作为其第二个参数，而 <code>signal</code> 不需要。造成这种差异的原因是 wait 调用除了使调用线程进入睡眠状态之外，还使调用者进入睡眠状态时释放锁。<ul>
<li>进入 wait 状态就会自动 release mutex。当其他线程通过<code>pthread_cond_signal()</code>或<code>pthread_cond_broadcast</code>，把该线程唤醒，之后需要重新获取 mutex 来进行之后的操作</li>
<li>1.将线程加入等待队列 2.将线程持有的锁先释放 这两个步骤必须是原子的</li>
</ul>
</li>
<li>被唤醒之后，从<code>wait</code>返回之前，还应该重新获取锁，防止竞态条件的发生</li>
</ul>
<p><code>int pthread_cond_signal(pthread_cond_t *cond)</code> </p>
<ul>
<li>一旦条件满足，**<code>pthread_cond_signal</code>** 函数可以被用来唤醒至少一个等待该条件(ready ==0)的线程，如果有多个线程阻塞在条件变量上，它们被唤醒的顺序由调度策略决定。</li>
<li>如果没有线程在条件变量上阻塞，调用 <strong><code>pthread_cond_signal</code></strong> ==将不会有任何效果==。</li>
<li>在实际应用中，**<code>pthread_cond_signal</code>** 通常用于<strong>生产者-消费者</strong>问题，其中生产者在添加了新项目后会通知消费者线程。此外，它也用于实现读写锁，以及在两阶段提交算法中通知所有客户端即将提交事务。</li>
<li><code>pthread_cond_broadcast()</code> 用于唤醒当前全部等待的线程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">int</span> ready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合特定条件，进入睡眠</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;<span class="comment">//循环检查条件	</span></span><br><span class="line">    	pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行当条件满足时的操作</span></span><br><span class="line">    execute_task();</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************************************************/</span></span><br><span class="line"><span class="comment">// 改变条件之后，唤起正在等待的线程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_condition</span><span class="params">()</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    </span><br><span class="line">    ready = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Simple-Flags"><a href="#Simple-Flags" class="headerlink" title="Simple Flags"></a>Simple Flags</h5><p>请注意，有时很容易使用简单的标志在两个线程之间发出信号，而不是使用条件变量和关联的锁。 例如，我们可以重写上面的等待代码，使其在等待代码中看起来更像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait code:</span></span><br><span class="line"><span class="keyword">while</span> (ready == <span class="number">0</span>)</span><br><span class="line">; <span class="comment">// spin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// notify code:</span></span><br><span class="line">ready = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>永远不要这样做，原因如下</strong>:</p>
<p>首先，它在很多情况下表现不佳（长时间自旋浪费 CPU 周期）。</p>
<p>其次，容易出错。正如最近的研究表明 ，使用 FLAG 在线程之间进行同步时非常容易出错；在那项研究中，这些临时同步的使用中大约有一半是有问题的！不要偷懒；即使您认为不这样做也可以逃脱，也要使用条件变量。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul>
<li><p>Keep simple. 任何在线程之间锁定或发出信号的代码都应该尽可能简单，避免复杂的线程交互</p>
</li>
<li><p><strong>最大限度减少线程交互方式</strong>，尝试将线程交互方式的数量保持在最低限度</p>
</li>
<li><p><strong>初始化</strong>锁和条件变量 (mutex and condition variables) <code>INITIALIZER</code></p>
</li>
<li><p>始终<strong>使用条件变量</strong>在线程之间发出信号。虽然使用简单的 <strong>FLAG</strong> 通常很诱人，但不要这样做</p>
</li>
<li><p>检查函数的<strong>返回码</strong>，比如断言失败导致的返回码会异常</p>
</li>
<li><p>如何向线程传递参数以及线程的返回值。比如<strong>不要返回 指向栈上变量的指针</strong> </p>
</li>
<li><p>每个线程都有<strong>自己的栈</strong>。如果线程正在执行的某个函数内部有一个局部分配的变量，那么它本质上是该<strong>线程私有</strong>的(Thread-Local)；没有其他线程可以（轻松）访问它。要在线程之间共享数据，值必须位于<strong>堆</strong>中或其他可全局访问的区域设置中。  </p>
</li>
</ul>
<h1 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h1><p>锁——程序员在 OS 调度的基础上实现对调度的最小控制，使调度的混乱状态变得更加可控</p>
<h2 id="Efficient-Lock"><a href="#Efficient-Lock" class="headerlink" title="Efficient Lock"></a>Efficient Lock</h2><ol>
<li>最基本的互斥(<strong>mut</strong>ual <strong>ex</strong>clusion)：能否在 OS 调度下，阻止多个线程同时进入临界区？</li>
<li>公平性(fairness)：是否会有线程始终无法竞争到锁(starvation)?</li>
<li>性能(performance)：在有竞争与没有竞争的情况下，抢锁、释放锁的开支如何？</li>
</ol>
<h2 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations"></a>Implementations</h2><ul>
<li>完全由软件实现的锁（✕）</li>
<li>硬件支持有更强大的原子指令 + 操作系统调用支持（✓）</li>
</ul>
<h3 id="Control-Interrupts"><a href="#Control-Interrupts" class="headerlink" title="Control Interrupts"></a>Control Interrupts</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">	DisableInterrupts();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">	EnableInterrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁：关中断</p>
<p>释放锁：开中断</p>
<ul>
<li><p>优点：实现简单，操作系统本身可能会采用这种方式保证访问自己数据结构的原子性</p>
</li>
<li><p>缺点</p>
</li>
</ul>
<ol>
<li>性能开销大：开关中断的指令耗时较长</li>
<li>丢失中断：关中断导致一些中断没有及时被 CPU 接收</li>
<li>调度失效：恶意程序一直运行，而时钟中断被屏蔽，操作系统的抢占式调度失效</li>
</ol>
<h3 id="Spin-Locks"><a href="#Spin-Locks" class="headerlink" title="Spin Locks"></a>Spin Locks</h3><h4 id="Set-flag-after-check"><a href="#Set-flag-after-check" class="headerlink" title="Set flag after check"></a>Set flag <strong>after</strong> check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span> <span class="type">int</span> flag; &#125; <span class="type">lock_t</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="comment">// 0 -&gt; lock is available, 1 -&gt; held</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LOCK GAIN</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (mutex-&gt;flag == <span class="number">1</span>) <span class="comment">// TEST the flag</span></span><br><span class="line">    	; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">1</span>; <span class="comment">// now SET it!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是简单的 flag 实现的，先检验 FLAG 是否为 1，如果不是就将其设置为 1，否则就自旋等待</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241222220609945.png" alt="image-20241222220609945"></p>
<p>线程1第一次检验到锁是空闲的，于是想将flag设为1，但与此同时也已耗尽时间片，切换到线程2以后线程2依然试图获取锁，结果获取成功，耗尽时间片回到线程1，线程1竟然也成功获取到了锁！</p>
<h4 id="Test-and-Set-TAS"><a href="#Test-and-Set-TAS" class="headerlink" title="Test-and-Set(TAS)"></a>Test-and-Set(<strong>TAS)</strong></h4><p>导致失败的主要原因是检验Test与赋值Set这两个操作并不是原子化的，会出现只执行一半的情况</p>
<p>因此应该改进锁的实现，使用一个硬件原语：TAS(Atomic Exchange)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">int</span> *old_ptr, <span class="type">int</span> new)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old = *old_ptr; <span class="comment">// fetch old value at old_ptr</span></span><br><span class="line">    *old_ptr = new; <span class="comment">// store ’new’ into old_ptr</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">// return the old value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">		; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>TestAndSet()</code> 是一个原子命令，功能是：获取旧值，将其设置为新值，然后返回旧值。这三个一定会在一次操作内完成。如果检测到锁被占用，就会<strong>自旋</strong>等待，一旦锁被释放，检测返回值为0的同时将其设置为1，成功获取锁，原子命令要么全部成功要么全部失败。自旋锁（spin lock）需要抢占式调度，通过时钟进行线程的中断。</p>
<h4 id="CAS-LL-SC-and-FAA"><a href="#CAS-LL-SC-and-FAA" class="headerlink" title="CAS, LL-SC and FAA"></a><strong>CAS</strong>, LL-SC and FAA</h4><p><strong>Compare-And-Swap(CAS)</strong></p>
<p>x86 中也叫 Compare-And-Exchange(cmpxchg)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> expected, <span class="type">int</span> new)</span>&#123;</span><br><span class="line">	<span class="type">int</span> actual = *ptr;</span><br><span class="line">	<span class="keyword">if</span> (actual == expected)&#123;</span><br><span class="line">		*ptr = new;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> actual;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Load-Linked, Store-Conditional(LL-SC)</strong></p>
<p>MIPS, PowerPC, Alpha, ARM 都有类似功能的指令</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Load_Linked(address): <span class="comment">// 读取某地址的值并将该地址标记为“保留地址”</span></span><br><span class="line">    value ← *address          <span class="comment">// 从地址中加载值</span></span><br><span class="line">    LL_reserved ← address      <span class="comment">// 设置保留的地址</span></span><br><span class="line">    <span class="keyword">return</span> value               <span class="comment">// 返回加载的值</span></span><br><span class="line">    </span><br><span class="line">Store_Conditional(address, value): </span><br><span class="line"><span class="comment">// 尝试将值存入地址，但前提是自 LL 设置保留后，该地址未被其他线程修改。</span></span><br><span class="line">    <span class="keyword">if</span> (LL_reserved == address) then  <span class="comment">// 检查是否仍然保留该地址</span></span><br><span class="line">        *address ← value              <span class="comment">// 将值存储到地址中</span></span><br><span class="line">        LL_reserved ← NULL            <span class="comment">// 清除保留状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>                      <span class="comment">// 存储成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>                      <span class="comment">// 存储失败</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(LL(&amp;lock-&gt;flag) == <span class="number">1</span>);  <span class="comment">// 首先加载当前值并标记保留</span></span><br><span class="line">                 ; <span class="comment">//spin-wait</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (SC(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">0</span>);  <span class="comment">// 如果存储失败，则重试</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_boolean_short_circuiting</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(LL(&amp;lock-&gt;flag) || !SC(&amp;lock-&gt;flag, <span class="number">1</span>))  </span><br><span class="line">                 ; <span class="comment">//spin-wait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>A 和 B 都执行 <strong>LL</strong>，地址相同，但状态保存在各自寄存器中。</li>
<li>假设 A 先执行 <strong>SC</strong> 并成功，硬件会==清除== B 的保留状态。</li>
<li>B 执行 <strong>SC</strong> 时发现状态无效，返回失败并进入重试。</li>
</ol>
<p><strong>Fetch-and-Add(FAA)</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FAA(address):</span><br><span class="line">    old_value = *address             <span class="comment">// 读取当前值</span></span><br><span class="line">    *address = old_value + <span class="number">1</span>         <span class="comment">// 增加指定值</span></span><br><span class="line">    <span class="keyword">return</span> old_value                 <span class="comment">// 返回旧值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> ticket;<span class="comment">//初始化为0</span></span><br><span class="line">    <span class="type">int</span> turn;<span class="comment">//初始化为0</span></span><br><span class="line">&#125; <span class="type">lock_t</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">    <span class="type">int</span> myturn = FAA(&amp;lock-&gt;ticket);</span><br><span class="line">	<span class="keyword">while</span>(lock-&gt;turn != myturn)</span><br><span class="line">		;   <span class="comment">// spin-wait	</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">    FAA(&amp;lock-&gt;turn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>每个线程通过 <strong>FAA</strong> 获取一个唯一的排队号 (<strong>myturn</strong>)。</li>
<li>当前服务号 (<strong>ticket</strong>)表示哪个线程正在被服务。</li>
<li>线程不断检查自己的排队号是否等于当前服务号，只有匹配时才能获得锁。</li>
<li>解锁时，将服务号递增，以便下一个线程继续执行。</li>
<li>特性：实现了<strong>公平性</strong>，每个线程最终都有机会被服务，类似排队机制，按照来的先后顺序排队</li>
</ol>
<h4 id="Evaluating-Spin-Locks"><a href="#Evaluating-Spin-Locks" class="headerlink" title="Evaluating Spin Locks"></a>Evaluating Spin Locks</h4><ol>
<li><strong>正确性</strong>: 能够实现最基本的互斥功能，不会被操作系统的调度影响</li>
<li><strong>公平性</strong>: 实际上并不能保证一个竞争的线程一定能够拿到锁，可能会有饥饿的现象发生</li>
<li><strong>性能</strong>: 单核性能差，只有一个执行的单位，如果一个获取锁的线程刚进入临界区就被抢占，那么直到此线程再次被调度之前，其他的等待者必须轮流自旋一整个时间片；而多核环境下，由于是各个线程物理上并行执行(parallel)，因此获取到锁的线程很快就会执行完并释放锁给别人。</li>
</ol>
<h5 id="Priority-Inversion"><a href="#Priority-Inversion" class="headerlink" title="Priority Inversion"></a>Priority Inversion</h5><p>自旋锁适合<strong>短时间的临界区操作</strong>，但不适合长时间持有锁的场景。在等待锁释放时，线程会<strong>忙等待（busy-waiting）</strong>，一直循环检查锁状态，而不会主动放弃 CPU。</p>
<p><strong>高优先级线程 A</strong>：需要自旋锁资源。</p>
<p><strong>低优先级线程 C</strong>：当前持有自旋锁资源。</p>
<p><strong>中优先级线程 B</strong>：占用 CPU 时间，导致 C 无法执行。</p>
<ol>
<li><strong>C 获得锁</strong>并进入临界区，但是此时被更高优先级的 A 抢占。</li>
<li><strong>A 尝试获取锁</strong>，但由于 C 持有锁，A 进入自旋状态忙等待。</li>
<li><strong>B 开始运行</strong>，其优先级高于 C，导致 C 仍然无法继续执行，因此也无法释放锁。</li>
<li><strong>A 等待 C 释放锁，但 C 被 B 抢占</strong> </li>
<li><strong>结果：高优先级的 A 无法执行，但是更低优先级的 B 反而能够顺利执行，优先级反转发生。</strong></li>
</ol>
<p><strong>解决方案：</strong></p>
<p><strong>(1) 优先级继承机制</strong>(Priority inheritance)</p>
<ul>
<li><strong>原理：</strong> 当低优先级线程持有锁，而高优先级线程请求锁时，系统会<strong>临时提高低优先级线程的优先级</strong>到高优先级线程的级别。</li>
<li><strong>效果：</strong> 确保低优先级线程尽快运行并释放锁，防止高优先级线程长期等待。</li>
<li><strong>应用：</strong> 常用于<strong>互斥锁 (mutex)</strong> 中，但自旋锁通常不支持该机制。</li>
</ul>
<p><strong>(2) 使用互斥锁替代自旋锁</strong></p>
<ul>
<li><strong>互斥锁会主动挂起等待线程</strong>，释放 CPU 给其他任务，提高资源调度效率。</li>
<li>适合可能存在较长等待时间的临界区操作，避免忙等待浪费资源。</li>
</ul>
<p><strong>(3) 控制自旋时间或自旋次数</strong></p>
<ul>
<li>设置自旋锁的最大等待时间或循环次数，超过后将线程挂起，而不是一直忙等待。</li>
<li>在 Linux 内核中，可通过**<code>spin_trylock()</code><strong>或</strong>自旋锁超时机制**控制。</li>
</ul>
<p><strong>(4) 避免中间优先级线程干扰，或取消优先级差异</strong></p>
<h3 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h3><h4 id="Yield"><a href="#Yield" class="headerlink" title="Yield"></a>Yield</h4><p>改进自旋锁：如果获取不到锁就立即让出 CPU (yield)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">	flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (TestAndSet(&amp;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">		yield(); <span class="comment">// give up the CPU</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">	flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>: <strong>容易受操作系统的调度影响</strong>，可能导致有线程被饿死，并且如果锁的拥有者在进入临界区之后被调度走，其他程序必须反复执行 运行-&gt;让出 的循环，上下文切换成本也不容忽视</p>
<h4 id="Queue-amp-Park-Solaris"><a href="#Queue-amp-Park-Solaris" class="headerlink" title="Queue &amp; Park(Solaris)"></a>Queue &amp; Park(Solaris)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="type">int</span> guard;</span><br><span class="line">    <span class="type">queue_t</span> *q;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line">    m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    		; <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">        m-&gt;flag = <span class="number">1</span>; <span class="comment">// lock is acquired</span></span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue_add(m-&gt;q, gettid());</span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">        park(); <span class="comment">// sleep here!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    		; <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">        m-&gt;flag = <span class="number">0</span>; <span class="comment">// let go of lock; no one wants it</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(queue_remove(m-&gt;q)); <span class="comment">// hold lock</span></span><br><span class="line">    								<span class="comment">// (for next thread!)</span></span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁外面套了一层 guard 锁，基本思想是，既然不能直接休眠，那就尽量减小自旋等待的范围，原来需要反复自旋获取 flag 锁，并且临界区是整个lock到unlock的区域，现在只需要先自旋获取 guard，临界区只需要获取锁(flag 设置为 1)或者休眠等待锁的释放(唤醒后直接返回，意为锁被上一个线程让了出来)</p>
<p><strong>加锁逻辑</strong>：</p>
<ul>
<li>自旋等待获取 <code>guard</code> </li>
<li>获取 <code>guard</code> 之后，如果 <code>flag</code> 未被占用，则直接获取 lock；</li>
<li>如果 <code>flag</code> 被占用，此时不要直接放弃，而是将自己加入等待队列中，释放 <code>guard</code>，并将自己休眠。先休眠后释放一定会造成死锁</li>
</ul>
<p><strong>释放锁逻辑</strong>：（可控调度的关键）</p>
<ul>
<li><p>自旋等待获取 <code>guard</code> </p>
</li>
<li><p>获取 <code>guard</code> 之后，如果队列为空，直接将 lock 释放，因为没有人正在等待                                                                                               </p>
</li>
<li><p><strong>如果队列不为空，唤醒队头线程，不能将 lock 释放，因为要为下一个要执行的线程保管好锁</strong></p>
</li>
<li><p>被唤醒的线程之前一直阻塞在 <code>park()</code> ，被唤醒之后依然符合 <code>flag == 1</code> 的条件，直接返回，进入临界区。</p>
<ul>
<li><p><code>wakeup race</code>: 如果在 <code>park()</code> 之前切换到了另一个线程（例如，持有锁的线程）可能会导致麻烦，例如，如果该线程随后释放了锁，就会试图唤醒队头线程并FIFO，但是此时线程并没有处于休眠状态，因此唤醒信号丢失，这个线程将永远挂起</p>
</li>
<li><p><strong>解决方案</strong>：Solaris 通过添加第三个系统调用来解决此问题：<code>setpark()</code> 通过调用此例程，线程A可以指示它即将停止(about to park)。如果A随后恰好被中断，并且另一个线程B在A实际调用 park 之前调用了 unpark，则后续 park 会立即返回而不是 sleep</p>
</li>
<li><p>```c<br>void lock(lock_t *m) {</p>
<pre><code>while (TestAndSet(&amp;m-&gt;guard, 1) == 1)
        ; //acquire guard lock by spinning
if (m-&gt;flag == 0) &#123;
    m-&gt;flag = 1; // lock is acquired
    m-&gt;guard = 0;
&#125; else &#123;
    queue_add(m-&gt;q, gettid());
    setpark(); // be about to sleep, ready to receive SIGWAKEUP
    m-&gt;guard = 0; // release guard
    park(); // return immediately if received SIGWAKEUP
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 最后返回之前将 `guard` 释放</span><br><span class="line"></span><br><span class="line">也可以将 guard 放入内核中，这样就能保持原子的释放</span><br><span class="line"></span><br><span class="line">#### **Futex**(Linux)</span><br><span class="line"></span><br><span class="line">Linux 提供了一个类似于 Solaris 接口的 futex(**F**ast **U**serspace mu**TEX**)，但提供更多 in-kernel 功能。具体来说，每个 futex 与特定的物理内存位置以及每个 futex 内核队列相关联（**SLAB Allocator**）</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">void mutex_lock (int *mutex) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    // Bit 31 was clear(0), we got the mutex (fastpath, no SYSCALL)</span><br><span class="line">    // Set bit 31 to 1, variable mutex is negative now </span><br><span class="line">    if (atomic_bit_test_set (mutex, 31) == 0)</span><br><span class="line">    	return;</span><br><span class="line">    // Not free </span><br><span class="line">    atomic_increment (mutex);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // If bit 31 is still 0, there is no contention, acquire the mutex</span><br><span class="line">        if (atomic_bit_test_set (mutex, 31) == 0) &#123;</span><br><span class="line">            atomic_decrement (mutex);</span><br><span class="line">            return;</span><br><span class="line">    	&#125; </span><br><span class="line">        /* </span><br><span class="line">        	First to make sure futex value</span><br><span class="line">        	we are monitoring is negative (locked).</span><br><span class="line">        */ </span><br><span class="line">        v = *mutex;</span><br><span class="line">        if (v &gt;= 0)</span><br><span class="line">            continue;</span><br><span class="line">        futex_wait (mutex, v);// immediately return if v!= *mutex</span><br><span class="line"> 							  // otherwise sleep	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mutex_unlock (int *mutex) &#123;</span><br><span class="line">    /* Adding 0x80000000 to counter results in 0 if and</span><br><span class="line">       only if there are not other interested threads </span><br><span class="line">       returns (new_mutex == 0)*/</span><br><span class="line">    if (atomic_add_zero (mutex, 0x80000000))</span><br><span class="line">    	return;</span><br><span class="line"></span><br><span class="line">    // There are other threads waiting for this mutex,</span><br><span class="line">    // wake one of them up.</span><br><span class="line">    futex_wake (mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>它使用单个整数来跟踪锁是否被持有（整数最高位）以及锁上的等待者数量（所有其他位）。 如果整数为负，则保持该锁定（因为设置了高位，并且该位确定整数的符号）</p>
<p>加锁：</p>
<ol>
<li>整数的最高位用来标记锁是否被占用，其余位用来标记等待者数量</li>
<li>如果获取锁失败，说明锁被占用，则低位自增，等待者 + 1</li>
<li>随后再次尝试获取锁（spin for one time，Phase 1）<ul>
<li>如果成功，则低位自减，等待者 - 1</li>
<li>如果失败，即将进入下个阶段(Phase 2)</li>
</ul>
</li>
<li>再次检查锁的状态（避免竞态条件，如果在这期间锁被释放就应该重新尝试获取锁）</li>
</ol>
<p>解锁：</p>
<ol>
<li>检测低位等待者的同时，清除最高位，如果结果不为0，则返回false</li>
<li>false，唤醒等待的线程</li>
</ol>
</blockquote>
<blockquote>
<p><strong>Function Signature</strong>: <code>int futex_wait(int *uaddr, int val)</code></p>
<p><strong>Purpose</strong>: If the <strong>futex word</strong> equals to <strong>val</strong>, the thread is put to sleep. The thread remains asleep until another thread calls <code>futex_wake</code> on the same futex word, signaling that the condition has changed.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>uaddr</code>: Pointer to the futex word in user space.</li>
<li><code>val</code>: The expected value of the futex word.</li>
</ul>
<p><strong>Return Value</strong>: Returns 0 on success, or an error code on failure.</p>
</blockquote>
<blockquote>
<p><strong>Function Signature</strong>: <code>int futex_wake(int *uaddr, int val)</code></p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>uaddr</code>: Pointer to the futex word in user space.</li>
<li><code>val</code>: The number of threads to wake up.</li>
</ul>
<p><strong>Return Value</strong>: Returns the number of threads that were woken up, or an error code on failure.</p>
</blockquote>
<blockquote>
<p><strong>Function Signature</strong>: <code>int atomic_bit_test_set(int *ptr, int bit)</code></p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>ptr</code>: Pointer to the integer variable.</li>
<li><code>bit</code>: The bit position to be tested and set.</li>
</ul>
<p><strong>Return Value</strong>: Returns the previous value of the bit (0 or 1).</p>
</blockquote>
<blockquote>
<p><strong>Function Signature</strong>: <code>bool atomic_add_zero(int *ptr, int value)</code></p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>ptr</code>: Pointer to the integer variable.</li>
<li><code>value</code>: Value to be added.</li>
</ul>
<p><strong>Return Value</strong>: Returns <code>true</code> if the result is zero, otherwise <code>false</code>.</p>
</blockquote>
<p>一般来说，内核态同步机制需要调用系统调用，来确保只有一个线程能进入互斥区，但如果根本没有竞争对象，则系统调用浪费了性能。</p>
<p>Futex 是一种用户态和内核态混合的同步机制。首先，同步的进程间通过 mmap <strong>共享一段内存</strong>，futex 变量就位于这段共享的内存中，且操作是原子的，当进程尝试进入互斥区<code>lock()</code>或者退出互斥区<code>unlock()</code>的时候，先去查看共享内存中的 futex 变量，如果没有竞争发生，则只修改 futex，而不用再执行系统调用了。当通过访问 futex 变量告诉进程有竞争发生，则还是得执行系统调用去完成相应的处理（<code>wait</code> 或者 <code>wake</code>）</p>
<p>简单的说，futex 就是通过在用户态的检查，如果了解到当前没有竞争就不用陷入内核了，大大提高了低竞争情况下的效率。</p>
<p>假设地址处的值等于预期，对 <code>futex_wait(address,expected) </code>的调用将使调用线程进入睡眠状态。如果不相等，则调用立即返回。对例程 <code>futex_wake(address)</code> 的调用会唤醒正在队列中等待的一个线程。</p>
<ol>
<li><p>Futex 变量的特征：</p>
<p>1）位于共享的用户空间中；</p>
<p>2）是一个32位的整型；</p>
<p>3）对它的操作是原子的。</p>
</li>
<li><p>Futex 在程序 low-contention 的时候能获得比传统同步机制更好的性能。</p>
</li>
<li><p>不要直接使用 Futex 系统调用。</p>
</li>
<li><p>Futex 同步机制可以用于进程间同步，也可以用于线程间同步。</p>
</li>
</ol>
<h5 id="Two-Phase-Locks"><a href="#Two-Phase-Locks" class="headerlink" title="Two-Phase Locks"></a>Two-Phase Locks</h5><p>两阶段锁中，自旋被看作可能很有用，特别是在锁即将被释放的情况下。在 Phase 1，会自旋一段时间，希望能够获取到锁。 如果在 Phase 1 没有获取锁，则进入 Phase 2，调用者将进入睡眠状态，只有在锁稍后释放时才会被唤醒。</p>
<p>上面的 Linux Futex 实现的 Mutex 就是这种锁的一种形式，但它只<strong>自旋一次</strong>；更常见的是在循环中自旋固定的（fixed）次数</p>
<h2 id="Thread-Safe-Data-Structures"><a href="#Thread-Safe-Data-Structures" class="headerlink" title="Thread-Safe Data Structures"></a>Thread-Safe Data Structures</h2><h3 id="Concurrent-Counter"><a href="#Concurrent-Counter" class="headerlink" title="Concurrent Counter"></a>Concurrent Counter</h3><p><strong>Basic Mutex</strong></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241224125018845.png" alt="image-20241224125018845"></p>
<p>简单给访问临界区加锁完全能够保证绝对的线程安全(thread safe)，但是锁的开销非常大</p>
<p><strong>Scalable Counting</strong></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241224134929698.png" alt="image-20241224134929698"></p>
<p>近似计数器：每个CPU有一个局部计数器(local)，所有CPU共享一个全局计数器(global)，局部计数器加到全局计数器上的时候才加给全局计数器加锁，这就显著减少了加锁解锁的次数。</p>
<p>另外，局部锁也是需要的，因为我们假设每个核心上可能有多个线程。相反，如果每个核心上仅运行一个线程，则不需要局部所锁。</p>
<p>为了使全局计数器保持最新（如果线程希望读取其值），通过获取全局锁并将其增加局部计数器的值，局部值会定期传输到全局计数器；然后局部计数器归零。 这种局部到全局传输发生的频率由阈值 S 决定，当局部计数器达到 S 就向全局计数器写入。S 越小，计数器的行为就越像上面的不可扩展计数器； S 越大，计数器的可扩展性就越高，但全局值可能与实际计数相差越远。人们可以简单地获取所有局部锁和全局锁（以指定的顺序，以避免死锁）来获得精确的值，但这是不可扩展的：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241224135017601.png" alt="image-20241224135017601"></p>
<p>图 29.6 显示了阈值 S 的重要性，其中有四个线程，每个线程在四个 CPU 上将计数器递增 100 万次。如果 S 较低，则性能较差（但全局计数总是相当准确）； 如果 S 较高，则性能出色，但全局计数滞后（最多为 CPU 数量乘以 S）。这种准确性/性能权衡正是近似计数器所实现的。</p>
<h3 id="Concurrent-Linked-List"><a href="#Concurrent-Linked-List" class="headerlink" title="Concurrent Linked List"></a>Concurrent Linked List</h3><p><strong>Basic Mutex</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic list structure (one used per list)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">list_t</span> &#123;</span><span class="type">node_t</span> *head; <span class="type">pthread_mutex_t</span> lock;&#125; <span class="type">list_t</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">List_Insert</span><span class="params">(<span class="type">list_t</span> *L, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">node_t</span> *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (new == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// fail</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    new-&gt;key = key;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);  <span class="comment">// lock</span></span><br><span class="line">    new-&gt;next = L-&gt;head;</span><br><span class="line">    L-&gt;head = new;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);<span class="comment">// unlock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">List_Lookup</span><span class="params">(<span class="type">list_t</span> *L, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rv = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="type">node_t</span> *curr = L-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;key == key) &#123;</span><br><span class="line">            rv = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock); <span class="comment">// failure</span></span><br><span class="line">	<span class="keyword">return</span> rv; <span class="comment">// rv = -1: </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>尽量缩小锁涵盖的范围（临界区大小）如果没有涉及到访问共享区域的就不要纳入范围</li>
<li>使用单一返回路径，减少代码中需要获取、释放锁的地方，降低了返回前忘记释放锁的可能</li>
</ul>
<p><strong>Lock and Control flow</strong>：</p>
<p>在并发编程中，函数通常在开始时获取锁或分配资源、更改状态。如果发生错误，函数必须在退出之前释放锁或释放资源。这个过程很容易出错，因为它需要仔细管理状态。为了避免这些问题，最好以一种尽量<strong>减少撤消状态更改</strong>的方式构建代码。这可以通过以下方式实现：</p>
<ul>
<li><strong>集中错误处理</strong>：谨慎处理导致函数返回、退出或其他停止执行的错误情况的更改，在函数中使用单个退出点来处理所有清理操作。 </li>
<li><strong>最小化模式</strong>：构造代码以尽量减少撤消状态更改的需要，从而降低出错风险。</li>
<li><strong>避免过早返回</strong>：减少函数中的返回语句数量，以确保执行所有必要的清理。 </li>
<li><strong>使用 RAII（资源获取即初始化）</strong>：在支持它的语言中，使用 RAII 自动管理资源。 </li>
</ul>
<p><strong>Hand-over-hand Locking</strong>: </p>
<p>每个节点都有一个锁，替代之前链表的整个链表一个锁，遍历链表时首先抢占下一个节点的锁，然后释放当前节点的锁，一定程度上增加了链表的并发能力，但是开销很大，</p>
<h3 id="Concurrent-Queue"><a href="#Concurrent-Queue" class="headerlink" title="Concurrent Queue"></a>Concurrent Queue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">queue_t</span> &#123;</span></span><br><span class="line">	<span class="type">node_t</span> *head; <span class="type">node_t</span> *tail; </span><br><span class="line">    <span class="type">pthread_mutex_t</span> head_lock, tail_lock;</span><br><span class="line">&#125;<span class="type">queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue_Init</span><span class="params">(<span class="type">queue_t</span> *q)</span> &#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;head = q-&gt;tail = tmp;</span><br><span class="line">    pthread_mutex_init(&amp;q-&gt;head_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;q-&gt;tail_lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue_Enqueue</span><span class="params">(<span class="type">queue_t</span> *q, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(tmp != <span class="literal">NULL</span>);</span><br><span class="line">    tmp-&gt;value = value;</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;tail_lock);<span class="comment">//在队尾加锁</span></span><br><span class="line">    q-&gt;tail-&gt;next = tmp;</span><br><span class="line">    q-&gt;tail = tmp;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;tail_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Queue_Dequeue</span><span class="params">(<span class="type">queue_t</span> *q, <span class="type">int</span> *value)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;head_lock);</span><br><span class="line">    <span class="type">node_t</span> *tmp = q-&gt;head;</span><br><span class="line">    <span class="type">node_t</span> *new_head = tmp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (new_head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;q-&gt;head_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// queue was empty</span></span><br><span class="line">    &#125;</span><br><span class="line">    *value = new_head-&gt;value;</span><br><span class="line">    q-&gt;head = new_head;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;head_lock);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列的加锁特点：</p>
<ul>
<li><p>入队只访问 <code>tail_lock</code> 出队只访问 <code>head_lock</code></p>
</li>
<li><p>在初始化阶段添加了 dummy node 假节点，不然空队列的情况需要同时处理 tail 和 head：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Queue_Enqueue</span><span class="params">(<span class="type">queue_t</span> *q, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(tmp != <span class="literal">NULL</span>);</span><br><span class="line">    tmp-&gt;value = value;</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;tail_lock);</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;tail == <span class="literal">NULL</span>) &#123;<span class="comment">// additional if-else!!!</span></span><br><span class="line">        q-&gt;head = q-&gt;tail = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;tail-&gt;next = tmp;</span><br><span class="line">        q-&gt;tail = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;tail_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Queue_Dequeue</span><span class="params">(<span class="type">queue_t</span> *q, <span class="type">int</span> *value)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;head_lock);</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;head == <span class="literal">NULL</span>) &#123;<span class="comment">// additional if-else!!!</span></span><br><span class="line">        pthread_mutex_unlock(&amp;q-&gt;head_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// queue was empty</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">node_t</span> *tmp = q-&gt;head;</span><br><span class="line">    <span class="type">node_t</span> *new_head = tmp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (new_head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;q-&gt;head_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// queue was empty</span></span><br><span class="line">    &#125;</span><br><span class="line">    *value = new_head-&gt;value;</span><br><span class="line">    q-&gt;head = new_head;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;head_lock);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Concurrent-Hash-Table"><a href="#Concurrent-Hash-Table" class="headerlink" title="Concurrent Hash Table"></a>Concurrent Hash Table</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUCKETS (101)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span> &#123;</span><span class="type">list_t</span> lists[BUCKETS];&#125; <span class="type">hash_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hash_Init</span><span class="params">(<span class="type">hash_t</span> *H)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUCKETS; i++)</span><br><span class="line">    	List_Init(&amp;H-&gt;lists[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash_Insert</span><span class="params">(<span class="type">hash_t</span> *H, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> List_Insert(&amp;H-&gt;lists[key % BUCKETS], key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash_Lookup</span><span class="params">(<span class="type">hash_t</span> *H, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> List_Lookup(&amp;H-&gt;lists[key % BUCKETS], key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241224205440775.png" alt="image-20241224205440775"></p>
<p>如图所示，哈希表中，每个桶都是一个单独的链表，因此，比单独的大锁并发链表性能好很多。</p>
<h1 id="Condition-Variables"><a href="#Condition-Variables" class="headerlink" title="Condition Variables"></a>Condition Variables</h1><p>任何线程库的另一个主要组件是条件变量，主要用于线程间交互。</p>
<p>概念上，一个条件变量就是一个线程队列(thread queue)， 其中的线程正等待某个条件变为真，比如 <code>ready == 0</code>，每个条件变量$c$关联着一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)">断言</a>，当一个线程等待时，该线程不算作占用了该管程，因而其它线程可以进入该管程执行，改变管程的状态，通知条件变量$c$其关联的断言$P_c$在当前状态下为真。</p>
<p>条件变量同锁一起使用使得线程可以以一种**<u>无竞争</u>**的方式等待任意条件的发生。所谓无竞争就是，条件改变之后这个信号会发送到所有等待这个信号的线程。而不是说一个线程接受到这个消息而其它线程就接收不到了。</p>
<h2 id="Precautions"><a href="#Precautions" class="headerlink" title="Precautions"></a>Precautions</h2><h3 id="“Wakeup”"><a href="#“Wakeup”" class="headerlink" title="“Wakeup”"></a>“Wakeup”</h3><p>线程状态:Ready, Run, Sleep</p>
<p><code>wait</code>: Run-&gt;Sleep</p>
<p><code>signal</code>: Sleep-&gt;Ready </p>
<h3 id="Specific-Condition"><a href="#Specific-Condition" class="headerlink" title="Specific Condition"></a>Specific Condition</h3><p>条件变量必须跟布尔条件挂钩，如果只是单纯地地像下面这样使用条件变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">thr_exit()&#123;</span><br><span class="line">	<span class="comment">// done = 1;</span></span><br><span class="line">	mutex_lock(&amp;m);</span><br><span class="line">	cond_signal(&amp;c);</span><br><span class="line">	mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line">thr_join()&#123;</span><br><span class="line">	mutex_lock(&amp;m);</span><br><span class="line">	<span class="comment">//while(done == 0)</span></span><br><span class="line">	cond_wait(&amp;c);</span><br><span class="line">	mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在父线程调用join之前，子线程创建并运行了exit，就会导致空唤醒，父线程将持续睡下去。</p>
<h3 id="Recheck-While-Loop"><a href="#Recheck-While-Loop" class="headerlink" title="Recheck: While Loop"></a>Recheck: <strong>While</strong> Loop</h3><h4 id="Mesa-Semantic"><a href="#Mesa-Semantic" class="headerlink" title="Mesa Semantic"></a>Mesa Semantic</h4><p>发信号只是一个状态改变的暗示，并不能保证他运行之前的状态一直是期望的情况，线程的 Ready 和 Run 之间的状态转换是由调度程序决定的，<code>signal</code> 以后，Run 之前可能状态会发生变化。</p>
<p>另一个是Hoare Semantic 能直接唤醒线程立即执行，几乎所有系统都采用了前者的语义。</p>
<h4 id="Lost-Wakeup"><a href="#Lost-Wakeup" class="headerlink" title="Lost Wakeup"></a>Lost Wakeup</h4><p>条件变量代表的是一种条件，需要将 <code>pthread_cond_wait</code> 放在一个 while 循环，而不是 if 语句中，因为很可能会出现在wait之前正好切换走了，这时候signal信号就会丢失。所以线程被唤醒后必须重新检查当时的条件是否仍然满足，如若仍然满足 while 循环的条件，就不能继续执行。</p>
<p>假设线程 A 和线程 B 都在等待同一个条件变量，并且导致线程休眠的条件布尔值最初为 <code>false</code>：</p>
<ol>
<li>线程 A 进入等待状态：<ul>
<li><code>pthread_cond_wait(&amp;cond, &amp;mutex)</code> </li>
</ul>
</li>
<li>线程 B 也进入等待状态；</li>
<li>某个线程 C 修改了条件布尔值为 <code>true</code>，并通过条件变量发送信号唤醒线程：<ul>
<li><code>pthread_cond_signal(&amp;cond)</code>。</li>
</ul>
</li>
<li>线程 A 被唤醒，并退出等待。此时它执行任务后将条件变量重新置为 <code>false</code>。</li>
<li><strong>问题：</strong> 线程 B 也被唤醒，但条件变量已被线程 A 改回 <code>false</code>。<ul>
<li>如果使用 <code>if</code> 检查条件，线程 B 会直接跳过检查并继续执行任务，从而导致程序逻辑错误。</li>
</ul>
</li>
</ol>
<p><strong>解决方案：用 <code>while</code> 再次检查条件</strong>：</p>
<ul>
<li>当线程 B 被唤醒时，<code>while</code> 循环会再次检查条件变量，发现条件未满足，然后重新进入等待状态，确保安全。</li>
</ul>
<h4 id="Spurious-Wakeup"><a href="#Spurious-Wakeup" class="headerlink" title="Spurious Wakeup"></a>Spurious Wakeup</h4><p>有一些 pthread 实现可能会<strong>虚假地唤醒</strong>多个正在等待的线程；在这种情况下，在不重新检查的情况下，等待线程将继续认为条件已更改，即使它没有更改。因此，应该树立起一个恒等式:</p>
<p>被唤醒⇔条件确实已经改变</p>
<h3 id="Hold-the-Lock-When-signal-or-wait"><a href="#Hold-the-Lock-When-signal-or-wait" class="headerlink" title="Hold the Lock When signal() or wait()"></a>Hold the Lock When <code>signal()</code> or <code>wait()</code></h3><p> ==使用条件变量的前提是必须要持有这把锁== </p>
<p><strong>想象一下</strong>：一个线程是某个队列的消费者，它必须要等到队列中有数据时才能执行，如果队列为空，则会一直等待挂起，直到另外一个线程在队列中存入数据，并<strong>通知</strong>先前挂起的线程，该线程才会唤醒重新开始执行。在这个例子中，队列是否 空/满 是线程执行所依赖的状态，而这个状态是多个线程都可以访问的，所以需要加锁互斥访问，这种加锁模式与其他同步加锁略有不同：</p>
<p>锁在 <code>wait</code> 调用中，休眠前需要释放锁，唤醒之后，返回之前需要重新获取锁</p>
<h3 id="Covering-Conditions-broadcast"><a href="#Covering-Conditions-broadcast" class="headerlink" title="Covering Conditions: broadcast()"></a>Covering Conditions: <code>broadcast()</code></h3><p>考虑分配内存的场景：</p>
<ol>
<li>有多个想要申请不同空间的线程，但是此时没有足够空间，因此他们陷入了睡眠；</li>
<li>此时第三个线程释放了一定的空间，想要唤醒，但唤醒哪一个是不确定的，可能释放的空间不足以支持被唤醒者申请的空间；</li>
<li>因此需要唤醒所有在此CV上等待的线程：<code>broadcast()</code></li>
</ol>
<h2 id="Producer-Consumer-Problem"><a href="#Producer-Consumer-Problem" class="headerlink" title="Producer/Consumer Problem"></a>Producer/Consumer Problem</h2><p>生产者/消费者问题 或 有界缓冲区问题：</p>
<ul>
<li>生产者：从缓冲区中拿东西，如果没东西可拿就应该阻塞</li>
<li>消费者：向缓冲区中放东西，如果缓冲区满了就应当阻塞</li>
</ul>
<p>因此要注意如下事项：</p>
<ol>
<li>不能唤醒同类：生产者和消费者应该使用两个不同的条件变量</li>
<li>while 循环：重新检查条件，以防在 Run 之前，条件发生改变</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 8</span></span><br><span class="line"><span class="type">int</span> buffer[MAXSIZE];</span><br><span class="line"><span class="type">int</span> fill_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> use_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">	fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = buffer[use_ptr];</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">cond_t</span> isEmpty,isFull;</span><br><span class="line"><span class="type">mutex_t</span> mutex;</span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == MAXSIZE)</span><br><span class="line">            cond_wait(&amp;isFull, &amp;mutex);</span><br><span class="line">    	put(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;producer:%d puts value:%d&quot;</span>, gettid(), i);</span><br><span class="line">        cond_signal((&amp;isEmpty);</span><br><span class="line">    	mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> consumer()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">            cond_wait(&amp;isEmpty, &amp;mutex);</span><br><span class="line">        <span class="type">int</span> value = get();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid:%d gets value:%d&quot;</span>, gettid(), value);</span><br><span class="line">        cond_signal(&amp;isFull);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h1><p><strong>互斥</strong>：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 </p>
<p><strong>同步</strong>：指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</p>
<p>Semaphore <strong>支持跨进程的同步</strong>，是线程同步所有工作的单一原语，能够将其作为锁或条件变量</p>
<p>Condition Variable 只支持同一进程内部线程的同步</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>信号量（Semaphore）</th>
<th>锁（Mutex）</th>
<th>条件变量（Condition Variable）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>功能</strong></td>
<td>控制资源数量（同步和互斥）</td>
<td>提供互斥访问</td>
<td>等待特定条件满足后继续执行</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>资源控制、多线程队列</td>
<td>保护临界区，单资源互斥</td>
<td>条件等待（生产者/消费者问题）</td>
</tr>
<tr>
<td><strong>能否跨进程</strong></td>
<td><strong>支持跨进程</strong></td>
<td>仅限线程同步（同一进程内）</td>
<td>仅限线程同步（同一进程内）</td>
</tr>
<tr>
<td><strong>是否需要互斥锁</strong></td>
<td><strong>不需要互斥锁</strong></td>
<td>自带互斥功能，不需要额外锁</td>
<td>必须依赖互斥锁来保护共享变量</td>
</tr>
<tr>
<td><strong>复杂条件判断</strong></td>
<td><strong>支持简单条件</strong>（通过计数控制）</td>
<td><strong>不支持条件判断</strong></td>
<td><strong>支持复杂条件</strong>判断和线程等待唤醒机制</td>
</tr>
</tbody></table>
<h2 id="POSIX-API"><a href="#POSIX-API" class="headerlink" title="POSIX API"></a>POSIX API</h2><p>POSIX API 给信号量添加了两个调用，这两个调用都是原子操作：</p>
<h3 id="sem-wait-sem-t-s-P"><a href="#sem-wait-sem-t-s-P" class="headerlink" title="sem_wait(sem_t *s)(P())"></a><code>sem_wait(sem_t *s)</code>(<code>P()</code>)</h3><p>信号量值减1，若变为负数，则阻塞在信号量上（信号量负数绝对值为阻塞的线程数量）</p>
<h3 id="sem-post-sem-t-s-V"><a href="#sem-post-sem-t-s-V" class="headerlink" title="sem_post(sem_t *s)(V())"></a><code>sem_post(sem_t *s)</code>(<code>V()</code>)</h3><p>将信号量的值加1，如果信号量值为负数，则肯定有线程正在此信号量上等待，唤醒其中一个线程</p>
<h2 id="Binary-Semaphores-Locks"><a href="#Binary-Semaphores-Locks" class="headerlink" title="Binary Semaphores: Locks"></a>Binary Semaphores: Locks</h2><p><strong>Workflow</strong>:</p>
<ol>
<li>信号量的初始值为 1，线程 A 调用 <code>sem_wait(*s)</code> 此时信号量为 0，直接返回，进入临界区</li>
<li>此时另一个线程 B 过来调用 <code>sem_wait(*s)</code> 此时信号量为 -1，休眠……</li>
<li>线程 A 完成临界区操作，调用 <code>sem_post(*s)</code> 此时信号量变成 0，唤醒线程 B </li>
<li>线程 B 从 <code>wait()</code> 返回，进入临界区</li>
</ol>
<p>因此二值信号量能够实现锁的功能。</p>
<h2 id="Semaphores-Condition-Variables"><a href="#Semaphores-Condition-Variables" class="headerlink" title="Semaphores: Condition Variables"></a>Semaphores: Condition Variables</h2><blockquote>
<p>给信号量设置初始值：在初始化之后愿意立即放弃的资源数量有多少？</p>
<ul>
<li><p>如果是锁，只有 1 把锁，那么就必须初始化为 1；</p>
</li>
<li><p>如果是用作任务排序，父进程等待子进程，没有能给出去的东西，那就只能初始化为 0</p>
</li>
<li><p>如果是消费者，一开始没有可以消费的东西，那就初始化为0；</p>
</li>
<li><p>如果是生产者，一开始可供生产的空间有MAXSIZE个，那就初始化为MAXSIZE。</p>
</li>
</ul>
</blockquote>
<h3 id="Mutex-Needed"><a href="#Mutex-Needed" class="headerlink" title="Mutex Needed"></a>Mutex Needed</h3><p>相当于将之前的 <code>count</code> 整合进条件变量中：</p>
<ul>
<li><code>sem_init(&amp;empty,0,MAXSIZE)</code> 空闲区域的大小为 MAXSIZE</li>
<li><code>sem_init(&amp;full,0,0)</code> 可消费区域大小为 0</li>
</ul>
<p><strong>Usage</strong>: </p>
<ul>
<li>生产者调用 <code>sem_wait(&amp;empty)</code> empty 自减，若为负数则生产者只能阻塞等待</li>
</ul>
<ul>
<li>消费者调用 <code>sem_wait(&amp;full)</code> full 自减，为负数则消费者需要阻塞等待</li>
</ul>
<ul>
<li><p>生产者操作完临界区， <code>sem_post(&amp;full)</code> 使 full 自增，某个消费者被唤醒并进入临界区</p>
</li>
<li><p>消费者操作完临界区， <code>sem_post(&amp;empty)</code> 使 empty 自增，某个生产者被唤醒并进入临界区</p>
</li>
</ul>
<p>这里没有锁，因此会出现并发问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        sem_wait(&amp;mutex); <span class="comment">// Line P0 (NEW LINE) 加锁</span></span><br><span class="line">        sem_wait(&amp;empty); <span class="comment">// Line P1</span></span><br><span class="line">        put(i); <span class="comment">// Line P2</span></span><br><span class="line">        sem_post(&amp;full); <span class="comment">// Line P3</span></span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// Line P4 (NEW LINE) 解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        sem_wait(&amp;mutex); <span class="comment">// Line C0 (NEW LINE) 加锁 </span></span><br><span class="line">        sem_wait(&amp;full); <span class="comment">// Line C1</span></span><br><span class="line">        <span class="type">int</span> tmp = get(); <span class="comment">// Line C2</span></span><br><span class="line">        sem_post(&amp;empty); <span class="comment">// Line C3</span></span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// Line C4 (NEW LINE) 解锁</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h3><p>生产者加锁，进入临界区之前，调用empty发现缓冲区已满，遂休眠，此时生产者依然持有锁</p>
<p>切换到就绪的消费者，因为获取不到锁，只能休眠，这样就导致了死锁，因此需要缩小锁的范围:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        sem_wait(&amp;full); <span class="comment">// Line C1</span></span><br><span class="line">        sem_wait(&amp;mutex); <span class="comment">// Line C1.5 (NEW LINE) 加锁 </span></span><br><span class="line">        <span class="type">int</span> tmp = get(); <span class="comment">// Line C2</span></span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// Line C2.5 (NEW LINE) 解锁</span></span><br><span class="line">        sem_post(&amp;empty); <span class="comment">// Line C3</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最根本的区别在于，睡眠的线程不会释放锁，因此条件变量应该加到锁的外面</p>
<h2 id="Mutex-CV-amp-Semaphore"><a href="#Mutex-CV-amp-Semaphore" class="headerlink" title="Mutex + CV &amp; Semaphore"></a><code>Mutex + CV</code> &amp; <code>Semaphore</code></h2><table>
<thead>
<tr>
<th>特性</th>
<th>Mutex + Condition Variable</th>
<th>Semaphore</th>
</tr>
</thead>
<tbody><tr>
<td><strong>设计理念</strong></td>
<td>提供更高层次的<strong>条件等待机制</strong>，依赖互斥锁管理共享数据状态。</td>
<td>基于简单的<strong>计数器模型</strong>，直接控制资源可用数量。</td>
</tr>
<tr>
<td><strong>同步功能</strong></td>
<td>适合复杂条件等待或<strong>事件驱动</strong>的同步场景（例如生产者-消费者模型）。</td>
<td>控制固定数量的资源访问或线程数量（例如资源池管理）。</td>
</tr>
<tr>
<td><strong>互斥功能</strong></td>
<td>需要显式的 <code>Mutex</code> 实现互斥保护。</td>
<td>内部实现互斥，无需额外的互斥锁。</td>
</tr>
<tr>
<td><strong>跨进程支持</strong></td>
<td>仅支持线程级同步（同一进程内线程同步）。</td>
<td>支持跨进程和线程同步（POSIX 信号量支持跨进程）。</td>
</tr>
<tr>
<td><strong>复杂性</strong></td>
<td>支持复杂条件判断，但需要手动管理条件和唤醒逻辑。</td>
<td>简单直观，直接基于计数器操作，不需要条件管理。</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>条件变量需要多步操作（加锁、解锁、条件检查、等待），效率略低。</td>
<td>基于计数器原子操作，性能较高，适合高并发场景。</td>
</tr>
<tr>
<td><strong>复杂条件处理</strong></td>
<td>支持复杂条件和多条件组合判断，适合生产者-消费者问题。</td>
<td>只能处理简单的资源计数条件，不适合复杂条件判断。</td>
</tr>
</tbody></table>
<h3 id="Mutex-Condition-Variable"><a href="#Mutex-Condition-Variable" class="headerlink" title="Mutex + Condition Variable"></a>Mutex + Condition Variable</h3><ol>
<li><strong>互斥锁（Mutex）：</strong><ul>
<li>提供临界区保护，确保线程在访问共享资源时互斥执行。</li>
<li>底层依赖于操作系统内核的<strong>互斥量数据结构</strong>（如 Linux 的 Futex 或信号量实现）。</li>
</ul>
</li>
<li><strong>条件变量（Condition Variable）：</strong><ul>
<li>条件变量不会保存条件状态，而是通过线程阻塞和唤醒机制等待条件变化。</li>
<li>必须与互斥锁配合使用，防止条件检查过程中出现竞争条件。</li>
</ul>
</li>
</ol>
<ul>
<li>条件变量使用<strong>等待队列（Wait Queue）</strong>机制管理线程。</li>
<li>当线程调用<code>pthread_cond_wait</code>，它会：<ol>
<li>释放锁（解锁 mutex）。</li>
<li>将线程放入条件变量的等待队列中，并进入<strong>阻塞状态</strong>（睡眠）。</li>
<li>等待其他线程通过 <code>pthread_cond_signal</code> 或 <code>pthread_cond_broadcast</code> 唤醒它。</li>
<li>被唤醒后，重新尝试获取互斥锁并继续执行。</li>
</ol>
</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Thread</span> <span class="number">1</span><span class="operator">:</span>              <span class="built_in">Condition</span> <span class="variable">Variable</span><span class="operator">:</span></span><br><span class="line">  <span class="operator">-</span> <span class="variable">Acquire</span> <span class="variable">Lock</span>         <span class="punctuation">[</span> <span class="variable">Wait</span> <span class="variable">Queue</span> <span class="punctuation">]</span></span><br><span class="line">  <span class="operator">-</span> <span class="built_in">Check</span> <span class="built_in">Condition</span> <span class="operator">----&gt;</span> <span class="variable">Add</span> <span class="variable">to</span> <span class="variable">Queue</span></span><br><span class="line">  <span class="operator">-</span> <span class="variable">Wait</span> <span class="punctuation">(</span><span class="variable">Unlock</span><span class="punctuation">)</span>        <span class="punctuation">[</span> <span class="variable">Blocked</span> <span class="punctuation">]</span></span><br><span class="line">                         <span class="operator">&lt;-----</span> <span class="variable">Signal</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">Thread</span> <span class="number">2</span><span class="operator">:</span>               <span class="variable">Wake</span> <span class="built_in">Up</span> <span class="built_in">Thread</span> <span class="number">1</span></span><br><span class="line">  <span class="operator">-</span> <span class="variable">Modify</span> <span class="built_in">Condition</span></span><br><span class="line">  <span class="operator">-</span> <span class="variable">Signal</span></span><br><span class="line">  <span class="operator">-</span> <span class="built_in">Release</span> <span class="variable">Lock</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>条件变量没有条件状态：</strong> 共享条件需要程序员手动管理（例如标志位）。</li>
<li><strong>支持复杂条件判断：</strong> 等待某些条件的组合，例如缓冲区为空或满。</li>
<li><strong>虚假唤醒机制：</strong> 被唤醒后必须重新检查条件，避免不满足条件的线程继续执行。</li>
</ul>
<hr>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><ul>
<li>信号量直接依赖<strong>原子操作</strong>（如 CPU 指令 <code>Test-And-Set</code> 或 <code>Compare-And-Swap</code>）更新计数器，确保多线程安全。</li>
<li>阻塞线程会进入<strong>等待队列</strong>，操作系统负责调度。</li>
</ul>
<ol>
<li>信号量内部维护一个<strong>计数器变量（Counter）</strong>，表示可用资源的数量。</li>
<li>当调用 <code>sem_wait</code> 时：<ul>
<li>如果计数器 &gt; 0，直接减 1，线程继续执行。</li>
<li>如果计数器 == 0，线程阻塞，进入等待队列。</li>
</ul>
</li>
<li>当调用 <code>sem_post</code> 时：<ul>
<li>增加计数器值。</li>
<li>如果等待队列中有线程，则唤醒其中一个线程。</li>
</ul>
</li>
</ol>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Semaphore</span> <span class="variable">Counter</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="built_in">Thread</span> <span class="number">1</span><span class="operator">:</span> <span class="variable">P</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">----&gt;</span> <span class="variable">Counter</span><span class="operator">--</span> <span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">Thread</span> <span class="number">2</span><span class="operator">:</span> <span class="variable">P</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">----&gt;</span> <span class="variable">Counter</span><span class="operator">--</span> <span class="punctuation">(</span><span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">Thread</span> <span class="number">3</span><span class="operator">:</span> <span class="variable">P</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">----&gt;</span> <span class="variable">Blocked</span> <span class="punctuation">(</span><span class="variable">Counter</span> <span class="operator">==</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">Thread</span> <span class="number">1</span><span class="operator">:</span> <span class="variable">V</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">----&gt;</span> <span class="variable">Counter</span><span class="operator">++</span> <span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="variable">Wake</span> <span class="built_in">Up</span> <span class="built_in">Thread</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>信号量管理的是资源数量，而不是条件状态。</li>
<li>自带互斥特性，适合多个线程访问有限资源。</li>
<li><strong>适合计数型条件：</strong> 一次允许多个线程执行，而不是简单的互斥。</li>
</ul>
<h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><ol>
<li><strong>Semaphore 更像一个通用工具：</strong><ul>
<li>适合管理固定资源数量，如线程池、连接池、令牌桶等。</li>
<li>更简单、更高效，适合需要资源计数的场景。</li>
<li>支持跨进程同步需求。</li>
</ul>
</li>
<li><strong>Mutex + Condition Variable 提供更高级的同步机制：</strong><ul>
<li>适合复杂条件判断或事件驱动模型，如生产者/消费者问题，依赖互斥锁保证数据一致性。</li>
<li>支持灵活的条件管理，适合多条件组合。</li>
<li>更适合线程间等待和唤醒机制，不适合跨进程同步。</li>
</ul>
</li>
</ol>
<ul>
<li>在实际开发中，如果场景简单且需求是资源访问控制，选择<strong>信号量</strong>；</li>
<li>如果需要更复杂的条件管理和线程间事件通知，则选择<strong>条件变量 + 锁</strong>。</li>
</ul>
<h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><h3 id="Reader-Writer-Lock"><a href="#Reader-Writer-Lock" class="headerlink" title="Reader/Writer Lock"></a>Reader/Writer Lock</h3><p>读者只读不写，写者才需要修改。类似 Shared/eXclusion 共享锁和独占锁</p>
<p>RW 锁支持一个写者或者多个读者：</p>
<ul>
<li>第一个读者首先获取lock（保护reader）增加reader，获取writelock，释放lock进入临界区</li>
<li>之后其他的读者只要获取lock后增加reader个数，直接访问临界区即可</li>
<li>写者需要等待最后一个读者释放writelock</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rwlock_t</span>&#123;</span></span><br><span class="line">    <span class="type">sem_t</span> lock; <span class="comment">// basic lock  INIT: 1</span></span><br><span class="line">    <span class="type">sem_t</span> writelock;<span class="comment">//allow 1 writer / many readers INIT: 1</span></span><br><span class="line">    <span class="type">int</span> readers;<span class="comment">//number of readers  INIT:0</span></span><br><span class="line">&#125;<span class="type">rwlock_t</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span>&#123;</span><br><span class="line">    sem_wait(rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span>(readers == <span class="number">1</span>)</span><br><span class="line">        sem_wait(rw-&gt;writelock); <span class="comment">//第一个读者获取写锁</span></span><br><span class="line">    sem_post(rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span>&#123;</span><br><span class="line">    sem_wait(rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers;</span><br><span class="line">    <span class="keyword">if</span>(readers == <span class="number">0</span>)</span><br><span class="line">        sem_post(rw-&gt;writelock);<span class="comment">//最后一个读者释放写锁</span></span><br><span class="line">    sem_post(rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span>&#123;</span><br><span class="line">    sem_wait(rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers;</span><br><span class="line">    <span class="keyword">if</span>(readers == <span class="number">0</span>)</span><br><span class="line">        sem_post(rw-&gt;writelock);<span class="comment">//最后一个读者释放写锁</span></span><br><span class="line">    sem_post(rw-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种读写锁并不一定比自旋锁更快，并且公平性无法保证，过多读者通常会饿死写者，需要进一步进行优化。</p>
<h3 id="Dining-Philosopher’s-Problem"><a href="#Dining-Philosopher’s-Problem" class="headerlink" title="Dining Philosopher’s Problem"></a>Dining Philosopher’s Problem</h3><p><strong>问题描述</strong></p>
<ul>
<li>有 5 位哲学家围坐在一张圆桌旁，他们的生活方式是 <strong>思考</strong> 和 <strong>进餐</strong>。</li>
<li>桌子上摆放着 5 根筷子，每位哲学家左右各放一根。</li>
<li>哲学家要进餐时，需要同时拿起左右两根筷子。</li>
<li>哲学家只能在拿到两根筷子后才能吃饭，否则必须等待。</li>
</ul>
<p><strong>主要难题</strong>：</p>
<ul>
<li>**死锁 (Deadlock)**：所有哲学家都同时拿起左边的筷子，导致没有哲学家能拿到第二根筷子，进入无限等待状态。</li>
<li>**饥饿 (Starvation)**：某位哲学家可能永远无法获得两根筷子，从而无法进餐。</li>
<li><strong>并发控制</strong>：需要保证哲学家拿筷子和放筷子的动作是线程安全的。</li>
</ul>
<ul>
<li><strong>方案 1：引入顺序编号</strong><br>将哲学家编号为 0 到 4，规定编号为偶数的哲学家先拿左筷子，再拿右筷子；编号为奇数的哲学家先拿右筷子，再拿左筷子。或者，最后一个哲学家先拿右筷子，再拿左筷子。这样就不会互相卡住，打破了等待的循环。</li>
<li><strong>方案 2：限制最多 4 个哲学家进入用餐状态</strong><br>使用一个计数器，确保最多 4 位哲学家能尝试拿筷子，这样至少会有一根筷子空闲，避免死锁。</li>
</ul>
<h3 id="Thread-Throttling"><a href="#Thread-Throttling" class="headerlink" title="Thread Throttling"></a>Thread Throttling</h3><p>信号量比较适合<strong>资源数量有限制</strong>的情况：比如有一群线程，每个线程都需要申请一块很大的内存空间用于计算，用于计算的这片区域就是 <strong>内存密集型</strong> 区域，如果所有线程同时申请，就会造成内存抖动（不停地换出又换入页面导致程序以极慢的速度执行）。</p>
<p>一个简单的信号量就可以解决这个问题：通过将信号量的值初始化为您希望一次进入内存密集区域的最大线程数，然后在该区域周围放置 sem_wait() 和 sem_post()，信号量自然地限制那些并发地处于危险区域的线程数量。</p>
<h2 id="Implement-sem-using-mutex-amp-cond"><a href="#Implement-sem-using-mutex-amp-cond" class="headerlink" title="Implement sem using mutex &amp; cond"></a>Implement <code>sem</code> using <code>mutex</code> &amp; <code>cond</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Zem_t</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	<span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">	<span class="type">pthread_cond_t</span> cond;</span><br><span class="line">&#125; Zem_t;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_init</span><span class="params">(Zem_t *s, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">	s-&gt;value = value;</span><br><span class="line">	Cond_init(s-&gt;cond);</span><br><span class="line">	Mutex_init(s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_wait</span><span class="params">(Zem_t *s)</span>&#123;</span><br><span class="line">	Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line">	<span class="keyword">while</span>(s-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">		Cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);</span><br><span class="line">	s-&gt;value--;</span><br><span class="line">	Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_post</span><span class="params">(Zem_t *s)</span>&#123;</span><br><span class="line">	Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line">	s-&gt;value++;</span><br><span class="line">	Cond_signal(&amp;s-&gt;cond);</span><br><span class="line">	Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Common-Concurrency-Bugs"><a href="#Common-Concurrency-Bugs" class="headerlink" title="Common Concurrency Bugs"></a>Common Concurrency Bugs</h1><p>总的来说可以分为死锁(Deadlock)和非死锁(Non-deadlock)两种，其中后者占绝大多数</p>
<h2 id="Non-deadlock-Bugs"><a href="#Non-deadlock-Bugs" class="headerlink" title="Non-deadlock Bugs"></a>Non-deadlock Bugs</h2><h3 id="Atomicity-Violation-Lock"><a href="#Atomicity-Violation-Lock" class="headerlink" title="Atomicity-Violation(Lock)"></a>Atomicity-Violation(Lock)</h3><p>这种错误违反了<strong>原子性</strong>，下图的 <code>proc_info</code> 在刚进入 if 循环的时候被取消调度，线程2将其置为NULL，切换回去的时候导致空指针异常</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241225194108926.png" alt="image-20241225194108926"></p>
<p>解决方案：在访问共享资源的时候加锁</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241225194511624.png" alt="image-20241225194511624"></p>
<h3 id="Order-Violation-CV"><a href="#Order-Violation-CV" class="headerlink" title="Order-Violation(CV)"></a>Order-Violation(CV)</h3><p>模块化：不同线程承担不同职责，线程1负责初始化 <code>mThread</code> ，线程2访问 <code>mThread</code></p>
<p>如果<strong>乱序执行</strong>，就会出现线程2访问到空指针导致程序崩溃：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241225194032626-1735126873754-1.png" alt="image-20241225194032626"></p>
<p>因此，用一个状态变量或者<code>mThread</code>本身来代表初始化是否成功，然后用条件变量解决问题：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241225194350912.png" alt="image-20241225194350912"></p>
<h2 id="Deadlock-Bugs"><a href="#Deadlock-Bugs" class="headerlink" title="Deadlock Bugs"></a>Deadlock Bugs</h2><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241225195039934.png" alt="image-20241225195039934"></p>
<p>死锁原因：获取锁的顺序相反</p>
<ol>
<li>在大型代码库中组件依赖复杂 循环依赖就会导致死锁的发生</li>
<li>模块化封装会隐藏底层的细节 <code>v1.addAll(v2)</code> <code>v2.addAll(v1)</code> 同时调用可能会发生死锁</li>
</ol>
<p>产生死锁的四个条件：</p>
<ol>
<li><strong>互斥</strong>：线程对资源进行互斥的访问</li>
<li><strong>持有并等待</strong>：线程在持有资源的同时也在等待其他资源</li>
<li><strong>非抢占</strong>：线程获得的资源（如锁）不能被抢占</li>
<li><strong>循环等待</strong>：线程之间存在环路，上面的每个线程都会额外持有下个线程想要申请的资源</li>
</ol>
<h3 id="Prevention"><a href="#Prevention" class="headerlink" title="Prevention"></a>Prevention</h3><h4 id="Circular-Wait-Forced-Order"><a href="#Circular-Wait-Forced-Order" class="headerlink" title="Circular Wait: Forced Order"></a>Circular Wait: Forced Order</h4><p>强制规定获取锁的顺序</p>
<p><strong>偏序锁：</strong>如果资源之间的依赖关系较少或依赖是局部的，偏序锁，提供更好的性能和灵活性。</p>
<p><strong>全序锁：</strong>如果资源之间的依赖关系复杂且必须确保一致性（如事务或分布式系统），全序锁更可靠</p>
<p>如果一个函数要抢多个锁，可以根据<strong>锁的地址</strong>作为锁的顺序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">do_something(mutex *m1,mutex *m2)&#123;</span><br><span class="line">	<span class="keyword">if</span>(m1 &lt; m2)&#123;</span><br><span class="line">		pthread_mutex_lock(*m1);</span><br><span class="line">		pthread_mutex_lock(*m2);</span><br><span class="line">	</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		pthread_mutex_lock(*m2);</span><br><span class="line">		pthread_mutex_lock(*m1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以保证 <code>do_something(&amp;m1,&amp;m2)</code> 和 <code>do_something(&amp;m2,&amp;m1)</code> 是同样的抢锁顺序</p>
<h4 id="Hold-and-wait-Atomic-Acquiring"><a href="#Hold-and-wait-Atomic-Acquiring" class="headerlink" title="Hold-and-wait: Atomic Acquiring"></a>Hold-and-wait: Atomic Acquiring</h4><p>在抢锁的最外层加一道锁（原子性抢锁）防止抢锁过程中突然被取消调度，切换到其他线程：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241225203212407.png" alt="image-20241225203212407"></p>
<p>缺点：不适合封装，因为需要准确知道要抢哪些锁并提前全部抢到（即使当前并不需要）</p>
<h4 id="No-Preemption-trylock"><a href="#No-Preemption-trylock" class="headerlink" title="No Preemption:trylock"></a>No Preemption:<code>trylock</code></h4><p>可以通过<code>trylock</code>这种非阻塞式抢锁来避免死锁，但是这种方法会导致活锁，对封装的支持也不好，代码抢完锁中途获取的资源（比如申请的内存空间），如果抢锁失败，还应该释放</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241225204421920.png" alt="image-20241225204421920"></p>
<h5 id="Livelock"><a href="#Livelock" class="headerlink" title="Livelock"></a>Livelock</h5><p><strong>死锁：</strong> 所有线程都进入等待状态，完全停止运行。</p>
<p><strong>活锁：</strong> 所有线程仍然在运行，但因为不断调整状态，始终无法完成任务。</p>
<p>解决方案：</p>
<ol>
<li>退避算法（Backoff）:在循环结束的时候，先随机等待一段时间再重复</li>
<li>引入有限重试机制: 因为线程一直在运行，因此可以限制最大重试次数</li>
<li>使用更高层次的同步机制,结合条件变量或阻塞队列</li>
</ol>
<h4 id="Mutual-Exclusion-Lock-free-CAS"><a href="#Mutual-Exclusion-Lock-free-CAS" class="headerlink" title="Mutual Exclusion: Lock-free(CAS)"></a>Mutual Exclusion: Lock-free(CAS)</h4><p>利用硬件指令的原子性，完全避免互斥区的存在：CAS 失败就不断重试，直到成功为止（乐观锁）</p>
<p>COMPARE AND SWAP 加之前看看是不是对应的正确的值，是的话再赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自增:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CAS</span><span class="params">(<span class="type">int</span> *address, <span class="type">int</span> expected, <span class="type">int</span> new)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(*address == expected)&#123;</span><br><span class="line">        *address = new;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> *value, <span class="type">int</span> amount)</span>&#123;</span><br><span class="line">    <span class="type">int</span> old;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">		old = *value;</span><br><span class="line">    &#125; <span class="keyword">while</span>(CAS(value, old, old + amount) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表插入</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CAS</span><span class="params">(<span class="type">node_t</span> **address, <span class="type">node_t</span> *expected, <span class="type">node_t</span> *new)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(*address == expected)&#123;</span><br><span class="line">        *address = new;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(n != <span class="literal">NULL</span>);</span><br><span class="line">    n-&gt;value = value;</span><br><span class="line">    pthread_mutex_lock(listlock); <span class="comment">// begin critical section</span></span><br><span class="line">    n-&gt;next = head;</span><br><span class="line">    head = n;</span><br><span class="line">    pthread_mutex_unlock(listlock); <span class="comment">// end critical section</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="type">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(n!=<span class="literal">NULL</span>);</span><br><span class="line">    n-&gt;value = value;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        n-&gt;next = head;<span class="comment">//新节点的下一个应该是现在的头</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(CAS(&amp;head, n-&gt;next, n) == <span class="number">0</span>);<span class="comment">//现在的头应该等于新节点的下一个,不等于</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Avoid-via-Scheduling"><a href="#Avoid-via-Scheduling" class="headerlink" title="Avoid via Scheduling"></a>Avoid via Scheduling</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241225213119760.png" alt="image-20241225213119760"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241225213105676.png" alt="image-20241225213105676"></p>
<p>不要同时并行执行需要获取完全相同锁的线程</p>
<h3 id="Detect-and-Recover"><a href="#Detect-and-Recover" class="headerlink" title="Detect and Recover"></a>Detect and Recover</h3><p>如果根除死锁实在很困难，可以定期检查死锁，并运行专门的程序来恢复</p>
<h1 id="Event-based-Concurrency"><a href="#Event-based-Concurrency" class="headerlink" title="Event-based Concurrency"></a>Event-based Concurrency</h1><p><strong>Event</strong> Loop: 等待事件-&gt;处理事件-&gt;等待事件，重点是如何获取事件？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	events = getEvents();</span><br><span class="line">    <span class="keyword">for</span> (e in events)</span><br><span class="line">    	processEvent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select"><a href="#select" class="headerlink" title="select()"></a><code>select()</code></h2><h3 id="API-Usage"><a href="#API-Usage" class="headerlink" title="API Usage"></a>API Usage</h3><ul>
<li><strong>Purpose</strong>: 监视 FD 是否准备好接受 I/O 操作</li>
<li><strong>Function Signature</strong>: <code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout)</code></li>
<li><strong>Parameters</strong>:<ul>
<li><code>nfds</code>: 检查集合中 [0,nfds-1] 的 FD</li>
<li><code>readfds</code>: 监控 readfds 中的可读事件(新的数据包到达，准备处理)</li>
<li><code>writefds</code>: 监控 writefds 中的可写事件(服务器回复需要写入队列有空)</li>
<li><code>errorfds</code>: 监控 errorfds 中的错误事件</li>
<li><code>timeout</code>: 最大等待时间</li>
</ul>
</li>
<li><strong>Return Value</strong>: 返回准备好 I/O 的 FDs</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/image-20241225225619265.png" alt="image-20241225225619265"></p>
<h3 id="Lock-free"><a href="#Lock-free" class="headerlink" title="Lock-free"></a>Lock-free</h3><p>有了单CPU和基于事件的应用程序，并发程序中的问题就不再存在。具体来说，因为一次只处理一个事件，所以不需要获取或释放锁；基于事件的服务器不能被另一个线程中断，因为它绝对是单线程的。因此，线程程序中常见的并发错误不会在基于事件的基本方法中体现出来。</p>
<h3 id="Problem-Blocking-Syscalls"><a href="#Problem-Blocking-Syscalls" class="headerlink" title="Problem: Blocking Syscalls"></a>Problem: Blocking Syscalls</h3><p>如果某个事件要求发出可能会阻塞的系统调用怎么办？ 例如，假设一个请求从客户端发送到服务器，以从磁盘读取文件并将其内容返回到请求客户端（非常类似于简单的 HTTP 请求）。为了服务这样的请求，某些事件处理程序最终必须发出 <code>open()</code> 系统调用来打开文件，然后执行一系列 <code>read()</code> 调用来读取文件。当文件被读入内存时，服务器可能会开始将结果发送到客户端。 <code>open()</code> 和 <code>read()</code> 调用都可能向存储系统发出 I/O 请求（当所需的元数据或数据尚未在内存中时），因此可能需要很长时间才能提供服务。对于基于线程的服务器，这不是问题：当发出 I/O 请求的线程挂起（等待 I/O 完成）时，其他线程可以运行，从而使服务器能够取得进展。事实上，I/O 和其他计算的这种自然重叠使得基于线程的编程变得非常自然和直接。</p>
<p>然而，使用基于事件的方法，没有其他线程可以运行：只有主事件循环。这意味着，如果事件处理程序发出阻塞调用，则整个服务器将执行此操作：阻塞直到调用完成。当事件循环阻塞时，系统处于空闲状态，因此潜在地浪费了巨大的资源。因此，我们在基于事件的系统中必须遵守一条规则：不允许阻塞调用。</p>
<h2 id="Asynchoronous-I-O"><a href="#Asynchoronous-I-O" class="headerlink" title="Asynchoronous I/O"></a>Asynchoronous I/O</h2><h3 id="API-Usage-1"><a href="#API-Usage-1" class="headerlink" title="API Usage"></a>API Usage</h3><p>要对文件发出异步读取，应用程序应首先使用相关信息填充此 AIO 控制块（aiocb）：</p>
<ul>
<li>要读取的文件的文件描述符 (aio fildes)</li>
<li>文件内的偏移量 (aio offset) </li>
<li>长度请求的长度 (aio nbytes)</li>
<li>读取结果应复制到的内存位置 (aio buf)</li>
</ul>
<p>填充该结构后，应用程序必须发出 AIO 来读取文件；在 Mac 上，此 API 是一个异步读取的 API： <code>int aio_read(struct aiocb *aiocbp</code>);  该调用尝试发出 I/O；如果成功，它会立即返回，并且应用程序（即基于事件的服务器）可以继续其工作。 </p>
<p>然而，我们必须解决最后一块难题。我们如何判断 I/O 何时完成，从而确定缓冲区（由 aiobuf 指向）现在已在其中包含所请求的数据？  还需要最后一个 API。在 Mac 上，它被称为 <code>aio_error()</code> API 如下所示： <code>int aio_error(const struct aiocb *aiocbp)</code>;  该系统调用检查 aiocbp 引用的请求是否已完成。如果是，则返回成功（用 0 表示）；  如果不是，则返回 <code>EINPROGRESS</code>。</p>
<h3 id="Poll-or-Interrupt"><a href="#Poll-or-Interrupt" class="headerlink" title="Poll or Interrupt"></a>Poll or Interrupt</h3><p>对于每个未完成的异步 I/O，应用程序可以通过调用 <code>aio_error()</code> 定期<strong>轮询</strong>系统，以确定所述 I/O 是否尚未完成。但是轮询很浪费CPU。为了解决这个问题，一些系统提供了基于中断的方法。此方法使用 UNIX Signals 来通知应用程序异步 I/O 何时完成，从而无需重复询问系统。</p>
<p>在没有异步I/O的系统中，无法实现纯粹的基于事件的方法。然而，出现了一些相当有效的混合方法。其中事件用于处理网络数据包，线程池用于管理未完成的 I/O。<strong>I/O 多路复用</strong></p>
<h4 id="UNIX-Signals"><a href="#UNIX-Signals" class="headerlink" title="UNIX Signals"></a>UNIX Signals</h4><p>所有现代 UNIX 变体中都存在一个巨大且令人着迷的基础设施，称为信号。最简单的是，信号提供了一种与进程通信的方式。具体来说，可以将信号传递给应用程序；这样做会阻止应用程序运行信号处理程序（即应用程序中处理该信号的某些代码）正在执行的任何操作。 完成后，该进程将恢复其之前的行为。 每个信号都有一个名称，如HUP（挂起）、INT（中断）、SEGV（分段违规）等</p>
<p>有趣的是，有时是内核本身发出信号。例如，当程序遇到 Segmentation Violation 时，操作系统会向其发送 <code>SIGSEGV</code>；如果程序调用了<code>signal(SIGSEV, handler)</code> 就可以运行一些代码（signal handler）来响应。当发送到没有配置响应信号的进程时，将执行默认行为；对于SEGV，该进程被终止。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> arg)</span> &#123;<span class="comment">//handler</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;stop wakin’ me up...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    signal(SIGHUP, handle);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// doin’ nothin’ except catchin’ some sigs</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>./main &amp;</code> 后台运行进程，随后返回pid；</p>
<p><code>kill -HUP [pid]</code> 给进程发送 SIGHUP 信号：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./main &amp;</span><br><span class="line">[<span class="number">3</span>] <span class="number">36705</span></span><br><span class="line">prompt&gt; <span class="built_in">kill</span> <span class="literal">-HUP</span> <span class="number">36705</span></span><br><span class="line">stop wakin’ me up...</span><br><span class="line">prompt&gt; <span class="built_in">kill</span> <span class="literal">-HUP</span> <span class="number">36705</span></span><br><span class="line">stop wakin’ me up...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Problem-State-Management"><a href="#Problem-State-Management" class="headerlink" title="Problem: State Management"></a>Problem: State Management</h3><p>在 Thread-based 服务器中，从<code>read</code>调用返回，程序可以直接从栈上知道 sd 是多少</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rc = read(fd, buffer, size);</span><br><span class="line">rc = write(sd, buffer, size);</span><br></pre></td></tr></table></figure>

<p>而在 Event-based 服务器中，从 <code>aio_read</code> 返回后，应当记录下在处理<code>read</code>事件时必要的信息(continuation)，比如将套接字描述符（sd）记录在某种数据结构（例如哈希表）中，并由文件描述符（fd）索引。</p>
<p>当<code>aio_error</code>显示成功读取后，事件处理器将使用 FD 来查找 continuation，这会将 sd 的值返回给调用者。最终，服务器可以完成最后一点工作，将数据写入套接字。</p>
<h2 id="Other-Problems-with-Events"><a href="#Other-Problems-with-Events" class="headerlink" title="Other Problems with Events"></a>Other Problems with Events</h2><ol>
<li><p>单核到多核将会有多个事件处理器同步运行的情况，会产生同步问题。不再可能进行无锁的简单事件处理。</p>
</li>
<li><p>不能与某些类型的系统活动（例如分页）很好地集成。例如，如果事件处理器发生Page Fault，这就会导致阻塞，因此服务器在Page Fault完成处理之前会一直阻塞。</p>
</li>
<li><p>随着各种程序的确切语义发生变化，基于事件的代码可能很难管理超时。例如，如果例程从非阻塞更改为阻塞，则调用该例程的事件处理程序也必须通过将自身分成两部分来进行更改以适应其新性质。由于阻塞对基于事件的服务器来说是灾难性的，因此程序员必须始终留意每个事件使用的 API 语义中的此类变化。 </p>
</li>
<li><p>异步磁盘 I/O 并未实现与异步网络 I/O 完全集成。例如，虽然人们只想使用 select() 接口来管理所有未完成的 I/O，但通常需要用于网络的 select() 和用于磁盘 I/O 的 AIO 调用的某种组合。</p>
</li>
</ol>
<h1 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h1><h2 id="Semaphore-amp-Monitor"><a href="#Semaphore-amp-Monitor" class="headerlink" title="Semaphore &amp; Monitor"></a>Semaphore &amp; Monitor</h2><ul>
<li>**信号量(Semaphere)**：操作系统提供的一种协调共享资源访问的方法。和用软件实现的同步比较，软件同步是平等线程间的的一种同步协商机制，不能保证原子性。而信号量则由操作系统进行管理，地位高于进程，操作系统保证信号量的原子性。</li>
<li>**管程(Monitor)**：解决信号量在临界区的 PV 操作上的配对的麻烦，把配对的 PV 操作集中在一起，生成的一种并发编程方法。其中使用了条件变量这种同步机制。</li>
</ul>
<p><strong>所谓管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。</strong>翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。一般采用 Mesa Semantic</p>
<p><strong>说明：</strong> 信号量将共享变量 S 封装起来，对共享变量 S 的所有操作都只能通过 PV 操作进行，这是不是和面向对象的思想是不是很像呢？事实上，封装共享变量是并发编程的常用手段。</p>
<p>在信号量中，当 P 操作无法获取到锁时，将当前线程添加到**同步队列(syncQueue)<strong>中。当其余线程 V 释放锁时，从同步队列中唤醒等待线程。但当有多个条件通过信号量 PV 配对时会异常复杂，所以管程中引入了</strong>等待队列(waitQueue)**的概念，进一步封装这些复杂的操作。</p>
<p>在用信号量实现的阻塞队列中，为了实现阻塞队列的功能，即等待-通知(wait-notify)，除了使用互斥锁 mutex 外，还需要两个判断队满和队空的资源信号量 full 和 empty，使用起来不仅复杂，还容易出错。管程在信号量的基础上，更进一步，增加了条件同步，对多个条件变量使用多个等待队列，将上述复杂的操作封装起来: <code>wait()</code> <code>notifyAll()</code> <code>notify()</code></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/1322310-20200320081430470-1065805408.png" alt=" "></p>
<h3 id="API-Usage-2"><a href="#API-Usage-2" class="headerlink" title="API Usage"></a>API Usage</h3><h4 id="While-Loop-wait"><a href="#While-Loop-wait" class="headerlink" title="While Loop wait()"></a>While Loop <code>wait()</code></h4><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Concurrency.assets/250px-Monitor_(synchronization)-Mesa.png" alt="img"></p>
<p>MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是<strong>当 T1 再次执行的时候，可能曾经满足的条件现在已经不满足了</strong>，所以需要以while循环方式检验条件变量。</p>
<p><code>notify()</code> or <code>notifyAll()</code> ？什么时候可以使用 <code>notify()</code> 呢？需要满足以下三个条件：</p>
<ol>
<li>所有等待线程拥有相同的等待条件；</li>
<li>所有等待线程被唤醒后，执行相同的操作；</li>
<li>只需要唤醒一个线程。</li>
</ol>
<p><code>notify()</code> 一般只适用于只有一个条件变量的情况，生产者和消费者等待在同一个条件上会导致错误唤醒同类，造成死锁。<code>notifyAll()</code> 类似于 <code>pthread_cond_broadcast()</code> 都可以用于唤醒多个等待在同一个条件变量上的线程。重点是 <strong>while 里面的等待条件是完全相同的。</strong></p>
<h2 id="BlockingQueue-Producer-Consumer"><a href="#BlockingQueue-Producer-Consumer" class="headerlink" title="BlockingQueue: Producer/Consumer"></a>BlockingQueue: Producer/Consumer</h2><p>Condition 能够更细粒度地进行编程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockedQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 条件变量：队列不满</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 条件变量：队列不空</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">enq</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (队列已满) &#123;</span><br><span class="line">                <span class="comment">// 等待队列不满</span></span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// add x to queue</span></span><br><span class="line">            <span class="comment">// 入队后,通知可出队</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deq</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (队列已空) &#123;</span><br><span class="line">                <span class="comment">// 等待队列不空</span></span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the first element from queue</span></span><br><span class="line">            <span class="comment">// 出队后，通知可入队</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AQS-amp-synchronized"><a href="#AQS-amp-synchronized" class="headerlink" title="AQS &amp; synchronized"></a>AQS &amp; synchronized</h2><p>JUC AQS 就是基于管程实现的，内部包含两个队列，一个是同步队列，一个是等待队列：</p>
<ol>
<li>同步队列：锁被占用时，会将该线程添加到同步队列中。当锁释放后，会从队列中唤醒一个线程，又分为公平和非公平两种。</li>
<li>等待队列：当调用 await 时，会将该线程添加到等待队列中。当其它线程调用 notify 时，会将该线程从等待队列移动到同步队列中，重新竞争锁。</li>
</ol>
<p>synchronized 也是基于管程实现的，核心的数据结构见 ObjectMonitor。AQS 和 synchronized 都是管程 MESA 模型在 Java 中的应用。一切都套路，有章可循。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/18/OSTEP%20Virtualization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/18/OSTEP%20Virtualization/" class="post-title-link" itemprop="url">虚拟化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-18 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-18T00:00:00+08:00">2025-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 21:12:30" itemprop="dateModified" datetime="2025-05-03T21:12:30+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CPU-Virtualization"><a href="#CPU-Virtualization" class="headerlink" title="CPU Virtualization"></a>CPU Virtualization</h1><h2 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h2><p><strong>操作系统</strong>：早期是一些函数库，然后发展出了保护的作用（内核态与用户态），之后是多道程序（多进程、多线程）</p>
<p><strong>软件设计思维</strong>：分离机制与策略</p>
<ul>
<li>机制：如何进行上下文切换？</li>
<li>策略：什么情况下，应该切换到谁？</li>
</ul>
<p><strong>进程</strong>：程序没有运行的时候，就是硬盘中静态的代码，程序开始运行了，就在内存中开辟属于自己的空间，进程可以看作是操作系统对程序运行的一种抽象。</p>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><ul>
<li>内存地址空间，特定CPU寄存器的值</li>
<li><strong>内存分配</strong>：程序代码、静态数据、运行时数据（包括堆栈和IO设置）</li>
<li><strong>栈空间</strong>（Stack）：可以由<code>main</code>传参进行初始化，主要存放局部变量、函数参数和返回地址</li>
<li><strong>用于IO的文件描述符</strong>（Descriptor）：默认开启<code>stdin</code> <code>stdout</code> <code>stderr</code>三个文件</li>
<li><strong>堆空间</strong>（Heap）：用于在程序运行时动态地向OS申请一片内存(<code>malloc</code>)</li>
<li>在进程创建之后，OS将CPU控制权给到程序，开始执行<code>main</code></li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241207204834626.png" alt="image-20241207204834626"></p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>加载到内存的进程基本状态如下三种</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241207204852570.png" alt="image-20241207204852570"></p>
<ul>
<li><strong>运行中</strong>：运行中的进程，也可以被反向调度</li>
<li><strong>待运行</strong>（就绪）：就绪的程序随时可以运行，等待调度</li>
<li><strong>阻塞</strong>：程序运行到不需要CPU的部分（比如IO）就会到阻塞状态，等IO任务完成会变成就绪</li>
<li>OS选择在进程发起IO时切换到别的进程，这样可以保持CPU繁忙，<strong>在IO结束时没有选择切换回去，这就是策略</strong></li>
</ul>
<h3 id="进程的数据结构"><a href="#进程的数据结构" class="headerlink" title="进程的数据结构"></a>进程的数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the registers xv6 will save and restore</span></span><br><span class="line"><span class="comment">// to stop and subsequently restart a process</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> eip;<span class="comment">//instruction ptr </span></span><br><span class="line">    <span class="type">int</span> esp;<span class="comment">//stack ptr</span></span><br><span class="line">    <span class="type">int</span> ebx;</span><br><span class="line">    <span class="type">int</span> ecx;</span><br><span class="line">    <span class="type">int</span> edx;</span><br><span class="line">    <span class="type">int</span> esi;</span><br><span class="line">    <span class="type">int</span> edi;</span><br><span class="line">    <span class="type">int</span> ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the different states a process can be in</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span> UNUSED, EMBRYO, SLEEPING,</span><br><span class="line">RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the information xv6 tracks about each process</span></span><br><span class="line"><span class="comment">// including its register context and state</span></span><br><span class="line"><span class="comment">// PCB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *mem; <span class="comment">// Start of process memory</span></span><br><span class="line">    uint sz; <span class="comment">// Size of process memory</span></span><br><span class="line">    <span class="type">char</span> *kstack; <span class="comment">// Bottom of kernel stack for this process</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span> <span class="comment">// Process state</span></span><br><span class="line">    <span class="type">int</span> pid; <span class="comment">// Process ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span> <span class="comment">// Parent process</span></span><br><span class="line">    <span class="type">void</span> *chan; <span class="comment">// If !zero, sleeping on chan</span></span><br><span class="line">    <span class="type">int</span> killed; <span class="comment">// If !zero, has been killed</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span> <span class="comment">// Open files</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span> <span class="comment">// Current directory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span> <span class="comment">// Switch here to run process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span> <span class="comment">// Trap frame for the current interrupt</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p> A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process control block (<strong>PCB</strong>), which is really just a structure that contains information about a specific process. </p>
</blockquote>
<ul>
<li><strong>上下文</strong>：指令指针、栈指针等都是CPU物理寄存器的内容，指令得以继续执行的关键，在恢复进程时很重要。</li>
<li><strong>进程状态</strong></li>
<li><strong>其他的静态信息</strong>：进程地址空间，父进程、中断信息、打开的文件等。</li>
</ul>
<p><img src="https://cdn.mazhen.tech/images/202209241609976.png" alt="vfs"></p>
<h3 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h3><h4 id="fork-wait-exec"><a href="#fork-wait-exec" class="headerlink" title="fork wait exec"></a>fork wait exec</h4><ul>
<li><strong>fork</strong>：复制一个和父进程一样的子进程（子进程直接从fork返回然后继续执行）子进程的内存空间和父进程是独立的，并且变量的值大部分一样，</li>
<li><strong>wait</strong>：子进程创建后，根据OS调度（schedule）决定先后顺序，wait可以使父进程等子进程执行完再开始运行</li>
<li><strong>exec</strong>：当前进程不想运行和之前一样的代码，可以调用exec加参数运行其他代码，新的程序会替代原来进程的所有信息，因此exec后边的代码是不会被执行的。</li>
</ul>
<h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><ul>
<li>shell的基本原理就是主进程fork wait 子进程这边exec 运行其他程序，运行完成主进程wait结束，继续进行其他操作</li>
<li><strong>输出重定向</strong>（redirecting）：默认输出就是标准输出流，如果你想重定向到一个文件，应当关闭stdout然后重新打开一个你想要的文件描述符。</li>
<li><strong>管道</strong>（pipe）：也类似与输出重定向，上一个的输出无缝作为下一个的输入</li>
<li><strong>有用的cli工具</strong>：top(table of processes), ps(process status), man(manual)…</li>
</ul>
<h4 id="signals-and-users"><a href="#signals-and-users" class="headerlink" title="signals and users"></a>signals and users</h4><blockquote>
<p>For example, control-c sends a SIGINT (interrupt) to the process (normally terminating it) and control-z sends a SIGTSTP (stop) signal thus pausing the process in mid-execution (you can resume it later with a command, e.g., the fg built-in command found in many shells).</p>
<p>receive and process those signals within individual processes, and  send signals to individual processes as well as entire process groups.</p>
</blockquote>
<p><code>signal()</code>可以使进程能够监听到上述这些信号，暂停现有程序执行，然后对信号做出一定的响应</p>
<blockquote>
<p>Users generally can only control their own processes; it is the job of the operating system to parcel out resources (such as CPU, memory, and disk) to each user (and their processes) to meet overall system goals.</p>
</blockquote>
<p>用户等级决定他们是否有权利发出某些特定的信号</p>
<hr>
<h2 id="机制：受限-直接执行"><a href="#机制：受限-直接执行" class="headerlink" title="机制：受限 直接执行"></a>机制：受限 直接执行</h2><h3 id="Limited-Direct-Execution"><a href="#Limited-Direct-Execution" class="headerlink" title="Limited Direct Execution"></a>Limited Direct Execution</h3><p><strong>直接执行</strong>：直接在CPU上运行程序。</p>
<p><strong>受限</strong>：一个进程要调用I/O，但是还不能让进程完全控制系统。</p>
<p><strong>用户模式</strong>（user mode）：应用程序不能完全控制硬件资源，如果硬要发起IO请求，CPU会出现异常，OS将终止进程</p>
<p><strong>内核模式</strong>（kernel mode）：操作系统可以完全掌控硬件。</p>
<blockquote>
<p>When changing protection levels from user to kernel mode, the kernel shouldn’t use the stack of the user process, because it may not be valid. The user process may be <strong>malicious</strong> or <strong>contain an error that causes the user %esp to contain an address that is not part of the process’s user memory</strong>.</p>
</blockquote>
<h4 id="syscall-amp-trap"><a href="#syscall-amp-trap" class="headerlink" title="syscall &amp; trap"></a>syscall &amp; trap</h4><p><strong>系统调用</strong>（system call）：允许内核小心地向用户暴露某些关键功能。执行<strong>trap</strong>指令，进入操作系统内核，将特权级别提升至内核模式，完成之后return from trap，返回值并将特权级别降低至用户模式。</p>
<blockquote>
<p>Typical user applications run in user mode, and use a system call to trap into the kernel to request operating system services.</p>
</blockquote>
<p>系统调用的参数放到一个指定的寄存器处，系统调用号也放到指定寄存器，需要仔细遵循约定来正确处理参数与返回值，高级语言通常屏蔽了底层硬件细节，因此需要使用汇编语言：</p>
<ul>
<li><strong>系统调用</strong>：用户程序通过陷阱指令请求内核服务（如文件操作、进程管理）。例如，在x86中：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 1   ; 系统调用号 (exit)</span><br><span class="line">mov ebx, 0   ; 参数 (退出码)</span><br><span class="line">int 0x80     ; 触发陷阱</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>中断处理</strong>：硬件设备通过中断向量触发陷阱，操作系统用汇编语言编写中断向量表。</li>
<li><strong>异常处理</strong>：陷阱用于处理非法操作（如除零或非法内存访问）。</li>
</ul>
<p><strong>陷阱表</strong>（trap table）：用户态不能执行io等直接操控底层硬件，否则就是非法的。进入内核态以后也不能随便寻址执行程序，必须跳到指定地址去执行对应的程序，这个指定的程序地址是<strong>内核</strong>（kernel）在启动时通过<strong>陷阱表</strong>告诉硬件的。用户程序也不能够识别陷阱表的内容。</p>
<blockquote>
<p>The trap instruction saves register state carefully, changes the hardware status to kernel mode, and jumps into the OS to a pre-specified destination: the trap table.</p>
<p>When the OS finishes servicing a system call, it returns to the user program via another special return-from-trap instruction, which reduces privilege and returns control to the instruction after the trap that jumped into the OS</p>
</blockquote>
<p>Limited Direct Execution Timeline：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241207194358704.png" alt="image-20241207194358704"></p>
<ul>
<li><p>要么是内核态要么是用户态，在用户进程开始执行之前（main）的准备工作肯定是由内核态完成，因此就要return from trap，切换到用户态。跳转到main函数</p>
</li>
<li><p>执行系统调用或者响应中断时，通过trap指令，cpu控制权腾给os，陷入内核态，执行的是与之前不同的程序，就需要保存执行的现场以便之后继续执行，将cpu寄存器上的内容先保存到<strong>内核栈（kernel stack）</strong>。</p>
</li>
<li><p>在系统调用结束之后把内核栈的内容弹出恢复到CPU寄存器上，切换回用户模式，继续执行之前的内容，最后main函数返回，同时通过exit()进行trap，进入内核态，做清理工作。</p>
</li>
</ul>
<h3 id="Limited-Direct-Execution-Timer-Interrupt"><a href="#Limited-Direct-Execution-Timer-Interrupt" class="headerlink" title="Limited Direct Execution(Timer Interrupt)"></a>Limited Direct Execution(Timer Interrupt)</h3><p><strong>直接执行（Direct Execution）</strong>：用户进程占用CPU，OS作为一个程序并没有在运行。问题在于OS如何重新获得CPU的控制权，以便在操控程序运行取得主动权。</p>
<p><strong>协作</strong>：OS只能等待被动的系统调用或者触发异常才会重新获得CPU控制权。</p>
<p><strong>非协作</strong>：时钟硬件设备可以编程为若干毫秒产生一次中断信号，CPU 检测到时钟中断信号后，暂停当前正在运行的任务，跳转到内核中预定义的<strong>中断服务例程（ISR, Interrupt Service Routine）</strong>处理</p>
<p>CPU必须在硬件层面实现能够保存用户程序运行的现场（trap的精髓）</p>
<ul>
<li><p><strong>操作系统处理时钟中断</strong>操作系统在时钟中断处理程序中执行以下任务：</p>
<ul>
<li><p>更新系统时间。</p>
</li>
<li><p>检查是否需要切换任务（触发<strong>任务调度</strong>）。</p>
</li>
<li><p>处理延迟或周期性任务（如超时处理、定时器事件等）。</p>
</li>
</ul>
</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241207200809875.png" alt="image-20241207200809875"></p>
<p>如图 hardware部分 需要在响应时钟中断时，把进程A的运行现场（寄存器）保存到内核栈中，然后跳转到trap处理程序。</p>
<h4 id="上下文切换（context-switch）"><a href="#上下文切换（context-switch）" class="headerlink" title="上下文切换（context switch）"></a>上下文切换（context switch）</h4><p>然后操作系统调用switch进行进程的切换A到B，因为一段时间内A都不会再运行，这时候就需要把A的寄存器内容保存到其进程空间（内存空间）</p>
<h5 id="kernel-stack-vs-Process-Control-Block"><a href="#kernel-stack-vs-Process-Control-Block" class="headerlink" title="kernel stack  vs Process Control Block"></a><code>kernel stack</code>  vs <code>Process Control Block</code></h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/likui360/p/6224624.html">Linux 系统中堆栈的使用方法 - 扫地猿 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/188577062">浅谈Linux 中的进程栈、线程栈、内核栈、中断栈 - 知乎</a></p>
<p>当进程在用户态运行时，使用的是用户栈，当进程陷入到内核态时，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，这个称作进程内核栈，内核栈保存进程在内核态运行的相关信息，一旦进程返回到用户态后，内核栈中保存的信息无效，会全部恢复，因此每次进程从用户态陷入内核的时候得到的内核栈都是空的。所以在进程陷入内核的时候，直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。</p>
<p>当位于用户空间的进程进行系统调用时，进程用户栈的地址会被存进内核栈中，CPU堆栈指针寄存器中的内容也会变为内核栈的地址。当系统调用执行完毕，进程从内核栈找到用户栈的地址，继续在用户空间中执行，此时CPU堆栈指针寄存器就变为了用户栈的地址。各进程独立的。进程运行时分用户态跟内核态，所以需要有内核栈和常说的堆栈段，寻址方式是相同的，都是查LDT和页表进行地址映射，但二者段描述符里的特权级不同，为了区分用户态和内核态。</p>
<p>为什么每个进程都有一个内核栈，而不是所有进程共用一个。老的UNIX和Linux当时就是每个CPU只有一个内核栈，那个时候不会出现“执行到一半的时候上下文切换”，因为不允许用户态程序抢占正在执行系统调用的另一个用户态程序。后来每个进程一个内核栈了，就可以发生“执行到一半的时候上下文切换”了</p>
<p>语言书里面讲的堆、栈大部分都是用户态的概念，用户态的堆、栈对应用户进程虚拟地址空间里的一个区域，栈向下增长，堆用malloc分配，向上增长。</p>
<ul>
<li>中断发生时，寄存器先保存到内核栈；如果需要切换进程，内核会将内核栈中的寄存器内容转存到进程结构中。</li>
<li><strong>内核栈</strong>主要用于快速保存和恢复寄存器内容，适用于临时的上下文切换或中断处理。</li>
<li><strong>进程结构</strong>适用于更复杂的进程调度和长时间的上下文切换，提供长期的状态保存。proc结构体中的context字段就是用来保存寄存器信息的（xv6）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>方面</strong></th>
<th><strong>内核栈</strong></th>
<th><strong>进程结构（PCB）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>保存时机</strong></td>
<td>短暂事件（如中断、系统调用）</td>
<td>进程调度时</td>
</tr>
<tr>
<td><strong>存储位置</strong></td>
<td>当前进程的内核栈</td>
<td>PCB 或其他持久性数据结构</td>
</tr>
<tr>
<td><strong>存储时间</strong></td>
<td><strong>临时保存</strong>，内核处理结束后直接恢复</td>
<td><strong>长期保存</strong>，直至进程切换回来</td>
</tr>
<tr>
<td><strong>访问开销</strong></td>
<td>较低，直接访问内核栈</td>
<td>较高，涉及更多内存操作</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>快速上下文切换、临时中断处理</td>
<td>进程调度或长时间上下文切换</td>
</tr>
<tr>
<td><strong>局限性</strong></td>
<td>不能长期存储</td>
<td>开销大，需要额外的数据结构</td>
</tr>
<tr>
<td>优点</td>
<td>连续内存块，访问效率较高，内核处理完直接恢复</td>
<td>寄存器信息可以跨多个调度周期存储</td>
</tr>
</tbody></table>
<p>进程调度，需要把B的现场信息从进程空间中恢复到寄存器里，然后恢复到用户态，跳转到B的PC，执行B的内容。</p>
<p><strong>并发</strong>：系统调用时触发中断。</p>
<hr>
<h2 id="策略：CPU-调度"><a href="#策略：CPU-调度" class="headerlink" title="策略：CPU 调度"></a>策略：CPU 调度</h2><h3 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h3><h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><p><strong>FIFO</strong>：先到先得，计算密集型会阻塞io密集型，降低效率</p>
<p><strong>SJF</strong>：Shortest Job First 最短工作优先，<u>同时到达</u>，先进行最短的工作</p>
<p><strong>STCF</strong>：Shortest Time-to-Complete First 最短完成时间优先，针对<u>随时到达</u>的情况，到达时比较里完成还有多少时间，首次出现了任务切换的概念。</p>
<h4 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h4><p>以上能够逐步优化 T<del>周转</del> = T<del>完成</del> - T<del>到达</del>，但是对于T<del>响应</del> = T<del>首次运行</del> - T<del>到达</del> 不友好，因为完成时间最长的必须等其他任务完成，自己才能继续。</p>
<p>交互式的任务对于响应时间很敏感。因此需要另外一种调度策略</p>
<p><strong>RR</strong>：Round-Robin 轮转，运行一个任务到时间片就切换到下一个任务（context switch）</p>
<ul>
<li>上下文的切换需要时间，因此时间片的大小也应该选择恰当</li>
</ul>
<p><strong>Overlap</strong>：重叠，如果A任务有IO，当A因为IO而空出CPU时，CPU就应该去服务B</p>
<p><strong>不可预知性</strong>：调度程序不知道到来的任务持续多长时间。</p>
<h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>准时比准确更加重要</p>
<h3 id="基于优先级且无需先验知识的调度：多级反馈队列-MLFQ"><a href="#基于优先级且无需先验知识的调度：多级反馈队列-MLFQ" class="headerlink" title="基于优先级且无需先验知识的调度：多级反馈队列 MLFQ"></a>基于优先级且无需先验知识的调度：多级反馈队列 MLFQ</h3><p>MLFQ：Multi-Level Feedback Queue，多级反馈队列</p>
<ul>
<li>设置不同的优先级，每个任务刚到达都是最高级</li>
<li>级别低的任务必须先让级别高的执行完</li>
<li>相同级别的任务轮转执行</li>
<li>在同一个优先级执行时间达到阈值就降低优先级：防止高优先级一直占据CPU，如果采用每次执行的计时方法可能会有恶意占据CPU的情况发生</li>
<li>每隔一段时间就重置所有任务的优先级为最高：防止低优先级变成饥饿状态</li>
</ul>
<h1 id="Memory-Virtualization"><a href="#Memory-Virtualization" class="headerlink" title="Memory Virtualization"></a>Memory Virtualization</h1><h2 id="每个程序员都应该知道的时延"><a href="#每个程序员都应该知道的时延" class="headerlink" title="每个程序员都应该知道的时延"></a>每个程序员都应该知道的时延</h2><p><img src="https://camo.githubusercontent.com/b425440f6447aded36e9e2dc9fcfd2e97dfaf9811b518d71fa92a5f3d94f9e07/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">L1 cache reference ......................... 0.5 ns</span><br><span class="line">Branch mispredict ............................ 5 ns</span><br><span class="line">L2 cache reference ........................... 7 ns</span><br><span class="line">Mutex lock/unlock ........................... 25 ns</span><br><span class="line">Main memory reference ...................... 100 ns             </span><br><span class="line">Compress 1 KB with Zippy ................. 3,000 ns  =       3 µs</span><br><span class="line">Send 2 KB over 1 Gbps network ........... 20,000 ns  =      20 µs</span><br><span class="line">SSD random read ........................ 150,000 ns  =     150 µs</span><br><span class="line">Read 1 MB sequentially from memory ..... 250,000 ns  =     250 µs</span><br><span class="line">Round trip within same datacenter ...... 500,000 ns  =     500 µs  =  0.5 ms</span><br><span class="line">Read 1 MB sequentially from SSD ...... 1,000,000 ns  =   1,000 µs  =    1 ms</span><br><span class="line">Disk seek ........................... 10,000,000 ns  =  10,000 µs  =   10 ms</span><br><span class="line">Read 1 MB sequentially from disk .... 20,000,000 ns  =  20,000 µs  =   20 ms</span><br><span class="line">Send packet CA-&gt;Netherlands-&gt;CA .... 150,000,000 ns  = 150,000 µs  =  150 ms</span><br></pre></td></tr></table></figure>

<h2 id="地址空间、分段（segmentation）"><a href="#地址空间、分段（segmentation）" class="headerlink" title="地址空间、分段（segmentation）"></a>地址空间、分段（segmentation）</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/7/70/VirtualMem01.png" alt="img"></p>
<p><strong>地址空间</strong>：程序认为自己独占了这片内存空间，以为自己是连续的内存空间。低位是代码，堆往上递增，栈往下反向增长。</p>
<p>实际上是在物理内存中申请了一片连续的内存空间分配给进程，进程根据指令寻址的时候，操作系统将虚拟地址 <strong>重定位</strong> 到真正的物理地址。虚拟地址从0开始，因此虚拟地址实际上就是物理地址的偏移量。直接打印指针变量的值是虚拟地址而不是物理地址。</p>
<h3 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h3><p><strong>隔离进程</strong>：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</p>
<p><strong>提升物理内存利用率</strong>：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</p>
<p><strong>简化内存管理</strong>：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</p>
<p><strong>多个进程共享物理内存</strong>：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</p>
<p><strong>提高内存使用安全性</strong>：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</p>
<p><strong>提供更大的可使用内存空间</strong>：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</p>
<hr>
<p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-02.html">https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-02.html</a></p>
<h3 id="重定位（relocation）"><a href="#重定位（relocation）" class="headerlink" title="重定位（relocation）"></a>重定位（relocation）</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210205158811.png" alt="image-20241210205158811"></p>
<p><code>Virtual Address + Base = Physical Address</code> </p>
<p><strong>静态重定位</strong>：用软件实现，直接将指令中的虚拟地址用计算的真实物理地址覆盖。</p>
<ul>
<li>缺点：不安全，不方便更改。</li>
</ul>
<p><strong>动态重定位</strong>：用硬件实现，也就是CPU中的==MMU==，里面两个最基本的寄存器：<strong>基址寄存器</strong>、<strong>界限寄存器</strong>。将指令中的虚拟地址和基址相加得出真实物理地址，然后取得从硬件层面取得对应地址的值。这一切都是用硬件进行的。</p>
<ul>
<li>安全性：用界限（bound）和虚拟地址比较，如果超过了界限，说明虚拟地址访问越界，抛出异常</li>
<li>便于更改：改变寄存器的值即可实现基址的改变</li>
<li>性能高：硬件实现性能好</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210205227715.png" alt="image-20241210205227715"></p>
<h3 id="实现虚拟内存"><a href="#实现虚拟内存" class="headerlink" title="实现虚拟内存"></a>实现虚拟内存</h3><p><strong>实现虚拟内存机制的硬件支持：MMU</strong></p>
<ul>
<li><p>划分用户空间和内核空间</p>
</li>
<li><p>一对基址寄存器和界限寄存器，专门用来进行地址转换的电路</p>
</li>
<li><p>专门用来判断是否越界的电路，判断越界之后应当向CPU抛出异常</p>
</li>
<li><p>特权指令：操作系统应当能够设置上述寄存器的值</p>
</li>
<li><p>特权指令：操作系统应当告诉硬件发现异常应该执行哪些代码（Exception Handler）</p>
</li>
</ul>
<p><strong>实现虚拟内存机制的软件支持：OS</strong></p>
<ul>
<li>内存管理：分配机制、释放机制、空闲空间的管理——free list</li>
<li>切换上下文时正确设置对应的寄存器</li>
<li>抛出异常（内存访问越界、非法指令）时执行特定的处理代码</li>
</ul>
<p><strong>地址空间的不足</strong>：内部碎片（inner fragment）栈和堆之间未使用的空间也分配给整个地址空间，浪费较大</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><h4 id="segmentation"><a href="#segmentation" class="headerlink" title="segmentation"></a>segmentation</h4><p><strong>段式管理</strong>：以段(—段连续的物理内存)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。然后给每个段都配一对基址寄存器和界限寄存器。</p>
<p>例：0-16KB的虚拟地址空间，虚拟地址14位，高2位为段号，低12位为最大4KB的段空间。虚拟地址 = 段号 + 偏移 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get top 2 bits of 14-bit VA</span></span><br><span class="line">Segment = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SEG_SHIFT</span><br><span class="line"><span class="comment">// now get offset</span></span><br><span class="line">Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line"><span class="keyword">if</span> (Offset &gt;= Bounds[Segment])</span><br><span class="line">	RaiseException(PROTECTION_FAULT)<span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	PhysAddr = Base[Segment] + Offset<span class="comment">//基址+偏移</span></span><br><span class="line">	Register = AccessMemory(PhysAddr)<span class="comment">//访存</span></span><br></pre></td></tr></table></figure>

<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210205528802.png" alt="image-20241210205528802"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210205438635.png" alt="image-20241210205438635"></p>
<table>
<thead>
<tr>
<th>段名称</th>
<th>段号</th>
<th>基址寄存器</th>
<th>界限寄存器</th>
<th>是否正向增长</th>
</tr>
</thead>
<tbody><tr>
<td>代码</td>
<td>00</td>
<td>26 KB</td>
<td>2 KB</td>
<td>1</td>
</tr>
<tr>
<td>堆</td>
<td>01</td>
<td>28 KB</td>
<td>2 KB</td>
<td>1</td>
</tr>
<tr>
<td>栈</td>
<td>11</td>
<td>18 KB</td>
<td>2 KB</td>
<td>0</td>
</tr>
</tbody></table>
<p>现在要判断虚拟地址15KB的真实地址：<code>11 11 00000 00000</code> 可见段号为 11，偏移 3 KB，栈空间反向增长，最大段空间为 4 KB，实际上就是计算15KB离全1有多远：3KB - 4KB = -1 KB,因此在基址寄存器减1KB即为实际物理地址。</p>
<h5 id="用于保护的额外状态字"><a href="#用于保护的额外状态字" class="headerlink" title="用于保护的额外状态字"></a>用于保护的额外状态字</h5><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241211001125226.png" alt="image-20241211001125226"></p>
<h5 id="分段的问题"><a href="#分段的问题" class="headerlink" title="分段的问题"></a>分段的问题</h5><ul>
<li><strong>外部碎片</strong>：每个分段的大小不一致，因此产生了大小不一致的碎片，无法使空间得到有效利用。</li>
<li><strong>不支持稀疏的大堆</strong>：Another problem is that some segments could have a larger size and since this segment can’t be “broken” into smaller pieces, it must be fully allocated in memory. 分段大小是固定的，并不能将其拆成小段，申请了一段物理内存，寄存器的基址和界限已经确定好，这部分物理空间就不能再由其他的进程使用了，因此不支持按需分配。</li>
<li>Segments of unequal size not suited as well for swapping.</li>
</ul>
<h5 id="段表：更细粒度的分段"><a href="#段表：更细粒度的分段" class="headerlink" title="段表：更细粒度的分段"></a>段表：更细粒度的分段</h5><p>细粒度分段需要进一步硬件支持，并且在内存中存储 段表 （segment table）</p>
<p>分段机制下的虚拟地址由两部分组成：</p>
<ul>
<li><strong>段号</strong>：标识着该虚拟地址属于整个虚拟地址空间中的哪一个段。</li>
<li><strong>段内偏移量</strong>：相对于该段起始地址的偏移量。</li>
</ul>
<p>具体的地址翻译过程如下：</p>
<ol>
<li>MMU 首先解析得到虚拟地址中的段号；</li>
<li>通过段号去该应用程序的段表中取出对应的段信息（找到对应的段表项）；</li>
<li>从段信息中取出该段的起始地址（物理地址）加上虚拟地址中的段内偏移量得到最终的物理地址。</li>
</ol>
<p><img src="https://miro.medium.com/v2/resize:fit:1313/1*82aSNHRAkNNinGuPpsl6TQ.png" alt="img">分段机制下的地址翻译过程</p>
<p>段表中还存有诸如段长(可用于检查虚拟地址是否超出合法范围)、段类型（该段的类型，例如代码段、数据段等）等信息。</p>
<p><strong>通过段号一定要找到对应的段表项吗？得到最终的物理地址后对应的物理内存一定存在吗？</strong></p>
<p>不一定。段表项可能并不存在：</p>
<ul>
<li><strong>段表项被删除</strong>：软件错误、软件恶意行为等情况可能会导致段表项被删除。</li>
<li><strong>段表项还未创建</strong>：如果系统内存不足或者无法分配到连续的物理内存块就会导致段表项无法被创建。</li>
</ul>
<h4 id="减少碎片"><a href="#减少碎片" class="headerlink" title="减少碎片"></a>减少碎片</h4><ul>
<li><p><strong>内存紧缩</strong>（compact）：内存存储不下程序，会把暂时休息的第一个进程方法放入磁盘，过段时间移除进程b放入进程a，这样会让内存中出现空洞，所以要将进程整体往下移动。必须将运行中的进程中断，将所有分散的内存碎片压到连续的部分中，然后再将新的基址和界限移动到寄存器中，进程按照新的上下文继续执行。缺点是代价太高，性能不好</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20240922142056246.png" alt="image-20240922142056246"></p>
</li>
<li><p><strong>改善空闲列表</strong>（free list）：分配内存的时候采取一定的策略，尽量减轻内存碎片的现象，但也无法根除碎片的出现</p>
</li>
</ul>
<h2 id="空闲空间的管理"><a href="#空闲空间的管理" class="headerlink" title="空闲空间的管理"></a>空闲空间的管理</h2><p>维护一个空闲空间的列表（freelist）</p>
<h3 id="机制：分割与合并"><a href="#机制：分割与合并" class="headerlink" title="机制：分割与合并"></a>机制：分割与合并</h3><p>splitting</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210222509968.png" alt="image-20241210222509968"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210222527700.png" alt="image-20241210222527700"></p>
<p>coalescing</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210222438918.png" alt="image-20241210222438918"></p>
<h3 id="内存-API"><a href="#内存-API" class="headerlink" title="内存 API"></a>内存 API</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p><code>void* malloc(int size)</code> 申请大小为size的连续字节空间（虚拟意义上的连续），返回一个指向这个空间首部的指针</p>
<p>除了用户申请的空间之外，在malloc时还会申请一个头部Header，size用来表示申请空间的大小，magic魔数用来验证完整性<a target="_blank" rel="noopener" href="https://www.cnblogs.com/whiteBear/p/16729327.html">延迟分配：提供内存利用率的三种机制 - 牛犁heart - 博客园</a></p>
<ul>
<li>malloc只是分配了虚拟内存，程序真正访问才会触发页错误给这些虚拟页分配物理页框（demand paging）</li>
<li>在标准 C 库中，提供了 malloc / free 函数分配释放内存，这两个函数底层是由 brk，mmap，munmap 这些系统调用实现的。 (<em>详见Linux虚拟内存系统</em>) 不过跟直接调用还是有区别的。</li>
</ul>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p><code>void free(void* ptr)</code> 将指针ptr所指向的已分配空间释放掉，依据的信息是<strong>分配内存的Header部分</strong> ，因此malloc的size并不是真正的大小，还要分配头部<img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210221647796.png" alt="image-20241210221647796"></p>
<h3 id="嵌入-free-list-到内存中"><a href="#嵌入-free-list-到内存中" class="headerlink" title="嵌入 free list 到内存中"></a>嵌入 free list 到内存中</h3><p>free list 本身也需要存储在内存中，这里我们知道：空闲的块作为空闲节点有额外的简单数据结构（int size, node* next），已分配的块同样也有简单的数据结构（int size, int magic），因此堆实际上是一个空闲内存和已分配的内存的混合。</p>
<ul>
<li>未分配空间</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210222820688.png" alt="image-20241210222820688"></p>
<ul>
<li>连续分配了3个100字节的空间</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210223130088.png" alt="image-20241210223130088"></p>
<ul>
<li>中间出现了空隙，可以看到空闲列表的头节点（head）发生了变化，两个空闲的块通过链表连接起来</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210223253160.png" alt="image-20241210223253160"></p>
<ul>
<li>全部释放之后，出现了4个空闲的块，但是还没有合并（merge）</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210223340586.png" alt="image-20241210223340586"></p>
<h3 id="策略：连续内存分配"><a href="#策略：连续内存分配" class="headerlink" title="策略：连续内存分配"></a>策略：连续内存分配</h3><h4 id="基本策略：空闲链表"><a href="#基本策略：空闲链表" class="headerlink" title="基本策略：空闲链表"></a>基本策略：空闲链表</h4><ul>
<li><strong>Best Fit</strong>：遍历整个列表，找到跟分配块大小最接近的空闲块，尽量减少碎片大小。细小碎片多，开销大。</li>
<li><strong>Worst Fit</strong>：遍历整个列表，找到跟分配块大小差距最大的，分割之后将剩余块加入空闲列表。碎片过量，开销大。</li>
<li><strong>First Fit</strong>：第一次找到足够大的块就直接分配。会让开头部分有许多小的碎片，可以通过按地址排序，便于合并操作。</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20240922142709440.png" alt="image-20240922142709440"></p>
<ul>
<li><strong>Next Fit</strong>：每次查找都从上次结束的地方开始，剩下逻辑依然是首次匹配，可以减少开头部分过多的小碎片，将其分散到其他地方。</li>
</ul>
<p><strong>位图</strong>：</p>
<p><img src="https://pic4.zhimg.com/v2-ccf3e0ea94a135e7f8548f3e9ef42813_1440w.jpg" alt="img"></p>
<h4 id="内存池（memory-pool）"><a href="#内存池（memory-pool）" class="headerlink" title="内存池（memory pool）"></a>内存池（memory pool）</h4><p>如果能将一大块内存分成多个小内存（称为内存池），不同的内存池又按照不同的「尺寸」分成大小相同的内存块（比如分别按照32, 64, 128……字节），同一内存池中的空闲内存块按照free list的方式连接。每次分配的时候，选择和申请的的内存在「尺寸」上最接近的内存池，比如申请60字节的内存，就直接从单个内存块大小为64字节的内存池的free list上分配。</p>
<img src="https://pic4.zhimg.com/v2-12148c36cd07924a26e0ce35b67f29eb_1440w.jpg" alt="img" style="zoom:150%;" />

<p>需要结合系统实际的内存分配需求，对内存池的大小进行合理的划分。比如一个系统常用的是256字节以下的内存申请，那设置过多的256字节以上的内存池，就会造成内存资源的闲置和浪费。</p>
<h4 id="其他策略"><a href="#其他策略" class="headerlink" title="其他策略"></a>其他策略</h4><p>Linux 发展出两种基于内存池的分配策略，<em>详见 Linux 实现</em></p>
<ul>
<li><strong>Buddy system</strong>: 将内存池划分为以2^n^为大小的类型，同一内存池中的空闲块大小相同，如果空闲块是相邻的则合并，将合并后的块加入更大的内存池中</li>
<li><strong>SLAB</strong>: 伙伴系统是按页分配的，但内核经常会申请一些特定大小的内存，往往不到一页，如果仍然使用伙伴系统将造成很多内部碎片，SLAB为它们分配了内核对象缓存，专门的连续内存区，依然使用内存池的思路，但是池子变得比以前更小。</li>
</ul>
<h2 id="分页（paging）"><a href="#分页（paging）" class="headerlink" title="分页（paging）"></a>分页（paging）</h2><h3 id="虚拟——物理页号转换"><a href="#虚拟——物理页号转换" class="headerlink" title="虚拟——物理页号转换"></a>虚拟——物理页号转换</h3><h4 id="页帧、页帧号、虚拟页号"><a href="#页帧、页帧号、虚拟页号" class="headerlink" title="页帧、页帧号、虚拟页号"></a>页帧、页帧号、虚拟页号</h4><p><strong>分页机制</strong>：将虚拟的地址替换成物理地址，用大小相等的页代替大小不等的段。原来一个进程是代码段和数据段不等，分配的内存空间也不一样，现在将段继续拆分成大小相等的页表项，这样从根本上解决了外部碎片的问题。</p>
<p><strong>页帧（Page Frame）</strong>：物理内存中存放数据的最小单位。当一个虚拟页被映射到物理页时，数据会存放在对应的<strong>页帧</strong>中。假设一个进程的虚拟地址空间中有一个虚拟页，虚拟地址 <code>0x1000</code> 对应的虚拟页页号是 <code>0x1</code>，偏移量为0。此时，操作系统通过页表将虚拟页 <code>0x1</code> 映射到物理内存中的一个页帧 <code>0x3</code>，即物理地址为 <code>0x3000</code>。那么，当该进程访问虚拟地址 <code>0x1000</code> 时，CPU 会通过页表将其转换为物理地址 <code>0x3000</code>，并在页帧 <code>0x3</code> 中访问数据。页帧大小固定为PageSize</p>
<p><strong>虚拟地址（Virtual Address）= 虚拟页号（VPN, Virtual Page Number） + 偏移量（Offset）</strong></p>
<p><strong>页表项（Page Table Entry）= 物理页号（PFN, Page Frame Number）+ 保留的功能位</strong></p>
<p><strong>页表的物理地址</strong>：加载到<strong>页表基址寄存器（PTBR, Page Table Base Register）</strong>，一个<strong>页表项（PTE）</strong>分为<strong>物理页号（PFN）</strong>，有效位valid，读写权限位protection，内核模式位，脏位dirty，引用reference，存在位present等功能位。</p>
<h4 id="从虚拟地址访存基本步骤"><a href="#从虚拟地址访存基本步骤" class="headerlink" title="从虚拟地址访存基本步骤"></a>从虚拟地址访存基本步骤</h4><ul>
<li><p><code>VirtualAddress = VPN + Offset</code> </p>
</li>
<li><p><code>PTE Address(Physical) = VPN * PageSize + PTBR</code> PTE保存着PFN以及其他功能位</p>
</li>
<li><p><code>Physical Address = PFN * PageSize + Offset</code> </p>
</li>
<li><p>实际上VPN PFN Offset都是通过和MASK（作用和子网掩码相同）相与，然后PFN移位后和Offset相或。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extract the VPN from the virtual address</span></span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line"><span class="comment">// Form the address of the page-table entry (PTE)</span></span><br><span class="line">PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br><span class="line"><span class="comment">// Fetch the PTE</span></span><br><span class="line">PTE = AccessMemory(PTEAddr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if process can access the page</span></span><br><span class="line"><span class="keyword">if</span> (PTE.Valid == False)<span class="comment">// Valid bit = 0</span></span><br><span class="line">	RaiseException(SEGMENTATION_FAULT) <span class="comment">//illegal memory access</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">	RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// Access OK: form physical address and fetch it</span></span><br><span class="line">    offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">    PhysAddr = (PTE.PFN &lt;&lt; PFN_SHIFT) | offset</span><br><span class="line">    Register = AccessMemory(PhysAddr)</span><br></pre></td></tr></table></figure>

<p><strong>一些功能位</strong></p>
<ul>
<li>Protection bit：权限位，保护位 r w x，如果违反了越权访问，就要陷入OS</li>
<li>Valid bit：有效位，虚拟地址空间并不是全部都要分配，如果访问了还没有分配的（valid bit = 0）就是非法访问，将会抛出异常陷入OS</li>
<li>Dirty bit：脏位，页面带入内存之后是否被修改过</li>
<li>Present bit：存在位，表示内存页在内存中还是已经被换出</li>
<li>Reference bit：参考位，追踪页面是否被访问</li>
</ul>
<h4 id="页表开销"><a href="#页表开销" class="headerlink" title="页表开销"></a>页表开销</h4><ul>
<li><strong>内存开销</strong>：每个页表项需要4B，页大小（PageSize）是4KB，要虚拟出一个4GB的空间，就要有4GB/4KB * 4B =4MB 空间来存储。对每个进程操作系统都要有4MB的空间用于页表的储存，开销很大。页表是按照页号进行索引查找的，这就需要本身是一段连续的内存空间，页表就是一个大的数组，实际上页表在物理上也连续。</li>
<li><strong>性能开销</strong>：对于每个内存引用，都要额外引入一次内存引用，效率不高,每一次访存都多了一步访问页表，性能显著下降</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1075436/201908/1075436-20190809172852450-661010612.png" alt="img"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241212120853391.png" alt="image-20241212120853391"></p>
<h4 id="页表总结"><a href="#页表总结" class="headerlink" title="页表总结"></a>页表总结</h4><p><strong>Pros</strong>:</p>
<ul>
<li>No external fragments</li>
<li>Flexible, good support for sparse address space</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>Physical Space costs (Page table)</li>
<li>Speed Costs (extra memory access)</li>
</ul>
<h3 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表 TLB"></a>快表 TLB</h3><p><strong>如果想要快速的缓存，他就必须小，因为光速和其他物理限制会起作用</strong></p>
<p><strong>TLB</strong>：因为有二八定律，所以MMU要记下经常使用的虚拟页号，将VPN与PFN的映射关系存在 <strong>TLB</strong> 快表中（<strong>Translation Lookaside Buffer</strong> aka. <strong>Address Translation Cache</strong>）</p>
<h4 id="硬件实现-TLB-控制流"><a href="#硬件实现-TLB-控制流" class="headerlink" title="硬件实现 TLB 控制流"></a>硬件实现 TLB 控制流</h4><p>CISC 将tlb miss逻辑全权交给硬件负责，拿着虚拟页号 VPN 去 TLB 中查询</p>
<ul>
<li>TLB hit：直接访存(<code>AccessMemory</code>)</li>
<li><strong>TLB miss：查页表，查到PFN后写入TLB（<code>TLB_Insert</code>），重新执行TLB查询操作（<code>RetryInstruction</code>）</strong>  </li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241212122549686.png" alt="image-20241212122549686"></p>
<p>硬件实现：需要PTBR（x86架构中为CR3寄存器），页表的确切格式是写死在硬件里的（x86中为多级页表）</p>
<h4 id="软件实现-TLB-控制流"><a href="#软件实现-TLB-控制流" class="headerlink" title="软件实现 TLB 控制流"></a>软件实现 TLB 控制流</h4><p>RISC 将tlb miss看作一个异常，陷入OS，执行对应的处理程序</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241212124132429.png" alt="image-20241212124132429"></p>
<p><strong>软件实现的好处</strong>：可以随时更改，可扩展性强，页表的数据结构由操作系统自行决定，</p>
<p><strong>注意的问题</strong>：</p>
<ul>
<li>TLBmissHandler和一般的trap不同，一般return from trap 会从陷入后的地方继续执行，而TLBmiss则会从<strong>重试</strong>陷入之前的程序，因此保存的上下文很重要，尤其是程序计数器</li>
<li>TLBmissHandler也是代码，要访存，须谨防无限递归tlb miss的问题，可以专门把一块TLB的空间划给TLBmiss处理程序使用；或者也可以不使用虚拟内存，直接把代码物理地址告诉硬件（unmapped，陷阱表）</li>
</ul>
<h4 id="TLB-内容"><a href="#TLB-内容" class="headerlink" title="TLB 内容"></a>TLB 内容</h4><h5 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h5><p><code>VPN | PFN | other bits</code></p>
<p>是一个全相联（fully-associative）的cache结构，硬件会并行地查找这些项，</p>
<p><strong>other bits</strong>：</p>
<ul>
<li><p>protection：访问权限</p>
</li>
<li><p>valid：表示TLB是否记录着一个有效的<code>VPN-&gt;PFN</code>映射，PTE的有效位为0表示这是一个并未被应用申请过的非法地址</p>
</li>
<li><p>dirty：脏位</p>
</li>
<li><p>asid：access space id，地址空间id，用来标识不同进程的TLB条目<a target="_blank" rel="noopener" href="https://blog.csdn.net/Rong_Toa/article/details/110758233">Linux进程管理+内存管理：进程切换的TLB处理（ASID-address space ID、PCID-process context ID）_进程的asid-CSDN博客</a> </p>
</li>
</ul>
<h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h5><p>TLB集成在CPU内部的MMU，因此一定会有上下文切换的问题，VPN一样的条目会导致数据错误</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241212131757567.png" alt="image-20241212131757567"></p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>上下文切换的时候将所有 TLB 条目的<strong>有效位</strong>置0（flush），下一个进程可以随便覆盖</li>
<li>使用ASID（类似于pid）记录这个TLB条目属于哪个进程</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241212131846711.png" alt="image-20241212131846711"></p>
<p><strong>PFN一样的条目</strong>：可能是共享代码页，这样可以减少额外分配物理页</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241212131859962.png" alt="image-20241212131859962"></p>
<h5 id="例：MIPS-TLB-Entry"><a href="#例：MIPS-TLB-Entry" class="headerlink" title="例：MIPS TLB Entry"></a>例：MIPS TLB Entry</h5><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241212134843225.png" alt="image-20241212134843225"></p>
<p>0-18 VPN  19 Global 进程间共享  24-31 ASID 进程空间 </p>
<h4 id="刷新、替换"><a href="#刷新、替换" class="headerlink" title="刷新、替换"></a>刷新、替换</h4><h5 id="TLB-flush"><a href="#TLB-flush" class="headerlink" title="TLB flush"></a>TLB flush</h5><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66971714">TLB之flush操作[一] - 知乎</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66994486">TLB之flush操作[二] - 知乎</a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/Rong_Toa/article/details/110760995">Linux内存管理：TLB flush操作-CSDN博客</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Rong_Toa/article/details/110758233">Linux进程管理+内存管理：进程切换的TLB处理（ASID-address space ID、PCID-process context ID）_进程的asid-CSDN博客</a> </p>
<p>在页表PTE的内容出现变化时，比如page fault时页面被换出，munmap()时映射被解除，就需要invalidate对应的TLB entry，有时这个操作也被称为flush（以下的讨论将统一称为flush）。</p>
<p>当系统中各个cpu的TLB中的asid合起来不大于256个的时候，系统正常运行，一旦超过256的上限后，我们将全部TLB flush掉，并重新分配ASID，每达到256上限，都需要flush tlb并重新分配HW ASID。</p>
<p>在多核系统中，虽然每个核心的MMU是独立的，但它们在访问<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=695131149&content_type=Answer&match_order=1&q=%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98&zhida_source=entity">共享内存</a>时需要进行协调。共享内存区域允许多个核心同时访问相同的物理内存，这对于核心间的通信或共享数据非常关键。MMU可以通过为不同的内存区域设置权限和属性，确保多个核心在访问这些共享区域时不会出现数据冲突或不一致的情况。这在多线程或多进程系统中，尤其在同步和内存一致性方面，显得尤为重要。</p>
<h5 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a><a href="#eviction">缓存更新策略</a></h5><h2 id="优化分页"><a href="#优化分页" class="headerlink" title="优化分页"></a>优化分页</h2><h3 id="扩大页面大小（Bigger-Pages）"><a href="#扩大页面大小（Bigger-Pages）" class="headerlink" title="扩大页面大小（Bigger Pages）"></a>扩大页面大小（Bigger Pages）</h3><p>Linux</p>
<ul>
<li><p>对TLB更加友好，考虑到空间局部性，同一页能够访问更多数据，也就不用频繁地查页表了</p>
</li>
<li><p>增大页面大小，VPN<del>max</del>变小，每个虚拟页占空间4B，页表占用总空间减小；</p>
</li>
<li><p>但应用程序申请的并不一定是会充满整个页，所以会出现内部碎片（internal fragment）</p>
</li>
</ul>
<h3 id="分段-分页（Hybrid-Approach）"><a href="#分段-分页（Hybrid-Approach）" class="headerlink" title="分段 + 分页（Hybrid Approach）"></a>分段 + 分页（Hybrid Approach）</h3><h4 id="线性页表的局限"><a href="#线性页表的局限" class="headerlink" title="线性页表的局限"></a>线性页表的局限</h4><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241212210406110.png" alt="image-20241212210406110"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241212210703824.png" alt="image-20241212210703824"></p>
<p>如图，虚拟空间是16KB，页面大小为1KB，因此页表共有16 entries，除去代码段，堆栈之间的空间是严重浪费的，就像分段会导致内部碎片一样，连续的线性页表也会导致内部碎片。</p>
<h4 id="段页结合"><a href="#段页结合" class="headerlink" title="段页结合"></a>段页结合</h4><p>VAX/VMS</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241212213305035-1734010396522-12.png" alt="image-20241212213305035"></p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/8904fb89ae0c49c4b0f2f7b5a0a7b099.png" alt="img"></p>
<p>可以根据代码、堆、栈对页表进行分类，然后使用三个base-bound寄存器对，上下文切换时保存、恢复寄存器内容。更细粒度的分段可以使用段表。base存储段在物理内存的位置，bound表示段大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SN  = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SN_SHIFT</span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; VPN_SHIFT</span><br><span class="line">AddressOfPTE = Base[SN] + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br></pre></td></tr></table></figure>

<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>与分段的缺陷一样，只不过是将真正的数据部分换成了页表</li>
<li>不灵活，假设地址空间有一定的使用模式，分段则需要为整个堆段预留连续空间，即使中间部分未使用也无法释放。<ul>
<li>a large but sparsely-used heap 仍然可能导致大量的页表浪费</li>
</ul>
</li>
<li>由于界限寄存器的存在，每个段有多少页是不确定的，因此每个段的页表大小也不确定，导致寻找足够的连续自由空间比较复杂。虽然节省内存但是有外部碎片问题</li>
</ul>
<h3 id="多级页表（Multi-level-Page-Tables）"><a href="#多级页表（Multi-level-Page-Tables）" class="headerlink" title="多级页表（Multi-level Page Tables）"></a>多级页表（Multi-level Page Tables）</h3><p>x86 ARM Linux Windows</p>
<p>减小页表占用的空间，分散成多个页表，<strong>每张页表大小==相同==<strong>，</strong>并且刚好能填满一整个内存页</strong>，消灭了外部碎片</p>
<p><strong>如果整页的PTE都是无效的（未分配），则完全不分配该页面的页表。</strong></p>
<ul>
<li>PDE的有效位：此条目指向的页是否有页表？PTE的有效位：此条目是否是一个有效的PFN映射？</li>
<li>树形结构，不用的可以不分配页表空间。支持稀疏空间：不用的就不分配物理内存页</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241212214704876.png" alt="image-20241212214704876"></p>
<h4 id="页表目录-页表-内存"><a href="#页表目录-页表-内存" class="headerlink" title="页表目录-页表-内存"></a>页表目录-页表-内存</h4><p>CR3存的是页表目录（Page Directory）的基址，假设虚拟地址前4位是页表目录的编号，中间4位是页表（Page Table）编号，后12位为偏移。CR3找到了页表目录，根据前4位索引到PTE的PFN，根据中间4位找到页表中的PTE，PTE中存储着物理页的PFN。</p>
<ul>
<li><p>基本思想：基址 + 偏移 </p>
</li>
<li><p><code>VPN = PD_index | PT_index</code> </p>
</li>
<li><p><strong>页目录项</strong>地址: <code>PD_Entry_Addr = Page_Dir_Base + PD_index * sizeof(PD_Entry_Addr)</code> </p>
</li>
<li><p><strong>页表项</strong>地址：  <code>PT_Entry_Addr = PD_Entry.PFN &lt;&lt; SHIFT + PT_index * sizeof(PT_Entry_Addr)</code> </p>
</li>
<li><p>页面地址 ：<code>Page_Entry_Addr = PT_Entry.PFN &lt;&lt; SHIFT + Offset</code> </p>
</li>
</ul>
<p>以16位虚拟地址为例：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20240924221042539.png" alt="image-20240924221042539"></p>
<ul>
<li><strong>虚拟内存的要求</strong>：每一层级内部必须是连续的，因为分配物理内存空间只能一次性分配连续的一段</li>
<li>单级页表要想实现页表只能一次性分配256个连续的entries。</li>
<li>多级页表如果<strong>真的只有</strong>这3个地址所在的physical page被用到，那么只需要48 个entries就可以了</li>
</ul>
<p>在32位系统中，进程的虚拟地址空间为4GB，但某个进程实际使用的页只占其中的一小部分，其分布是稀疏的，因此非常适合使用多级页表这种稀疏的级联数组(<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Radix_tree">radix tree</a>)来表示。</p>
<h4 id="fill-the-pages"><a href="#fill-the-pages" class="headerlink" title="fill the pages"></a>fill the pages</h4><h5 id="例：30位虚拟地址"><a href="#例：30位虚拟地址" class="headerlink" title="例：30位虚拟地址"></a>例：30位虚拟地址</h5><p>目标：每张表填满一整个内存页 Page Size = 2^7^ * 4 B = 512 B，二级页表不能刚好占满一页</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241213134804005.png" alt="image-20241213134804005"><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241213135215659.png" alt="image-20241213135215659"></p>
<h5 id="实际的32位和64位页表"><a href="#实际的32位和64位页表" class="headerlink" title="实际的32位和64位页表"></a>实际的32位和64位页表</h5><p>在32位处理器中，采用4KB的page大小，则虚拟地址中低12位为offest，剩下高20位给页表，<strong>分成两级</strong>，每个级别占10个bit（10+10）。为什么32位系统的页表每级占10位，每个页的大小被设定为<code>4KB</code>而不是2KB或者8KB？</p>
<p>如果index为10位，则其可索引的范围是1024个entris，32位系统中，每级页表的每个entry的大小为4个字节，则每个页表的大小刚好是4KB。页表首地址也是要按页对齐的，如果占不满一个页，页中剩下的空间也就浪费了。80386引入<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=102569108&content_type=Article&match_order=1&q=%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6&zhida_source=entity">分页机制</a>的时候应该就考虑过把页设置为多大是最合适的，显然4KB的页大小对内存的利用是最充分的。1024 * 4 = 4 K</p>
<p><img src="https://i.stack.imgur.com/R19zY.png" alt="memory management - Why 32-bit Windows can maximum have 16TB Page File ..."></p>
<p>为什么64位系统的页表<strong>每级占9位</strong>呢？为了和硬件配合，基于i386编写的linux也采用4KB的页大小作为<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=102569108&content_type=Article&match_order=1&q=%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&zhida_source=entity">内存管理</a>的基本单位。处理器进入64位时代后，其实可以不再使用4KB作为一个页帧的大小，但可能为了提供硬件的向前兼容性以及和操作系统的兼容性吧，大部分64位处理器依然使用4KB作为默认的页大小（ARMv8-A还支持16KB和64KB的页大小）。因为64位系统中，每级页表的每个entry的大小为8个字节，如果index为9位，则每个页表的大小也刚好是4KB。</p>
<p>512 * 8 = 4K </p>
<p><img src="https://i.sstatic.net/Bswtz.png" alt="img"></p>
<h4 id="TLB-控制流"><a href="#TLB-控制流" class="headerlink" title="TLB 控制流"></a>TLB 控制流</h4><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241213141353216.png" alt="image-20241213141353216"></p>
<p>依然是先查TLB，TLB没有再查页表，先用PDBR加偏移 算出PDE的物理地址得到PTE所在的PFN，找到PTE之后根据PTE里面的PFN加偏移算出真实的物理地址。</p>
<h3 id="倒排页表（Inverted-Page-Table）"><a href="#倒排页表（Inverted-Page-Table）" class="headerlink" title="倒排页表（Inverted Page Table）"></a>倒排页表（Inverted Page Table）</h3><p>PowerPC</p>
<p>页表的映射反过来，PFN-&gt;VPN，除了VPN，还有使用此页的进程标识。通常使用Hash散列表来加快搜索。</p>
<p><img src="https://images2015.cnblogs.com/blog/1006507/201612/1006507-20161224105816979-1390337413.png" alt="img"></p>
<h3 id="交换到磁盘（Swap）"><a href="#交换到磁盘（Swap）" class="headerlink" title="交换到磁盘（Swap）"></a>交换到磁盘（Swap）</h3><p>之前的页表都需要直接访问物理内存，页表本身并没有在程序的地址空间中，因此页表必须时时刻刻在物理内存中</p>
<p>VAX/VMS 把页表纳入内核的虚拟内存，允许在内存压力较大时将页表的一部分交换到磁盘。</p>
<h2 id="超越物理内存"><a href="#超越物理内存" class="headerlink" title="超越物理内存"></a>超越物理内存</h2><p>虚拟内存本质是虚的，实际数据可以存储在任何地方：<strong>寄存器（TLB）</strong>、<strong>物理内存（DRAM）</strong>，甚至是<strong>磁盘（HDD SSD）</strong>，因此虚拟内存大小跟物理内存大小并没有直接的关系，编程人员只需提供<code>Virtual Address</code>，由硬件和OS负责剩下的步骤，这就提升了程序的易用性，也提升了处理程序的多样性，考虑页表的数据结构，页表存储的位置等问题。</p>
<h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><h4 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h4><p>硬盘需要腾出一片专门的空间用来存放物理内存的内容，因此也需要进行编址。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241213145818889.png" alt="image-20241213145818889"></p>
<blockquote>
<p>The code pages from this binary are initially found on disk, and when the program runs, they are loaded into memory (either all at once when the program starts execution, or, as in modern systems, one page at a time when needed). However, if the system needs to <strong>make room in physical memory for other needs</strong>, it can safely re-use the memory space for these code pages, knowing that it can later swap them in again from the on-disk binary in the file system.</p>
</blockquote>
<p><strong>虚拟内存提供了一种将磁盘和物理内存结合起来的方式</strong>：</p>
<ul>
<li>代码页从磁盘加载到内存，过一段时间被换出，随后在需要的时候又被换入。</li>
<li>操作系统将整个物理内存看作“缓存”。</li>
<li>当内存不足时，系统会将不常用的内存页换出到磁盘（称为交换或分页）。</li>
<li>反之，如果需要使用换出的页面，系统会从磁盘重新加载到内存。</li>
</ul>
<h4 id="页错误（page-fault）"><a href="#页错误（page-fault）" class="headerlink" title="页错误（page fault）"></a>页错误（page fault）</h4><p><strong>存在位（presentation bit）</strong>：用来标识一个页是否在物理内存中，如果不在，对此内存地址的访问就会触发page fault（实际上是page miss），陷入OS</p>
<p><strong>Why OS</strong> <strong>Handles This?：</strong>TLB miss可以由硬件实现，但是Page Fault并不需要，因为Page Fault的处理性能瓶颈在硬盘：硬盘的读写速度比内存慢很多，硬件处理性能提升并不明显，并且硬件必须添加其他复杂的机制（写死在硬件里）</p>
<p>硬盘IO完成，更新PTE的PFN和存在位（也可以同时写入TLB中）然后Retry Instruction，IO过程中进程处于<strong>阻塞状态（blocked state）</strong>，OS可以在这段时间内切换到其他进程以提高CPU利用率。</p>
<p><img src="https://media.geeksforgeeks.org/wp-content/uploads/121-1.png" alt="Lightbox"></p>
<p>上述是硬性的页错误（虚拟内存地址不在物理内存中），还有一种软性页错误（虚拟内存地址在物理内存中），<em>详见VAX/VMS</em></p>
<p><strong>控制流</strong>：</p>
<ul>
<li>错误的严重程度：<ol>
<li><code>segmentation fault</code>（<code>valid bit = 0</code>, 没有分配） </li>
<li><code>protection fault</code>（<code>protect bits</code>, 权限不够）</li>
<li><code>page fault</code>（<code>present bit = 0</code>, 不在内存里）</li>
</ol>
</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241213153405737.png" alt="image-20241213153405737"><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241213153341054.png" alt="image-20241213153341054"></p>
<p><strong>Page-Fault Handler by OS</strong>：</p>
<ul>
<li>找空闲的物理内存，记录其PFN<ul>
<li>找不到就使用<strong>淘汰策略</strong>，把现在的物理内存页换一部分到磁盘里，腾出空间</li>
<li>如果找到了就进行磁盘 I/O，系统调用会<strong>休眠</strong>，直到 I/O 完成。</li>
</ul>
</li>
<li>换入完成就更新页表的存在位和PFN</li>
</ul>
<h4 id="访存机制总结"><a href="#访存机制总结" class="headerlink" title="访存机制总结"></a>访存机制总结</h4><p>首先到 MMU 集成的 TLB 中查询，TLB 中存储的是虚拟地址页号（VPN）和物理地址页号（PFN）的映射关系，TLB 命中则直接访问物理页框；之后就是之前正常的 CPU 访存过程，与操作系统没有关系。TLB 未命中则去找 CPU 集成的 Table Walk Unit，TWU 中的 CR3 寄存器存储着当前页目录（Page Directory）的物理地址页号PFN，如果内存中的页表没有对应的内容，则触发页错误（Page Fault）去磁盘中寻找，页表命中则更新 TLB，重试指令。</p>
<p><img src="https://slideplayer.com/4814084/15/images/slide_1.jpg" alt="Virtual to Physical Address Translation Effective Address TLB Lookup Page  Table Walk Update TLBPage Fault OS Table Walk Protection Check Physical  Address. - ppt download"></p>
<h3 id="Swap-页面置换策略"><a href="#Swap-页面置换策略" class="headerlink" title="Swap 页面置换策略"></a><span id="eviction">Swap 页面置换策略</span></h3><p>$$<br>AMAT=(P_\text{Hit} \cdot T_\text{Mem})+(P_\text{Miss} \cdot T_\text{Disk})<br>$$</p>
<p>Tmem = 100ns(100个时钟周期) Tdisk = 10ms（10000个时钟周期） 对性能影响极大</p>
<h4 id="基本策略-1"><a href="#基本策略-1" class="headerlink" title="基本策略"></a>基本策略</h4><p>将物理内存看作虚拟内存的缓存，置换策略实际上就是缓存淘汰策略</p>
<p><strong>局部性原理</strong></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000043722445">缓存算法：LRU、LFU、随机替换等常见算法简介 - 个人文章 - SegmentFault 思否</a> </p>
<p>我们能不能既享受 CPU Cache 的速度，又享受内存、硬盘巨大的容量和低廉的价格呢？前辈们已经探索出了答案，那就是，存储器中数据的局部性原理（Principle of Locality）</p>
<ul>
<li><p>**时间局部性(temporal locality)**：如果一个数据被访问了，那么它在短时间内还会被再次访问。如 LRU 缓存机制，将频繁访问的数据保存在内存中。</p>
</li>
<li><p>**空间局部性(spatial locality)**：如果一个数据被访问了，那么和它相邻的数据也很快会被访问。如果数组的 CPU 预读功能。</p>
</li>
<li><p><strong>OPT 最优</strong>：事先知道缓存的访问顺序（不可能）但是可以作为一个比较指标。</p>
</li>
<li><p><strong>无状态策略</strong>：</p>
<ul>
<li><p>FIFO：先进先出</p>
</li>
<li><p>Random：随机</p>
</li>
</ul>
</li>
<li><p><strong>LRU</strong>(Recently)基于上次被访问时间，<strong>LFU</strong>(Frequently)基于被访问的频率</p>
</li>
</ul>
<p>基本有LRU FIFO Random，时钟算法（近似LRU），SecondChance（完善的FIFO），2Q（LRU+FIFO）</p>
<p>LFU：当使用 mmap() 访问文件缓存页面时，无法计数，实现较为复杂，不适合操作系统对虚拟内存的管理</p>
<h4 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h4><h5 id="完全随机访问"><a href="#完全随机访问" class="headerlink" title="完全随机访问"></a>完全随机访问</h5><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241213175231404.png" alt="image-20241213175231404"></p>
<h5 id="二八定律"><a href="#二八定律" class="headerlink" title="二八定律"></a>二八定律</h5><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241213175332544.png" alt="image-20241213175332544"></p>
<h5 id="循环顺序访问"><a href="#循环顺序访问" class="headerlink" title="循环顺序访问"></a>循环顺序访问</h5><p>依次引用第0到第49页，LRU和FIFO，缓存在50以内，命中率为0</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241213175411886.png" alt="image-20241213175411886"></p>
<ul>
<li><p>LRU，基于<strong>时间局部性</strong>的策略，<strong>预测性强</strong>：对于访问频繁的页表项保留效果好。</p>
<ul>
<li>循环访问 n+1 页，但TLB只有n页容量，第一次TLB空的，全部 miss，由于空间限制，最后第n+1页会覆盖第1页。下一个循环开始第1页又 miss，第1页覆盖第2页内容，连锁的 miss</li>
</ul>
</li>
<li><p>Random，实现简单，避免出现极端情况下LRU命中率极低的情况，<strong>不可预测</strong>：无法优化特定程序的访问模式。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>策略</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LRU</strong></td>
<td>高命中率，适应访问局部性</td>
<td>实现复杂，硬件成本高</td>
<td>对性能敏感的高端系统</td>
</tr>
<tr>
<td><strong>随机</strong></td>
<td>实现简单，硬件成本低，性能稳定</td>
<td>命中率较低，忽略访问规律</td>
<td>简单的嵌入式系统或硬件资源有限的场景</td>
</tr>
</tbody></table>
<h4 id="LRU-实现"><a href="#LRU-实现" class="headerlink" title="LRU 实现"></a>LRU 实现</h4><ul>
<li>可以对每一页添加时间字段，可以在页表中也可以专门在物理内存中的一片区域（redis就是这么做的），但代价高。</li>
</ul>
<p>添加一个 <strong>reference bit</strong> 使用位（用页表或者bitmap存储）当页被访问（读或写）时，由硬件（MMU）将其置1，操作系统负责将其置0，1代表最近用过了，0代表最近没用过</p>
<h5 id="近似-LRU：时钟算法"><a href="#近似-LRU：时钟算法" class="headerlink" title="近似 LRU：时钟算法"></a>近似 LRU：时钟算法</h5><p>维护一个循环列表，里面放着所有页的使用情况，时钟指针指向其中的一页，当需要替换页，如果use bit=1，将其置0，然后移动到下一页，直到寻找到第一个use bit = 0的页，将其换出</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241213184105746.png" alt="image-20241213184105746"></p>
<h5 id="脏位"><a href="#脏位" class="headerlink" title="脏位"></a>脏位</h5><p>dirty bit的优先级大于use bit 也由MMU维护，硬件会在发生<strong>写操作</strong>时自动设置脏位，页面换出首先考虑的是未被访问过的干净页，然后是被访问过的干净页。</p>
<ol>
<li><strong>标记页面是否被修改过</strong><ul>
<li>当一个页面被写入（例如进程对该页面的内容进行了修改），操作系统会将该页面的脏位置为 <code>1</code>。</li>
<li>如果页面从加载到内存以来未被修改，脏位保持为 <code>0</code>。</li>
</ul>
</li>
<li><strong>决定页面是否需要写回磁盘</strong><ul>
<li>如果一个页面需要被换出（从内存移到磁盘），操作系统会检查其脏位：<ul>
<li><strong>脏位为 1</strong>：表示页面内容已被修改，需要将修改后的内容写回磁盘（例如文件或交换区）。</li>
<li><strong>脏位为 0</strong>：页面未被修改，可以直接丢弃内存中的内容，因为磁盘上已有最新副本。</li>
</ul>
</li>
</ul>
</li>
<li><strong>减少不必要的磁盘写入</strong><ul>
<li>通过脏位的判断，可以避免无意义的磁盘写入操作，提高性能。例如，如果页面内容没有修改，就无需将内存中的数据写回磁盘。</li>
</ul>
</li>
</ol>
<h5 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h5><p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/41aee01a98aa03f4c3d75ef4c2c7749a.png" alt="img" style="zoom:200%;" /> 

<ol>
<li>数据第一次被访问，加入到访问历史列表；</li>
<li>如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</li>
<li>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</li>
<li>缓存数据队列中被再次访问后，重新排序；</li>
<li>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</li>
</ol>
<p>LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。</p>
<h3 id="其他-Swap-策略"><a href="#其他-Swap-策略" class="headerlink" title="其他 Swap 策略"></a>其他 Swap 策略</h3><p><strong>页面置换策略</strong>：<u>which</u> page to <u>swap out</u>?</p>
<p><strong>页面选择策略</strong>：when to <u>swap in</u> which page? </p>
<ul>
<li>OS决定何时将页面载入内存，大多数页面是按需载入(demand paging)</li>
<li>有时会提前载入(prefetching)马上可能要被访问的页面，比如连续的代码页</li>
</ul>
<p><strong>写入磁盘策略</strong>：when and how to <u>swap out</u>? or not?</p>
<ul>
<li>不一定是内存满了才会开始交换，OS预留部分空闲空间，设置HW和LW，当可用页少于LW，就swap out，直到可用页数达到HW，有一个守护进程 <code>swapd</code> 专门做这件事情。</li>
<li>交换本身是IO操作，可以通过聚集/分组的方式将多个等待写入写出的页合并操作，提高硬盘效率，执行单次大的写操作比许多小的写操作有效。</li>
<li>数据一致性：脏页需要被换出（刷盘, sync）</li>
</ul>
<p><strong>颠簸（thrashing）</strong>: 内存被超额请求，os需要不断进行页面的置换，此时可能会考虑终止一些进程(linux oom killer会杀死内存密集型，一般这些都是低优先级的，也有一定的风险)</p>
<h2 id="完整的虚拟内存系统"><a href="#完整的虚拟内存系统" class="headerlink" title="完整的虚拟内存系统"></a>完整的虚拟内存系统</h2><h3 id="VAX-VMS-虚拟内存系统"><a href="#VAX-VMS-虚拟内存系统" class="headerlink" title="VAX/VMS 虚拟内存系统"></a>VAX/VMS 虚拟内存系统</h3><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><h5 id="应用进程共享内核空间"><a href="#应用进程共享内核空间" class="headerlink" title="应用进程共享内核空间"></a>应用进程共享内核空间</h5><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241213214150106.png" alt="image-20241213214150106" style="zoom:150%;" />

<ul>
<li>地址空间的下半部分称为进程空间，前半段是代码和向下增长的堆（P0），后半段是向上增长的堆（P1），<strong>各自拥有一个页表</strong>，减少了内部碎片。</li>
<li>地址空间的上半段称为系统空间S，只使用其中一半</li>
</ul>
<p>内核段包含在用户空间中，是所有的进程共享的，这样使得内核与用户程序之间数据交互更加方便，OS可以轻松地解析用户程序传入的指针。通过给系统空间设置保护位来确保内核的安全。</p>
<h5 id="优化页表"><a href="#优化页表" class="headerlink" title="优化页表"></a>优化页表</h5><ul>
<li>分出来的两个段，各自有一个页表[段页式管理]，减少了内部碎片 </li>
<li>进程的虚拟地址空间也包含了内核段，因此可以把用户<strong>页表纳入受保护的内核虚拟内存</strong>中，当存储压力巨大时可以将页表换出到磁盘，有一定的访问性能开销。</li>
</ul>
<h5 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h5><p>NULL是一个宏，实际上就是0，虚拟地址0有效位始终是0，因此试图访问这个有效位会出现段错误异常，陷入OS终止进程</p>
<h4 id="惰性优化（Lazy）"><a href="#惰性优化（Lazy）" class="headerlink" title="惰性优化（Lazy）"></a>惰性优化（Lazy）</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/whiteBear/p/16729327.html">延迟分配：提供内存利用率的三种机制 - 牛犁heart - 博客园</a> </p>
<h5 id="写入时复制-copy-on-write"><a href="#写入时复制-copy-on-write" class="headerlink" title="写入时复制 copy-on-write"></a>写入时复制 copy-on-write</h5><p>如果要将一个页面从一个地址空间复制到另一个地址空间，会获取相同的指针，指向相同的资源。这个资源或许是内存中的数据，又或许是硬盘中的文件，直到某个应用真正需要<strong>修改某一页</strong>时，操作系统才会（惰性地）<strong>复制一份该页的专用副本</strong>给该应用，填充数据而其他所见的最初资源仍然保持不变。</p>
<p>COW的优点：<strong>如果应用没有修改该资源，就不会产生副本，因此多个应用只是在读取操作时可以共享同一份资源，从而节省内存空间。</strong> <strong>fork 会复制应用 A 的很多关键数据，但不会复制应用 A 对应的物理内存页面，而是要监测这些物理内存的读写，只有这样才能让应用 A 和应用 B 正常运行</strong></p>
<ul>
<li>fork但未写入</li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/1059417/202209/1059417-20220925215845353-1129676397.png" alt="image"></p>
<ul>
<li>fork后写入</li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/1059417/202209/1059417-20220925221038426-1637796167.png" alt="image"></p>
<p>fork()需要复制整个地址空间的内容，如果fork之后还调用了exec，这些地址空间内容又会被马上覆盖，做无用功，cow避免了大量不必要的复制操作，仍然保留正确的语义。</p>
<h5 id="按需调页-demand-paging"><a href="#按需调页-demand-paging" class="headerlink" title="按需调页 demand paging"></a>按需调页 demand paging</h5><ul>
<li><p><strong>按需调页</strong>是一种<strong>动态内存分配技术</strong>，更是一种优化技术，它把<strong>物理内存页面的分配推迟到不能再推迟为止</strong>。之所以能实现，是因为应用程序开始运行时，并不会访问虚拟内存空间中的全部内容。</p>
</li>
<li><p>由于<strong>程序的局部性原理</strong>，使得应用程序在执行的每个阶段，真正使用的内存页面只有一小部分，对于暂时不用的物理内存页，就可以分配由其他应用程序使用。因此，在不改变物理内存页面数量的情况下，请求调页能够提高系统的吞吐量。</p>
</li>
</ul>
<p>当页添加到地址空间时，会在页表做一个标记（保留的操作系统字段），当进程真正访问到这个虚拟页时，操作系统才会真正寻找物理页并将其置零，映射到地址空间，这样就避免了申请了但是从来不访问 导致浪费的情况。</p>
<h4 id="SWAP-策略"><a href="#SWAP-策略" class="headerlink" title="SWAP 策略"></a>SWAP 策略</h4><h5 id="替换策略：Second-Chance-FIFO"><a href="#替换策略：Second-Chance-FIFO" class="headerlink" title="替换策略：Second Chance FIFO"></a>替换策略：Second Chance FIFO</h5><p>利用的是软性的页错误</p>
<ul>
<li>用RSS(Resident Set Size)限制每个进程可以保存在内存中的最大页数，超过RSS就要“First out”，防止自私进程</li>
<li>引入两个全局的页面表，一个记录空闲干净页，另一个记录脏页</li>
<li>First Out 被换出的页面根据脏位添加到 干净页列表 或 脏页列表 的<strong>末尾</strong> </li>
<li>另一个进程需要空闲页，会先去干净页列表中取出<strong>第一个</strong>空闲页</li>
<li>如果换出页面的进程触发了page fault，则会从表中重新回收页，避免磁盘I/O </li>
</ul>
<h5 id="批量换出：page-clustering"><a href="#批量换出：page-clustering" class="headerlink" title="批量换出：page clustering"></a>批量换出：page clustering</h5><p>把大批量的页从上述的全局脏页列表中分组聚集到一起，一起写入到磁盘中，使IO次数减少，单次IO写入量更大，提高性能</p>
<h3 id="Linux-虚拟内存系统"><a href="#Linux-虚拟内存系统" class="headerlink" title="Linux 虚拟内存系统"></a>Linux 虚拟内存系统</h3><p><strong>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理</strong>。于是 Linux 就把所有段的基地址设为 <code>0</code>，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。虚拟空间分布可分为<strong>用户态</strong>和<strong>内核态</strong>两部分</p>
<h4 id="地址空间-1"><a href="#地址空间-1" class="headerlink" title="地址空间"></a>地址空间</h4><p><img src="https://pica.zhimg.com/v2-50e72a482d4b10604708f5e6a6c76435_r.jpg?source=1940ef5c" alt="img"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241213232325106.png" alt="image-20241213232325106"></p>
<ul>
<li>0-3GB是用户空间，其中用户态的分布：代码段(.ELF)、全局变量（初始化的数据段）、BSS（未初始化的数据段）、堆内存（Heap）、映射区（mmap）、函数栈（Stack）、初始化参数（argument, environment）</li>
<li>最高1GB为内核空间，存放内核的代码以及其他受保护的数据；像VAX/VMS一样，每个用户的进程空间内有着相同的内核。</li>
<li>64位的地址空间：低128T为用户空间，高128T为内核空间，中间未定义</li>
</ul>
<h5 id="逻辑内核空间（kmalloc）"><a href="#逻辑内核空间（kmalloc）" class="headerlink" title="逻辑内核空间（kmalloc）"></a>逻辑内核空间（kmalloc）</h5><ul>
<li><p>内核代码需要调用<code>kmalloc</code>申请，内核栈、页表等数据结构存储在这里</p>
</li>
<li><p>只能在物理内存中，不能被换出到磁盘</p>
</li>
<li><p><strong>严格的一对一直接映射</strong>：<code>0xC0000000</code> to <code>0x00000000</code>, <code>0xC0000FFF</code> to <code>0x00000FFF</code></p>
<ul>
<li><p>不需要进行复杂地址转换，直接将其当成物理地址即可，因此也不需要页表结构</p>
</li>
<li><p>连续的虚拟地址在物理上也一定是连续的</p>
</li>
<li><p>适合DMA</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>This makes memory allocated in this part of the kernel’s address space suitable for operations which need contiguous physical memory to work correctly, such as I/O transfers to and from devices via <strong>direct memory access (DMA)</strong></p>
</blockquote>
<h5 id="虚拟内核空间（vmalloc）"><a href="#虚拟内核空间（vmalloc）" class="headerlink" title="虚拟内核空间（vmalloc）"></a>虚拟内核空间（vmalloc）</h5><ul>
<li>内核代码需要调用<code>vmalloc</code>申请，returns 指向连续虚拟内存区域的指针</li>
<li>不是直接映射，因此连续的虚拟地址在物理上并不一定连续</li>
<li>容易分配(easy to allocate), 因此适合大块缓冲区，因为连续的大块物理内存显然不容易找到</li>
</ul>
<p>在32位Linux中，虚拟内核空间可以让内核空间大于1GB</p>
<blockquote>
<p>Kernel virtual addresses, and their disconnection from <strong>a strict one-to-one mapping to physical memory</strong>, make this possible. However, with the move to 64-bit Linux, the need is less urgent, because the kernel is not confined to only the last 1 GB of the virtual address space. （64位就没那么重要了）</p>
</blockquote>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/overview.png" style="zoom:150%;" />

<h5 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h5><h6 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h6><ul>
<li><p>在不同OS中，malloc的实现也不同，有 dlmalloc, jemalloc, tcmalloc等实现</p>
</li>
<li><p>Linux中，用户可以显式调用mmap或者malloc分配，malloc底层基于mmap（大于128K）或brk（小于128K）</p>
</li>
<li><p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p>
</li>
<li><p>大部分不建议使用brk，brk和sbrk分配的堆空间类似于缓冲池，调用它相当于增大缓冲池。用malloc可以重用前面空闲的内存空间，每次malloc从缓冲池获得内存，如果缓冲池不够了，malloc才会调用brk或sbrk扩充缓冲池，直到达到缓冲池大小的上限，free则将应用程序使用的内存空间归还给缓冲池。而free mmap会直接释放，将空间给操作系统，无法复用，一定会触发缺页中断。</p>
</li>
</ul>
<h6 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h6><p>brk 的实现方式是移动Program break，将数据段的最高地址指针 _edata(end of data) 往高地址推（分配的内存小于 128KB），sbrk是通过增量来控制的，原理类似。</p>
<ul>
<li><p>同一个程序bss的结束地址是固定的，而heap的起始地址在每次运行的时候都会改变 <strong>ASLR</strong>。</p>
</li>
<li><p>当<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a>（Address Space Layout Randomization）关闭时，<code>start_brk</code>和brk同时指向<code>data/bss</code>段的结束位置（<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/include/linux/mm_types.h?v=3.8#L364">end_data</a>）。</p>
</li>
<li><p>当ASLR打开时，<code>start_brk</code>和brk同时指向<code>data/bss</code>段的结束位置（<code>end_data</code>）再加上一个随机的brk偏移。</p>
</li>
</ul>
<img src="https://pengrl.com/images/post/20032_0.png" alt="img" style="zoom:150%;" />

<p>brk的问题：</p>
<p>使用brk连续申请了10K, 20K, 30K内存，前两部分释放了，但是不会归还给操作系统，如果再次申请内存小于30K，就可以复用空闲区域，但是如果申请40K，就会出现内部碎片问题，只能继续新申请40K内存，导致大量内存碎片问题</p>
<h6 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h6><p>在用户进程空间内的内存映射段找一块空闲的虚拟内存（分配的内存大于 128k））—匿名空间，具体使用可见: <em>Memory-mapped I/O</em> </p>
<h5 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h5><h6 id="伙伴系统（Buddy-system）"><a href="#伙伴系统（Buddy-system）" class="headerlink" title="伙伴系统（Buddy system）"></a>伙伴系统（Buddy system）</h6><p>Buddy分配系统在普通内存池的基础上，允许两个<strong>大小相同且相邻</strong>的内存块合并，合并之后的内存块的「尺寸」增大，因而将被移动到另一个内存池的free list上。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241210230312259.png" alt="image-20241210230312259"></p>
<p>总空间为2^N^，按照递归二分法分配内存，直到块大小刚好满足要求（显然这会导致内部碎片）当一个块释放的时候，allocator会检验与他相同大小的相邻块（buddy）是否空闲，若是则将二者合并，直到合并全部空闲内存。</p>
<p>优点：buddy的地址很容易确认，既然是相邻，说明首部地址只差一位，这个位决定了他们在整个数中的层次</p>
<p>在 Linux 系统中，连续内存管理采用了 <strong>伙伴系统（Buddy System）算法</strong> 来实现，对于内部碎片的问题，采用了SLAB进行解决。</p>
<p>它把所有的空闲页放到11个链表中，每个链表分别管理大小为1，2，4，8，16，32，64，128，256，512，1024个页的内存块。当系统需要分配内存时，就可以从buddy系统中获取。当分配内存时，会优先从需要分配的内存块链表上查找空闲内存块，当发现对应大小的内存块都已经被使用后，那么会从更大一级的内存块上分配一块内存，并且分成一半给我们使用，剩余的一半释放到对应大小的内存块链表上。</p>
<p>想要分配一个8KB大小的内存，但是发现对应大小的内存已经没有了，那么伙伴系统会从16KB的链表中查找一个空闲内存块，分成两个8KB大小，把其中的一个8KB大小返回给申请者使用，剩下的8KB放到8KB对应的内存块链表中进行管理。更坏的一种情况是，系统发现16KB大小的连续内存页已经没有了，那么以此会向更高的32KB链表中查找，如果找到了空闲内存块，那么就把32KB分成一个16KB和两个8KB，16KB的内存块放到16KB的链表进行管理，两个8KB的内存块一个返回给申请者，另一个放到8KB大小的链表进行管理。</p>
<p>当释放内存时，会扫描对应大小的内存块链表，查看是否存在地址能够连续在一起的内存块，如果发现有，那么就合并两个内存块放置到更大一级的内存块链表上，以此类推。比如我们释放8KB大小的内存，那么会从对应的链表扫描是否有能够合并的内存块，如果有另一个8KB大小的内存和我们使用的内存地址连续，那么就合并它们组成一个16KB大小的内存块，然后接着扫描16KB大小的内存块链表，继续查找合并的可能，以此类推下去。</p>
<p>操作系统的内存管理通常是基于<strong>页（page）</strong>的概念，即操作系统将物理内存分为固定大小的页。页是内存管理的基本单位，这样可以统一管理和访问内存。页的大小通常是2的幂次方，例如4KB、8KB或16KB等。</p>
<ul>
<li><strong>操作系统需要高效地管理内存</strong>，而将内存管理的单位限定为页大小可以简化这一过程。每一页都有一个对应的页表项，操作系统只需要管理页而不是单个字节或更小的单位。这减少了管理开销。</li>
</ul>
<h6 id="分离空闲列表（SLAB-segregated-free-lists）"><a href="#分离空闲列表（SLAB-segregated-free-lists）" class="headerlink" title="分离空闲列表（SLAB, segregated free lists）"></a>分离空闲列表（SLAB, segregated free lists）</h6><img src="https://hammertux.github.io/img/slab-org.png" alt="slab org" style="zoom:150%;" />



<p>为了方便管理，Linux中的buddy allocator以物理页框为最小粒度，而现实的应用中，操作系统作为一个一直在运行的程序，多是以<strong>内核objects</strong>（比如描述文件的”struct inode”）的大小来申请和释放内存的，这些内核objects的大小通常从几十字节到几百字节不等，远远小于一个page的大小。如果程序固定分配一个或者几个大小的的内存，那就专门给他分配一块内存用于分配这些固定大小空间，减少了大小上的差异，碎片自然也就少了</p>
<p>在内核启动时，为诸如锁、文件inode之类频繁请求的内核object分配 <strong>Object cache</strong>，他们的对象缓存分离了特定大小的空闲列表，获得了性能上的提升，当cache将要耗尽时从通用的内存分配程序申请slab（总量是page size和object size的最小公倍数）例如，2.5KB objectsize, 4KB pagesize 就去申请5个页, 专门用来放这种object,一个页能放5个</p>
<p>当cache中内核object的引用计数变为0，通用的内存分配程序会从专用的分配器中回收这些资源。同时还使空闲对象保持在预初始化的状态，避免频繁销毁、初始化的开销。</p>
<p>Linux实现</p>
<img src="https://www.kernel.org/doc/gorman/html/understand/understand-html037.png" alt="img" style="zoom:150%;" />

<img src="https://picx.zhimg.com/v2-90fe0938cf0c8ab8836257ed587654d1_1440w.jpg" alt="img" style="zoom:150%;" />

<p>每个<code>kmem_cache</code>都是链接在一起形成一个全局的双向链表，系统可以从Cache_chain开始扫描每个<code>kmem_cache</code>（相当于上面说的内存池, fixed size）</p>
<p><code>slab</code>是内存池从系统申请内存的最小单位，在实现上一个<code>slab</code>有一个或多个连续的物理页组成（通常只有一页）单个<code>slab</code>可以在<code>slab</code>链表之间移动，例如如果一个<code>slabs_partial</code>中的slab被分配了对象后变满了，就要从<code>slabs_partial</code>中被删除，同时插入到<code>slabs_full</code>中去。</p>
<h4 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h4><p>虚拟地址：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241214003409861.png" alt="image-20241214003409861"></p>
<p>4KB的页大小对应12位offset，共四级页表，每级索引为9位，一个表条目占用4B空间，一张表正好占满一页</p>
<h4 id="更大的页大小（huge-pages）"><a href="#更大的页大小（huge-pages）" class="headerlink" title="更大的页大小（huge pages）"></a>更大的页大小（huge pages）</h4><blockquote>
<p>Specifically, recent designs support 2-MB and even 1-GB pages in hardware. Thus, over time, Linux has evolved to allow applications to utilize these <strong>huge pages</strong> (as they are called in the world of Linux).</p>
</blockquote>
<h5 id="提升-TLB-命中率"><a href="#提升-TLB-命中率" class="headerlink" title="提升 TLB 命中率"></a>提升 TLB 命中率</h5><p>一方面是减少了页表项数，更重要的是<strong>提升了TLB的命中率（hit rate）</strong>：</p>
<ul>
<li><strong>TLB的条目数(slots)是固定的，因为空间局部性，同一页放更多数据，将更多的物理内存空间纳入到TLB中</strong></li>
<li>换个角度，如果发生TLBmiss，因为页表项数的减少，遍历速度就会加快</li>
<li>与此同时，某些情况下也可以加快分配内存</li>
</ul>
<h5 id="如何申请"><a href="#如何申请" class="headerlink" title="如何申请"></a>如何申请</h5><p>一些对性能要求严格的应用如大型数据库应该使用更大的页大小，用来提高性能，必须通过<code>mmap</code>或者<code>shmget</code>进行显式申请，因此其他正常使用4KB页大小的程序不受影响。</p>
<p>**透明大页(transparent huge pages)**：不需要应用程序修改源代码，OS 会自动根据情况决定是否分配大页。</p>
<h5 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h5><blockquote>
<p>Huge pages are not without their costs. The biggest potential cost is <strong>internal fragmentation</strong>, i.e., a page that is large but sparsely used. This form of waste can fill memory with large but little used pages. <strong>Swapping</strong>, if enabled, also does not work well with huge pages, sometimes greatly amplifying the amount of I/O a system does.</p>
</blockquote>
<ol>
<li><strong>内部碎片</strong>：由于各种内存操作基本都要求按照page对齐，比如一个可执行文件映射到进程地址空间，根据文件大小的不同，平均算下来会浪费掉半个page size的物理内存，使用large page的话这个消耗就显得比较大了。</li>
<li><strong>需要连续大块的物理内存</strong>：系统运行一段时间后，会很难再也大块的连续物理内存，这时分配large page将会变的很困难，所以通常需要在系统初始化的时候就划分出一段物理内存给large page用（类似于DMA的内存分配），这样就减少了一些灵活性。</li>
<li><strong>swap开销大</strong>：动态large page（THP）在换出到外部的flash/disk和从flash/disk换入物理内存的过程会比normal size的page带来更大的开销（可参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/117239320">这篇文章</a>）。</li>
</ol>
<h4 id="Page-Cache-Disk-Cache"><a href="#Page-Cache-Disk-Cache" class="headerlink" title="Page Cache/Disk Cache"></a>Page Cache/Disk Cache</h4><p><a target="_blank" rel="noopener" href="https://www.mazhen.tech/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-page-cache/">深入理解 Page Cache</a></p>
<p><strong>Page Cache</strong> 是由内核管理的内存，位于 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">VFS(Virtual File System)</a> 层和具体文件系统层（例如ext4，ext3）之间。应用进程使用 <code>read</code>/<code>write</code> 等文件操作，通过系统调用进入到 <strong>VFS</strong> 层，根据 <strong>O_DIRECT</strong> 标志，可以使用 <strong>Page Cache</strong> 作为文件内容的缓存，也可以跳过 <strong>Page Cache</strong> 不使用内核提供的缓存功能</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/vzb3z8uo.png" alt="vzb3z8uo"></p>
<blockquote>
<p>aggressive caching subsystem to <strong>keep popular data items from persistent storage</strong> in memory</p>
</blockquote>
<ul>
<li><p><strong>Buffered I/O</strong>: IO缓存 (<code>read()</code>, <code>write()</code>) [<code>dentry, inode cache</code>]</p>
</li>
<li><p><strong>Memory-mapped I/O</strong>: 内存映射 mmap()</p>
<ul>
<li><strong>File-backed 文件映射</strong>: 其可以将文件内容映射到用户空间，虚拟内存和磁盘文件中间通过 Page Cache 进行数据中转，因此可以像普通虚拟内存一样访问文件，这些虚拟内存<strong>在磁盘中有对应的文件</strong>，读取这部分内容就像是文件I/O一样</li>
<li><strong>Anonymous Mapping 匿名映射</strong>: mmap以<code>MAP_ANONYMOUS</code>方式申请内存，这些虚拟内存在磁盘中<strong>没有确切的文件，持久化到swap space</strong>，全部初始化为0，</li>
</ul>
</li>
<li><p>通过<code>page_cache_hashtable</code>搜索，加快访问速度。</p>
</li>
</ul>
<h5 id="Memory-mapped-I-O"><a href="#Memory-mapped-I-O" class="headerlink" title="Memory-mapped I/O"></a>Memory-mapped I/O</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/longerzone/article/details/12948925#">Linux 下的两个特殊的文件 – /dev/null 和 /dev/zero 简介及对比_linux空洞文件null-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangle4695/article/details/52139585">Linux 内存映射函数 mmap（）函数详解_mmap fb-CSDN博客</a>  </p>
<ul>
<li><code>void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset);</code> </li>
<li><code>int munmap(void* start, size_t length);</code> <ul>
<li><code>prot:</code> 保护位 <code>PROT_EXEC</code>, <code>PROT_READ</code> , <code>PROT_WRITE</code> , <code>PROT_NONE</code></li>
<li><code>flags:</code> <code>MAP_SHARED</code>共享模式 <code>MAP_PRIVATE</code>写时复制，不共享 <code>MAP_ANONYMOUS</code>匿名模式fd无效</li>
<li><code>fd:</code> 文件描述符，如果是匿名模式可以置为<code>-1</code>，或者打开<code>/dev/zero</code>获取其fd</li>
<li><code>offset:</code>文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。</li>
</ul>
</li>
</ul>
<ol>
<li><code>fopen()</code> 系统调用打开文件，并返回描述符 <code>fd</code>。</li>
<li><code>mmap(start,...)</code>建立内存映射并返回映射首地址指针 <code>start</code>参数start可以是空指针，系统自动分配地址</li>
<li>通过对<code>start</code> 对文件进行各种操作，首次访问start指向的内容会触发页错误(demand paging)</li>
<li><code>munmap (start,...)</code> 关闭内存映射</li>
<li><code>fclose(fd)</code> 系统调用关闭文件 <code>fd</code> </li>
</ol>
<img src="https://miro.medium.com/v2/resize:fit:1313/0*DgRx8tGpS1T0St_b.png" alt="img" style="zoom:150%;" />

<p>通过对一个打开的FD调用<code>mmap()</code>，进程能够获得一个指向内存映射区的指针，内存映射区是一个独立区域，因此可以独立释放。通过这个指针就能够对文件进行操作。这里采用了demand paging——<strong>懒加载</strong>的策略，直到第一次访问触发页错误，才会真正把文件内容分配到物理页中。</p>
<p>数据一致性：</p>
<ul>
<li><strong>files</strong>：程序通过 <code>mmap</code> 映射文件时，如果页面未修改（脏位为 <code>0</code>），无需将内存中的数据写回磁盘</li>
<li><strong>Swap space</strong>：当内存不足时，未被修改的页面无需写回磁盘的 Swap space，节省时间和空间</li>
</ul>
<p>即使不显式调用<code>mmap</code>也会使用这个共享的文件映射区域，比如从可执行文件中加载的代码、进程之间共享的库代码</p>
<p>使用<code>pmap</code>分析<code>tcsh</code>进程的虚拟内存映射情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Virtual Address  	Size  	Protection  Source</span><br><span class="line">0000000000400000 	372K  	r-x--       tcsh</span><br><span class="line">00000000019d5000 	1780K 	rw---       [anon ]</span><br><span class="line">00007f4e7cf06000 	1792K 	r-x--       libc-2.23.so</span><br><span class="line">00007f4e7d2d0000	36K   	r-x--       libcrypt-2.23.so</span><br><span class="line">00007f4e7d508000	148K  	r-x--       libtinfo.so.5.9</span><br><span class="line">00007f4e7d731000 	152K  	r-x--       ld-2.23.so</span><br><span class="line">00007f4e7d932000 	16K   	rw---       [stack ]</span><br></pre></td></tr></table></figure>

<p>除了<code>tcsh</code>自己的代码，<code>libc, libcrypt, libtinfo</code> 这些共享库代码也被加载到tcsh的虚拟地址空间中，连接器<code>ld</code>的可执行代码也在其中。[anon]表示自己的heap堆空间，[stack]表示自己的stack栈空间</p>
<p>和 <strong>shmem</strong> 的区别：</p>
<p>System V 共享内存是持久的：除非被进程显式删除，否则它会保留在内存中并保持可用，直到系统关闭。 mmap 内存在应用程序的执行之间不是持久的（除非它由文件支持，<code>MAP_SHARED</code>）</p>
<h5 id="Buffered-I-O"><a href="#Buffered-I-O" class="headerlink" title="Buffered I/O"></a>Buffered I/O</h5><p><strong>Buffered I/O</strong> 与 <strong>内存映射文件</strong> 的区别：</p>
<p><img src="https://cdn.mazhen.tech/images/202209241611674.png" alt="d"></p>
<h6 id="读取机制"><a href="#读取机制" class="headerlink" title="读取机制"></a>读取机制</h6><ol>
<li><p><code>int fd = open(file_path)</code></p>
<ul>
<li>fd是内核对打开的文件的编号，通过fd就可以操作文件</li>
</ul>
</li>
<li><p><code>int c = read(fd, buf, 512)</code>  </p>
<ul>
<li>由内核负责将 fd 翻译成 inode+offset</li>
<li>读取inode，如果page cache没有就从磁盘读，然后写入inode到Page cache中</li>
<li>读取对应偏移的block，如果page cache没有就从磁盘读，然后写入block到Page cache中</li>
<li>从内存中的 cached block 复制 512 B 到 buf 中</li>
</ul>
</li>
</ol>
<h6 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h6><p><strong>Write-back (default)</strong> </p>
<p>write back 写回 只对缓存进行操作 read-allocate 先把数据读取到Cache中，再从Cache中读数据</p>
<blockquote>
<p>By default, kernel marks written pages dirty and flushes after a delay:</p>
</blockquote>
<ol>
<li><p><code>int fd = open(&quot;myfile&quot;);</code> </p>
</li>
<li><p><code>write(fd, &quot;hello world&quot;, 11)</code></p>
<ul>
<li>内核将hello world字符串写入到 cached block 对应的 page cache 页中</li>
<li>内核将被修改的页加入脏页列表中</li>
<li>按照一定的策略进行刷盘</li>
</ul>
</li>
</ol>
<p>在系统发生宕机的情况下无法确保数据已经落盘，因此存在数据丢失的问题。不过，在程序挂了，例如被 kill -9，Page Cache 中的数据操作系统还是会确保落盘；</p>
<p><strong>Write-through</strong></p>
<p>直写，在更改page cache的<strong>同时</strong>刷盘(synchoronized)</p>
<blockquote>
<p><strong>O_SYNC</strong> flag converts file descriptor to write-through</p>
</blockquote>
<ul>
<li><code>int fd = open(&quot;myfile&quot;, O_SYNC |...); </code></li>
<li><code>write(fd, &quot;hello world&quot;, 11);</code> <ul>
<li>This affects all accesses to the same disk blocks</li>
</ul>
</li>
</ul>
<p>以牺牲系统 I/O 吞吐量作为代价，向上层应用确保一旦写入，数据就已经落盘，不会丢失</p>
<h5 id="脏页刷盘"><a href="#脏页刷盘" class="headerlink" title="脏页刷盘"></a>脏页刷盘</h5><p>Page cache 追踪脏页，保存一个脏文件inode链表，脏页需要写入到磁盘的文件或者swap space中，确保内存数据的持久化，可以由叫做<code>pdflush</code>的后台线程，唤醒方式有如下</p>
<ul>
<li><p><strong>定期</strong>唤起<code>pdflush</code>，确保不会有脏页驻留时间过长</p>
</li>
<li><p>在脏页比例达到<strong>阈值</strong>时，按照一定速率刷盘（1024）</p>
</li>
<li><p>内存可用空间低到一定<strong>阈值</strong>，刷脏页释放内存</p>
</li>
<li><p>响应特定的系统调用</p>
<ul>
<li><p><code>fsync(int fd)</code> 将fd的脏数据和所有脏元数据刷盘</p>
</li>
<li><p><code>fdatasync(int fd)</code> 将fd的脏数据和必要的脏元数据刷盘</p>
</li>
<li><p><code>sync()</code> 将全部脏页刷盘</p>
</li>
<li><p><code>O_SYNC</code> 文件打开方式要求同步写操作</p>
</li>
</ul>
</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li><strong>文件映射</strong>：程序通过 <code>mmap</code> 映射文件时，如果页面未修改（脏位为 <code>0</code>），无需将内存中的数据写回磁盘。</li>
<li><strong>交换区</strong>：当内存不足时，未被修改的页面无需写回交换区，节省时间和空间。</li>
</ul>
<h5 id="Direct-I-O"><a href="#Direct-I-O" class="headerlink" title="Direct I/O"></a>Direct I/O</h5><p>Buffered I/O要在磁盘和VFS之间加一层Page cache，对于写入操作，需要在cache中开辟新页，然后将其标记为脏。</p>
<p>OS cache提供的这些预读取、顺序读取等特性，这些特性并不适用于所有的场景，比如数据库，数据库通常都有自己的一套缓存机制，就像mysql的innodb存储引擎，它有自己的缓存页，有自己的落盘机制，如果不使用directIO，这明显就会存在双重的cache，一个是OS设计的，一个是DB设计的，而通常，DB需要更加符合自己使用的cache机制，而非OS提供的通用化的缓存机制。直接写入不会将要写入的数据先从磁盘读到cache，而是直接将要写的数据写入磁盘。</p>
<p>O_DIRECT 下的 I/O 操作是直达磁盘的，用户空间通过 DMA 的方式与磁盘以及网卡进行数据拷贝。</p>
<h4 id="页面置换：2Q"><a href="#页面置换：2Q" class="headerlink" title="页面置换：2Q"></a>页面置换：2Q</h4><p>关键词：<strong>预读失效 + 缓存污染</strong> </p>
<ul>
<li><strong>预读失效：提前加载到内存，但是并没有访问</strong></li>
<li><strong>缓存污染：加载到内存，但是只访问一次</strong></li>
</ul>
<p><strong>LRU</strong>：如果打开一个非常大的文件，LRU会把其他在内存中的文件都淘汰掉，但是写入这个文件到内存中并没有什么用，就和循环访问一样，文件之前的数据在被淘汰掉之前再也被访问。</p>
<p><strong>Linux的2Q(Two queue)策略</strong></p>
<p>该算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/73bc553b295b04f7a2bc634b6bd10ab9.png" alt="img" style="zoom:200%;" />

<p>Linux对于2Q的实现，只淘汰FIFO队列里面的数据：</p>
<p>Page cache（Buffered I/O或mmap）维护两个队列:</p>
<p><code>inactive list(FIFO), active list(LRU)</code> </p>
<ul>
<li>第一次被访问，将页面加入<code>inactive list</code></li>
<li>之后的访问，将页面升至<code>active list</code> </li>
<li>需要进行替换时，<code>inactive list</code>进行FIFO</li>
<li><code>active list</code>对定期 LRU 到<code>inactive list</code>，使<code>active list</code>占 Page cache 的2/3左右。</li>
<li>循环访问大文件时，大文件的页面不会跑到<code>active list</code>中，因此原来<code>active list</code>的页面就不会被迫换出</li>
</ul>
<h4 id="其他策略-1"><a href="#其他策略-1" class="headerlink" title="其他策略"></a>其他策略</h4><ul>
<li><code>fork()</code> 采用COW写时复制的策略，减少无效的复制</li>
<li><code>swapd</code> 可以监控内存状况，内存占用过高（watermark）换出页面，释放到安全水平（异步）</li>
<li><strong>swappiness</strong>：修改换出页面的积极性，0为不主动换出</li>
<li><strong>关闭swap</strong>：服务器内存本身足够大，不需要换出操作，因为会降低效率</li>
<li><strong>内存颠簸（thrashing）</strong> 虚拟内存申请，但是物理内存几乎占满，导致同时出现大量缺页错误，此时linux oom killer会杀死内存密集型，一般这些都是低优先级的，也有一定的风险)</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>现代操作系统最大的一个特点就是对安全的注重，仅仅使用内核</p>
<h4 id="针对用户程序：缓冲区溢出攻击"><a href="#针对用户程序：缓冲区溢出攻击" class="headerlink" title="针对用户程序：缓冲区溢出攻击"></a>针对用户程序：缓冲区溢出攻击</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">some_function</span><span class="params">(<span class="type">char</span> *input)</span> &#123;</span><br><span class="line">    <span class="type">char</span> dest_buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(dest_buffer, input); <span class="comment">// oops, unbounded copy!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入超过缓冲区，input就会开始覆盖其他数据，攻击者可以利用缓冲区溢出注入他们的恶意代码，在页表中引入<code>NX</code>bit能够在一定程度上解决问题，但是黑客可以更改函数的执行栈，将函数的返回值指向恶意代码的地址。</p>
<p>return-to-libc attack:==ROP==</p>
<blockquote>
<p>Thus, an attacker can overwrite the stack such that the <strong>return address in the currently executing function</strong> points to <strong>a desired malicious instruction (or series of instructions)</strong>, followed by a return instruction.</p>
<p>By stringing together a large number of gadgets (i.e., ensuring each return jumps to the next gadget), the attacker can execute arbitrary code. Amazing!</p>
</blockquote>
<p>address space layout randomization:==ASLR==</p>
<blockquote>
<p>Instead of placing code, stack, and the heap <strong>at fixed locations</strong> within the virtual address space, the OS <strong>randomizes their placement</strong>, thus making it quite challenging to craft the intricate code sequence required to implement this class of attacks.</p>
</blockquote>
<p>ASLR可以确保客户的程序只崩溃不执行恶意代码，ASLR将brk、mmap、stack的开始段加一些随机数，</p>
<p>由此衍生出了KASLR，内核的地址空间也可以随机生成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//random.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">stack</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    prompt&gt; ./random</span></span><br><span class="line"><span class="comment">    0x7ffd3e55d2b4</span></span><br><span class="line"><span class="comment">    prompt&gt; ./random</span></span><br><span class="line"><span class="comment">    0x7ffe1033b8f4</span></span><br><span class="line"><span class="comment">    prompt&gt; ./random</span></span><br><span class="line"><span class="comment">    0x7ffe45522e94</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="针对内核程序：Meltdown-amp-Spectre"><a href="#针对内核程序：Meltdown-amp-Spectre" class="headerlink" title="针对内核程序：Meltdown &amp; Spectre"></a>针对内核程序：Meltdown &amp; Spectre</h4><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23973128">CPU 的分支預測器是怎樣工作的？ - 知乎</a> </p>
<p>利用了 CPU 预测执行的漏洞，分支预测将串行的程序变成了并行的，而前后数据依赖，不可避免地在硬件上留下了踪迹，造成了并发安全问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rax byte[x]  ; 非法操作 将x的数据拷贝到rax</span><br><span class="line">shl rax 0xC  ; rax * 4096, 页对齐</span><br><span class="line">mov rbx qword [rbx + rax]  ; [rbx] 为用户空间的一个array，合法操作</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32757727">解读 Meltdown &amp; Spectre CPU 漏洞 - 知乎</a> </p>
<p>操作系统会事先标注好内核的内存地址范围，如果 x 在内核的这个地址范围内，并且 CPU 不是以内核模式运行的话，那么该指令会被 CPU 标注为非法，引起异常，异常处理程序会将 rax 清空为0，并且终结此程序，这样后续指令再来读 rax 的时候就只能读到0了。</p>
<p>理论上讲，在执行第二条指令之前，rax应该已经被清零了。然而在实际的 CPU 运行中，为了达到更好的性能，第二条和第三条指令在异常处理生效之前都会被<strong>部分执行</strong>，直到异常处理时 rax 和 rbx 被清零。</p>
<p>但问题的关键就在第三行指令：<strong>如果地址 rbx + rax 不在cache中的话，CPU 会自动将这一地址调入cache中，以便之后访问时获得更好的性能，然而异常处理并不会将这个cache flush掉。而这条 cache 的地址是和 rax 直接相关的，这样就相当于在 CPU 硬件中留下了和rax 相关的信息。</strong>  </p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OSTEP%20Virtualization.assets/image-20241214175132236.png" alt="image-20241214175132236"></p>
<p>那么如何还原 rbx + rax 这个被cache的地址呢？这时候需要用到的原理就是利用cache的访问延时，即已经被cache的数据访问时间短，没有被cache的数据访问时间长。由于[rbx]这个array是在用户地址空间内的，可以自由操作，首先我们要确保整个 [rbx]这个array 都是没有被cache的，然后执行上述攻击代码，这时候 rbx + rax 这个地址就已经被cache了，接下来遍历整个[rbx] array，来测量访问时间，访问时间最短的那个 page 就可以确定为 rbx + rax。</p>
<p>对于个人终端用户，利用Meltdown与Spectre漏洞，低权限用户可以访问内核的内容，泄露本地操作系统底层的信息、秘钥信息等，通过获取泄露的信息，可以绕过内核的隔离防护;如果配合其它漏洞，可以利用该漏洞泄露内核模块地址绕过KASLR等防护机制实现其他类型的攻击进行提权。另外，利用浏览器JIT特性预测执行特殊的JIT代码，从而读取整个浏览器内存中的数据，泄露用户帐号，密码，邮箱, cookie等隐私信息。</p>
<p>因此，增强内核保护的一种途径是从每个用户进程中删除尽可能多的内核地址空间，并为大多数内核数据提供单独的内核页表（称为内核页表隔离，或 KPTI）[G+17]。因此，不是将内核的代码和数据结构映射到每个进程中，而是只保留最低限度的代码和数据结构；当切换到内核时，现在需要切换到内核页表。这样做可以提高安全性并避免一些攻击媒介，但代价是：性能。切换页表的成本很高。</p>
<h2 id="内存虚拟化总结"><a href="#内存虚拟化总结" class="headerlink" title="内存虚拟化总结"></a>内存虚拟化总结</h2><ul>
<li><p>虚拟地址的作用</p>
</li>
<li><p>虚拟地址的翻译（重定位）</p>
<ul>
<li>段式 base+bound, bound varies from each other</li>
<li>页式 fixed bound</li>
<li>段页式 </li>
<li>多级页表 fill one page with one table, hi-level table points to low-level table</li>
<li>TLB：翻译缓存</li>
</ul>
</li>
<li><p>Swap：将物理内存看作虚拟内存的缓存</p>
<ul>
<li>机制：Page Fault &amp; Disk I/O </li>
<li>策略：<ul>
<li>是否需要SWAP？物理内存充足就没必要开启</li>
<li>具体换<strong>出</strong>哪一页？LRU, FIFO, Random, Second Chance, LRU-K, 2Q, Clock</li>
<li>何时换<strong>出</strong>？(被动watermark、主动swappiness&gt;0)</li>
<li>一次 I/O 换<strong>出</strong>多少页？(clustering)</li>
<li>何时换<strong>入</strong>？(lazy aka. demand paging)</li>
<li>一次 I/O 只换<strong>入</strong>一页<strong>吗</strong>？(prefetching)</li>
</ul>
</li>
</ul>
</li>
<li><p>内存分配:</p>
<ul>
<li>机制：空闲空间链表节点的分割与合并</li>
<li>物理：Buddy, SLAB</li>
<li>虚拟：mmap malloc brk</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
