<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Slab:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/01/Starter%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/01/Starter%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">自定义 starter</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T00:00:00+08:00">2025-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 13:50:16" itemprop="dateModified" datetime="2025-04-26T13:50:16+08:00">2025-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><mark>在 Spring Boot 生态中，“Starter” 本质上就是一组依赖的“捆绑包”，它的目标是让使用方 <strong>一行依赖</strong> 就把启动一个完整的 Spring Boot 应用所需的所有东西都拉过来。</mark> </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/01/01/Starter%E7%9A%84%E5%AE%9E%E7%8E%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/01/rpc-interpretation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/01/rpc-interpretation/" class="post-title-link" itemprop="url">基于 Netty 的 RPC 框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T00:00:00+08:00">2025-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 14:03:01" itemprop="dateModified" datetime="2025-04-26T14:03:01+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="wxy-rpc"><a href="#wxy-rpc" class="headerlink" title="wxy-rpc"></a>wxy-rpc</h1><p>这是一个同步调用的 RPC 框架。</p>
<p>服务消费方包装好 RpcRequest，做完服务发现之后发送网络请求，使用 Promise 来进行异步请求的同步等待 await(timeout) 与收到 RpcResponse 之后的 setSuccess(rpcMessage)。</p>
<p>服务提供方收到 RpcRequest，根据服务名称在本地注册中心找到实现类，执行调用，返回结果封装在 RpcResponse 内。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250423123418951.png" alt="责任链"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/01/01/rpc-interpretation/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/31/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/31/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">并发集合框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-31 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-31T00:00:00+08:00">2024-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 13:52:02" itemprop="dateModified" datetime="2025-04-26T13:52:02+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="并发安全-Map"><a href="#并发安全-Map" class="headerlink" title="并发安全 Map"></a>并发安全 Map</h2><p><strong><code>ConcurrentSkipListMap</code></strong> : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="JDK-1-7-Segment-ReentrantLock"><a href="#JDK-1-7-Segment-ReentrantLock" class="headerlink" title="JDK 1.7: Segment(ReentrantLock)"></a>JDK 1.7: Segment(ReentrantLock)</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java7_concurrenthashmap.png" alt="Java7 ConcurrentHashMap 存储结构"></p>
<p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，</p>
<p>JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 继承自 <code>ReentrantLock</code>。每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p>
<ul>
<li><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</li>
<li><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 数组属于链表结构。</li>
</ul>
<p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>
<p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>
<p>JDK 1.7 最大并发度是 Segment 的个数，默认是 16</p>
<h4 id="JDK-1-8-Node-CAS-synchronized"><a href="#JDK-1-8-Node-CAS-synchronized" class="headerlink" title="JDK 1.8: Node+CAS+synchronized"></a>JDK 1.8: Node+CAS+synchronized</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构"></p>
<p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是<mark>直接用 <code>Node</code></mark> 数组+链表+红黑树的数据结构来实现，并发控制使用 <mark><code>synchronized</code> 和 CAS</mark> 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
<p>JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p>
<ul>
<li><p>每个 <strong>桶（bucket）</strong> 对应一个链表或红黑树，用于解决<strong>哈希冲突</strong>。</p>
</li>
<li><p>如果链表长度超过一定阈值（默认为 8），链表会自动转换为<strong>红黑树</strong>，提高查询效率。</p>
</li>
<li><p>红黑树的情况需要使用 **<code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树。<code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p>
</li>
</ul>
<p>JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p>
<p><strong>链表的线程安全性</strong> </p>
<p>在 <strong>ConcurrentHashMap</strong> 中，链表本身不是直接加锁的，而是通过更细粒度的<strong>CAS（Compare-And-Swap）机制</strong>和<strong>自旋锁</strong>来保证线程安全：</p>
<ol>
<li><strong>插入节点</strong>时通过 CAS 更新表头或表尾。</li>
<li><strong>查询节点</strong>时允许并发读操作，而不会阻塞其他线程。</li>
<li><strong>扩容操作</strong>采用链表迁移的方式，通过分段迁移减少阻塞时间。</li>
</ol>
<h4 id="不保证复合操作原子性"><a href="#不保证复合操作原子性" class="headerlink" title="不保证复合操作原子性"></a>不保证复合操作原子性</h4><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！</p>
<p>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作，例如先判断某个键是否存在<code>containsKey(key)</code>，然后根据结果进行插入或更新<code>put(key, value)</code>。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低</p>
<h2 id="并发安全-List"><a href="#并发安全-List" class="headerlink" title="并发安全 List"></a>并发安全 List</h2><h3 id="线程不安全-ArrayList"><a href="#线程不安全-ArrayList" class="headerlink" title="线程不安全 ArrayList"></a>线程不安全 ArrayList</h3><p>我们通常使用的ArrayList就是线程不安全的，举个简单的例子</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestList</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并发修改异常</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;4&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">   at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">   at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">   at java.util.AbstractCollection.toString(AbstractCollection.java:<span class="number">461</span>)</span><br><span class="line">   at java.lang.String.valueOf(String.java:<span class="number">2994</span>)</span><br><span class="line">   at java.io.PrintStream.println(PrintStream.java:<span class="number">821</span>)</span><br><span class="line">   at com.hnguigu.<span class="keyword">unsafe</span>.TestList.lambda$main$<span class="number">0</span>(TestList.java:<span class="number">20</span>)</span><br><span class="line">   at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案，有以下几种！</strong></p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">concurrent</span>.<span class="property">CopyOnWriteArrayList</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestList</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * 1. List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                list.<span class="title function_">add</span>(<span class="variable constant_">UUID</span>.<span class="title function_">randomUUID</span>().<span class="title function_">toString</span>().<span class="title function_">substring</span>(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(list);</span><br><span class="line">            &#125;,<span class="title class_">String</span>.<span class="title function_">valueOf</span>(i)).<span class="title function_">start</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种通用优化策略。</p>
<p>CopyOnWrite容器即写入时复制的容器。<strong>通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</strong>这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据。CopyOnWrite并发容器用于读多写少的并发场景。</p>
<blockquote>
<p>CopyOnWriteArrayList 比 Vector 厉害在哪里？</p>
</blockquote>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224114551267-580082797.png" alt="CopyOnWrite"></p>
<p>CopyOnWriteArrayList底层采用了Lock锁，是JDK层面的，效率高！</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221223214340940-165732240.png" alt="VectorSource"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ul>
<li>CopyOnWriteArrayList 并发安全且性能比 Vector 好。Vector 是增删改查方法都加了synchronized 来保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而 CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于 Vector。</li>
<li>线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据一致性问题。这种实现只是保证数据的<strong>最终一致性</strong>，不能保证数据的<strong>实时一致性</strong>。在添加到拷贝数据而还没进行替换的时候，读到的仍然是旧数据。</li>
<li>内存占用问题。如果对象比较大，内存写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。 这个时候，我们应该考虑其他的容器，例如 ConcurrentHashMap。</li>
<li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点 多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种 操作分分钟引起故障。</li>
</ul>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector底层采用了Synchronized加锁的方式，保证了数据的安全性，但是效率低下！</p>
<p>解释一下：Synchronized是Java内置的机制，是JVM层面的，效率低是因为底层操作依赖于操作系统，操作系统切换线程要从用户态切换到内核态，花费很多时间。</p>
<h2 id="并发安全-Set"><a href="#并发安全-Set" class="headerlink" title="并发安全 Set"></a>并发安全 Set</h2><h3 id="线程不安全-HashSet"><a href="#线程不安全-HashSet" class="headerlink" title="线程不安全 HashSet"></a>线程不安全 HashSet</h3><p>Set和List同样是多线程下不安全的集合类，同样会报并发修改异常！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSet</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="keyword">set</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSet</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * set集合没有可替换的集合</span></span><br><span class="line"><span class="comment">         * 1. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 2. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;String&gt; <span class="keyword">set</span> = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="keyword">set</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和面试官谈到这里，一般都会问hashSet的底层实现原理。<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224125000674-1551081400.png" alt="hashSetSource"></p>
<p>底层其实就是用hashMap实现的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224125144809-649163275.png" alt="hashSetAdd"></p>
<p>HashSet底层使用了哈希表来支持的，特点：存储快 往HashSet添加元素的时候，HashSet会先调用元素的HashCode方法得到元素的哈希值，然后通过元素的哈希值经过异或移位等运算，就可以算出该元素在哈希表中的存储位置。如果算出的元素存储的位置目前没有任何元素存储，那么该元素可以直接存储在该位置上；如果算出的元素的存储位置上目前已经有了其他的元素，那么还会调用该元素的equals方法 ，与该位置的元素进行比较一次，如果过equals方法返回的是true，那么该位置上的元素就会被视为重复元素，不允许被添加，如果false，则允许添加。</p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><strong><code>BlockingQueue</code></strong> 是 Java 并发包（<code>java.util.concurrent</code>）中的一个接口，专门用于<strong>线程安全的生产者-消费者模型</strong>。它支持线程在队列为空或已满时自动阻塞，从而简化了多线程编程中的同步问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/arrayblockingqueue-class-diagram.png" alt="ArrayBlockingQueue 类图"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>线程安全：<ul>
<li>内部使用锁和条件变量（Condition）实现线程安全操作。</li>
</ul>
</li>
<li>阻塞机制：<ul>
<li>当队列为空时，获取元素的线程会被阻塞，直到队列中有可用元素。</li>
<li>当队列已满时，添加元素的线程会被阻塞，直到队列有空间。</li>
</ul>
</li>
<li>常用场景：<ul>
<li><strong>生产者-消费者模型</strong>，生产者向队列中添加数据，消费者从队列中取数据。</li>
<li>控制线程执行顺序或流量，避免资源争抢。</li>
</ul>
</li>
</ol>
<p><strong><code>BlockingQueue</code></strong> : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><code>ArrayBlockingQueue</code> </p>
<ul>
<li><strong>best performance</strong> </li>
<li>单lock 双condition 算法，必须显式设置容量</li>
<li>底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。</li>
</ul>
<p><code>LinkedBlockingQueue</code> / <code>LinkedBlockingDeque</code></p>
<ul>
<li>2 locks 2 conditions，默认Integer.MAX_VALUE</li>
<li>底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。</li>
</ul>
<p><code>SynchronousQueue</code></p>
<ul>
<li>每次插入操作必须等待一个取出操作，否则就会阻塞，适合高并发传递数据。</li>
<li>不允许null</li>
<li>本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。</li>
</ul>
<p><code>DelayQueue</code></p>
<ul>
<li>延时队列，只有到期的元素才能被取出，适合定时任务或延迟执行场景。</li>
<li>elements must implement <code>java.util.concurrent.Delayed</code> </li>
</ul>
<p><code>LinkedTransferQueue</code></p>
<ul>
<li>waits for consumer to consume the element (message passing need to be guaranteed)</li>
</ul>
<p><strong><code>ConcurrentLinkedQueue</code></strong> :</p>
<ul>
<li>高效的并发队列，使用链表实现。一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li>
</ul>
<p><code>PriorityBlockingQueue</code></p>
<ul>
<li>concurrent version of <code>PriorityQueue</code></li>
<li>无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</li>
<li>基于优先级堆实现的无界阻塞队列，元素按优先级排序，不保证 FIFO。</li>
</ul>
<h3 id="主要方法-put-take-offer-poll"><a href="#主要方法-put-take-offer-poll" class="headerlink" title="主要方法: put-take offer-poll"></a>主要方法: put-take offer-poll</h3><p>add、remove实际上是对offer的封装</p>
<ul>
<li><strong>插入元素：</strong><ul>
<li><code>put(E e)</code>：如果队列已满，阻塞等待空间。</li>
<li><code>offer(E e)</code>: 非阻塞插入<ul>
<li><code>offer(E e, long timeout, TimeUnit unit)</code>：带自旋的非阻塞插入</li>
</ul>
</li>
</ul>
</li>
<li><strong>取出元素：</strong> <ul>
<li><code>take()</code>：如果队列为空，阻塞等待数据。</li>
<li><code>poll()</code>: 非阻塞获取<ul>
<li><code>poll(long timeout, TimeUnit unit)</code>：带自旋的非阻塞获取</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查队列状态：</strong><ul>
<li><code>size()</code>：返回当前元素数量。</li>
<li><code>remainingCapacity()</code>：返回剩余可用空间。</li>
</ul>
</li>
<li>队列数据迁移<ul>
<li><code>int elemCount = queue.drainTo(list);</code></li>
<li> <code>drainTo</code> 会一次性将队列中所有元素存放到列表，如果队列中有元素，且成功存到 list 中则 <code>drainTo</code> 会返回本次转移到 list 中的元素数，若队列为空，<code>drainTo</code> 则直接返回 0</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    queue.put(i); <span class="comment">// 阻塞插入</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> queue.take(); <span class="comment">// 阻塞获取</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>实际上就是生产者——消费者模式的具体实现</p>
<p>加锁访问共享区域，阻塞使用的是和锁相关的condition条件变量，细化了等待条件</p>
<p>condition.await    condition.signal/signalAll   就是使用了这个细节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE <span class="number">8</span></span><br><span class="line"><span class="type">int</span> buffer[MAXSIZE];</span><br><span class="line"><span class="type">int</span> <span class="variable">fill_ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">use_ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">	fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> buffer[use_ptr];</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">cond_t notEmpty,notFull;</span><br><span class="line">mutex_t mutex;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == MAXSIZE)</span><br><span class="line">            cond_wait(&amp;notEmpty, &amp;mutex);</span><br><span class="line">    	put(i);</span><br><span class="line">        printf(<span class="string">&quot;producer:%d puts value:%d&quot;</span>, gettid(), i);</span><br><span class="line">        cond_signal((&amp;notFull);</span><br><span class="line">    	mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">            cond_wait(&amp;isEmpty, &amp;mutex);</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> get();</span><br><span class="line">        printf(<span class="string">&quot;pid:%d gets value:%d&quot;</span>, gettid(), value);</span><br><span class="line">        cond_signal(&amp;isFull);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                    </span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/26/Netty%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/26/Netty%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">Netty 最佳实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-26T00:00:00+08:00">2024-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 13:49:08" itemprop="dateModified" datetime="2025-04-26T13:49:08+08:00">2025-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/12/26/Netty%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/11/01/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/01/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Java 集合框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-01T00:00:00+08:00">2024-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 14:04:55" itemprop="dateModified" datetime="2025-04-26T14:04:55+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p>并发集合见 JUC</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-collection-hierarchy.png" alt="Java 集合框架概览"></p>
<h2 id="Collecion-单列"><a href="#Collecion-单列" class="headerlink" title="Collecion 单列"></a>Collecion 单列</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915133525868-1735477273565-35-1735477280164-37.png" alt="Collection"></p>
<ul>
<li><code>List</code>系列：添加元素有序，可重复，有索引<ul>
<li><code>ArrayList</code></li>
<li><code>LinkedList</code></li>
</ul>
</li>
<li><code>Set</code>系列：添加元素无序，不重复，无索引<ul>
<li><code>HashSet</code> 无序不重复无索引<ul>
<li><code>LinkedHashSet</code> 有序不重复无索引</li>
</ul>
</li>
<li><code>TreeSet</code> 按照大小默认升序排序 不重复 无索引</li>
</ul>
</li>
</ul>
<h3 id="Collection-Methods"><a href="#Collection-Methods" class="headerlink" title="Collection Methods"></a>Collection Methods</h3><ul>
<li><code>boolean add(E e)</code>  <code>boolean isEmpty()</code> <code>boolean remove(E e)</code> <code>boolean contains(Object o)</code> </li>
<li><code>void clear()</code> <code>int size()</code> </li>
<li><code>Object[] toArray()</code>:集合colletion转换成对象<strong>数组</strong> （返回Object数组是为了防止添加不同类型的对象）重载的<code>toArray(String[] strs)</code> 方法能够返回一个String数组<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914230120510.png" alt="toArray"></li>
<li><code>void addAll(Collections&lt;E&gt; c2)</code> <code>c1.addAll(c2)</code> 把c2的数据全部加入c1中</li>
</ul>
<h3 id="Collection-遍历"><a href="#Collection-遍历" class="headerlink" title="Collection 遍历"></a>Collection 遍历</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = collection.iterator();<span class="comment">//默认在第一个对象</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;<span class="comment">//判断迭代器是否能继续指向下一个</span></span><br><span class="line"> System.out.println(it.next()); <span class="comment">//迭代器返回现在指向的对象，之后指向下一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最好是一次<code>hasNext()</code>对应一次<code>next()</code></p>
<h4 id="for-Each增强循环"><a href="#for-Each增强循环" class="headerlink" title="for-Each增强循环"></a>for-Each增强循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; colle = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String name:colle)&#123;</span><br><span class="line">&#125;<span class="comment">//colle代表要遍历的集合名，name代表集合中每个元素的名字</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果等同于迭代器Iterator</p>
<h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">colle.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span>&#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">colle.forEach(s-&gt;System.out.println(s));</span><br><span class="line">colle.forEach(System.out::println);<span class="comment">//前后参数一样</span></span><br></pre></td></tr></table></figure>

<p>action已经实现了Consumer接口的accept方法</p>
<p>内部实现还是增强for循环，将colle集合中的元素t送到action的accept()处，相当于用元素t执行accept()方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914234023283.png" alt="forEach"></p>
<h3 id="List-支持索引"><a href="#List-支持索引" class="headerlink" title="List 支持索引"></a>List 支持索引</h3><p><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code> </p>
<ul>
<li><code>void add(int index, E e)</code>(add()重载)</li>
<li><code>E remove(int index)</code> 返回remove的数据</li>
<li><code>E get(int index)</code>返回指定索引的数据</li>
<li><code>E set(int index, E e)</code> 修改指定索引数据，返回原来的数据</li>
<li><code>List&lt;E&gt; sublist(int from, int to)</code> 返回一个list里面装有[from,to)部分的list</li>
</ul>
<h4 id="List-遍历"><a href="#List-遍历" class="headerlink" title="List 遍历"></a>List 遍历</h4><ul>
<li>for-Each-Loop Lambda Iterator</li>
<li>for循环（支持索引）</li>
</ul>
<h4 id="ArrayList-基于数组"><a href="#ArrayList-基于数组" class="headerlink" title="ArrayList 基于数组"></a>ArrayList 基于数组</h4><ul>
<li>基于<u><strong>数组</strong></u>实现 <strong>对象数组</strong> </li>
<li>查询速度快 (索引) O(1) 集合末端元素有时可以达到 O(1)</li>
<li>删除效率低，添加效率极低，基本都需要整体移动甚至扩容 都是 O(n) </li>
<li>有参构造：指定长度，不够再添</li>
</ul>
<p>适用场景：索引查询，数据量不大</p>
<p>数据量大还要频繁进行增删操作，不适合！</p>
<ol>
<li>动态扩容</li>
<li>创建指定大小</li>
<li>指定泛型，确保元素安全</li>
<li>线程不安全</li>
</ol>
<h5 id="ArrayList-扩容-源码分析：grow-int-minCapacity"><a href="#ArrayList-扩容-源码分析：grow-int-minCapacity" class="headerlink" title="ArrayList 扩容 源码分析：grow(int minCapacity)"></a>ArrayList <strong>扩容</strong> 源码分析：<code>grow(int minCapacity)</code></h5><p>三种创建方式：默认容量为 10</p>
<ol>
<li>空参：首先创建的是一个<mark>空</mark>数组 <em>懒加载的运用</em>   </li>
<li>参数为 n：创建<mark>容量为n<mark>的对象数组，0则创建空数组</li>
<li>参数为 collection：将 collection 的内容复制进入 新的 ArrayList 中</li>
</ol>
<ol>
<li><mark>无参构造，先使用一个长度为0的对象数组<mark> <ul>
<li><code>Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</code></li>
</ul>
</li>
<li><mark>添加首个元素，创建长度为10的对象数组<mark>  <ul>
<li><code>elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</code></li>
</ul>
</li>
<li>存满后，再添加时创建扩容1.5倍的数组，原内容加进去<ul>
<li><code>newCap = oldCap + oldCap &gt;&gt; 1</code></li>
<li> <code>Arrays.copyof(elementData,newCap)</code></li>
</ul>
</li>
<li>一次加多个元素，addAll，1.5 倍或者10个放不下，新创建数组长度以实际为准<code>minCapacity</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入一个元素，此时元素个数size = 0，存放元素的数组容量 length = 0，因此正好符合扩容条件：<code>grow(int minCapacity)</code> 对于普通的add，此处 <code>minCapacity = size + 1</code>，也就是现元素个数+1</p>
<p><strong><mark>扩容逻辑<mark></strong></p>
<p>空数组扩容到<code>max</code>[ <mark>10<mark> , <code>minCapacity</code> ], <code>minCapacity</code>是用来应对<code>addAll()</code>的</p>
<p>非空数组扩容到<mark>原来的1.5倍<mark>，当然1.5倍导致溢出则扩容到minCapacity即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="comment">// 最小容量应为size+1, length为数组的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//当前大小</span></span><br><span class="line">    <span class="comment">// 1. 如果是无参构造就是空数组: DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || </span><br><span class="line">    	elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                minCapacity - oldCapacity, <span class="comment">/* minimum growth  */</span></span><br><span class="line">                oldCapacity &gt;&gt; <span class="number">1</span>  <span class="comment">/* preferred GROWTH 0.5倍 原长度*/</span>);</span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1.1 上面是空数组，那就是默认容量 10 和 size+1 进行比较 创建比较大的那个</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength,<span class="type">int</span> minGrowth,<span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line">    <span class="comment">// preconditions not checked because of inlining</span></span><br><span class="line">    <span class="comment">// assert oldLength &gt;= 0</span></span><br><span class="line">    <span class="comment">// assert minGrowth &gt; 0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth); <span class="comment">// might overflow</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefLength;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// put code cold in a separate method</span></span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上来说，最好在向 <code>ArrayList</code> 添加大量元素之前用 <code>ensureCapacity(minCapacity)</code> 方法，以减少增量重新分配的次数</p>
<h5 id="Vector-Deprecated"><a href="#Vector-Deprecated" class="headerlink" title="Vector(Deprecated)"></a><del>Vector(Deprecated)</del></h5><p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 。</p>
<p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全，但是并发性能较差。</p>
<h5 id="Stack-Deprecated"><a href="#Stack-Deprecated" class="headerlink" title="Stack(Deprecated)"></a><del>Stack(Deprecated)</del></h5><ul>
<li><code>Vector</code> 和 <code>Stack</code> 两者都是线程安全的，都是使用 <code>synchronized</code> 关键字进行同步处理。</li>
<li><code>Stack</code> 继承自 <code>Vector</code>，是一个后进先出的栈，而 <code>Vector</code> 是一个列表。</li>
</ul>
<p>随着 Java 并发编程的发展，<code>Vector</code> 和 <code>Stack</code> 已经被淘汰，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p>
<h4 id="LinkedList-基于链表"><a href="#LinkedList-基于链表" class="headerlink" title="LinkedList 基于链表"></a>LinkedList 基于链表</h4><ul>
<li>基于<u>双向链表</u>实现，比单链表快</li>
<li>查询速度慢O(n)，<strong>对首尾元素操作极快</strong> O(1)</li>
<li>添加和删除不需要扩容，位移 不过还是O(n)的时间复杂度</li>
<li>线程不安全</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/linkedlist-unlink.jpg" alt="unlink 方法逻辑"></p>
<p>新增双链尾首尾特有方法：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915001950393.png" alt="LinkedList"></p>
<p>适用场景：</p>
<ul>
<li><p>对首尾的操作性能很高，LinkedList可以用来实现先进先出(FIFO)的 <strong>队列</strong></p>
<ul>
<li><p><code>LinkedList queue = new LinkedList&lt;&gt;();</code></p>
</li>
<li><p><code>Enqueue</code>⇔<code>addLast</code> <code>Dequeue</code>⇔<code>removeFirst</code></p>
</li>
</ul>
</li>
<li><p>可以实现<strong>Stack</strong> 栈</p>
<ul>
<li><p><code>LinkedList stack = new LinkedList&lt;&gt;();</code></p>
</li>
<li><p><code>push</code>⇔<code>addFirst</code> <code>Pop</code>⇔<code>removeFirst</code></p>
</li>
<li><p><code>push</code> <code>pop</code>方法已经由官方写入API可直接调用</p>
</li>
</ul>
</li>
</ul>
<h3 id="Queue：FIFO"><a href="#Queue：FIFO" class="headerlink" title="Queue：FIFO"></a>Queue：FIFO</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>add/remove实际上是对offer/poll的封装</p>
<ol>
<li><strong>添加元素的方法</strong></li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>add(E e)</code></strong></td>
<td>将指定元素插入队列，如果队列已满，则抛出 <code>IllegalStateException</code> 异常。</td>
</tr>
<tr>
<td><strong><code>offer(E e)</code></strong></td>
<td>将指定元素插入队列，如果队列已满，则返回 <code>false</code> 而不抛异常。</td>
</tr>
</tbody></table>
<p><strong>2. 移除元素的方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>remove()</code></strong></td>
<td>移除队列头部的元素，如果队列为空，则抛出 <code>NoSuchElementException</code> 异常。</td>
</tr>
<tr>
<td><strong><code>poll()</code></strong></td>
<td>移除队列头部的元素，如果队列为空，则返回 <code>null</code>。</td>
</tr>
</tbody></table>
<p><strong>3. 查看元素的方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>element()</code></strong></td>
<td>查看队列头部的元素，不移除。如果队列为空，则抛出 <code>NoSuchElementException</code> 异常。</td>
</tr>
<tr>
<td><strong><code>peek()</code></strong></td>
<td>查看队列头部的元素，不移除。如果队列为空，则返回 <code>null</code>。</td>
</tr>
</tbody></table>
<h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><ul>
<li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循FIFO</li>
<li><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素，LinkedList就实现了Deque，因此可以用来模拟栈和队列<ul>
<li>Deque 常用的方法就是对头尾元素的 <code>add/remove/get</code> <code>offer/poll/peek</code>，前者会抛异常，后者不会抛异常只会返回 false(offer) 或者 null(poll/peek) 。</li>
<li>pop = removeFirst   push = addFirst。</li>
</ul>
</li>
</ul>
<h5 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h5><p>基于可变长的数组和双指针来实现，<code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>详见 JUC</p>
<h3 id="Set-不重复"><a href="#Set-不重复" class="headerlink" title="Set 不重复"></a>Set 不重复</h3><p><code>Set&lt;Integer&gt; set = new HashSet();</code>//无序</p>
<p><code>Set&lt;Integer&gt; set = new LinkedHashSet();</code> //有序</p>
<p><code>Set&lt;Integer&gt; set = new TreeSet()</code> //排序</p>
<h4 id="HashSet-无序"><a href="#HashSet-无序" class="headerlink" title="HashSet 无序"></a>HashSet 无序</h4><ul>
<li>每个对象都有哈希值，int类型，通过<code>hashCode()</code>返回</li>
<li>也可能相同，大部分情况下是相同的</li>
<li>增删改查性能较好，类比查字典，只要看到偏旁就能定位大概的位置</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915124422018.png" alt="JDK 8 之前的 HashSet">数据过多会导致链表过长，查询性能降低，然后就扩容，加载因子0.75*16=12，占到12个数据就开始扩容，2倍大小</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915125104423.png" alt="HashSet 底层结构"></li>
<li>二叉搜索树：小的存左边，大的存右边，一样的不存</li>
<li>平衡二叉树：左右高度差不超过1</li>
<li>红黑树：自平衡的二叉搜索树 </li>
<li>无序，不重复，无索引！<ul>
<li>内容一样的两个对象s1s2，HashSet认为他们不一样</li>
<li>对于HashSet可以重写对象类的<code>equals()</code>方法，比较对象的内容而不是地址，重写<code>hashCode()</code>方法根据对象的内容计算哈希值。<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915125944598.png" alt="equals hashcode"></li>
</ul>
</li>
</ul>
<h5 id="去重原理：Hashmap-put-k-v"><a href="#去重原理：Hashmap-put-k-v" class="headerlink" title="去重原理：Hashmap put(k,v)"></a>去重原理：Hashmap put(k,v)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns: true if this set did not already contain the specified element</span></span><br><span class="line"><span class="comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而 map 的 put ，只有在key不存在时返回null，其他时候返回旧值，因此key不存在正好能够去重</p>
<h4 id="LinkedHashSet-有序"><a href="#LinkedHashSet-有序" class="headerlink" title="LinkedHashSet 有序"></a>LinkedHashSet 有序</h4><ul>
<li>在HashSet基础上，每个元素多了一个双链表机制记录前后位置，原来链表依然存在，双链表仅用来记录**<mark>添加<mark>先后顺序**</li>
<li>占用内存相对多</li>
</ul>
<h4 id="TreeSet-可自定义排序"><a href="#TreeSet-可自定义排序" class="headerlink" title="TreeSet 可自定义排序"></a>TreeSet 可自定义排序</h4><ul>
<li>不重复无索引，<strong>可排序</strong>。底层红黑树</li>
<li>对数值类型按照大小升序排序，对字符串类型按照首字符编号升序排序</li>
<li>自定义<code>Student</code>对象无法直接排序<ul>
<li><ol>
<li>让<code>Student</code>类实现<code>Comparable</code>接口，重写<code>int compareTo()</code>方法</li>
</ol>
</li>
<li><ol start="2">
<li><code>TreeSet</code>有参构造，用<code>Comparator</code>实现对象指定比较规则，2规则优先</li>
</ol>
</li>
<li>如果指定排序规则是年龄，年龄相等的是不会存的</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a><span id="concurrentmodificaiton">ConcurrentModificationException</span></h3><ul>
<li><p>遍历集合并删除集合中的元素时，会导致元素位置移动但索引没有及时更新导致的漏操作</p>
</li>
<li><p>迭代器会报错，<code>fori</code> 循环会正常执行但返回结果错误</p>
</li>
<li><p><code>fori</code> 循环：i– 、倒着遍历</p>
</li>
<li><p>迭代器：不能调用集合自己的删除，要调用迭代器自己的删除，相当于也是做了i–的操作</p>
</li>
<li><p>0     1    2    3<br>a     b    c    d</p>
<p>删除b以后，索引为1，下一步是i++，中间插一个i–让索引不变(正序遍历)<br>删除b以后，索引为1，下一步是i–，不影响正常的遍历（倒序遍历）</p>
</li>
</ul>
<p>迭代器遍历的是开始遍历那一刻拿到的集合拷贝，遍历期间原集合发生的修改迭代器不知道。</p>
<p><strong>不要<mark>在 forEach 循环里进行元素的 <code>remove/add</code> 操作<mark>。remove 元素请使用 <code>Iterator</code> 方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> userNames.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterator.next().equals(<span class="string">&quot;Hollis&quot;</span>)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>removeIf：遍历并删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br></pre></td></tr></table></figure>

<p><strong><mark>如果并发操作<mark>，在使用iterator迭代的时候使用synchronized或者Lock进行同步，或者使用JUC</strong> </p>
<p>并发情况下使用juc的并发集合，这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li>可以不传参数，也可以传一个，两个多个，也可以传数组，接收数据比较灵活</li>
<li>对外是灵活接收数据，对内就是一个数组</li>
<li>一个参数列表只有一个可变参数，而且要放在最后</li>
</ul>
<h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915140018933.png" alt="Collections"></p>
<ul>
<li><code>addAll(Collection&lt;? super T&gt; c, T...elements)</code>为集合批量添加数据<ul>
<li>泛型属于多态写法，<code>Animal</code>的<code>List</code>可以接收猫<code>Cat</code>和狗<code>Dog</code>作为可变参数</li>
</ul>
</li>
<li><code>shuffle(List&lt;?&gt; list)</code> 打乱 <mark>list<mark> 的顺序</li>
<li><code>sort(List&lt;?&gt; list)</code> 帮助list排好序，自定义类要实现<code>Comparable</code>接口</li>
<li><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> 帮助list排好序,自定义排序规则 <code>Animal</code> 的<code>Comparator</code>可以给<code>Cat</code>排序</li>
</ul>
<p>重写T的toString方法，控制println的输出</p>
<h2 id="Map-双列-K-V"><a href="#Map-双列-K-V" class="headerlink" title="Map 双列 (K-V)"></a>Map 双列 (K-V)</h2><ul>
<li>键值对集合 <code>key-value</code></li>
<li><code>key</code>不允许重复 <code>value</code>允许重复</li>
</ul>
<ol>
<li><code>HashMap</code>无序、不重复、无索引,键相同的会覆盖值</li>
<li><code>LinkedHashMap</code>有序(添加顺序)、不重复、无索引</li>
<li><code>TreeMap</code>大小默认升序、不重复、无索引</li>
</ol>
<p><code>Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();</code></p>
<h3 id="Map-常用方法"><a href="#Map-常用方法" class="headerlink" title="Map 常用方法"></a>Map 常用方法</h3><ul>
<li><code>put(K key, V value)</code>把键值对加入Map</li>
<li><code>void clear()</code> <code>int size()</code> <code>boolean isEmpty()</code> </li>
<li><code>boolean containsKey(Object key)</code> 是否有某个键</li>
<li><code>boolean containsValue(V val)</code>是否有值<code>val</code> </li>
<li><code>V get(Object key)</code> 根据键获取值 不存在返回<code>null</code></li>
<li><code>V remove(Object key)</code>根据键获取值, 删除</li>
<li><code>Set&lt;K&gt; keySet()</code> 获取包含所有键的集合，无序不重复无索引</li>
<li><code>Collection&lt;V&gt; values()</code> 获取所有值的集合，<strong>可重复</strong> </li>
<li><code>map1.putAll(Map&lt;E&gt; map2)</code>map2所有元素加入map1，能覆盖的覆盖</li>
</ul>
<h3 id="Map-遍历方式"><a href="#Map-遍历方式" class="headerlink" title="Map 遍历方式"></a>Map 遍历方式</h3><ol>
<li><p>键找值</p>
<ol>
<li><code>keySet()</code> 获取所有键</li>
<li><code>V get(Object key)</code> 根据键找值</li>
</ol>
</li>
<li><p>键值对</p>
<ol>
<li><p><code>Map.Entry&lt;K,V&gt;</code> API自带的Entry类型把Key-Value看做一个整体</p>
</li>
<li><p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> 返回一个Set，包含所有Entry对象</p>
</li>
<li><p>增强for循环遍历<code>Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entryset</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry: entryset)&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Lambda表达式(<strong>Most Simple</strong>)</p>
<ul>
<li><code>map.forEach((k,v)-&gt;&#123;System.out.println(k + &quot;+&quot; + v)&#125;)</code></li>
<li><code>forEach</code>方法的参数是<code>BiConsumer</code>接口的实现对象，要求重写<code>action</code>函数(遍历的时候要做的事情)</li>
<li><code>forEach</code>方法具体的实现：用增强for循环遍历键值对组成的的Set</li>
</ul>
</li>
</ol>
<h3 id="HashMap-无序"><a href="#HashMap-无序" class="headerlink" title="HashMap 无序"></a>HashMap 无序</h3><h4 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a><a href="#hashmap-%E5%92%8C-hashset-%E5%8C%BA%E5%88%AB">HashMap 和 HashSet 区别</a></h4><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th align="center"><code>HashMap</code></th>
<th align="center"><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了 <code>Map</code> 接口</td>
<td align="center">实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put()</code>向 map 中添加元素</td>
<td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<ul>
<li>增删改查数据，性能都较好的集合</li>
<li>无序不重复无索引</li>
<li>Key依赖hashCode和equals保证键的唯一性</li>
<li>如果存储自定义对象，重写上述方法即可</li>
<li>HashSet实际上就是HashMap实现的，只关注键</li>
<li>线程不安全</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/jdk1.8_hashmap.png" alt="JDK 1.8 之后的内部结构-HashMap"></p>
<h4 id="HashTable-Deprecated"><a href="#HashTable-Deprecated" class="headerlink" title="HashTable(Deprecated)"></a><del>HashTable(Deprecated)</del></h4><p><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。基本都是直接在方法中加<code>synchronized</code>，性能比ConcurrentHashMap弱很多。与 Hashmap相比线程安全，不支持null</p>
<h4 id="HashMap-遍历"><a href="#HashMap-遍历" class="headerlink" title="HashMap 遍历"></a>HashMap 遍历</h4><p><code>EntrySet</code> 之所以比 <code>KeySet</code> 的性能高是因为，<code>KeySet</code> 在循环时使用了 <code>map.get(key)</code>，而 <code>map.get(key)</code> 相当于又遍历了一遍 Map 集合去查询 <code>key</code> 所对应的值。为什么要用“又”这个词？那是因为<strong>在使用迭代器或者 for 循环时，其实已经遍历了一遍 Map 集合了，因此再使用 <code>map.get(key)</code> 查询时，相当于遍历了两遍</strong>。</p>
<p>而 <code>EntrySet</code> 只遍历了一遍 Map 集合，之后通过代码“Entry&lt;Integer, String&gt; entry = iterator.next()”把对象的 <code>key</code> 和 <code>value</code> 值都放入到了 <code>Entry</code> 对象中，因此再获取 <code>key</code> 和 <code>value</code> 值时就无需再遍历 Map 集合，只需要从 <code>Entry</code> 对象中取值就可以了。</p>
<p>所以，**<code>EntrySet</code> 的性能比 <code>KeySet</code> 的性能高出了一倍，因为 <code>KeySet</code> 相当于循环了两遍 Map 集合，而 <code>EntrySet</code> 只循环了一遍**。</p>
<h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>默认的<strong>数组长度</strong>为 16，也就是<strong>容量 or 桶数量（capacity / number of buckets）</strong></p>
<p>数据过多会导致链表过长，查询性能降低</p>
<p><strong>加载因子（loadfactor）</strong>为 0.75</p>
<p>元素个数达到<strong>阈值（threshold）</strong>: capacity*loadfactor = 16*0.75 = 12 ，扩容到原来的两倍</p>
<p>扩容后，需要将原数组中的所有元素重新计算哈希值，并放入新的桶中，这个过程称为<strong>rehash</strong>，会有性能损耗，因此要尽量减少扩容次数。</p>
<h5 id="为什么容量必须是-2-n"><a href="#为什么容量必须是-2-n" class="headerlink" title="为什么容量必须是 2^n^"></a>为什么容量必须是 2^n^</h5><ol>
<li>容量cap 参与 hash % cap 运算，相当于截取低位，cap 如果是2的幂次方，cap-1就是全1，hash % cap = hash &amp; (cap-1)，通过位运算提高了效率。</li>
<li>还有一方面，因为cap-1是全1，因此hash的每一位都能充分参与运算，降低了哈希冲突的风险。</li>
<li>扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。详见下文的<a href="#rehash">rehashing</a></li>
</ol>
<h4 id="链表转红黑树"><a href="#链表转红黑树" class="headerlink" title="链表转红黑树"></a>链表转红黑树</h4><p>JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，<strong>如果当前数组的长度小于 64</strong>，那么会选择<strong>先进行数组扩容</strong>，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="FIELDs-属性字段"><a href="#FIELDs-属性字段" class="headerlink" title="FIELDs 属性字段"></a>FIELDs 属性字段</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量（数组长度），必须是2的幂次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量，必须小于2的30次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认加载因子 LoadFactor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表转换成树的阈值（链表长度）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树转换回链表的阈值（链表长度）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表转换成树的阈值（数组容量）</span></span><br><span class="line"><span class="comment"> * 应该至少为TREEIFY_THRESHOLD的4倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<h5 id="节点-Node-lt-K-V-gt"><a href="#节点-Node-lt-K-V-gt" class="headerlink" title="节点 Node&lt;K,V&gt;"></a>节点 Node&lt;K,V&gt;</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// 哈希值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 设置新的返回旧的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;value = newValue;<span class="keyword">return</span> oldValue;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Map.Entry&lt;?, ?&gt; e</span><br><span class="line">                &amp;&amp; Objects.equals(key, e.getKey())</span><br><span class="line">                &amp;&amp; Objects.equals(value, e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Contructor"><a href="#Contructor" class="headerlink" title="Contructor"></a>Contructor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> * 数组 table 每个 Entry 都是一个 节点Node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructors</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    	initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line"><span class="comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> (n &lt; <span class="number">0</span>)? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>四个构造方法中，都初始化了负载因子 loadFactor，由于 HashMap 中没有 capacity 这样的字段，即使指定了初始化容量 initialCapacity ，也只是通过 tableSizeFor() 扩容到与 initialCapacity 最接近的 2 的幂次方大小，然后<strong>暂时赋值给 threshold ，后续通过 resize 方法将 threshold 赋值给 newCap 进行 table 的初始化。</strong> </p>
<h6 id="使用另一个map构造-putMapEntries-map"><a href="#使用另一个map构造-putMapEntries-map" class="headerlink" title="使用另一个map构造 putMapEntries(map)"></a>使用另一个map构造 <code>putMapEntries(map)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// s 是实际个数，dt 就是添加 s 个元素的最小容量 ceil 向上取整</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">dt</span> <span class="operator">=</span> Math.ceil(s / (<span class="type">double</span>)loadFactor);</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((dt &lt; (<span class="type">double</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)dt : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 如果超过</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已经初始化，只要超过阈值就要 resize</span></span><br><span class="line">            <span class="comment">// Because of linked-list bucket constraints, we cannot</span></span><br><span class="line">            <span class="comment">// expand all at once, but can reduce total resize</span></span><br><span class="line">            <span class="comment">// effort by repeated doubling now vs later</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt; threshold &amp;&amp; table.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="getNode"><a href="#getNode" class="headerlink" title="getNode()"></a><code>getNode()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n, hash; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; (hash = hash(key))]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 快速检查头节点</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e; <span class="comment">// 从头节点开始遍历。</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="putVal"><a href="#putVal" class="headerlink" title="putVal()"></a><code>putVal()</code></h5><p>体现了懒加载的思想，只有真正put的时候才初始化资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1. 如果没有初始化，先调用resize初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 2.1 没有哈希冲突的情况</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 2.2 出现了哈希冲突/值重复，在else逻辑里return</span></span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// .......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 没有哈希冲突或者值重复，元素自增与扩容策略</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">// 用于LinkedHashMap支持LRU实现,HashMap无用</span></span><br><span class="line">    <span class="comment">// 4. key值不存在,则返回值是null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="哈希冲突-值重复"><a href="#哈希冲突-值重复" class="headerlink" title="哈希冲突/值重复"></a>哈希冲突/值重复</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 是链表/树的第一个节点</span></span><br><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">/* 1. 快速判断第一个节点table[i]的key是否与插入的key一样 先判断 hash </span></span><br><span class="line"><span class="comment">				若相同就将现在的节点p赋给e，然后在4中处理。     */</span> 		</span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; <span class="comment">// key 的 hash </span></span><br><span class="line"><span class="comment">// 1.5 短路逻辑：先用 == 比较地址，地址不同再用equals比较内容（K需要重写equals）</span></span><br><span class="line">	((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br><span class="line"><span class="comment">// 2. 树节点去执行树的逻辑</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">// 3. 链表节点</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">// 3.0 边遍历边比较是否出现了重复key, binCount+1 能得出链表长度</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.1 一直遍历到了尾部，说明肯定没有重复的，在链表尾端创建新 Node</span></span><br><span class="line">            p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 3.2 如果到了 TREEIFY_THRESHOLD 就触发 treeifyBin 扩容或</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            <span class="comment">// 3.3 跳出循环 e == null, 不会走重复的逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.5 判断key是否重复 重复就直接跳出，去4处理key的重复情况 e!=null</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        p = e;<span class="comment">// 遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. key 重复 应对1和3.5的重复情况 </span></span><br><span class="line"><span class="comment">// 	在putIfAbsent中，onlyIfAbsent = true, 在put中，onlyIfAbsent = false</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="comment">// putIfAbsent只有原值null才能赋值</span></span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>) </span><br><span class="line">        e.value = value;</span><br><span class="line">    afterNodeAccess(e);<span class="comment">//回调方法，只在LinkedHashMap中实现,可维护访问顺序(如LRU)</span></span><br><span class="line">    <span class="comment">// 4.5 key值如果存在,则会返回原先被替换掉的value值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode()"></a><code>removeNode()</code></h5><p>remove主要有两个：一个是remove(key)，返回值为被删除的value，如果节点不存在则返回null</p>
<p>另一个是remove(key,value) 用来表示只有key对应的值为value时才移除，返回值为boolean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">/**  1. 寻找匹配到key的节点</span></span><br><span class="line"><span class="comment">      *  短路条件1: table 不为空(已初始化过)</span></span><br><span class="line"><span class="comment">      *  短路条件2: key 对应的桶不为空</span></span><br><span class="line"><span class="comment">      *  同时满足上述两个条件才会进入正式判断，否则直接返回 null</span></span><br><span class="line"><span class="comment">      *  p 现在是桶的第一个节点。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 1.1 快速检查: 先检查桶的第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 1.2 开始遍历， e 相当于 tmp</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 树节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 链表节点</span></span><br><span class="line">                <span class="keyword">do</span> &#123; </span><br><span class="line">                    <span class="comment">// 1.2.1 找到了节点，直接break，将e赋给node</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">//  p是e的前驱</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 2. 正式开始删除节点</span></span><br><span class="line"><span class="comment">          * node 为将要删除的节点</span></span><br><span class="line"><span class="comment">          * remove(k,v)-&gt;matchValue=true | remove(k)-&gt;matchValue = false</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// 对应 1.1 快速检查, 将node.next赋值给tab[i]</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//对应 1.2.1, p 是 node 的前驱节点， 直接将node.next赋给p.next</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;<span class="comment">// 减小容量</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;<span class="comment">// 返回被删除的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="resize"><a href="#resize" class="headerlink" title="resize()"></a><code>resize()</code></h5><p>用于初始化或扩容，初始化就调用属性字段里面的 threshold 初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//—————————扩容——————————</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// threshold * 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//————————初始化——————————</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">    <span class="comment">// 创建时指定了初始化容量或者负载因子 就会把算出的容量暂时存放到threshold中</span></span><br><span class="line">    <span class="comment">// 			在这里进行新容量的初始化</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 创建时无参构造，就使用默认的 capacity 和 threshold 对容量和阈值进行初始化</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建时指定了初始化容量或者负载因子，在这里进行新阈值的初始化，</span></span><br><span class="line">        <span class="comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// 新的阈值。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 正式创建新的数组, 可以看到分配大小为 newCap</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// oldTab 的 rehash</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新的 Table 数组;</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="rehashing-oldTab"><a href="#rehashing-oldTab" class="headerlink" title="rehashing oldTab"></a><span id="rehash">rehashing oldTab</span></h6><p>索引本质还是哈希值对容量取余。</p>
<p>HashMap 扩容时采用的容量是 <strong>2 的幂次方</strong>，它的二进制特性使得新容量只在<strong>高位多出一位 1</strong>。</p>
<p>元素 A B 的哈希值分别为 2 和 6，容量从 4 扩容到 8：</p>
<ul>
<li><code>0010 &amp; 0011 = 0010</code> <code>0110 &amp; 0011 = 0010</code>  旧索引均为 2</li>
<li><code>0010 &amp; 0111 = 0010</code> <code>0110 &amp; 0111 = 0110</code>  新索引分别为 2 和 6</li>
</ul>
<p><strong>二者的区别仅在于高位是否为 1</strong>：避免了复杂的哈希重算，仅通过简单的位运算就完成了分配。</p>
<p>本质上还是取hash值的低位，原来只取低两位，只有这两位参与运算，新的需要取低三位，那么此时直接和原容量 <code>0100</code> 相与，看看第三位是不是0，如果第三位是0，索引当然不变，如果第三位是1，新的索引就是原索引+原容量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;<span class="comment">// tmp</span></span><br><span class="line">    <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="literal">null</span>)<span class="comment">// 如果没有后继节点，直接映射到新的哈希位即可</span></span><br><span class="line">            newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">		<span class="comment">// e.hash &amp; (newCap - 1) 等价于 e.hash % newCap</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 树：</span></span><br><span class="line">            ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order 保证原来的顺序</span></span><br><span class="line">            Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>; <span class="comment">// 低索引，索引不变</span></span><br><span class="line">            Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>; <span class="comment">// 高索引，索引变化</span></span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            <span class="comment">// 链表尾插法</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                next = e.next;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 还在原桶</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 换到新桶</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在旧桶的，索引不变</span></span><br><span class="line">                loTail.next = <span class="literal">null</span>;</span><br><span class="line">                newTab[j] = loHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在新桶的，新索引为原索引+原容量</span></span><br><span class="line">                hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                newTab[j + oldCap] = hiHead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTab;</span><br></pre></td></tr></table></figure>

<h6 id="链表尾插法-防止多线程死循环"><a href="#链表尾插法-防止多线程死循环" class="headerlink" title="链表尾插法 防止多线程死循环"></a><strong>链表尾插法</strong> 防止多线程死循环</h6><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p>
<p>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p>
<blockquote>
<p><code>if (tail == null)     head = e; </code></p>
<p><code>else tail.next = e;</code>    </p>
<p><code>tail = e;</code>    </p>
</blockquote>
<h5 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin()"></a><code>treeifyBin()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果容量没有超过阈值64，优先扩容！</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashMap-有序"><a href="#LinkedHashMap-有序" class="headerlink" title="LinkedHashMap 有序"></a>LinkedHashMap 有序</h3><ul>
<li>有序（添加顺序） 不重复 无索引</li>
<li>HashMap加了双链表机制记录添加顺序</li>
<li>LinkedHashSet实际上就是LinkedHashMap实行的</li>
</ul>
<p>继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看</p>
<h3 id="TreeMap-可自定义排序-定向搜索"><a href="#TreeMap-可自定义排序-定向搜索" class="headerlink" title="TreeMap 可自定义排序 定向搜索"></a>TreeMap 可自定义排序 定向搜索</h3><ul>
<li>基于红黑树，TreeSet跟TreeMap原理一样</li>
<li>排序：自定义排序规则<ul>
<li>自定义的类实现<code>Comparable</code>接口，重写 <code>int compareTo(Object o)</code>方法</li>
<li>TreeMap的有参构造 参数是<code>Comparator</code>的实现对象，重写了<code>int compare()</code>方法</li>
</ul>
</li>
</ul>
<h4 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h4><p><code>Map&lt;String,List&lt;String&gt;&gt; cityMap = new HashMap&lt;&gt;();</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915170039061.png" alt="嵌套"></p>
<h2 id="Arrays-数组操作"><a href="#Arrays-数组操作" class="headerlink" title="Arrays 数组操作"></a>Arrays 数组操作</h2><ul>
<li><p><code>toString(Object[] arr)</code> 返回一个数组字符串，每个元素调用<code>toString()</code>转换成字符串，用<code>[,,,]</code>拼接成一个总字符串</p>
</li>
<li><p> <code>copyOfRange(Object[] arr, from, to)</code> 返回值为数组， 内容为arr中索引 <strong>[from, to)</strong> 的部分</p>
</li>
<li><p><code>copyOf(Object[] arr, int newlength)</code> 返回值为数组，内容为arr的内容，长度为newlength，不够的用0补齐，索引超出的截断</p>
</li>
<li><p><code>setAll</code>  第二个参数是接口<code>IntToDoubleFunction</code>的实现对象，重写了<code>applyAsDouble(int value)</code>方法，value是数组的索引，返回对数组中内容进行操作的结果，图中是将数组内容乘以0.8。这个对象传进来以后，对数组进行遍历，都用<code>applyAsDouble</code>的方法进行操作。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913170741004.png" alt="applyAsDouble"></p>
</li>
<li><p><code>sort([] arr)</code> 对arr升序排序(默认升序)</p>
</li>
<li><p><code>asList()</code>:只能加<strong>引用类型</strong>，基本数据类型需要改成包装类，并且返回的<code>List</code>是不能运用<code>add remove clear</code>方法的，这个<code>list</code>是<code>AbstractList</code>的子类，如果要访问<code>utils</code>只能将返回的这个<code>List</code>添加到<code>new ArrayList&lt;&gt;()</code>作为有参构造</p>
</li>
</ul>
<h3 id="对象数组排序"><a href="#对象数组排序" class="headerlink" title="对象数组排序"></a>对象数组排序</h3><p><strong>自己指定比较规则</strong> </p>
<ul>
<li><p>方法1：对象类实现<code>Comparable&lt;E&gt;</code>这个泛型接口，类中重写<code>int compareTo(E e)</code> 方法，将E改为自己的对象类型。</p>
<ul>
<li>约定，左边大于右边 return 正整数，小于 return 负整数，等于 return 0;（升序排序）</li>
<li><code>return this.age - o.age</code>  注意返回值是int double可以调用<code>Double.compare(o1.height, o2.height)</code></li>
<li>调用<code>Arrays.sort(students)</code>即可</li>
</ul>
</li>
<li><p>方法2：实现<code>Comparator</code>这个泛型接口，运用</p>
<ul>
<li><p>sort有一个重载函数，第一个参数是对象数组<code>T[] arr</code>，第二个参数是<code>Comparator&lt;? super T&gt; comparator</code></p>
</li>
<li><p>泛型接口做参数用匿名内部类实现，类中重写<code>int compare(T o1,T o2)</code>方法，同时注意返回的是int</p>
</li>
<li><p>```java<br>Arrays.sort(students, new Comparator<Students>(){</p>
<pre><code>@Override
public int compare(Student o1, Student o2)&#123;
    return Double.compare(o1.height,o2.height);//升序
&#125;
</code></pre>
<p>})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ArrayList有自己的sort方法，实现同Comparator，可以免去泛型的指定</span><br><span class="line"></span><br><span class="line"># Stream流</span><br><span class="line"></span><br><span class="line">- 需要有**数据源**，集合/数组等</span><br><span class="line">- 调用流水线的方法对集合处理、计算</span><br><span class="line">- 支持链式方法</span><br><span class="line"></span><br><span class="line">![stream 流](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915171033434-1735476275516-27.png)</span><br><span class="line"></span><br><span class="line">得到流，filter forEach</span><br><span class="line"></span><br><span class="line">## 常见方法</span><br><span class="line"></span><br><span class="line">### 获取Stream流</span><br><span class="line"></span><br><span class="line">- 流的泛型就是集合中元素的类型</span><br><span class="line">- **集合**：`set.stream()` </span><br><span class="line">- **数组**：</span><br><span class="line">  - `Arrays.stream(T[] array)`</span><br><span class="line">  - `Stream&lt;T&gt;.of(T...values)` </span><br><span class="line">- Map：处理键用`keySet`，处理值用`values` Map.Entry用`entrySet` ![entrySet](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915171810424-1735476275516-28.png)</span><br><span class="line"></span><br><span class="line">### 中间方法</span><br><span class="line"></span><br><span class="line">- 返回新的Stream流支持链式编程</span><br><span class="line">- `filter`:接口的实现`filter(s-&gt;s.getAge&gt;=23 &amp;&amp; s.getAge&lt;=30)`重写`boolean test()`方法返回值是一个布尔变量。**筛选条件** s就代表集合中的元素</span><br><span class="line">- `sorted`:无参数默认根据值升序排序，有参数（实现`Comparator`接口并重写`int compare(o1,o2)`）自定义排序规则。**排序**</span><br><span class="line">- `limit(long maxSize)`:取前3个对象 </span><br><span class="line">- `skip(long n)`:跳过前n个对象，“指针”移动到对应位置，可以实现逻辑分页</span><br><span class="line">- `distinct()`:去重</span><br><span class="line">- `map(mapper)`:把集合中元素映射，mapper `map(Student::getName)` `map(s-&gt;s.getName())` 把集合中的元素 通过映射方法`mapper` 转换成对应元素</span><br><span class="line">- `distinct()`:去重复，**自定义**类型对象如果希望对比内容，应该重写`hashCode()` `equals()`方法</span><br><span class="line">- `Stream.concat(st1,st2)`:合并两个流内容,返回新的流</span><br><span class="line">- `boxed()` 基本数据类型装箱操作</span><br><span class="line"></span><br><span class="line">### 终结方法 void</span><br><span class="line"></span><br><span class="line">- （没有返回值）</span><br><span class="line">- `void forEach(action)`: `forEach(s-&gt;System.out.println(s))` 元素s -&gt; 指定s想做的事情</span><br><span class="line">- `long count()`: 返回经过前面处理以后集合剩下的元素个数</span><br><span class="line">- `max((o1,o2)-&gt;Double.compare(o1.getScore(),o2.getScore()))` </span><br><span class="line">- `min()`同`max()` 实现`Comparator`</span><br><span class="line">- `get()`:用于在`min max`后接收对象</span><br><span class="line">- `collect(Collectors.toList())` `collect(Collectors.toSet())` 把流收集起来转换成集合</span><br><span class="line">- `collect(Collectors.toMap(a-&gt;a.getName() , a-&gt;a.getHeight()))` 两个接口做参数，Lambda表达式。如果遇到`key`冲突，`toMap`需要调用重载函数，启用第三个参数，`(o1,o2)-&gt;o2`表示前后`key`冲突时，后添加的`value`会覆盖之前的`value`</span><br><span class="line">- `collect(Collectors.groupingBy(Shop::getTypeId))`把流收集起来，并按照typeId分组，返回一个typeId:集合Map</span><br><span class="line">- `toArray()`将流中的元素收集到一个`Object`**数组中** </span><br><span class="line">- `toArray(len -&gt; new Student[len])`将流中的元素收集到一个指定`Student`类型的数组中 方法引用`toArray(Student[]::new)` 此处参数是`IntFunction&lt;A[]&gt;`接口的实现对象`generator` 重写函数需要`return`一个对应类型的数组，故可以用此写法</span><br><span class="line"></span><br><span class="line">### toList() &amp; collect(Collectors.toList())</span><br><span class="line"></span><br><span class="line">- 确定其是一个不再被set/add/remove的list 可使用 Stream `toList`; 如果使用`collect(Collectors.toList())` ,sonar或idea自带以及第三方的一些code checker会爆warning, 以本人经验，可以使用`collect(Collectors.toCollection(ArrayList::new))`来代替</span><br><span class="line"></span><br><span class="line">另外ListOf也是返回的不可增删改的List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Lambda表达式省略规则 REVIEW</span><br><span class="line"></span><br><span class="line">- 只有一个参数可以省略`()` ，没有参数不能省略</span><br><span class="line"></span><br><span class="line">- `-&gt;`后是具体的函数重写，多条语句需要`&#123;&#125;` `;` 单条语句可以省略分号</span><br><span class="line"></span><br><span class="line">  - 单条语句分为有返回值和无返回值，只有一行`return`的可以省略`return`关键字，没有返回值的比如输出`System.out.println(s)` 就要注意了</span><br><span class="line">  - `a-&gt;a.getName()` 要么getName()的返回值 matters 要么没有返回值 </span><br><span class="line"></span><br><span class="line">- 方法引用</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  Function&lt;Item, String&gt; getNameFunction = item -&gt; item.getName();</span><br><span class="line">  </span><br><span class="line">  Item item = new Item(&quot;Apple&quot;);</span><br><span class="line">  String name = getNameFunction.apply(item);  // 返回 &quot;Apple&quot;</span><br><span class="line">  </span><br><span class="line">  R apply(T t);//抽象方法 给一个T，返回R类型</span><br><span class="line">  String apply(Item item);//泛型将接口具体化</span><br><span class="line">  </span><br><span class="line">  /*</span><br><span class="line">  键：return 键 </span><br><span class="line">  值：return 值 </span><br><span class="line">  转换成 Lambda 表达式 调用的函数必须有返回值的</span><br><span class="line">  */</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>操作数组：最终的目的仍然是数组、集合</p>
<h1 id="集合最佳实践"><a href="#集合最佳实践" class="headerlink" title="集合最佳实践"></a>集合最佳实践</h1><p>（1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。</p>
<p>（2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。</p>
<p>（3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。</p>
<p>（4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。</p>
<p>（5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。</p>
<p>（6）尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。</p>
<h2 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h2><p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 <code>O(1)</code>。</p>
<p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 <code>O(1)</code>，不过，也有很多复杂度不是 <code>O(1)</code> 的，比如 <code>java.util.concurrent</code> 包下的 <code>ConcurrentLinkedQueue</code>。<code>ConcurrentLinkedQueue</code> 的 <code>isEmpty()</code> 方法通过 <code>first()</code> 方法进行判断，其中 <code>first()</code> 方法返回的是队列中第一个值不为 <code>null</code> 的节点（节点值为<code>null</code>的原因是在迭代器中使用的逻辑删除）</p>
<h2 id="集合遍历-iterator-并发修改异常"><a href="#集合遍历-iterator-并发修改异常" class="headerlink" title="集合遍历 iterator 并发修改异常"></a><a href="#concurrentmodificaiton">集合遍历 iterator 并发修改异常</a></h2><h2 id="集合转-Map"><a href="#集合转-Map" class="headerlink" title="集合转 Map"></a>集合转 Map</h2><p>**在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。 **</p>
<h2 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h2><p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line"><span class="comment">//没有指定类型的话会报错</span></span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型</p>
<h2 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h2><p><strong><code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</strong> </p>
<p>toList() &amp; collect(Collectors.toList())</p>
<p><code>Arrays.asList()</code> 或者流的<code>toList()</code>或者<code>List.of()</code>，得到的List只能读，不能进行修改操作，因为这个list是AbstarctList的实现类，并没有实现修改的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><code>List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code> 也可以</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">单例模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-20T00:00:00+08:00">2024-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 01:01:23" itemprop="dateModified" datetime="2025-04-26T01:01:23+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h1><h2 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="keyword">return</span> instance;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全，但是可能造成资源的浪费</p>
<h2 id="懒汉-双重校验锁-DCL"><a href="#懒汉-双重校验锁-DCL" class="headerlink" title="懒汉 双重校验锁 DCL"></a><u><strong>懒汉 双重校验锁 DCL</strong></u></h2><ol>
<li>懒汉（延迟初始化） 要素：无参构造私有，进行判断<strong>「线程不安全」</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原来的实现容易出现线程安全问题，改进：<code>getInstance()</code>变成 <code>synchronized</code> 方法。<ul>
<li><p><strong>锁范围太大</strong>：性能差，同步开销大。正常的执行路径不需要同步，只需要在创建实例的时候进行锁定即可。</p>
<ul>
<li><p>锁对象的选择：<strong>两个不相关的方法不要使用同一把锁</strong>。<strong>并且要注意不能出现死锁互相等待</strong>。</p>
</li>
<li><p>class：适用于保护静态变量或者类级别的共享资源，如果是为了保护某个对象的状态，就应该使用this。</p>
</li>
<li><p>this可能的问题：这边在内部使用this调用task.dosth()，另一边一个完全无关的业务使用 task做锁。</p>
</li>
<li><p>死锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Friend</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bow</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在向 &quot;</span> + other.name + <span class="string">&quot; 鞠躬&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟执行延迟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            other.bowBack(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bowBack</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在回礼 &quot;</span> + other.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 死锁：a和b同时向对方bow，先都锁住了自己，bowBack的时候就会造成互相等待</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>未二次判空</strong>：线程 A 通过了条件判断，获取了锁，开始创建实例，就在同时，线程B也通过判断等待锁释放，在线程 A 出来之后线程B又进去创建了一次。</p>
</li>
<li><p><strong>指令重排序</strong>：Java 允许指令重排序，创建对象可以分为 1. 分配内存地址 2. 在这块内存地址创建对象 3. 将 对象的引用 instance 指向这块地址。如果2 3的顺序颠倒，线程 A 进去之后在完全创建对象之前就将 instance 置为 非null，线程B就会以为别人已经创建好了，直接返回 instance 引用，线程B拿到以后就开始使用，其中就会随机发生空指针或者状态异常等其他难以复现调试的bug。引入 volatile，表示这个变量不允许指令重排，且线程对它的写入会立刻对其他线程可见。避免发生拿到错误对象的情况</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// 1. 禁止指令重排序</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;<span class="comment">// 2. 锁的范围缩小</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;<span class="comment">// 3. 二次判空</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用场景：</p>
<ul>
<li><strong>单例模式</strong>：延迟初始化全局唯一的对象。</li>
<li><strong>高并发资源初始化</strong>：如数据库连接池、线程池等。</li>
<li><strong>框架中的扩展点加载</strong>：如 Dubbo 的 <code>ExtensionLoader</code> 按需加载扩展类。</li>
</ul>
<h2 id="双重校验锁-与类解耦"><a href="#双重校验锁-与类解耦" class="headerlink" title="双重校验锁 (与类解耦)"></a><u>双重校验锁 (与类解耦)</u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> T instance;</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;T&gt; supplier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">(Supplier&lt;T&gt; supplier)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = supplier.get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T instance;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>&#123;</span><br><span class="line">        instance = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 在外部实现</span></span><br></pre></td></tr></table></figure>



<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a><u><strong>枚举 enum</strong></u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>天然线程安全，并且能够防止反射攻击</p>
<h2 id="Holder-静态内部类-（利用类加载机制）"><a href="#Holder-静态内部类-（利用类加载机制）" class="headerlink" title="Holder 静态内部类 （利用类加载机制）"></a><u><strong>Holder 静态内部类 （利用类加载机制）</strong></u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Holder 在 Singleton 加载时并不会被加载，只有第一次调用 <code>getInstance()</code> 才会加载 Holder，然后创建单例。</p>
<h2 id="CAS-自旋"><a href="#CAS-自旋" class="headerlink" title="CAS 自旋"></a>CAS 自旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;Singleton&gt; instance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">current</span> <span class="operator">=</span> instance.get();</span><br><span class="line">            <span class="keyword">if</span> (current != <span class="literal">null</span>) <span class="keyword">return</span> current;</span><br><span class="line">            current = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">if</span> (instance.compareAndSet(<span class="literal">null</span>, current)) &#123; <span class="comment">// 期望值为 null，设置值为 current</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无锁，非阻塞，线程安全。实现较为复杂，追求极致性能才考虑</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/classfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/classfile/" class="post-title-link" itemprop="url">ClassFile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 14:04:21" itemprop="dateModified" datetime="2025-04-26T14:04:21+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ClassFile-字节码"><a href="#ClassFile-字节码" class="headerlink" title="ClassFile 字节码"></a>ClassFile 字节码</h1><p>Java 字节码是 Java 编译器将 Java 源代码编译成的 <strong>中间表示格式</strong>，它运行在 <strong>Java 虚拟机（JVM）</strong> 上。Java 字节码文件的扩展名为 **<code>.class</code>**，可以通过 <strong><code>javap -c</code></strong> 命令查看其内容。</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。本章中， 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它完全不 需要以磁盘文件的形式存在。</p>
<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/13/classfile/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/12/G1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/12/G1/" class="post-title-link" itemprop="url">G1 垃圾收集器介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-12 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-12T00:00:00+08:00">2024-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 13:48:31" itemprop="dateModified" datetime="2025-04-26T13:48:31+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>之前根据 Sun 的内存管理白皮书介绍了在 HotSpot JVM 分代算法中的几个垃圾收集器，本文将介绍 G1 垃圾收集器。</p>
<p>G1 的主要关注点在于达到<strong>可控的停顿时间</strong>，在这个基础上尽可能提高吞吐量，这一点非常重要。</p>
<p>G1 被设计用来长期取代 CMS 收集器，和 CMS 相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。区别在于，G1 没有 CMS 的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间。</p>
<p>如果你的应用使用了较大的堆（如 6GB 及以上）而且还要求有较低的垃圾收集停顿时间（如 0.5 秒），那么 G1 是你绝佳的选择，是时候放弃 CMS 了。</p>
<p><strong>阅读建议</strong>：本文力求用简单的话介绍清楚 G1 收集器，但是并不会重复介绍每一个细节，所以希望读者了解其他几个收集器的工作过程，尤其是 CMS 收集器。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/12/G1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/11/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/11/JVM/" class="post-title-link" itemprop="url">JVM 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-11T00:00:00+08:00">2024-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 14:04:00" itemprop="dateModified" datetime="2025-04-26T14:04:00+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM-是虚拟机吗？"><a href="#JVM-是虚拟机吗？" class="headerlink" title="JVM 是虚拟机吗？"></a>JVM 是虚拟机吗？</h1><h2 id="JVM-是什么？"><a href="#JVM-是什么？" class="headerlink" title="JVM 是什么？"></a>JVM 是什么？</h2><p><strong>Java Virtual Machine (JVM)</strong> 是 Java 平台的核心组件，它是一个**<mark>程序运行环境<mark>**，专门用来执行 Java 字节码（Bytecode）</p>
<p><strong>主要功能：</strong></p>
<ol>
<li><strong>跨平台支持</strong>：JVM 实现了 Java 的 “Write Once, Run Anywhere” 特性，使 Java 程序能够在不同操作系统上运行。</li>
<li>字节码解释和编译：JVM 将 Java 编译器生成的字节码（平台无关）转换为平台相关的机器代码，并执行。</li>
<li>内存管理：提供垃圾回收机制 (Garbage Collection, GC)。</li>
<li>安全性：内置安全检查机制，确保 Java 程序在受控环境中运行，防止恶意代码执行。</li>
</ol>
<h2 id="Hypervisor-VMM-是什么"><a href="#Hypervisor-VMM-是什么" class="headerlink" title="Hypervisor/VMM 是什么?"></a>Hypervisor/VMM 是什么?</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-Hyperviseur.svg.png" alt="undefined"></p>
<p>Hypervisor 是一种一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也可叫做虚拟机监视器，即 VMM（ virtual machine monitor ）。</p>
<ul>
<li>当服务器启动并执行 Hypervisor 时，它会加载所有虚拟机客户端的操作系统同时会分配给每一台虚拟机适量的内存，CPU，网络和磁盘。它允许多个操作系统（称为<strong>Guest OS</strong>）在同一台物理机器（称为<strong>Host</strong>）上同时运行，每个操作系统被隔离在独立的虚拟机中。</li>
<li>Hypervisor 负责资源分配，如 CPU、内存和存储，协调着这些硬件资源的访问，而且在各个虚拟机之间施加防护，处理虚拟机之间的通信和安全隔离。</li>
</ul>
<h2 id="JVM-与-Hypervisor-VMM-的对比"><a href="#JVM-与-Hypervisor-VMM-的对比" class="headerlink" title="JVM 与 Hypervisor/VMM 的对比"></a>JVM 与 Hypervisor/VMM 的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>JVM</th>
<th>Hypervisor/VMM</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>运行 Java 程序的虚拟环境</td>
<td>管理和运行多个虚拟机，每个虚拟机可运行不同操作系统</td>
</tr>
<tr>
<td><strong>虚拟化层级</strong></td>
<td>应用程序级虚拟化（针对 Java 字节码）</td>
<td>操作系统级虚拟化（针对硬件资源）</td>
</tr>
<tr>
<td><strong>管理对象</strong></td>
<td><strong>Java 字节码执行环境</strong></td>
<td>虚拟机管理和<strong>硬件资源虚拟化</strong></td>
</tr>
<tr>
<td><strong>依赖性</strong></td>
<td>必须安装在操作系统上，依赖操作系统环境</td>
<td>Type 1 可以直接运行在硬件上，Type 2 依赖操作系统</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>程序之间隔离性较弱，依赖 JVM 的安全机制</td>
<td>每个虚拟机互相独立，硬件级别隔离</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>Oracle HotSpot VM、OpenJDK JVM</td>
<td>VMware ESXi、VirtualBox、KVM、Hyper-V</td>
</tr>
</tbody></table>
<ol>
<li>在 VMware ESXi 上创建一个虚拟机；</li>
<li>在虚拟机内部运行一个 Guest OS，比如 Linux；</li>
<li>在 Linux 中安装 Java 环境并运行 JVM。</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/11/JVM/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/15/hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/15/hash/" class="post-title-link" itemprop="url">哈希函数的工程应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-15T00:00:00+08:00">2024-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 13:48:37" itemprop="dateModified" datetime="2025-04-26T13:48:37+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/math/" itemprop="url" rel="index"><span itemprop="name">math</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">散列函数 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h2 id="Hash-是什么"><a href="#Hash-是什么" class="headerlink" title="Hash 是什么"></a>Hash 是什么</h2><p>哈希（Hash）的原理是通过一种<strong>特定的函数</strong>，将任意长度的输入（也称为键）<strong>映射</strong>为固定长度的输出（称为哈希值、哈希码或散列值）。这种函数称为<strong>哈希函数</strong>或<strong>散列函数</strong>。哈希主要用于快速查找、数据完整性验证等方面，下面具体解释其原理和应用：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/15/hash/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
