<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/12/leetcode-cn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/12/leetcode-cn/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-12 21:46:48 / 修改时间：21:50:10" itemprop="dateCreated datePublished" datetime="2025-05-12T21:46:48+08:00">2025-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>反转链表思路：手动记录前一个prev。将temp = curr.next，然后 curr.next = prev，然后 prev = curr，最后 curr = temp</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/09/software-engineering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/09/software-engineering/" class="post-title-link" itemprop="url">软件工程期末复习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-09 00:00:00 / 修改时间：22:24:07" itemprop="dateCreated datePublished" datetime="2025-05-09T00:00:00+08:00">2025-05-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>软件危机的原因</strong>：一方面是与软件本身的特点有关，另一方面是由软件开发和维护的方法不正确有关。</p>
<p><strong>软件危机包含两方面问题</strong>：</p>
<ul>
<li>如何开发软件，以满足不断增长，日趋复杂的需求；</li>
<li>如何维护数量不断膨胀的软件产品。</li>
</ul>
<h1 id="过程与活动"><a href="#过程与活动" class="headerlink" title="过程与活动"></a>过程与活动</h1><p><strong>过程</strong>：<mark>问题定义、可行性研究、需求分析、设计、实施、测试、部署</mark></p>
<p>可行性研究：成本/效益</p>
<h2 id="过程模型"><a href="#过程模型" class="headerlink" title="过程模型"></a>过程模型</h2><p><strong>过程模型</strong>：线性、瀑布、V、环形。。。（不推荐）</p>
<h2 id="过程模型推荐"><a href="#过程模型推荐" class="headerlink" title="过程模型推荐"></a>过程模型推荐</h2><p>XP: 小型团队、需求变化频繁、开发周期短的项目（尤其适合互联网软件）</p>
<p>螺旋： 大型、复杂、风险高、需求不明确的项目</p>
<h3 id="RUP-统一过程模型"><a href="#RUP-统一过程模型" class="headerlink" title="RUP 统一过程模型"></a>RUP 统一过程模型</h3><ul>
<li><strong>面向对象、用例驱动</strong>：以用例为中心，符合面向对象开发思想</li>
<li><strong>可迭代、可增量</strong>：每个迭代都能交付可运行的软件</li>
<li><strong>风险驱动</strong>：在早期识别并降低风险</li>
<li><strong>文档规范、过程标准化</strong>：有明确的阶段、里程碑和文档产物</li>
<li><strong>可视化建模</strong>：强调UML建模，方便沟通与分析</li>
</ul>
<p> <strong>适合：</strong> 大中型、复杂项目，需求复杂、风险高的项目</p>
<h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><ul>
<li><strong>可分阶段交付</strong>：每个增量都是一个子系统，能早交付部分功能</li>
<li><strong>降低风险</strong>：问题可在后续增量中修复</li>
<li><strong>用户反馈快</strong>：用户能早体验到产品并反馈</li>
<li><strong>适应需求变化</strong>：后续增量可以增加新需求</li>
</ul>
<p><strong>适合：</strong> 需求较清楚，但无法一次开发完成的项目；资金、时间有限，想逐步发布的项目</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>需求分析：做什么、不做什么、做到什么程度。</p>
<p>分为功能性、非功能性需求两类。</p>
<h2 id="传统分析"><a href="#传统分析" class="headerlink" title="传统分析"></a>传统分析</h2><ul>
<li><p>数据流程图：分为总体（系统与环境的关系）、零级（描述主要功能）、细节三个层次。</p>
</li>
<li><p>行为建模：状态转换图 Petri 网</p>
</li>
</ul>
<h2 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h2><h3 id="用例图（用例建模）"><a href="#用例图（用例建模）" class="headerlink" title="用例图（用例建模）"></a>用例图（用例建模）</h3><img src="https://img2023.cnblogs.com/blog/2518308/202305/2518308-20230508183405083-694565082.png" alt="img" style="zoom:50%;" />

<ul>
<li>参与者之间只有泛化（继承）关系</li>
<li>用例之间有泛化、包含include、扩展extend关系</li>
</ul>
<h3 id="类图（对象-关系建模）"><a href="#类图（对象-关系建模）" class="headerlink" title="类图（对象-关系建模）"></a>类图（对象-关系建模）</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2518308-20230508190511869-1015084285.png" alt="img" style="zoom:50%;" />

<ul>
<li>实体类类图：类间有泛化（继承）、关联（聚合组合）、依赖。类和接口之间有实现。</li>
</ul>
<hr>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2518308-20230508183323424-1524786895.png" alt="img" style="zoom:50%;" />

<ul>
<li>参与类（分析类）类图：<ul>
<li>边界类：系统及其参与者边界，xx界面类</li>
<li>控制类：系统控制逻辑，xxHandler</li>
<li>实体类：系统使用信息。</li>
</ul>
</li>
</ul>
<h3 id="活动图（对象-行为建模）"><a href="#活动图（对象-行为建模）" class="headerlink" title="活动图（对象-行为建模）"></a>活动图（对象-行为建模）</h3><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250509220108193.png" alt="image-20250509220108193" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2518308-20230508190542460-1232279932.png" alt="img" style="zoom:50%;" />

<h4 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-2219e76c264b835778365af494a2c887_1440w.jpg" alt="img" style="zoom: 80%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2518308-20230508183431532-1286422022.png" alt="img" style="zoom:50%;" />



<h1 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h1><h2 id="总体设计（概要、架构设计）"><a href="#总体设计（概要、架构设计）" class="headerlink" title="总体设计（概要、架构设计）"></a>总体设计（概要、架构设计）</h2><p>不应该陷入片面性，追踪分析模型，选择合适技术，可集成，可复用，有韧性，交互人性化。</p>
<p>软件架构应该反应整体组织结构和基本特征，体现层次结构、模块相互作用、全局重要的数据变量和数据结构、接口</p>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>在软件构架的基础上进一步确定如何实现目 标系统，具体包括系统的模块（如类及其方 法）逻辑的详细设计、系统数据结构的设计、 系统数据库结构的设计、系统人-机接口的 设计等</p>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><ul>
<li>分治概念：将一个大的系统分解为一系列小 模块的过程和方法，是软件工程最重要的思 想之一</li>
<li>架构设计将系统分解为一组子系统或模 块，以及子系统或模块之间的接口。</li>
<li>详细设计子系统或模块被再次细分为子 模块 • 传统软件工程中的过程、函数 • 面向对象软件工程中的包、类、接口和方法等</li>
</ul>
<h4 id="最小成本邻域"><a href="#最小成本邻域" class="headerlink" title="最小成本邻域"></a>最小成本邻域</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250509221307387.png" alt="image-20250509221307387" style="zoom:50%;" />

<p>软件开发成本随模块数量增加变小，但将模块组装起来的集成成本将随模块数量增加变大， 软件总成本为两个成本之和。模块成本和集成成本两个曲线的交汇点M代表了最低软件总成本，应尽量使系统划分的模块数量在M点所在的邻域内，即最小成本邻域</p>
<h2 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><p><strong>设计模式原则</strong>：指导我们如何写出“低耦合、高内聚、可扩展、易维护”的代码。</p>
<ul>
<li>SRP 单一职责：一个类只有一个职责。</li>
<li>ISP 接口隔离：接口应该专精一类功能。</li>
<li>OCP 开闭：对扩展开放，对修改关闭。SPI</li>
<li>LSP 里氏替换：子类应该可以替换父类对象，完全可以将其看做一个父类</li>
<li>DIP 依赖倒转：依赖接口/抽象，而不是实现类。JDBC</li>
<li>迪米特法则：一个对象应该尽可能少了解别的对象，减少耦合。</li>
<li>CRP 组合复用：组合优于继承，Car中用组合的形式引入Engine，避免继承地狱导致功能冗余。不过组合冗余代码较多，难以利用多态，也是需要注意的。</li>
</ul>
<h1 id="软件实施、测试"><a href="#软件实施、测试" class="headerlink" title="软件实施、测试"></a>软件实施、测试</h1><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试：是选择适当的测试用例执行被测 程序的过程，其目的在于发现程序错误。有单元测试、集成测试、系统测试、alpha、beta、验收测试。掌握单元测试、集成测试、回 归测试基本概念，能根据实际情况设计集成测试的模块测试 顺序，并分析各种测试的优劣 以及分析模块测试次数。</p>
<p><strong>测试用例</strong>：为特定目标开发的测试输入、 执行条件和预期结果的集合</p>
<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>导出测试用例是依据模块的编码，即<u>模块的内部逻辑对测试者是可见的</u>。掌握白盒测试方法，能根据实际项目情况采用<mark>基本途径测试、条件测试、循环测试</mark>等技术设计合适的测试用例。</p>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>在接口级别进行的测试，<u>不考虑程序内部逻辑</u>。掌握黑盒测试方法，能根据实际项目情况采用<mark>等价类划分、边界值分析</mark>等技术设计合适的测试用例。</p>
<h4 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250509221813185.png" alt="image-20250509221813185" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250509221826463.png" alt="image-20250509221826463" style="zoom:50%;" />

<h4 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250509221844900.png" alt="image-20250509221844900" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250509221853890.png" alt="image-20250509221853890" style="zoom:50%;" />

<img src="https://img2023.cnblogs.com/blog/2518308/202305/2518308-20230508183505415-100945804.png" alt="img" style="zoom:50%;" />

<p>测试用例：</p>
<ul>
<li>等价类划分：员工每年请假次数为[0, 10]，因此可以形成3个等价类：&lt;0、1~10、&gt;10</li>
<li>边界值分析：基于上述等价类划分结果，采用边界值分析法生成的测试用例共有7个：-1、0、1、5、9、10、11</li>
</ul>
<p>可验证的验收标准：</p>
<ul>
<li><p>系统需界面友好</p>
<ul>
<li>员工无需培训即可使用</li>
<li>经理经过2小时培训即可使用</li>
<li>部长经过2小时培训即可使用</li>
</ul>
</li>
<li><p>较高可靠性</p>
<ul>
<li>在使用系统的前三个月内，系统从未发生过崩溃（数据不可恢复）或死机现象</li>
<li>在随机的3个工作日内，系统可靠性指标都大于0.95%</li>
</ul>
</li>
</ul>
<p>独立途径集合：</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250509222254965.png" alt="image-20250509222254965" style="zoom: 25%;" />

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/07/math-distribute-math-graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/07/math-distribute-math-graph/" class="post-title-link" itemprop="url">离散数学：图、树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-07 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-07T00:00:00+08:00">2025-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:20:45" itemprop="dateModified" datetime="2025-05-08T13:20:45+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/math/" itemprop="url" rel="index"><span itemprop="name">math</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>平凡图：只有一个定点，没有任何边。</p>
<h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250506203413162.png" alt="image-20250506203413162" style="zoom:33%;" />

<p>v4 悬挂节点 只有一个边e4</p>
<p>e4 悬挂边</p>
<h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><p>平行边必须起点终点都相同，引入了出入度的概念</p>
<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250506203740347.png" alt="image-20250506203740347" style="zoom:33%;" />

<h3 id="握手定理（节点个数和边的关系）"><a href="#握手定理（节点个数和边的关系）" class="headerlink" title="握手定理（节点个数和边的关系）"></a><span id="shakehands">握手定理（节点个数和边的关系）</span></h3><ol>
<li>节点数n，边数e，所有n个节点的入度出度之和 =  2e（偶数）（计算题）</li>
<li>推论：任何图中，<strong>度数为奇数的节点个数必为偶数</strong>（判定是否能作为图的节点的度数序列）</li>
<li>推论：有向图中，<strong>所有节点的出度之和=所有节点的入度之和=e</strong></li>
</ol>
<blockquote>
<p>n 阶 无向简单图： 有n个节点，不含平行边，不含环</p>
<p>PS：如果n阶无向简单图中，有p个n-1度的节点，说明其他节点的度数最小就是p，不可能存在比p小的度数（7阶简单图，6,6,5,4,3,3,1）</p>
</blockquote>
<h2 id="通路、回路、连通"><a href="#通路、回路、连通" class="headerlink" title="通路、回路、连通"></a>通路、回路、连通</h2><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250506214035534.png" alt="image-20250506214035534" style="zoom:33%;" />

<p><strong>基本通路</strong>：点不重复、边也不重</p>
<p><strong>简单通路</strong>：边不重复</p>
<p><strong>回路</strong>：起点等于终点的通路</p>
<p><mark>连通图</mark>：</p>
<ul>
<li>无向连通图G：任意两节点之间都有一条通路，则G为 <strong>无向连通图</strong> </li>
<li>有向连通图G(V,E)：任意两节点uv，u到v存在通路则u到v可达，否则称u到v不可达。推之，可有相互可达的推论，一个节点到自己总是可达的<ul>
<li>G中任意两个节点，至少从一个节点到另一个节点是可达的，则G <strong>单向连通</strong></li>
<li>G中任意两个节点之间均为互相可达，则G <strong>强连通</strong></li>
<li>G中在略去方向之后得到的无向图连通，则G <strong>弱连通</strong> </li>
<li>任意一种连通都可以叫做 有向连通图</li>
</ul>
</li>
</ul>
<h3 id="邻接矩阵计算通路数目"><a href="#邻接矩阵计算通路数目" class="headerlink" title="邻接矩阵计算通路数目"></a><strong>邻接矩阵</strong>计算通路数目</h3><p><strong>邻接矩阵A</strong>：顶点作为坐标轴，数字就填直接连接的边数目。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250506221454171.png" alt="image-20250506221454171" style="zoom:33%;" />

<ul>
<li>A: Aij 就是vi到vj长度为1的通路条数。</li>
<li>A的n次：Aij 就是vi到vj长度为n的通路条数。</li>
<li>起点终点一样的通路就是回路</li>
</ul>
<h3 id="可达矩阵"><a href="#可达矩阵" class="headerlink" title="可达矩阵"></a>可达矩阵</h3><p><strong>可达矩阵P</strong>：数字填写两顶点之间是否可达，若可达则1，反之0</p>
<p>是否可达：先看A4，A4里面只要是正的那就是可达，如果出现了0，就翻回去看看A3 A2 A1，如果全是0，那么才是不可达的</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250506221951938.png" alt="image-20250506221951938" style="zoom:33%;" />

<h3 id="关联矩阵"><a href="#关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507205539160.png" alt="image-20250507205539160" style="zoom:33%;" />

<h1 id="欧拉图、哈密顿图"><a href="#欧拉图、哈密顿图" class="headerlink" title="欧拉图、哈密顿图"></a>欧拉图、哈密顿图</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h3><p>欧拉通路：通过G中<strong>所有边</strong> <strong>一次且仅一次</strong>的<strong>通路</strong> </p>
<p>欧拉回路：欧拉通路（起点和中点相同）</p>
<p><strong>欧拉图</strong>：有欧拉回路的图</p>
<p><strong>半欧拉图</strong>：只有有欧拉通路的图</p>
<p>推论：<em><strong>欧拉图度数均为偶数，半欧拉图有且只有两个奇度节点</strong></em></p>
<ul>
<li><p>无向连通图是欧拉图：所有节点<strong>度数均为偶数</strong> </p>
</li>
<li><p>无向连通图是半欧拉图：只有两个奇度节点</p>
</li>
<li><p>有向连通图是欧拉图：每个节点的入度=出度（度数为偶数）</p>
</li>
<li><p>有向连通图是半欧拉图：只有两个奇度节点，其中一个节点的入度比出度大1，另一个的出度比入度大1。其余每个节点的入度=出度</p>
</li>
</ul>
<h3 id="哈密顿图（设计题）"><a href="#哈密顿图（设计题）" class="headerlink" title="哈密顿图（设计题）"></a>哈密顿图（设计题）</h3><p>哈密顿回路：G中一条包含所有节点一次且进一次的回路。图G为哈密顿图</p>
<p>哈密顿通路：G中一条包含所有节点一次且进一次的通路。只有这个，图G为半哈密顿图</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250506225240817.png" alt="image-20250506225240817" style="zoom: 33%;" />

<h2 id="最短路问题（Dijkstra-标号法）"><a href="#最短路问题（Dijkstra-标号法）" class="headerlink" title="最短路问题（Dijkstra 标号法）"></a>最短路问题（Dijkstra 标号法）</h2><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>任意两顶点之间存在唯一路径</p>
<p>G无回路/连通 且节点数=边数+1</p>
 <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507191139682.png" alt="image-20250507191139682" style="zoom:33%;" />

<p>N阶非平凡的无向树至少有两片树叶</p>
<h3 id="握手定理"><a href="#握手定理" class="headerlink" title="握手定理"></a><a href="#shakehands">握手定理</a></h3><ul>
<li><p><strong>节点数 = 边数 + 1</strong>      </p>
</li>
<li><p>度数 = 边数 * 2</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507191458705.png" alt="image-20250507191458705" style="zoom:33%;" /></li>
</ul>
<h2 id="最小生成树（求连通图的最小权的生成树）"><a href="#最小生成树（求连通图的最小权的生成树）" class="headerlink" title="最小生成树（求连通图的最小权的生成树）"></a>最小生成树（求连通图的最小权的生成树）</h2><p>连通图G中的所有生成树中，带权最小的生成树 就是最小生成树。最后形成树，顶点比边多一条</p>
<h3 id="避圈法（添加的时候不要形成圈）"><a href="#避圈法（添加的时候不要形成圈）" class="headerlink" title="避圈法（添加的时候不要形成圈）"></a>避圈法（添加的时候不要形成圈）</h3><p>边按照权从小到大排列，逐次连线，注意不要形成圈</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507192348804.png" alt="image-20250507192348804" style="zoom:33%;" />

<h3 id="破圈法（见圈就破）"><a href="#破圈法（见圈就破）" class="headerlink" title="破圈法（见圈就破）"></a>破圈法（见圈就破）</h3><p>找圈，去掉其中权最大的那条边</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507192619854.png" alt="image-20250507192619854" style="zoom:33%;" />

<h2 id="根树"><a href="#根树" class="headerlink" title="根树"></a>根树</h2><p>有向树：如果有向图的基是一个无向树，那么这个有向图就是有向树</p>
<p><strong>根树</strong>：一个顶点入度为0，其余的入度为1的有向树。这个顶点是树根</p>
<p>层数：根到顶点的长度</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507210303018.png" alt="image-20250507210303018" style="zoom:33%;" />

<p>v1 是树的树根，v1到v2是一条有向边。v1 是v5可达，那么v1就是v5祖先，反过来v5是v1后代。最多分几叉就是几叉树</p>
<h3 id="最优二元树（哈夫曼树）"><a href="#最优二元树（哈夫曼树）" class="headerlink" title="最优二元树（哈夫曼树）"></a>最优二元树（哈夫曼树）</h3><p>求带权 3,4,5,8,9 的最优二元树（除了树叶，其他所有的分支节点的度数都为2 ）3,4,5,8,9 </p>
<p>首先，34合并为7。第二步，57合并为12。第三部，89合并为17。最后一步，12 17合并为29</p>
<h2 id="其他树概念"><a href="#其他树概念" class="headerlink" title="其他树概念"></a>其他树概念</h2><p><strong>完全二叉树</strong>：边数=2x-2 x为叶子数</p>
<h1 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h1><p>设计电路，线路不能交叉。除了顶点之外的任意两条边都不相交。 </p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507193654854.png" alt="image-20250507193654854" style="zoom:33%;" />

<h2 id="平面图满足欧拉公式"><a href="#平面图满足欧拉公式" class="headerlink" title="平面图满足欧拉公式"></a>平面图满足欧拉公式</h2><p>次数：面的边界所包含的边数</p>
<p>平面图所有面的次数之和 = 2e （边数的2倍）一条边提供两个次数</p>
<ul>
<li><mark>欧拉公式</mark>：G为任意<mark>连通平面图</mark>，n个顶点，m条边，r个面。那么， $n-m+r=2$</li>
<li>推广：G为任意<mark>平面图</mark>，有k个连通分支（k&gt;=2）。那么， $n-m+r=k+1$</li>
</ul>
<h2 id="对偶图"><a href="#对偶图" class="headerlink" title="对偶图"></a>对偶图</h2><p>G是简单图，每个面指定一个新的节点，只要是两面的一条公共边就让节点连一条边与其相交。新的点和边组成的图就是图G的对偶图。</p>
<p>对偶图的边数m’和原来相同，<mark>顶点数n’和原来的面数r相同</mark></p>
<p>结论：<mark>平面图</mark>的对偶图一定是平面图，一定满足<mark>欧拉公式</mark></p>
<p>边e是环，对应到对偶图里面就是桥，反之一样。</p>
<h1 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h1><h2 id="二部图"><a href="#二部图" class="headerlink" title="二部图"></a>二部图</h2><p>判定定理：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/06/math-distribute-math-lattice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/06/math-distribute-math-lattice/" class="post-title-link" itemprop="url">离散数学：格</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-06 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-06T00:00:00+08:00">2025-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:20:04" itemprop="dateModified" datetime="2025-05-08T13:20:04+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/math/" itemprop="url" rel="index"><span itemprop="name">math</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dreamsrj/articles/17743445.html">07-格与布尔代数 - Dreamsrj - 博客园</a> </p>
<h1 id="格及其判定"><a href="#格及其判定" class="headerlink" title="格及其判定"></a>格及其判定</h1><p>偏序集 (P, ≤)</p>
<ul>
<li>反身性：∀a∈P, a≤a</li>
<li>反对称：a≤b且b≤a ⇒ a=b</li>
<li>传递性：a≤b且b≤c ⇒ a≤c</li>
</ul>
<p><strong>格 (L, ∧, ∨)</strong></p>
<ul>
<li>定义：对任意a,b∈L, 最小上界a∨b和最大下界a∧b均存在</li>
<li>最小上界：满足大于等于他们俩的最近的一个元素</li>
<li>最大下界：满足小于等于他们俩的最近的一个元素</li>
<li>等价公理：交换律、结合律、吸收律</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507153802250.png" alt="image-20250507153802250" style="zoom: 25%;" />

<ul>
<li>如图右下角 ，e和f之间没有最小上界，因此不是格</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507154055264.png" alt="image-20250507154055264" style="zoom: 25%;" />

<ul>
<li>ec无法找出。df无法找出</li>
<li>幂集（所有子集构成的集合）上的包含关系是格</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507154417169.png" alt="image-20250507154417169" style="zoom: 25%;" />

<p>格的判定技巧：最底层/最上层的两个元素之间完全没关系因此不可比较。存在多个上界或者多个下界。</p>
<h2 id="子格、格同态"><a href="#子格、格同态" class="headerlink" title="子格、格同态"></a>子格、格同态</h2><p><strong>子格</strong></p>
<ul>
<li>H⊆L, 若(H,∨,∧)满足格的封闭性和公理，即为子格</li>
<li>格L的非空子集S构成L的子格的条件：<strong>H对L的∨,∧运算<u>封闭</u>。</strong> 在原格中做运算的结果还在 H里面，那么就是封闭的</li>
<li><strong>分配性可以继承，但是有补性不一定</strong>（有补性跟元素相关，少了一个元素可能就没有对应的补元了）</li>
</ul>
<p><strong>格同态</strong></p>
<ul>
<li>存在双射f:L→M, 满足f(a∨b)=f(a)∨f(b), f(a∧b)=f(a)∧f(b)</li>
</ul>
<h1 id="有补格"><a href="#有补格" class="headerlink" title="有补格"></a>有补格</h1><p><strong>有界格</strong>：格(L, ∧, ∨,O,I)</p>
<ol>
<li>格的全上界：对任意元素x，这个元素I都满足x&lt;=I</li>
<li>格的全下界：对任意元素x，这个元素O都满足b&lt;=O</li>
</ol>
<p><strong>元素a的补元</strong>：有界格中，如果存在 b∈L，使得a和b的最大下界是0（全下界），a和b的最小上界是1（全上界）那么b为a的补元。因此8和1互为补元，24没有补元</p>
<p>要么是全上界和全下界互为补元，要么是中间平行的这几个互为补元。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507180654617.png" alt="image-20250507180654617" style="zoom:33%;" />

<p><strong>有补格</strong>：每个元素都有至少一个补元。</p>
<h1 id="分配格"><a href="#分配格" class="headerlink" title="分配格"></a>分配格</h1><p><strong>分配格</strong>：格的 ∧, ∨满足分配律。<strong>链</strong>、密集、命题格都是分配格</p>
<ul>
<li>判别：不存在钻石格或者五角格同构的子格</li>
<li>四个元素及以下的都是分配格</li>
<li>五个元素，除了五角格和钻石格，其他都是分配格</li>
<li><strong>性质</strong>：支持消去律</li>
<li><a target="_blank" rel="noopener" href="https://img2023.cnblogs.com/blog/1629163/202310/1629163-20231005154333651-1708543792.png"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1629163-20231005154333651-1708543792.png" alt="img" style="zoom:33%;" /></a>L1,L2L1,L2是分配格， L3(钻石格),L4(五角格)L3(钻石格),L4(五角格)不是分配格。</li>
<li><a target="_blank" rel="noopener" href="https://img2023.cnblogs.com/blog/1629163/202310/1629163-20231005154340340-1628803049.png"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1629163-20231005154340340-1628803049.png" alt="img" style="zoom: 33%;" /></a>上述都不是分配格。 它们是钻石格或五角格的子格。</li>
</ul>
<h1 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h1><p><mark>布尔代数（布尔格）</mark>：如果<strong>有补格</strong>的∧, ∨满足分配律，那么他就是一个布尔格（布尔代数）<strong>每个元素有且只有唯一的一个补元</strong> </p>
<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250507161010076.png" alt="image-20250507161010076" style="zoom:33%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507161155099.png" alt="image-20250507161155099" style="zoom:33%;" />

<p>（2）两个元素的最小上界是全下界0，那么他们都是0。 由此可知 a和b’互为补元 b就是a </p>
<p>性质：</p>
<ul>
<li><p><strong>双重性</strong>：任何布尔恒等式对偶仍成立</p>
</li>
<li><p><strong>Stone表征定理</strong>：每个布尔代数同构于某个集合代数的幂集（P(X), ∪, ∩, ᶜ）</p>
</li>
</ul>
<p>模格</p>
<ul>
<li>x∨(y∧z)=(x∨y)∧z</li>
<li>所有分配格都是模格，反过来不一定。</li>
</ul>
<p>对偶格：把一个格中的“$\vee$”和“$\wedge$”运算、以及“$\leq$”和“$\geq$”关系全部反向，得到的新格。它是从原格“逆向”得到的结构。</p>
<ul>
<li></li>
</ul>
<h1 id="题"><a href="#题" class="headerlink" title="题"></a>题</h1><ol>
<li><strong>判定题</strong>：给出下列偏序集，判断是否构成格，并说明理由。<br> a. (所有自然数N, 整除关系)  b. (P({1,2,3}), ⊆)</li>
<li><strong>等式证明</strong>：在任意格中证明：<br> a. (a∨b)∧(a∨c) = a∨(b∧c)<br> b. a∧(b∨c) ≥ (a∧b)∨(a∧c)</li>
<li><strong>子格判别</strong>：设L是格，H={x∈L | x≥a}，证明H是L的子格</li>
<li><strong>特殊格判别</strong>：给定有界格, 判断其是否为：<br> a. 分配格  b. 补格  c. 布尔格</li>
<li><strong>有限布尔代数</strong>：列出所有阶为4的布尔代数，并验证它们满足补元律</li>
</ol>
<hr>
<ol>
<li><strong>判定题</strong>：<br> a. (N,|) 的上确界 gcd(m,n) 存在，下确界 lcm(m,n) 存在 ⇒ 是格<br> b. (P(X),⊆) 的∧=交集、∨=并集 ⇒ 是格</li>
<li><strong>等式证明</strong>：<br> a. 左边 = (a∨b)∧(a∨c) = a∨(b∧c) （分配律）<br> b. 由吸收律和分配可得 ≥ 方向</li>
<li><strong>子格判别</strong>：<ul>
<li>H封闭：若x,y≥a，则x∨y≥a, x∧y≥a</li>
<li>满足格公理</li>
</ul>
</li>
<li><strong>特殊格判别</strong>：<ul>
<li>分配：验证分配律是否在格中成立</li>
<li>补格：对每个元素检查是否存在补元</li>
<li>布尔格：同时满足上述两条</li>
</ul>
</li>
<li><strong>阶4布尔代数</strong>：<ul>
<li>同构于P({1,2})，元素{∅,{1},{2},{1,2}}，补元为集合补集</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/05/math-distribute-math-group/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/05/math-distribute-math-group/" class="post-title-link" itemprop="url">离散数学：群环域</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-05 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-05T00:00:00+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:21:10" itemprop="dateModified" datetime="2025-05-08T13:21:10+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/math/" itemprop="url" rel="index"><span itemprop="name">math</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dreamsrj/articles/17610183.html">06-代数系统的一般概念 - Dreamsrj - 博客园</a> </p>
<h1 id="群、环、域"><a href="#群、环、域" class="headerlink" title="群、环、域"></a>群、环、域</h1><h2 id="特殊元"><a href="#特殊元" class="headerlink" title="特殊元"></a>特殊元</h2><p>幂等元：$a^2=e$ </p>
<p>单位元：$ax=x$</p>
<p>零元：$ax=a$</p>
<p>逆元：$ab=e$</p>
<h2 id="群的概念递进"><a href="#群的概念递进" class="headerlink" title="群的概念递进"></a>群的概念递进</h2><p><strong>广群</strong>：封闭</p>
<p><strong>半群</strong>：封闭+可结合</p>
<p><strong>独异点</strong>：封闭+可结合+有单位元</p>
<p><strong>群</strong>：封闭+可结合+有单位元+所有元素有逆元</p>
<p><strong>阿贝尔群</strong>：群+可交换</p>
<h3 id="环、域的概念递进"><a href="#环、域的概念递进" class="headerlink" title="环、域的概念递进"></a>环、域的概念递进</h3><p>环：$(R,+,*)$ +是阿贝尔群，*是半群，并且*对+满足分配律</p>
<p>域：$(F,+,*)$ 是一个乘法含有单位元的环，并且F扣去零之后就是乘法的阿贝尔群（整环 + 非零元都可逆。）</p>
<p>整环：单位交换环，和域的区别是少了逆元（环 + <strong>无零因子</strong> + 交换 + 单位元。）</p>
<h2 id="群的阶、元素的阶"><a href="#群的阶、元素的阶" class="headerlink" title="群的阶、元素的阶"></a>群的阶、元素的阶</h2><p>群的阶：里面有n个元素即为n阶群</p>
<p>元素的阶：存在最小正整数k使得 $a^k=e$，那么a就为k阶元。</p>
<ul>
<li>一阶元：$a=e$，只有一个一阶元</li>
<li><strong>二阶元：$a^2=e$，因此 $a=a^{-1}$，a和其逆元实际上是一个元素。</strong></li>
<li><strong>二阶元以上：$a≠a^{-1}$，所以a和其逆元成对出现。</strong></li>
<li><strong>推论：偶数阶的群，一定含有二阶元：二阶以上成对出现，一阶元只有一个，那么必定存在二阶元。</strong></li>
</ul>
<h2 id="子群、拉格朗日定理"><a href="#子群、拉格朗日定理" class="headerlink" title="子群、拉格朗日定理"></a>子群、拉格朗日定理</h2><p>平凡群：只有一个元素（单位元）是所有群的子群，同时也是循环群、阿贝尔群。</p>
<p><strong>子群证明</strong>：</p>
<ol>
<li><strong>H是G非空子集</strong>。H通常是加了条件限定的，代入单位元证明其非空</li>
<li><strong>H对于运算是封闭的</strong>。H的元素同样也是G的元素，同样具备G的特性，利用G的特性，证明H的元素符合之前的条件限定。逆元可以使用 $xy^{-1}$进行变换。</li>
<li>H的非零元素都存在逆元</li>
</ol>
<p><strong>求所有子群</strong>：</p>
<ul>
<li>阶为1的子群：单位元</li>
<li>阶为2的子群：单位元、平方等于单位元的元素。。。。</li>
<li>阶为4的子群：单位元、四次放等于单位元的元素。。。。。</li>
</ul>
<p><strong>拉格朗日定理</strong>：对于有限群 G 和其子群 H，H 阶 必然是 G阶 的因子。陪集数量乘H阶=G阶</p>
<ul>
<li><strong>G的元素a，a 阶k 必然是 G阶n 的因子，并且 $a^n=e$（并不代表a是n阶元，因为n是k的倍数）</strong></li>
<li><strong>若 ∣G∣= n，则 G 的子群的阶只能是 n 的约数。</strong><ul>
<li>6-&gt; 子群阶只能是1,2,3,6</li>
<li>8-&gt; 1,2,4,8</li>
</ul>
</li>
<li>左右陪集阶为 H阶，左右陪集要么相同，要么不相交</li>
<li>H，K为子群，H交K就是H,K的子集，所以H交K是 H 和 K 的因子，其能够整除HK的最大公因数。因为HK互质，所以 H交K只能是一阶</li>
</ul>
<h2 id="循环群"><a href="#循环群" class="headerlink" title="循环群"></a>循环群</h2><p>循环群：G中存在一个元素a，使得所有的元素都可以表达为 a 的幂次方的形式，那么a是群的生成元，G是循环群</p>
<p>循环群的性质：</p>
<ul>
<li><strong>n 阶循环群，生成元也是 n阶元</strong>，即 $g^n=e$</li>
<li>一定是阿贝尔群</li>
<li>n 阶循环群，同构于$(N_n, +_n)$</li>
<li>无限循环群，同构于$(I_n,+_n)$</li>
</ul>
<h2 id="群的性质总结"><a href="#群的性质总结" class="headerlink" title="群的性质总结"></a>群的性质总结</h2><p>群的性质：</p>
<ul>
<li>逆元和单位元唯一，没有零元</li>
<li>$(a\times b)^{-1}=b^{-1}\times a^{-1}$ <strong>重要，证明题里面逆元出现</strong></li>
<li><strong>支持左右消去</strong> ，方程一定可解</li>
<li>每个元素在运算表的行/列必然出现且只会出现一次</li>
<li>阶的性质<ul>
<li><strong>素数阶群必是循环群，没有非平凡子群，并且除了单位元，剩下的全都是生成元。</strong></li>
<li><strong>逆元和自己有着相同的阶数</strong></li>
</ul>
</li>
</ul>
<h2 id="群的同态"><a href="#群的同态" class="headerlink" title="群的同态"></a>群的同态</h2><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250507013240349.png" alt="image-20250507013240349" style="zoom:50%;" />

<p>群的同态和同构：</p>
<p>同态： $f(a*b) = f(a)+f(b)$ 如果是$f(ab)=f(a)f(b)$，那就是自同态。</p>
<p>同构：f是双射的同态</p>
<p>同态核K：S中那些经过映射之后变成 S’单位元的元素，如果只有S的单位元，说明是单射</p>
<ul>
<li><p>f(e) = e</p>
</li>
<li><p>证明题：对于 x∈K，f(x)=e，</p>
</li>
</ul>
<p>证明自同构：</p>
<ol>
<li>f是双射<ol>
<li>先证明是入射: 任取不相等的两个元素x1x2，f(x1) f(x2)肯定不相等</li>
<li>再证明满射: 对于任意一个y，肯定有一个x∈G对应</li>
</ol>
</li>
<li>f(xy)=f(x)f(y)</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/03/408-in-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/03/408-in-one/" class="post-title-link" itemprop="url">22408 分值</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-03 22:25:09" itemprop="dateCreated datePublished" datetime="2025-05-03T22:25:09+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 12:50:11" itemprop="dateModified" datetime="2025-05-05T12:50:11+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="22408"><a href="#22408" class="headerlink" title="22408"></a>22408</h1><p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/smilehappiness/article/details/109964058">考研公共部分科目分支分布以及计算机408分值分布-CSDN博客</a> </p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在考研的竞争压力越来越大，这里，笔者也把考研中计算机的，408试卷分值分布做一个总结，方便以后考研的时候使用。</p>
<h2 id="计算机4科分值分配比"><a href="#计算机4科分值分配比" class="headerlink" title="计算机4科分值分配比"></a>计算机4科分值分配比</h2><table>
<thead>
<tr>
<th><strong>科目</strong></th>
<th><strong>大概分值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>45分</td>
</tr>
<tr>
<td>计算机组成原理</td>
<td>45分</td>
</tr>
<tr>
<td>操作系统</td>
<td>35分</td>
</tr>
<tr>
<td>计算机网络</td>
<td>25分</td>
</tr>
</tbody></table>
<h2 id="408"><a href="#408" class="headerlink" title="408"></a>408</h2><p><strong>408考试中，分值总分150分，大致题型以及分值如下（仅供参考）：</strong></p>
<h3 id="选择题-共80分"><a href="#选择题-共80分" class="headerlink" title="选择题 (共80分)"></a>选择题 (共80分)</h3><table>
<thead>
<tr>
<th>选择题</th>
<th>题目序号</th>
<th>分值</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>1~11</td>
<td>11X2=22分</td>
</tr>
<tr>
<td>计算机组成原理</td>
<td>12~22</td>
<td>11X2=22分</td>
</tr>
<tr>
<td>操作系统</td>
<td>23~32</td>
<td>10X2=20分</td>
</tr>
<tr>
<td>计算机网络</td>
<td>33~40</td>
<td>8X2=16分</td>
</tr>
</tbody></table>
<h3 id="综合应用题-共70分"><a href="#综合应用题-共70分" class="headerlink" title="综合应用题 (共70分)"></a>综合应用题 (共70分)</h3><p>一共有41、42、43、44 、45、46 、47，共七个大题，<code>总分值70分</code><br><strong>21年考研大题41~47分值分布依次为：</strong>15、8、15、8、7、8、9</p>
<p>正在备考的童鞋们，根据以上的分支分布，可以做一下复习侧重点呦</p>
<h2 id="其他公共科目"><a href="#其他公共科目" class="headerlink" title="其他公共科目"></a>其他公共科目</h2><h3 id="英二"><a href="#英二" class="headerlink" title="英二"></a>英二</h3><p>英语二试题分四部分，共48题，总计<code>100分</code>，包括<code>英语知识运用</code>、<code>阅读理解</code>、<code>英译汉</code>和<code>写作</code>。</p>
<p><strong>表格速览：</strong></p>
<table>
<thead>
<tr>
<th>题目类型</th>
<th>题目序号</th>
<th>分值</th>
</tr>
</thead>
<tbody><tr>
<td>英语知识运用</td>
<td>1~20</td>
<td>20X0.5=<code>10分</code></td>
</tr>
<tr>
<td>阅读理解</td>
<td>21~45</td>
<td>25X2=<code>50分</code></td>
</tr>
<tr>
<td>英译汉</td>
<td>第三部分</td>
<td><code>15分</code></td>
</tr>
<tr>
<td>作文</td>
<td>第四部分</td>
<td><code>25分</code></td>
</tr>
</tbody></table>
<h4 id="第一部分（英语知识运用）"><a href="#第一部分（英语知识运用）" class="headerlink" title="第一部分（英语知识运用）"></a>第一部分（英语知识运用）</h4><p>主要考查考生对英语知识的综合运用能力。共<code>20</code>小题，每小题<code>0.5</code>分，<code>共10分</code>。</p>
<p>在一篇约350词的文章中留出20个空白，要求考生从每题给出的4个选项中选出最佳答案，使补全后的文章意思通顺、前后连贯、结构完整。</p>
<h4 id="第二部分（阅读理解）"><a href="#第二部分（阅读理解）" class="headerlink" title="第二部分（阅读理解）"></a>第二部分（阅读理解）</h4><p>主要考查考生获取信息、理解文章、猜测重要生词词义并进行推断等方面的能力。该部分<code>由A、B两节组成</code>，共<code>25</code>小题，每小题<code>2</code>分，共<code>50</code>分。</p>
<ul>
<li><p><strong>A节(20小题)</strong><br>本部分为多项选择题。<code>共四篇文章</code>，总长度为1500词左右。<code>每篇文章设5题，共20题</code>。每小题2分，共40分。</p>
</li>
<li><p><strong>B节(5小题)</strong><br>本部分有两种备选题型。每次考试从这两种题型中选择其中的一种形式，或者两种形式的组合进行考查。本节文章设<code>5小题</code>，每小题2分，<code>共10分</code>。</p>
<p>备选题型包括：<br><strong>1)多项对应</strong><br>本部分为一篇长度为450~550词的文章，试题内容分为左右两栏，左侧一栏为5道题目，右侧一栏为7个选项。要求考生在阅读后根据文章内容和左侧一栏中提供的信息从右侧一栏中的7个选项中选出对应的5项相关信息。</p>
<p><strong>2)小标题对应</strong><br>在一篇长度为450~550词的文章前有7个概括句或小标题。这些文字或标题分别是对文章中某一部分的概括或阐述。要求考生根据文章内容和篇章结构从这7个选项中选出最恰当的5个概括句或小标题填入文章空白处。</p>
</li>
</ul>
<h4 id="第三部分（英译汉）"><a href="#第三部分（英译汉）" class="headerlink" title="第三部分（英译汉）"></a>第三部分（英译汉）</h4><p>要求考生阅读、理解长度为150词左右的一个或几个英语段落，并将其全部译成汉语，<code>共15分</code>。</p>
<h4 id="第四部分（写作）"><a href="#第四部分（写作）" class="headerlink" title="第四部分（写作）"></a>第四部分（写作）</h4><p>该部分由<code>A、B</code>两节组成，主要考查考生的书面表达能力。<code>共2题</code>，<code>25分</code>。</p>
<ul>
<li><strong>A节</strong><br>考生根据所给情景写出约100词(标点符号不计算在内)的应用性短文，包括私人和公务信函（常见的有：）、备忘录、报告等。共10分。</li>
</ul>
<p><strong>大致分类如下：</strong><br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8c5d133eb5d9b1deaa794f4441f60b77.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>B节</strong><br>要求考生根据所规定的情景或给出的提纲，写出一篇150词左右的英语说明文或议论文。提供情景的形式为图画、图表或文字。共15分。</li>
</ul>
<h3 id="政治分值分布"><a href="#政治分值分布" class="headerlink" title="政治分值分布"></a>政治分值分布</h3><p>政治部分分值，总共<code>100</code>分。</p>
<table>
<thead>
<tr>
<th>题目类型</th>
<th>题目序号</th>
<th>分值</th>
</tr>
</thead>
<tbody><tr>
<td>单项选择题</td>
<td>1~16</td>
<td>16X1=<code>16分</code></td>
</tr>
<tr>
<td>多项选择题</td>
<td>17~33</td>
<td>17X2=<code>34分</code></td>
</tr>
<tr>
<td>材料分析题</td>
<td>共5个大题</td>
<td>10X5=<code>50分</code></td>
</tr>
</tbody></table>
<h3 id="数二"><a href="#数二" class="headerlink" title="数二"></a>数二</h3><p>数学部分分值，总共<code>150</code>分。</p>
<table>
<thead>
<tr>
<th>题目类型</th>
<th>题目序号</th>
<th>分值</th>
</tr>
</thead>
<tbody><tr>
<td>单项选择题</td>
<td>1~10</td>
<td>10X5=<code>50分</code></td>
</tr>
<tr>
<td>填空题</td>
<td>11~16</td>
<td>16X5=<code>30分</code></td>
</tr>
<tr>
<td>大题</td>
<td>共6个大题</td>
<td>1X10 + 5X12=<code>70分</code></td>
</tr>
</tbody></table>
<p><strong>参考资料</strong>：<a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/12821750.html">https://zhidao.baidu.com/question/12821750.html</a></p>
<p><code>注意：</code> <strong>以上总结仅供参考，实际还是以实际的考卷分值分布为准</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">希望笔者总结的分值分布，对小伙伴有所帮助~</span><br></pre></td></tr></table></figure>

<blockquote>
<p>写博客是为了记住自己容易忘记的东西，另外也是对自己工作的总结，希望尽自己的努力，做到更好，大家一起努力进步！</p>
<p>如果有什么问题，欢迎大家评论，一起探讨</p>
<p>给自己的梦想添加一双翅膀，让它可以在天空中自由自在的飞翔！</p>
</blockquote>
<h1 id="11408"><a href="#11408" class="headerlink" title="11408"></a>11408</h1><h2 id="408-1"><a href="#408-1" class="headerlink" title="408"></a>408</h2><table>
<thead>
<tr>
<th>科目</th>
<th>大致分值</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>45</td>
</tr>
<tr>
<td>计算机组成原理</td>
<td>45</td>
</tr>
<tr>
<td>操作系统</td>
<td>35</td>
</tr>
<tr>
<td>计算机网络</td>
<td>25</td>
</tr>
</tbody></table>
<p>其中包括</p>
<table>
<thead>
<tr>
<th>科目</th>
<th>题号</th>
<th>分值</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>1~11</td>
<td>22</td>
</tr>
<tr>
<td>计算机组成原理</td>
<td>12~22</td>
<td>22</td>
</tr>
<tr>
<td>操作系统</td>
<td>23~32</td>
<td>20</td>
</tr>
<tr>
<td>计算机网络</td>
<td>33~40</td>
<td>16</td>
</tr>
</tbody></table>
<p>以及七3道综合应用题共70分</p>
<h2 id="数一"><a href="#数一" class="headerlink" title="数一"></a>数一</h2><table>
<thead>
<tr>
<th>科目</th>
<th>大致分值</th>
</tr>
</thead>
<tbody><tr>
<td>高等数学</td>
<td>84</td>
</tr>
<tr>
<td>线性代数</td>
<td>33</td>
</tr>
<tr>
<td>概率论与数理统计</td>
<td>33</td>
</tr>
</tbody></table>
<p>其中</p>
<table>
<thead>
<tr>
<th>题型</th>
<th>高数</th>
<th>线代</th>
<th>概率</th>
<th>题号</th>
<th>分值</th>
</tr>
</thead>
<tbody><tr>
<td>选择题</td>
<td>6</td>
<td>2</td>
<td>2</td>
<td>1~10</td>
<td>50</td>
</tr>
<tr>
<td>填空题</td>
<td>4</td>
<td>1</td>
<td>1</td>
<td>11~16</td>
<td>30</td>
</tr>
<tr>
<td>计算题</td>
<td>4</td>
<td>1</td>
<td>1</td>
<td>17~22</td>
<td>70</td>
</tr>
</tbody></table>
<h2 id="英一"><a href="#英一" class="headerlink" title="英一"></a>英一</h2><table>
<thead>
<tr>
<th>题型</th>
<th>题号</th>
<th>分值</th>
</tr>
</thead>
<tbody><tr>
<td>英语知识运用</td>
<td>1~20</td>
<td>10</td>
</tr>
<tr>
<td>阅读理解</td>
<td>21~50</td>
<td>60</td>
</tr>
<tr>
<td>写作</td>
<td>51~52</td>
<td>30</td>
</tr>
</tbody></table>
<p>其中</p>
<p>阅读理解<br>A、B、C三节组成，考查考生理解书面英语的能力。共30小题，每小题2分，共60分。</p>
<p>A节(20小题)：主要考查考生理解主旨要义、具体信息、概念性含义，进行有关的判断、推理和引申，根据上下文推测生词的词义等能力。要求考生根据所提供的4篇(总长度约为1 600词)文章的内容，从每题所给出的4个选项中选出最佳答案。考生在答题卡1上作答。</p>
<p>B节(5小题)：主要考查考生对诸如连贯性、一致性等语段特征以及文章结构的理解。本部分有3种备选题型。每次考试从这3种备选题型中选择一种进行考查。考生在答题卡1上作答。</p>
<p>C节(5小题)：主要考查考生准确理解概念或结构较复杂的英语文字材料的能力。要求考生阅读一篇约400词的文章，并将其中5个画线部分(约150词)译成汉语，要求译文准确、完整、通顺。考生在答题卡2上作答。</p>
<p>写作<br>该部分由A、B两节组成，主要考查考生的书面表达能力。共30分。</p>
<p>A节：考生根据所给情景写出约100词(标点符号不计算在内)的应用性短文，包括私人和公务信函、备忘录、报告等。</p>
<p>B节：考生根据提示信息写出一篇160~200词的短文(标点符号不计算在内)。提示信息的形式有主题句、写作提纲、规定情景、图、表等。考生在答题卡2上作答。共20分。 *硕士研究生入学考试将英译汉试题作为阅读理解的一部分，其目的是测试考生根据上下文准确理解概念或复杂结构并用汉语正确予以表达的能力。</p>
<h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><table>
<thead>
<tr>
<th>科目</th>
<th>大致分值</th>
</tr>
</thead>
<tbody><tr>
<td>马原</td>
<td>24</td>
</tr>
<tr>
<td>毛中特</td>
<td>30</td>
</tr>
<tr>
<td>近代史</td>
<td>14</td>
</tr>
<tr>
<td>思修</td>
<td>16</td>
</tr>
</tbody></table>
<p>其中</p>
<table>
<thead>
<tr>
<th>题型</th>
<th>题号</th>
<th>分值</th>
</tr>
</thead>
<tbody><tr>
<td>单选</td>
<td>1~16</td>
<td>16</td>
</tr>
<tr>
<td>多选</td>
<td>17~33</td>
<td>34</td>
</tr>
<tr>
<td>材料分析</td>
<td>34~38</td>
<td>50</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/01/review-4-30-%E5%8D%8E%E4%B8%BA%E4%B8%80%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/01/review-4-30-%E5%8D%8E%E4%B8%BA%E4%B8%80%E9%9D%A2/" class="post-title-link" itemprop="url">4.30 华为一面+主管面</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-01T00:00:00+08:00">2025-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 23:32:20" itemprop="dateModified" datetime="2025-05-03T23:32:20+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/review/" itemprop="url" rel="index"><span itemprop="name">review</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>华为 半导体业务部 通用软件开发工程师 暑期实习</strong> </p>
<p>3.28投递 4.9笔试 4.30 一面 主管面</p>
<p>一面：</p>
<ul>
<li>自我介绍。</li>
<li>介绍一下项目中遇到的难点？答得不好。</li>
<li>数组和链表的区别？</li>
<li>队列和栈的区别？两个队列能否实现栈？</li>
<li>手撕（寻找缺失的第一个正整数）</li>
<li>复盘笔试</li>
<li>c语言宏定义的求两个数之间的大数怎么办？（c语言忘得差不多了）</li>
<li>反问：</li>
<li>实习生如何培养的？</li>
<li>部门主要用什么语言开发的？（c，不过都会有对应的培训）</li>
<li>您对我的面试有什么建议？（处女面，太紧张了脱口而出，不然没话聊了）</li>
</ul>
<p>主管面：</p>
<ul>
<li>你们专业主要学什么？</li>
<li>绩点排名怎样？保研还是考研？</li>
<li>英语水平怎么样？</li>
<li>现在数学是不是比以前难很多？</li>
<li>反问</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/02/03/rpc-interpretation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/03/rpc-interpretation/" class="post-title-link" itemprop="url">基于 Netty 的 RPC 框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-03 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-03T00:00:00+08:00">2025-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-11 18:41:37" itemprop="dateModified" datetime="2025-05-11T18:41:37+08:00">2025-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基于-Netty-的-RPC-框架"><a href="#基于-Netty-的-RPC-框架" class="headerlink" title="基于 Netty 的 RPC 框架"></a>基于 Netty 的 RPC 框架</h1><p>实现要点： </p>
<ul>
<li>实现了 Netty <a href="#%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6">心跳机制</a>，保持连接。客户端<a href="#%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF">指数退避</a>重试连接，服务端用线程池处理请求。可选 HTTP 和 Socket。</li>
<li>实现了自定义 RPC <a href="#protocol">通信协议</a>，<a href="#codec">自定义编解码器和拆包解码器</a>解决粘包和半包，实现了 Kryo 等5种<a href="#serialization">序列化方式</a>。</li>
<li><a href="#center">注册中心</a>支持 Nacos 与 Zookeeper，服务发现支持本地缓存、实时监听。除利用健康检查机制外，下线服务还会主动通知注册中心注销，实现优雅下线。支持一致性哈希等3种<a href="#loadbalance">负载均衡</a>算法。</li>
<li>集成 SpringBoot。通过<a href="#annotation">自定义注解</a>，提供者自动扫描并注册服务 Bean，消费者自动注入<a href="#proxy">代理对象</a>。自定义 starter 实现<a href="#autoconfig">自动装配</a>。</li>
<li>参考 Dubbo 实现 <a href="#spi">SPI</a>，支持<a href="#spi1">序列化</a>、<a href="#spi2">服务发现</a>等的动态扩展，实现与类型解耦的<a href="#cache">单例缓存</a>，减少大量冗余的对象创建。</li>
</ul>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/项目架构图.png" alt="项目架构图" style="zoom:67%;" />

<p><code>consumer</code>模块：服务的消费者，依赖于 <code>rpc-client-spring-boot-starter</code> 模块；</p>
<p><code>provider-api</code>模块：服务提供者暴露的API；</p>
<p><code>provider</code>模块：服务的提供者，依赖于 <code>rpc-server-spring-boot-starter</code> 模块：</p>
<p><code>rpc-client-spring-boot</code>模块：rpc 客户端模块，封装客户端发起的请求过程，提供服务发现、动态代理，网络通信等功能；</p>
<p><code>rpc-client-spring-boot-stater</code>模块：是<code>rpc-client-spring-boot</code>的stater模块，负责引入相应依赖进行自动配置；</p>
<p><code>rpc-framework-core</code>模块：是rpc核心依赖，提供负载均衡、服务注册发现、消息协议、消息编码解码、序列化算法；</p>
<p><code>rpc-server-spring-boot</code>模块：rpc 服务端模块，负责启动服务，接受和处理RPC请求，提供服务发布、反射调用等功能；</p>
<p><code>rpc-server-spring-boot-stater</code>模块：是<code>rpc-server-spring-boot</code>的stater模块，负责引入相应依赖进行自动配置；</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/02/03/rpc-interpretation/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/24/408-OS-%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/24/408-OS-%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">并发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-24 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-24T00:00:00+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:43:28" itemprop="dateModified" datetime="2025-05-05T11:43:28+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><h2 id="Thread-A-New-Executor"><a href="#Thread-A-New-Executor" class="headerlink" title="Thread: A New Executor"></a>Thread: A New Executor</h2><h3 id="Different-from-Process"><a href="#Different-from-Process" class="headerlink" title="Different from Process"></a>Different from Process</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241221230956042.png" alt="image-20241221230956042"></p>
<p>线程和进程最大的区别是，线程之间可以共享地址空间，因此线程的上下文切换不需要切换页表，但是每个线程都有独立的执行栈，它们分散在整个地址空间中，任何有关线程执行相关的信息都存在线程的执行栈——线程本地存储(TLS, Thread Local Storage)中。</p>
<ol>
<li><strong>进程是容器</strong>：一个进程可以包含<strong>一个或多个线程</strong>。线程依赖于进程，不能独立存在。</li>
<li><strong>线程属于进程</strong>：线程是进程的一部分，所有线程共享该进程的资源，如代码段、数据段和打开的文件等。</li>
<li><strong>进程管理资源，线程执行任务</strong>：进程管理资源和环境，而线程负责实际计算和操作。</li>
</ol>
<h3 id="Why-Threads"><a href="#Why-Threads" class="headerlink" title="Why Threads?"></a>Why Threads?</h3><p>事实证明，您应该使用线程至少有两个主要原因。</p>
<p>第一个很简单：==并行性==。想象一下，您正在编写一个对非常大的数组执行操作的程序，例如，将两个大数组相加，或者将数组中每个元素的值增加一定量。如果仅在单个处理器上运行，则任务很简单：只需执行每个操作即可完成。 如果在具有多个处理器的系统上执行程序，则可以通过使用每个处理器执行一部分工作来显著加快此过程。将标准单线程程序转换为在多个 CPU 上执行此类工作的程序的任务称为并行化，并且使用每个 CPU 的线程来执行此工作是使程序运行的自然而典型的方法在现代硬件上速度更快。</p>
<p>第二个原因有点微妙：避免由于 I/O 缓慢而**==阻塞程序进度==**。想象一下，您正在编写一个执行不同类型 I/O 的程序：等待发送或接收消息、等待显式磁盘 I/O 完成，甚至（隐式）等待页面错误完成。您的程序可能不想等待，而是希望做其他事情，包括利用 CPU 执行计算，甚至发出进一步的 I/O 请求。使用线程是避免阻塞的自然方法；当程序中的一个线程等待时（即被阻塞等待 I/O），CPU 调度程序可以切换到其他线程，这些线程已准备好运行并执行一些有用的操作。线程允许 I/O 与单个程序中的其他活动重叠，就像多道程序设计对跨程序的进程所做的那样；因此，许多现代基于服务器的应用程序（Web 服务器、数据库管理系统等）在其实现中都使用了线程。</p>
<p>当然，在上述任何一种情况下，您都可以使用多个进程而不是线程。然而，**==线程共享地址空间==<strong>，因此可以轻松共享数据，因此是构建这些类型的程序时的自然选择，</strong>==线程更加轻量==**，切换成本没有那么高。对于逻辑上独立的任务来说，进程是一个更合理的选择，因为这些任务几乎不需要共享内存中的数据结构。</p>
<h3 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h3><p>一、不可控调度引发的问题：</p>
<ol>
<li>临界区(critical section): 多个任务共享的一片区域</li>
<li>竞态条件(race condition): 多个任务几乎同时读取一片区域，并做了修改，结果不符合预期</li>
<li>不确定性(indeterminate)：多个竞态条件组成程序，导致结果不确定</li>
<li>解决方案：注重原子性<ul>
<li>线程使用互斥(mutex exclusion)原语，保证同时只有一个任务进入临界区修改，避免竞态</li>
<li>原语：若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断</li>
<li>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192?fromModule=lemma_inlink">操作系统</a>中，某些被进程调用的操作，如队列操作、对信号量的操作、检查启动外设操作等，一旦开始执行，就不能被中断，否则就会出现操作错误，造成系统混乱。</li>
</ul>
</li>
</ol>
<p>二、任务之间应该如何唤醒对方？</p>
<h2 id="POSIX-Thread-API"><a href="#POSIX-Thread-API" class="headerlink" title="POSIX Thread API"></a>POSIX Thread API</h2><h3 id="Structured-“fork-join”-Parallelism"><a href="#Structured-“fork-join”-Parallelism" class="headerlink" title="Structured (“fork-join”) Parallelism"></a>Structured (“fork-join”) Parallelism</h3><h4 id="Compile-and-Run-pthread"><a href="#Compile-and-Run-pthread" class="headerlink" title="Compile and Run: -pthread"></a>Compile and Run: <code>-pthread</code></h4><p>在链接行上，您还必须通过添加 <code>-pthread</code> 标志来显式动态链接 pthreads 库。</p>
<p><code>prompt&gt; gcc -o thread thread.c -Wall -pthread</code> </p>
<p><code>prompt&gt; gcc thread.c -o thread -lpthread</code> </p>
<p>并且要在源码中加入 <code>pthread.h</code></p>
<h4 id="Creation-pthread-create"><a href="#Creation-pthread-create" class="headerlink" title="Creation: pthread_create()"></a>Creation: <code>pthread_create()</code></h4><p><code>create</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine)(<span class="type">void</span>*),</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数说明</strong>：<ul>
<li><code>thread</code> 是一个 <code>pthread_t</code> 类型的指针，也就是待初始化的线程指针</li>
<li><code>attr</code> 用来配置这个线程的属性，比如栈大小，线程调度优先级，默认可以为 <code>NULL</code></li>
<li><code>start_routine</code> 是函数指针,,前面是返回值类型，后面是参数类型及个数</li>
<li><code>void *</code> 可以代表任何类型的参数/返回值， <code>arg</code> 和 <code>start_routine</code> 参数类型一致</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; <span class="type">myarg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mythread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">myarg_t</span> *args = (<span class="type">myarg_t</span> *) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, args-&gt;a, args-&gt;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p;</span><br><span class="line">    <span class="type">myarg_t</span> args = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rc = pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, &amp;args);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只是创建一个传递两个参数的线程，并将其打包成我们自己定义的单个类型（<code>myarg t</code>）</p>
<p>线程一旦创建，就可以简单地将其参数转换为它期望的类型，从而根据需要解压参数。</p>
<p>创建线程后，您实际上拥有另一个实时的执行实体，具有自己的调用堆栈，与程序中所有当前现有线程在同一地址空间中运行。 </p>
<h4 id="Completion-pthread-join"><a href="#Completion-pthread-join" class="headerlink" title="Completion: pthread_join()"></a>Completion: <code>pthread_join()</code></h4><p><strong><code>join</code></strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **value_ptr)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数说明</strong>：<ul>
<li> <code>thread</code> 用于指定要等待哪个线程。该变量由线程创建例程初始化（当您将指向它的指针作为参数传递给 <code>pthread_create()</code> 时）；如果保留，则可以使用它等待线程终止。</li>
<li> <code>value_ptr</code> 是指向 指向期望返回值的指针 的二级指针，因为还没返回，只能传进去一个指针变量，<code>join</code>修改指针就需要传二级指针</li>
</ul>
</li>
</ul>
<p>Usage: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">int</span> a; <span class="type">int</span> b; &#125; <span class="type">myarg_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">int</span> x; <span class="type">int</span> y; &#125; <span class="type">myret_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mythread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里用的是包装函数，首字母大写，用来应对可能发生的异常</span></span><br><span class="line">    <span class="type">myret_t</span> *rvals = Malloc(<span class="keyword">sizeof</span>(<span class="type">myret_t</span>));</span><br><span class="line">    rvals-&gt;x = <span class="number">1</span>;</span><br><span class="line">    rvals-&gt;y = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) rvals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p;</span><br><span class="line">    <span class="type">myret_t</span> *rvals;</span><br><span class="line">    <span class="type">myarg_t</span> args = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line">    <span class="comment">// 这里用的是包装函数，首字母大写，用来应对可能发生的异常</span></span><br><span class="line">    Pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, &amp;args);</span><br><span class="line">    Pthread_join(p, (<span class="type">void</span> **) &amp;rvals);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;returned %d %d\n&quot;</span>, rvals-&gt;x, rvals-&gt;y);</span><br><span class="line">    <span class="built_in">free</span>(rvals);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，再次创建单个线程，并通过 <code>myarg_t</code> 结构传递几个参数。要返回值，请使用 <code>myret_t</code> 类型。一旦线程完成运行，一直在 <code>pthread_join()</code> 例程1内等待的主线程就会返回，我们可以访问从线程返回的值，即 <code>myret_t</code> 中的任何内容。 </p>
<p>关于这个例子有几点需要注意：</p>
<ol>
<li><p>首先，很多时候我们不必进行所有这些痛苦的参数打包和拆包。例如，如果我们只是创建一个不带参数的线程，则可以在创建线程时将 <code>NULL</code> 作为参数传入。类似地，如果我们不关心返回值，我们可以将 <code>NULL</code> 传递给 <code>pthread_join()</code>。</p>
</li>
<li><p>```c<br>void *mythread(void *arg) {</p>
<pre><code>long long int value = (long long int) arg;
printf(&quot;%lld\n&quot;, value);
return (void *) (value + 1);
</code></pre>
<p>}<br>int main(int argc, char *argv[]) {</p>
<pre><code>pthread_t p;
long long int rvalue;
Pthread_create(&amp;p, NULL, mythread, (void *) 100);
Pthread_join(p, (void **) &amp;rvalue);
printf(&quot;returned %lld\n&quot;, rvalue);
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   如上图，如果我们只是传递单个值（例如，`long long int`），则不必将其打包为参数。在这种情况下，我们不必将参数和返回值打包在结构体内部。  </span><br><span class="line"></span><br><span class="line">3. ```c</span><br><span class="line">   void *mythread(void *arg) &#123;</span><br><span class="line">       myarg_t *args = (myarg_t *) arg;</span><br><span class="line">       printf(&quot;%d %d\n&quot;, args-&gt;a, args-&gt;b);</span><br><span class="line">       myret_t oops; // ALLOCATED ON STACK: BAD!</span><br><span class="line">       oops.x = 1;</span><br><span class="line">       oops.y = 2;</span><br><span class="line">       return (void *) &amp;oops;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如上图，必须非常小心线程的返回值，永远不要**<u>返回指向线程栈上分配的内容的指针</u>**，因为栈随着函数返回，空间也会自动释放，<code>oops</code>返回的指针指向的是一片不确定区域。</p>
</li>
<li><p>这种 fork-join 式的多线程编程方式是较为普遍的结构化编程方法。但我们应该注意，并非所有多线程代码都使用 <code>join</code> 例程。例如，多线程 Web 服务器可能会创建多个工作线程，然后使用主线程无限期地接受请求并将它们传递给工作线程。因此，此类长期计划可能不需要加入。然而，创建线程来执行特定任务（并行）的并行程序可能会使用 <code>join</code> 来确保所有此类工作在退出或进入下一个计算阶段之前完成。</p>
</li>
</ol>
<h4 id="Mutex-lock-unlock"><a href="#Mutex-lock-unlock" class="headerlink" title="Mutex: lock() unlock()"></a>Mutex: <code>lock()</code> <code>unlock()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;  <span class="comment">// lock is here</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);  <span class="comment">// LOCK</span></span><br><span class="line">... <span class="comment">// critical section</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);<span class="comment">// UNLOCK</span></span><br></pre></td></tr></table></figure>

<p>整体结构如上，但是缺乏正确的初始化和各种细节：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;<span class="comment">// 宏，设置为默认的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rc = pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">assert(rc == <span class="number">0</span>); <span class="comment">// always check success!</span></span><br><span class="line">Pthread_mutex_lock(lock);</span><br><span class="line">...</span><br><span class="line">Pthread_mutex_unlock(lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keeps code clean; only use if exit() OK upon failure 包装</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rc = pthread_mutex_lock(mutex);</span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t)</code>: <ul>
<li><code>pthread_mutexattr_t</code>: 具体的参数设置，可以使用 <code>NULL</code> 作为缺省选项</li>
</ul>
</li>
<li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex)</code>: <ul>
<li>销毁一个已经初始化但未上锁的互斥锁是安全的。</li>
<li>使用完锁资源需要释放 (RAII 的思想) ，只能是被释放，不再被争抢，不再被需要时才可以</li>
</ul>
</li>
</ul>
<p>改进：增加适当的检测错误机制，健壮的程序需要能够应对调用失败的情况（断言）</p>
<p><strong>还有其他与锁交互的例程</strong>：</p>
<ul>
<li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex)</code> 只尝试一次，non-blocking</li>
<li><code>int pthread_mutex_timedlock(pthread_mutex_t *mutex, timespec *tsptr)</code> 尝试一段时间，如果等一段时间获取不到锁就直接返回 <code>ETIMEOUT</code> </li>
</ul>
<h4 id="Condition-Variables-wait-signal"><a href="#Condition-Variables-wait-signal" class="headerlink" title="Condition Variables: wait() signal()"></a>Condition Variables: <code>wait()</code> <code>signal()</code></h4><h5 id="Thread-Interaction"><a href="#Thread-Interaction" class="headerlink" title="Thread Interaction"></a>Thread Interaction</h5><p><code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)</code></p>
<ul>
<li>使调用的线程休眠，等待唤醒(通常是在程序中的某些内容发生更改，使某个条件发生了变化，而使得 wait 处于的 while 循环条件发生了变化)</li>
<li>您可能会注意到等待调用将 <code>mutex</code> 作为其第二个参数，而 <code>signal</code> 不需要。造成这种差异的原因是 wait 调用除了使调用线程进入睡眠状态之外，还使调用者进入睡眠状态时释放锁。<ul>
<li>进入 wait 状态就会自动 release mutex。当其他线程通过<code>pthread_cond_signal()</code>或<code>pthread_cond_broadcast</code>，把该线程唤醒，之后需要重新获取 mutex 来进行之后的操作</li>
<li>1.将线程加入等待队列 2.将线程持有的锁先释放 这两个步骤必须是原子的</li>
</ul>
</li>
<li>被唤醒之后，从<code>wait</code>返回之前，还应该重新获取锁，防止竞态条件的发生</li>
</ul>
<p><code>int pthread_cond_signal(pthread_cond_t *cond)</code> </p>
<ul>
<li>一旦条件满足，**<code>pthread_cond_signal</code>** 函数可以被用来唤醒至少一个等待该条件(ready ==0)的线程，如果有多个线程阻塞在条件变量上，它们被唤醒的顺序由调度策略决定。</li>
<li>如果没有线程在条件变量上阻塞，调用 <strong><code>pthread_cond_signal</code></strong> ==将不会有任何效果==。</li>
<li>在实际应用中，**<code>pthread_cond_signal</code>** 通常用于<strong>生产者-消费者</strong>问题，其中生产者在添加了新项目后会通知消费者线程。此外，它也用于实现读写锁，以及在两阶段提交算法中通知所有客户端即将提交事务。</li>
<li><code>pthread_cond_broadcast()</code> 用于唤醒当前全部等待的线程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">int</span> ready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合特定条件，进入睡眠</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;<span class="comment">//循环检查条件	</span></span><br><span class="line">    	pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行当条件满足时的操作</span></span><br><span class="line">    execute_task();</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************************************************/</span></span><br><span class="line"><span class="comment">// 改变条件之后，唤起正在等待的线程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_condition</span><span class="params">()</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    </span><br><span class="line">    ready = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Simple-Flags"><a href="#Simple-Flags" class="headerlink" title="Simple Flags"></a>Simple Flags</h5><p>请注意，有时很容易使用简单的标志在两个线程之间发出信号，而不是使用条件变量和关联的锁。 例如，我们可以重写上面的等待代码，使其在等待代码中看起来更像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait code:</span></span><br><span class="line"><span class="keyword">while</span> (ready == <span class="number">0</span>)</span><br><span class="line">; <span class="comment">// spin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// notify code:</span></span><br><span class="line">ready = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>永远不要这样做，原因如下</strong>:</p>
<p>首先，它在很多情况下表现不佳（长时间自旋浪费 CPU 周期）。</p>
<p>其次，容易出错。正如最近的研究表明 ，使用 FLAG 在线程之间进行同步时非常容易出错；在那项研究中，这些临时同步的使用中大约有一半是有问题的！不要偷懒；即使您认为不这样做也可以逃脱，也要使用条件变量。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul>
<li><p>Keep simple. 任何在线程之间锁定或发出信号的代码都应该尽可能简单，避免复杂的线程交互</p>
</li>
<li><p><strong>最大限度减少线程交互方式</strong>，尝试将线程交互方式的数量保持在最低限度</p>
</li>
<li><p><strong>初始化</strong>锁和条件变量 (mutex and condition variables) <code>INITIALIZER</code></p>
</li>
<li><p>始终<strong>使用条件变量</strong>在线程之间发出信号。虽然使用简单的 <strong>FLAG</strong> 通常很诱人，但不要这样做</p>
</li>
<li><p>检查函数的<strong>返回码</strong>，比如断言失败导致的返回码会异常</p>
</li>
<li><p>如何向线程传递参数以及线程的返回值。比如<strong>不要返回 指向栈上变量的指针</strong> </p>
</li>
<li><p>每个线程都有<strong>自己的栈</strong>。如果线程正在执行的某个函数内部有一个局部分配的变量，那么它本质上是该<strong>线程私有</strong>的(Thread-Local)；没有其他线程可以（轻松）访问它。要在线程之间共享数据，值必须位于<strong>堆</strong>中或其他可全局访问的区域设置中。  </p>
</li>
</ul>
<h1 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h1><p>锁——程序员在 OS 调度的基础上实现对调度的最小控制，使调度的混乱状态变得更加可控</p>
<h2 id="Efficient-Lock"><a href="#Efficient-Lock" class="headerlink" title="Efficient Lock"></a>Efficient Lock</h2><ol>
<li>最基本的互斥(<strong>mut</strong>ual <strong>ex</strong>clusion)：能否在 OS 调度下，阻止多个线程同时进入临界区？</li>
<li>公平性(fairness)：是否会有线程始终无法竞争到锁(starvation)?</li>
<li>性能(performance)：在有竞争与没有竞争的情况下，抢锁、释放锁的开支如何？</li>
</ol>
<h2 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations"></a>Implementations</h2><ul>
<li>完全由软件实现的锁（✕）</li>
<li>硬件支持有更强大的原子指令 + 操作系统调用支持（✓）</li>
</ul>
<h3 id="Control-Interrupts"><a href="#Control-Interrupts" class="headerlink" title="Control Interrupts"></a>Control Interrupts</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">	DisableInterrupts();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">	EnableInterrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁：关中断</p>
<p>释放锁：开中断</p>
<ul>
<li><p>优点：实现简单，操作系统本身可能会采用这种方式保证访问自己数据结构的原子性</p>
</li>
<li><p>缺点</p>
</li>
</ul>
<ol>
<li>性能开销大：开关中断的指令耗时较长</li>
<li>丢失中断：关中断导致一些中断没有及时被 CPU 接收</li>
<li>调度失效：恶意程序一直运行，而时钟中断被屏蔽，操作系统的抢占式调度失效</li>
</ol>
<h3 id="Spin-Locks"><a href="#Spin-Locks" class="headerlink" title="Spin Locks"></a>Spin Locks</h3><h4 id="Set-flag-after-check"><a href="#Set-flag-after-check" class="headerlink" title="Set flag after check"></a>Set flag <strong>after</strong> check</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span> <span class="type">int</span> flag; &#125; <span class="type">lock_t</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="comment">// 0 -&gt; lock is available, 1 -&gt; held</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LOCK GAIN</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (mutex-&gt;flag == <span class="number">1</span>) <span class="comment">// TEST the flag</span></span><br><span class="line">    	; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">1</span>; <span class="comment">// now SET it!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是简单的 flag 实现的，先检验 FLAG 是否为 1，如果不是就将其设置为 1，否则就自旋等待</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241222220609945.png" alt="image-20241222220609945"></p>
<p>线程1第一次检验到锁是空闲的，于是想将flag设为1，但与此同时也已耗尽时间片，切换到线程2以后线程2依然试图获取锁，结果获取成功，耗尽时间片回到线程1，线程1竟然也成功获取到了锁！</p>
<h4 id="Test-and-Set-TAS"><a href="#Test-and-Set-TAS" class="headerlink" title="Test-and-Set(TAS)"></a>Test-and-Set(<strong>TAS)</strong></h4><p>导致失败的主要原因是检验Test与赋值Set这两个操作并不是原子化的，会出现只执行一半的情况</p>
<p>因此应该改进锁的实现，使用一个硬件原语：TAS(Atomic Exchange)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">int</span> *old_ptr, <span class="type">int</span> new)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old = *old_ptr; <span class="comment">// fetch old value at old_ptr</span></span><br><span class="line">    *old_ptr = new; <span class="comment">// store ’new’ into old_ptr</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">// return the old value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">		; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>TestAndSet()</code> 是一个原子命令，功能是：获取旧值，将其设置为新值，然后返回旧值。这三个一定会在一次操作内完成。如果检测到锁被占用，就会<strong>自旋</strong>等待，一旦锁被释放，检测返回值为0的同时将其设置为1，成功获取锁，原子命令要么全部成功要么全部失败。自旋锁（spin lock）需要抢占式调度，通过时钟进行线程的中断。</p>
<h4 id="CAS-LL-SC-and-FAA"><a href="#CAS-LL-SC-and-FAA" class="headerlink" title="CAS, LL-SC and FAA"></a><strong>CAS</strong>, LL-SC and FAA</h4><p><strong>Compare-And-Swap(CAS)</strong></p>
<p>x86 中也叫 Compare-And-Exchange(cmpxchg)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> expected, <span class="type">int</span> new)</span>&#123;</span><br><span class="line">	<span class="type">int</span> actual = *ptr;</span><br><span class="line">	<span class="keyword">if</span> (actual == expected)&#123;</span><br><span class="line">		*ptr = new;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> actual;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Load-Linked, Store-Conditional(LL-SC)</strong></p>
<p>MIPS, PowerPC, Alpha, ARM 都有类似功能的指令</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Load_Linked(address): <span class="comment">// 读取某地址的值并将该地址标记为“保留地址”</span></span><br><span class="line">    value ← *address          <span class="comment">// 从地址中加载值</span></span><br><span class="line">    LL_reserved ← address      <span class="comment">// 设置保留的地址</span></span><br><span class="line">    <span class="keyword">return</span> value               <span class="comment">// 返回加载的值</span></span><br><span class="line">    </span><br><span class="line">Store_Conditional(address, value): </span><br><span class="line"><span class="comment">// 尝试将值存入地址，但前提是自 LL 设置保留后，该地址未被其他线程修改。</span></span><br><span class="line">    <span class="keyword">if</span> (LL_reserved == address) then  <span class="comment">// 检查是否仍然保留该地址</span></span><br><span class="line">        *address ← value              <span class="comment">// 将值存储到地址中</span></span><br><span class="line">        LL_reserved ← NULL            <span class="comment">// 清除保留状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>                      <span class="comment">// 存储成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>                      <span class="comment">// 存储失败</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(LL(&amp;lock-&gt;flag) == <span class="number">1</span>);  <span class="comment">// 首先加载当前值并标记保留</span></span><br><span class="line">                 ; <span class="comment">//spin-wait</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (SC(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">0</span>);  <span class="comment">// 如果存储失败，则重试</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_boolean_short_circuiting</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(LL(&amp;lock-&gt;flag) || !SC(&amp;lock-&gt;flag, <span class="number">1</span>))  </span><br><span class="line">                 ; <span class="comment">//spin-wait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>A 和 B 都执行 <strong>LL</strong>，地址相同，但状态保存在各自寄存器中。</li>
<li>假设 A 先执行 <strong>SC</strong> 并成功，硬件会==清除== B 的保留状态。</li>
<li>B 执行 <strong>SC</strong> 时发现状态无效，返回失败并进入重试。</li>
</ol>
<p><strong>Fetch-and-Add(FAA)</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FAA(address):</span><br><span class="line">    old_value = *address             <span class="comment">// 读取当前值</span></span><br><span class="line">    *address = old_value + <span class="number">1</span>         <span class="comment">// 增加指定值</span></span><br><span class="line">    <span class="keyword">return</span> old_value                 <span class="comment">// 返回旧值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> ticket;<span class="comment">//初始化为0</span></span><br><span class="line">    <span class="type">int</span> turn;<span class="comment">//初始化为0</span></span><br><span class="line">&#125; <span class="type">lock_t</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">    <span class="type">int</span> myturn = FAA(&amp;lock-&gt;ticket);</span><br><span class="line">	<span class="keyword">while</span>(lock-&gt;turn != myturn)</span><br><span class="line">		;   <span class="comment">// spin-wait	</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">    FAA(&amp;lock-&gt;turn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>每个线程通过 <strong>FAA</strong> 获取一个唯一的排队号 (<strong>myturn</strong>)。</li>
<li>当前服务号 (<strong>ticket</strong>)表示哪个线程正在被服务。</li>
<li>线程不断检查自己的排队号是否等于当前服务号，只有匹配时才能获得锁。</li>
<li>解锁时，将服务号递增，以便下一个线程继续执行。</li>
<li>特性：实现了<strong>公平性</strong>，每个线程最终都有机会被服务，类似排队机制，按照来的先后顺序排队</li>
</ol>
<h4 id="Evaluating-Spin-Locks"><a href="#Evaluating-Spin-Locks" class="headerlink" title="Evaluating Spin Locks"></a>Evaluating Spin Locks</h4><ol>
<li><strong>正确性</strong>: 能够实现最基本的互斥功能，不会被操作系统的调度影响</li>
<li><strong>公平性</strong>: 实际上并不能保证一个竞争的线程一定能够拿到锁，可能会有饥饿的现象发生</li>
<li><strong>性能</strong>: 单核性能差，只有一个执行的单位，如果一个获取锁的线程刚进入临界区就被抢占，那么直到此线程再次被调度之前，其他的等待者必须轮流自旋一整个时间片；而多核环境下，由于是各个线程物理上并行执行(parallel)，因此获取到锁的线程很快就会执行完并释放锁给别人。</li>
</ol>
<h5 id="Priority-Inversion"><a href="#Priority-Inversion" class="headerlink" title="Priority Inversion"></a>Priority Inversion</h5><p>自旋锁适合<strong>短时间的临界区操作</strong>，但不适合长时间持有锁的场景。在等待锁释放时，线程会<strong>忙等待（busy-waiting）</strong>，一直循环检查锁状态，而不会主动放弃 CPU。</p>
<p><strong>高优先级线程 A</strong>：需要自旋锁资源。</p>
<p><strong>低优先级线程 C</strong>：当前持有自旋锁资源。</p>
<p><strong>中优先级线程 B</strong>：占用 CPU 时间，导致 C 无法执行。</p>
<ol>
<li><strong>C 获得锁</strong>并进入临界区，但是此时被更高优先级的 A 抢占。</li>
<li><strong>A 尝试获取锁</strong>，但由于 C 持有锁，A 进入自旋状态忙等待。</li>
<li><strong>B 开始运行</strong>，其优先级高于 C，导致 C 仍然无法继续执行，因此也无法释放锁。</li>
<li><strong>A 等待 C 释放锁，但 C 被 B 抢占</strong> </li>
<li><strong>结果：高优先级的 A 无法执行，但是更低优先级的 B 反而能够顺利执行，优先级反转发生。</strong></li>
</ol>
<p><strong>解决方案：</strong></p>
<p><strong>(1) 优先级继承机制</strong>(Priority inheritance)</p>
<ul>
<li><strong>原理：</strong> 当低优先级线程持有锁，而高优先级线程请求锁时，系统会<strong>临时提高低优先级线程的优先级</strong>到高优先级线程的级别。</li>
<li><strong>效果：</strong> 确保低优先级线程尽快运行并释放锁，防止高优先级线程长期等待。</li>
<li><strong>应用：</strong> 常用于<strong>互斥锁 (mutex)</strong> 中，但自旋锁通常不支持该机制。</li>
</ul>
<p><strong>(2) 使用互斥锁替代自旋锁</strong></p>
<ul>
<li><strong>互斥锁会主动挂起等待线程</strong>，释放 CPU 给其他任务，提高资源调度效率。</li>
<li>适合可能存在较长等待时间的临界区操作，避免忙等待浪费资源。</li>
</ul>
<p><strong>(3) 控制自旋时间或自旋次数</strong></p>
<ul>
<li>设置自旋锁的最大等待时间或循环次数，超过后将线程挂起，而不是一直忙等待。</li>
<li>在 Linux 内核中，可通过**<code>spin_trylock()</code><strong>或</strong>自旋锁超时机制**控制。</li>
</ul>
<p><strong>(4) 避免中间优先级线程干扰，或取消优先级差异</strong></p>
<h3 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h3><h4 id="Yield"><a href="#Yield" class="headerlink" title="Yield"></a>Yield</h4><p>改进自旋锁：如果获取不到锁就立即让出 CPU (yield)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">	flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (TestAndSet(&amp;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">		yield(); <span class="comment">// give up the CPU</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">	flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>: <strong>容易受操作系统的调度影响</strong>，可能导致有线程被饿死，并且如果锁的拥有者在进入临界区之后被调度走，其他程序必须反复执行 运行-&gt;让出 的循环，上下文切换成本也不容忽视</p>
<h4 id="Queue-amp-Park-Solaris"><a href="#Queue-amp-Park-Solaris" class="headerlink" title="Queue &amp; Park(Solaris)"></a>Queue &amp; Park(Solaris)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="type">int</span> guard;</span><br><span class="line">    <span class="type">queue_t</span> *q;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line">    m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    		; <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">        m-&gt;flag = <span class="number">1</span>; <span class="comment">// lock is acquired</span></span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue_add(m-&gt;q, gettid());</span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">        park(); <span class="comment">// sleep here!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    		; <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">        m-&gt;flag = <span class="number">0</span>; <span class="comment">// let go of lock; no one wants it</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(queue_remove(m-&gt;q)); <span class="comment">// hold lock</span></span><br><span class="line">    								<span class="comment">// (for next thread!)</span></span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁外面套了一层 guard 锁，基本思想是，既然不能直接休眠，那就尽量减小自旋等待的范围，原来需要反复自旋获取 flag 锁，并且临界区是整个lock到unlock的区域，现在只需要先自旋获取 guard，临界区只需要获取锁(flag 设置为 1)或者休眠等待锁的释放(唤醒后直接返回，意为锁被上一个线程让了出来)</p>
<p><strong>加锁逻辑</strong>：</p>
<ul>
<li>自旋等待获取 <code>guard</code> </li>
<li>获取 <code>guard</code> 之后，如果 <code>flag</code> 未被占用，则直接获取 lock；</li>
<li>如果 <code>flag</code> 被占用，此时不要直接放弃，而是将自己加入等待队列中，释放 <code>guard</code>，并将自己休眠。先休眠后释放一定会造成死锁</li>
</ul>
<p><strong>释放锁逻辑</strong>：（可控调度的关键）</p>
<ul>
<li><p>自旋等待获取 <code>guard</code> </p>
</li>
<li><p>获取 <code>guard</code> 之后，如果队列为空，直接将 lock 释放，因为没有人正在等待                                                                                               </p>
</li>
<li><p><strong>如果队列不为空，唤醒队头线程，不能将 lock 释放，因为要为下一个要执行的线程保管好锁</strong></p>
</li>
<li><p>被唤醒的线程之前一直阻塞在 <code>park()</code> ，被唤醒之后依然符合 <code>flag == 1</code> 的条件，直接返回，进入临界区。</p>
<ul>
<li><p><code>wakeup race</code>: 如果在 <code>park()</code> 之前切换到了另一个线程（例如，持有锁的线程）可能会导致麻烦，例如，如果该线程随后释放了锁，就会试图唤醒队头线程并FIFO，但是此时线程并没有处于休眠状态，因此唤醒信号丢失，这个线程将永远挂起</p>
</li>
<li><p><strong>解决方案</strong>：Solaris 通过添加第三个系统调用来解决此问题：<code>setpark()</code> 通过调用此例程，线程A可以指示它即将停止(about to park)。如果A随后恰好被中断，并且另一个线程B在A实际调用 park 之前调用了 unpark，则后续 park 会立即返回而不是 sleep</p>
</li>
<li><p>```c<br>void lock(lock_t *m) {</p>
<pre><code>while (TestAndSet(&amp;m-&gt;guard, 1) == 1)
        ; //acquire guard lock by spinning
if (m-&gt;flag == 0) &#123;
    m-&gt;flag = 1; // lock is acquired
    m-&gt;guard = 0;
&#125; else &#123;
    queue_add(m-&gt;q, gettid());
    setpark(); // be about to sleep, ready to receive SIGWAKEUP
    m-&gt;guard = 0; // release guard
    park(); // return immediately if received SIGWAKEUP
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 最后返回之前将 `guard` 释放</span><br><span class="line"></span><br><span class="line">也可以将 guard 放入内核中，这样就能保持原子的释放</span><br><span class="line"></span><br><span class="line">#### **Futex**(Linux)</span><br><span class="line"></span><br><span class="line">Linux 提供了一个类似于 Solaris 接口的 futex(**F**ast **U**serspace mu**TEX**)，但提供更多 in-kernel 功能。具体来说，每个 futex 与特定的物理内存位置以及每个 futex 内核队列相关联（**SLAB Allocator**）</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">void mutex_lock (int *mutex) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    // Bit 31 was clear(0), we got the mutex (fastpath, no SYSCALL)</span><br><span class="line">    // Set bit 31 to 1, variable mutex is negative now </span><br><span class="line">    if (atomic_bit_test_set (mutex, 31) == 0)</span><br><span class="line">    	return;</span><br><span class="line">    // Not free </span><br><span class="line">    atomic_increment (mutex);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // If bit 31 is still 0, there is no contention, acquire the mutex</span><br><span class="line">        if (atomic_bit_test_set (mutex, 31) == 0) &#123;</span><br><span class="line">            atomic_decrement (mutex);</span><br><span class="line">            return;</span><br><span class="line">    	&#125; </span><br><span class="line">        /* </span><br><span class="line">        	First to make sure futex value</span><br><span class="line">        	we are monitoring is negative (locked).</span><br><span class="line">        */ </span><br><span class="line">        v = *mutex;</span><br><span class="line">        if (v &gt;= 0)</span><br><span class="line">            continue;</span><br><span class="line">        futex_wait (mutex, v);// immediately return if v!= *mutex</span><br><span class="line"> 							  // otherwise sleep	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mutex_unlock (int *mutex) &#123;</span><br><span class="line">    /* Adding 0x80000000 to counter results in 0 if and</span><br><span class="line">       only if there are not other interested threads </span><br><span class="line">       returns (new_mutex == 0)*/</span><br><span class="line">    if (atomic_add_zero (mutex, 0x80000000))</span><br><span class="line">    	return;</span><br><span class="line"></span><br><span class="line">    // There are other threads waiting for this mutex,</span><br><span class="line">    // wake one of them up.</span><br><span class="line">    futex_wake (mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>它使用单个整数来跟踪锁是否被持有（整数最高位）以及锁上的等待者数量（所有其他位）。 如果整数为负，则保持该锁定（因为设置了高位，并且该位确定整数的符号）</p>
<p>加锁：</p>
<ol>
<li>整数的最高位用来标记锁是否被占用，其余位用来标记等待者数量</li>
<li>如果获取锁失败，说明锁被占用，则低位自增，等待者 + 1</li>
<li>随后再次尝试获取锁（spin for one time，Phase 1）<ul>
<li>如果成功，则低位自减，等待者 - 1</li>
<li>如果失败，即将进入下个阶段(Phase 2)</li>
</ul>
</li>
<li>再次检查锁的状态（避免竞态条件，如果在这期间锁被释放就应该重新尝试获取锁）</li>
</ol>
<p>解锁：</p>
<ol>
<li>检测低位等待者的同时，清除最高位，如果结果不为0，则返回false</li>
<li>false，唤醒等待的线程</li>
</ol>
</blockquote>
<blockquote>
<p><strong>Function Signature</strong>: <code>int futex_wait(int *uaddr, int val)</code></p>
<p><strong>Purpose</strong>: If the <strong>futex word</strong> equals to <strong>val</strong>, the thread is put to sleep. The thread remains asleep until another thread calls <code>futex_wake</code> on the same futex word, signaling that the condition has changed.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>uaddr</code>: Pointer to the futex word in user space.</li>
<li><code>val</code>: The expected value of the futex word.</li>
</ul>
<p><strong>Return Value</strong>: Returns 0 on success, or an error code on failure.</p>
</blockquote>
<blockquote>
<p><strong>Function Signature</strong>: <code>int futex_wake(int *uaddr, int val)</code></p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>uaddr</code>: Pointer to the futex word in user space.</li>
<li><code>val</code>: The number of threads to wake up.</li>
</ul>
<p><strong>Return Value</strong>: Returns the number of threads that were woken up, or an error code on failure.</p>
</blockquote>
<blockquote>
<p><strong>Function Signature</strong>: <code>int atomic_bit_test_set(int *ptr, int bit)</code></p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>ptr</code>: Pointer to the integer variable.</li>
<li><code>bit</code>: The bit position to be tested and set.</li>
</ul>
<p><strong>Return Value</strong>: Returns the previous value of the bit (0 or 1).</p>
</blockquote>
<blockquote>
<p><strong>Function Signature</strong>: <code>bool atomic_add_zero(int *ptr, int value)</code></p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>ptr</code>: Pointer to the integer variable.</li>
<li><code>value</code>: Value to be added.</li>
</ul>
<p><strong>Return Value</strong>: Returns <code>true</code> if the result is zero, otherwise <code>false</code>.</p>
</blockquote>
<p>一般来说，内核态同步机制需要调用系统调用，来确保只有一个线程能进入互斥区，但如果根本没有竞争对象，则系统调用浪费了性能。</p>
<p>Futex 是一种用户态和内核态混合的同步机制。首先，同步的进程间通过 mmap <strong>共享一段内存</strong>，futex 变量就位于这段共享的内存中，且操作是原子的，当进程尝试进入互斥区<code>lock()</code>或者退出互斥区<code>unlock()</code>的时候，先去查看共享内存中的 futex 变量，如果没有竞争发生，则只修改 futex，而不用再执行系统调用了。当通过访问 futex 变量告诉进程有竞争发生，则还是得执行系统调用去完成相应的处理（<code>wait</code> 或者 <code>wake</code>）</p>
<p>简单的说，futex 就是通过在用户态的检查，如果了解到当前没有竞争就不用陷入内核了，大大提高了低竞争情况下的效率。</p>
<p>假设地址处的值等于预期，对 <code>futex_wait(address,expected) </code>的调用将使调用线程进入睡眠状态。如果不相等，则调用立即返回。对例程 <code>futex_wake(address)</code> 的调用会唤醒正在队列中等待的一个线程。</p>
<ol>
<li><p>Futex 变量的特征：</p>
<p>1）位于共享的用户空间中；</p>
<p>2）是一个32位的整型；</p>
<p>3）对它的操作是原子的。</p>
</li>
<li><p>Futex 在程序 low-contention 的时候能获得比传统同步机制更好的性能。</p>
</li>
<li><p>不要直接使用 Futex 系统调用。</p>
</li>
<li><p>Futex 同步机制可以用于进程间同步，也可以用于线程间同步。</p>
</li>
</ol>
<h5 id="Two-Phase-Locks"><a href="#Two-Phase-Locks" class="headerlink" title="Two-Phase Locks"></a>Two-Phase Locks</h5><p>两阶段锁中，自旋被看作可能很有用，特别是在锁即将被释放的情况下。在 Phase 1，会自旋一段时间，希望能够获取到锁。 如果在 Phase 1 没有获取锁，则进入 Phase 2，调用者将进入睡眠状态，只有在锁稍后释放时才会被唤醒。</p>
<p>上面的 Linux Futex 实现的 Mutex 就是这种锁的一种形式，但它只<strong>自旋一次</strong>；更常见的是在循环中自旋固定的（fixed）次数</p>
<h2 id="Thread-Safe-Data-Structures"><a href="#Thread-Safe-Data-Structures" class="headerlink" title="Thread-Safe Data Structures"></a>Thread-Safe Data Structures</h2><h3 id="Concurrent-Counter"><a href="#Concurrent-Counter" class="headerlink" title="Concurrent Counter"></a>Concurrent Counter</h3><p><strong>Basic Mutex</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241224125018845.png" alt="image-20241224125018845"></p>
<p>简单给访问临界区加锁完全能够保证绝对的线程安全(thread safe)，但是锁的开销非常大</p>
<p><strong>Scalable Counting</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241224134929698.png" alt="image-20241224134929698"></p>
<p>近似计数器：每个CPU有一个局部计数器(local)，所有CPU共享一个全局计数器(global)，局部计数器加到全局计数器上的时候才加给全局计数器加锁，这就显著减少了加锁解锁的次数。</p>
<p>另外，局部锁也是需要的，因为我们假设每个核心上可能有多个线程。相反，如果每个核心上仅运行一个线程，则不需要局部所锁。</p>
<p>为了使全局计数器保持最新（如果线程希望读取其值），通过获取全局锁并将其增加局部计数器的值，局部值会定期传输到全局计数器；然后局部计数器归零。 这种局部到全局传输发生的频率由阈值 S 决定，当局部计数器达到 S 就向全局计数器写入。S 越小，计数器的行为就越像上面的不可扩展计数器； S 越大，计数器的可扩展性就越高，但全局值可能与实际计数相差越远。人们可以简单地获取所有局部锁和全局锁（以指定的顺序，以避免死锁）来获得精确的值，但这是不可扩展的：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241224135017601.png" alt="image-20241224135017601"></p>
<p>图 29.6 显示了阈值 S 的重要性，其中有四个线程，每个线程在四个 CPU 上将计数器递增 100 万次。如果 S 较低，则性能较差（但全局计数总是相当准确）； 如果 S 较高，则性能出色，但全局计数滞后（最多为 CPU 数量乘以 S）。这种准确性/性能权衡正是近似计数器所实现的。</p>
<h3 id="Concurrent-Linked-List"><a href="#Concurrent-Linked-List" class="headerlink" title="Concurrent Linked List"></a>Concurrent Linked List</h3><p><strong>Basic Mutex</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic list structure (one used per list)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">list_t</span> &#123;</span><span class="type">node_t</span> *head; <span class="type">pthread_mutex_t</span> lock;&#125; <span class="type">list_t</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">List_Insert</span><span class="params">(<span class="type">list_t</span> *L, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">node_t</span> *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (new == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// fail</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    new-&gt;key = key;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);  <span class="comment">// lock</span></span><br><span class="line">    new-&gt;next = L-&gt;head;</span><br><span class="line">    L-&gt;head = new;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);<span class="comment">// unlock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">List_Lookup</span><span class="params">(<span class="type">list_t</span> *L, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rv = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="type">node_t</span> *curr = L-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;key == key) &#123;</span><br><span class="line">            rv = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock); <span class="comment">// failure</span></span><br><span class="line">	<span class="keyword">return</span> rv; <span class="comment">// rv = -1: </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>尽量缩小锁涵盖的范围（临界区大小）如果没有涉及到访问共享区域的就不要纳入范围</li>
<li>使用单一返回路径，减少代码中需要获取、释放锁的地方，降低了返回前忘记释放锁的可能</li>
</ul>
<p><strong>Lock and Control flow</strong>：</p>
<p>在并发编程中，函数通常在开始时获取锁或分配资源、更改状态。如果发生错误，函数必须在退出之前释放锁或释放资源。这个过程很容易出错，因为它需要仔细管理状态。为了避免这些问题，最好以一种尽量<strong>减少撤消状态更改</strong>的方式构建代码。这可以通过以下方式实现：</p>
<ul>
<li><strong>集中错误处理</strong>：谨慎处理导致函数返回、退出或其他停止执行的错误情况的更改，在函数中使用单个退出点来处理所有清理操作。 </li>
<li><strong>最小化模式</strong>：构造代码以尽量减少撤消状态更改的需要，从而降低出错风险。</li>
<li><strong>避免过早返回</strong>：减少函数中的返回语句数量，以确保执行所有必要的清理。 </li>
<li><strong>使用 RAII（资源获取即初始化）</strong>：在支持它的语言中，使用 RAII 自动管理资源。 </li>
</ul>
<p><strong>Hand-over-hand Locking</strong>: </p>
<p>每个节点都有一个锁，替代之前链表的整个链表一个锁，遍历链表时首先抢占下一个节点的锁，然后释放当前节点的锁，一定程度上增加了链表的并发能力，但是开销很大，</p>
<h3 id="Concurrent-Queue"><a href="#Concurrent-Queue" class="headerlink" title="Concurrent Queue"></a>Concurrent Queue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">queue_t</span> &#123;</span></span><br><span class="line">	<span class="type">node_t</span> *head; <span class="type">node_t</span> *tail; </span><br><span class="line">    <span class="type">pthread_mutex_t</span> head_lock, tail_lock;</span><br><span class="line">&#125;<span class="type">queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue_Init</span><span class="params">(<span class="type">queue_t</span> *q)</span> &#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;head = q-&gt;tail = tmp;</span><br><span class="line">    pthread_mutex_init(&amp;q-&gt;head_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;q-&gt;tail_lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue_Enqueue</span><span class="params">(<span class="type">queue_t</span> *q, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(tmp != <span class="literal">NULL</span>);</span><br><span class="line">    tmp-&gt;value = value;</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;tail_lock);<span class="comment">//在队尾加锁</span></span><br><span class="line">    q-&gt;tail-&gt;next = tmp;</span><br><span class="line">    q-&gt;tail = tmp;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;tail_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Queue_Dequeue</span><span class="params">(<span class="type">queue_t</span> *q, <span class="type">int</span> *value)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;head_lock);</span><br><span class="line">    <span class="type">node_t</span> *tmp = q-&gt;head;</span><br><span class="line">    <span class="type">node_t</span> *new_head = tmp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (new_head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;q-&gt;head_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// queue was empty</span></span><br><span class="line">    &#125;</span><br><span class="line">    *value = new_head-&gt;value;</span><br><span class="line">    q-&gt;head = new_head;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;head_lock);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列的加锁特点：</p>
<ul>
<li><p>入队只访问 <code>tail_lock</code> 出队只访问 <code>head_lock</code></p>
</li>
<li><p>在初始化阶段添加了 dummy node 假节点，不然空队列的情况需要同时处理 tail 和 head：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Queue_Enqueue</span><span class="params">(<span class="type">queue_t</span> *q, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(tmp != <span class="literal">NULL</span>);</span><br><span class="line">    tmp-&gt;value = value;</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;tail_lock);</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;tail == <span class="literal">NULL</span>) &#123;<span class="comment">// additional if-else!!!</span></span><br><span class="line">        q-&gt;head = q-&gt;tail = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;tail-&gt;next = tmp;</span><br><span class="line">        q-&gt;tail = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;tail_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Queue_Dequeue</span><span class="params">(<span class="type">queue_t</span> *q, <span class="type">int</span> *value)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;head_lock);</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;head == <span class="literal">NULL</span>) &#123;<span class="comment">// additional if-else!!!</span></span><br><span class="line">        pthread_mutex_unlock(&amp;q-&gt;head_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// queue was empty</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">node_t</span> *tmp = q-&gt;head;</span><br><span class="line">    <span class="type">node_t</span> *new_head = tmp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (new_head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;q-&gt;head_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// queue was empty</span></span><br><span class="line">    &#125;</span><br><span class="line">    *value = new_head-&gt;value;</span><br><span class="line">    q-&gt;head = new_head;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;head_lock);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Concurrent-Hash-Table"><a href="#Concurrent-Hash-Table" class="headerlink" title="Concurrent Hash Table"></a>Concurrent Hash Table</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUCKETS (101)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span> &#123;</span><span class="type">list_t</span> lists[BUCKETS];&#125; <span class="type">hash_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hash_Init</span><span class="params">(<span class="type">hash_t</span> *H)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUCKETS; i++)</span><br><span class="line">    	List_Init(&amp;H-&gt;lists[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash_Insert</span><span class="params">(<span class="type">hash_t</span> *H, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> List_Insert(&amp;H-&gt;lists[key % BUCKETS], key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash_Lookup</span><span class="params">(<span class="type">hash_t</span> *H, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> List_Lookup(&amp;H-&gt;lists[key % BUCKETS], key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241224205440775.png" alt="image-20241224205440775"></p>
<p>如图所示，哈希表中，每个桶都是一个单独的链表，因此，比单独的大锁并发链表性能好很多。</p>
<h1 id="Condition-Variables"><a href="#Condition-Variables" class="headerlink" title="Condition Variables"></a>Condition Variables</h1><p>任何线程库的另一个主要组件是条件变量，主要用于线程间交互。</p>
<p>概念上，一个条件变量就是一个线程队列(thread queue)， 其中的线程正等待某个条件变为真，比如 <code>ready == 0</code>，每个条件变量$c$关联着一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)">断言</a>，当一个线程等待时，该线程不算作占用了该管程，因而其它线程可以进入该管程执行，改变管程的状态，通知条件变量$c$其关联的断言$P_c$在当前状态下为真。</p>
<p>条件变量同锁一起使用使得线程可以以一种**<u>无竞争</u>**的方式等待任意条件的发生。所谓无竞争就是，条件改变之后这个信号会发送到所有等待这个信号的线程。而不是说一个线程接受到这个消息而其它线程就接收不到了。</p>
<h2 id="Precautions"><a href="#Precautions" class="headerlink" title="Precautions"></a>Precautions</h2><h3 id="“Wakeup”"><a href="#“Wakeup”" class="headerlink" title="“Wakeup”"></a>“Wakeup”</h3><p>线程状态:Ready, Run, Sleep</p>
<p><code>wait</code>: Run-&gt;Sleep</p>
<p><code>signal</code>: Sleep-&gt;Ready </p>
<h3 id="Specific-Condition"><a href="#Specific-Condition" class="headerlink" title="Specific Condition"></a>Specific Condition</h3><p>条件变量必须跟布尔条件挂钩，如果只是单纯地地像下面这样使用条件变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">thr_exit()&#123;</span><br><span class="line">	<span class="comment">// done = 1;</span></span><br><span class="line">	mutex_lock(&amp;m);</span><br><span class="line">	cond_signal(&amp;c);</span><br><span class="line">	mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line">thr_join()&#123;</span><br><span class="line">	mutex_lock(&amp;m);</span><br><span class="line">	<span class="comment">//while(done == 0)</span></span><br><span class="line">	cond_wait(&amp;c);</span><br><span class="line">	mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在父线程调用join之前，子线程创建并运行了exit，就会导致空唤醒，父线程将持续睡下去。</p>
<h3 id="Recheck-While-Loop"><a href="#Recheck-While-Loop" class="headerlink" title="Recheck: While Loop"></a>Recheck: <strong>While</strong> Loop</h3><h4 id="Mesa-Semantic"><a href="#Mesa-Semantic" class="headerlink" title="Mesa Semantic"></a>Mesa Semantic</h4><p>发信号只是一个状态改变的暗示，并不能保证他运行之前的状态一直是期望的情况，线程的 Ready 和 Run 之间的状态转换是由调度程序决定的，<code>signal</code> 以后，Run 之前可能状态会发生变化。</p>
<p>另一个是Hoare Semantic 能直接唤醒线程立即执行，几乎所有系统都采用了前者的语义。</p>
<h4 id="Lost-Wakeup"><a href="#Lost-Wakeup" class="headerlink" title="Lost Wakeup"></a>Lost Wakeup</h4><p>条件变量代表的是一种条件，需要将 <code>pthread_cond_wait</code> 放在一个 while 循环，而不是 if 语句中，因为很可能会出现在wait之前正好切换走了，这时候signal信号就会丢失。所以线程被唤醒后必须重新检查当时的条件是否仍然满足，如若仍然满足 while 循环的条件，就不能继续执行。</p>
<p>假设线程 A 和线程 B 都在等待同一个条件变量，并且导致线程休眠的条件布尔值最初为 <code>false</code>：</p>
<ol>
<li>线程 A 进入等待状态：<ul>
<li><code>pthread_cond_wait(&amp;cond, &amp;mutex)</code> </li>
</ul>
</li>
<li>线程 B 也进入等待状态；</li>
<li>某个线程 C 修改了条件布尔值为 <code>true</code>，并通过条件变量发送信号唤醒线程：<ul>
<li><code>pthread_cond_signal(&amp;cond)</code>。</li>
</ul>
</li>
<li>线程 A 被唤醒，并退出等待。此时它执行任务后将条件变量重新置为 <code>false</code>。</li>
<li><strong>问题：</strong> 线程 B 也被唤醒，但条件变量已被线程 A 改回 <code>false</code>。<ul>
<li>如果使用 <code>if</code> 检查条件，线程 B 会直接跳过检查并继续执行任务，从而导致程序逻辑错误。</li>
</ul>
</li>
</ol>
<p><strong>解决方案：用 <code>while</code> 再次检查条件</strong>：</p>
<ul>
<li>当线程 B 被唤醒时，<code>while</code> 循环会再次检查条件变量，发现条件未满足，然后重新进入等待状态，确保安全。</li>
</ul>
<h4 id="Spurious-Wakeup"><a href="#Spurious-Wakeup" class="headerlink" title="Spurious Wakeup"></a>Spurious Wakeup</h4><p>有一些 pthread 实现可能会<strong>虚假地唤醒</strong>多个正在等待的线程；在这种情况下，在不重新检查的情况下，等待线程将继续认为条件已更改，即使它没有更改。因此，应该树立起一个恒等式:</p>
<p>被唤醒⇔条件确实已经改变</p>
<h3 id="Hold-the-Lock-When-signal-or-wait"><a href="#Hold-the-Lock-When-signal-or-wait" class="headerlink" title="Hold the Lock When signal() or wait()"></a>Hold the Lock When <code>signal()</code> or <code>wait()</code></h3><p> ==使用条件变量的前提是必须要持有这把锁== </p>
<p><strong>想象一下</strong>：一个线程是某个队列的消费者，它必须要等到队列中有数据时才能执行，如果队列为空，则会一直等待挂起，直到另外一个线程在队列中存入数据，并<strong>通知</strong>先前挂起的线程，该线程才会唤醒重新开始执行。在这个例子中，队列是否 空/满 是线程执行所依赖的状态，而这个状态是多个线程都可以访问的，所以需要加锁互斥访问，这种加锁模式与其他同步加锁略有不同：</p>
<p>锁在 <code>wait</code> 调用中，休眠前需要释放锁，唤醒之后，返回之前需要重新获取锁</p>
<h3 id="Covering-Conditions-broadcast"><a href="#Covering-Conditions-broadcast" class="headerlink" title="Covering Conditions: broadcast()"></a>Covering Conditions: <code>broadcast()</code></h3><p>考虑分配内存的场景：</p>
<ol>
<li>有多个想要申请不同空间的线程，但是此时没有足够空间，因此他们陷入了睡眠；</li>
<li>此时第三个线程释放了一定的空间，想要唤醒，但唤醒哪一个是不确定的，可能释放的空间不足以支持被唤醒者申请的空间；</li>
<li>因此需要唤醒所有在此CV上等待的线程：<code>broadcast()</code></li>
</ol>
<h2 id="Producer-Consumer-Problem"><a href="#Producer-Consumer-Problem" class="headerlink" title="Producer/Consumer Problem"></a>Producer/Consumer Problem</h2><p>生产者/消费者问题 或 有界缓冲区问题：</p>
<ul>
<li>生产者：从缓冲区中拿东西，如果没东西可拿就应该阻塞</li>
<li>消费者：向缓冲区中放东西，如果缓冲区满了就应当阻塞</li>
</ul>
<p>因此要注意如下事项：</p>
<ol>
<li>不能唤醒同类：生产者和消费者应该使用两个不同的条件变量</li>
<li>while 循环：重新检查条件，以防在 Run 之前，条件发生改变</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 8</span></span><br><span class="line"><span class="type">int</span> buffer[MAXSIZE];</span><br><span class="line"><span class="type">int</span> fill_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> use_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">	fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = buffer[use_ptr];</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">cond_t</span> isEmpty,isFull;</span><br><span class="line"><span class="type">mutex_t</span> mutex;</span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == MAXSIZE)</span><br><span class="line">            cond_wait(&amp;isFull, &amp;mutex);</span><br><span class="line">    	put(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;producer:%d puts value:%d&quot;</span>, gettid(), i);</span><br><span class="line">        cond_signal((&amp;isEmpty);</span><br><span class="line">    	mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> consumer()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">            cond_wait(&amp;isEmpty, &amp;mutex);</span><br><span class="line">        <span class="type">int</span> value = get();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid:%d gets value:%d&quot;</span>, gettid(), value);</span><br><span class="line">        cond_signal(&amp;isFull);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h1><p><strong>互斥</strong>：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 </p>
<p><strong>同步</strong>：指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</p>
<p>Semaphore <strong>支持跨进程的同步</strong>，是线程同步所有工作的单一原语，能够将其作为锁或条件变量</p>
<p>Condition Variable 只支持同一进程内部线程的同步</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>信号量（Semaphore）</th>
<th>锁（Mutex）</th>
<th>条件变量（Condition Variable）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>功能</strong></td>
<td>控制资源数量（同步和互斥）</td>
<td>提供互斥访问</td>
<td>等待特定条件满足后继续执行</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>资源控制、多线程队列</td>
<td>保护临界区，单资源互斥</td>
<td>条件等待（生产者/消费者问题）</td>
</tr>
<tr>
<td><strong>能否跨进程</strong></td>
<td><strong>支持跨进程</strong></td>
<td>仅限线程同步（同一进程内）</td>
<td>仅限线程同步（同一进程内）</td>
</tr>
<tr>
<td><strong>是否需要互斥锁</strong></td>
<td><strong>不需要互斥锁</strong></td>
<td>自带互斥功能，不需要额外锁</td>
<td>必须依赖互斥锁来保护共享变量</td>
</tr>
<tr>
<td><strong>复杂条件判断</strong></td>
<td><strong>支持简单条件</strong>（通过计数控制）</td>
<td><strong>不支持条件判断</strong></td>
<td><strong>支持复杂条件</strong>判断和线程等待唤醒机制</td>
</tr>
</tbody></table>
<h2 id="POSIX-API"><a href="#POSIX-API" class="headerlink" title="POSIX API"></a>POSIX API</h2><p>POSIX API 给信号量添加了两个调用，这两个调用都是原子操作：</p>
<h3 id="sem-wait-sem-t-s-P"><a href="#sem-wait-sem-t-s-P" class="headerlink" title="sem_wait(sem_t *s)(P())"></a><code>sem_wait(sem_t *s)</code>(<code>P()</code>)</h3><p>信号量值减1，若变为负数，则阻塞在信号量上（信号量负数绝对值为阻塞的线程数量）</p>
<h3 id="sem-post-sem-t-s-V"><a href="#sem-post-sem-t-s-V" class="headerlink" title="sem_post(sem_t *s)(V())"></a><code>sem_post(sem_t *s)</code>(<code>V()</code>)</h3><p>将信号量的值加1，如果信号量值为负数，则肯定有线程正在此信号量上等待，唤醒其中一个线程</p>
<h2 id="Binary-Semaphores-Locks"><a href="#Binary-Semaphores-Locks" class="headerlink" title="Binary Semaphores: Locks"></a>Binary Semaphores: Locks</h2><p><strong>Workflow</strong>:</p>
<ol>
<li>信号量的初始值为 1，线程 A 调用 <code>sem_wait(*s)</code> 此时信号量为 0，直接返回，进入临界区</li>
<li>此时另一个线程 B 过来调用 <code>sem_wait(*s)</code> 此时信号量为 -1，休眠……</li>
<li>线程 A 完成临界区操作，调用 <code>sem_post(*s)</code> 此时信号量变成 0，唤醒线程 B </li>
<li>线程 B 从 <code>wait()</code> 返回，进入临界区</li>
</ol>
<p>因此二值信号量能够实现锁的功能。</p>
<h2 id="Semaphores-Condition-Variables"><a href="#Semaphores-Condition-Variables" class="headerlink" title="Semaphores: Condition Variables"></a>Semaphores: Condition Variables</h2><blockquote>
<p>给信号量设置初始值：在初始化之后愿意立即放弃的资源数量有多少？</p>
<ul>
<li><p>如果是锁，只有 1 把锁，那么就必须初始化为 1；</p>
</li>
<li><p>如果是用作任务排序，父进程等待子进程，没有能给出去的东西，那就只能初始化为 0</p>
</li>
<li><p>如果是消费者，一开始没有可以消费的东西，那就初始化为0；</p>
</li>
<li><p>如果是生产者，一开始可供生产的空间有MAXSIZE个，那就初始化为MAXSIZE。</p>
</li>
</ul>
</blockquote>
<h3 id="Mutex-Needed"><a href="#Mutex-Needed" class="headerlink" title="Mutex Needed"></a>Mutex Needed</h3><p>相当于将之前的 <code>count</code> 整合进条件变量中：</p>
<ul>
<li><code>sem_init(&amp;empty,0,MAXSIZE)</code> 空闲区域的大小为 MAXSIZE</li>
<li><code>sem_init(&amp;full,0,0)</code> 可消费区域大小为 0</li>
</ul>
<p><strong>Usage</strong>: </p>
<ul>
<li>生产者调用 <code>sem_wait(&amp;empty)</code> empty 自减，若为负数则生产者只能阻塞等待</li>
</ul>
<ul>
<li>消费者调用 <code>sem_wait(&amp;full)</code> full 自减，为负数则消费者需要阻塞等待</li>
</ul>
<ul>
<li><p>生产者操作完临界区， <code>sem_post(&amp;full)</code> 使 full 自增，某个消费者被唤醒并进入临界区</p>
</li>
<li><p>消费者操作完临界区， <code>sem_post(&amp;empty)</code> 使 empty 自增，某个生产者被唤醒并进入临界区</p>
</li>
</ul>
<p>这里没有锁，因此会出现并发问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        sem_wait(&amp;mutex); <span class="comment">// Line P0 (NEW LINE) 加锁</span></span><br><span class="line">        sem_wait(&amp;empty); <span class="comment">// Line P1</span></span><br><span class="line">        put(i); <span class="comment">// Line P2</span></span><br><span class="line">        sem_post(&amp;full); <span class="comment">// Line P3</span></span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// Line P4 (NEW LINE) 解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        sem_wait(&amp;mutex); <span class="comment">// Line C0 (NEW LINE) 加锁 </span></span><br><span class="line">        sem_wait(&amp;full); <span class="comment">// Line C1</span></span><br><span class="line">        <span class="type">int</span> tmp = get(); <span class="comment">// Line C2</span></span><br><span class="line">        sem_post(&amp;empty); <span class="comment">// Line C3</span></span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// Line C4 (NEW LINE) 解锁</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h3><p>生产者加锁，进入临界区之前，调用empty发现缓冲区已满，遂休眠，此时生产者依然持有锁</p>
<p>切换到就绪的消费者，因为获取不到锁，只能休眠，这样就导致了死锁，因此需要缩小锁的范围:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        sem_wait(&amp;full); <span class="comment">// Line C1</span></span><br><span class="line">        sem_wait(&amp;mutex); <span class="comment">// Line C1.5 (NEW LINE) 加锁 </span></span><br><span class="line">        <span class="type">int</span> tmp = get(); <span class="comment">// Line C2</span></span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// Line C2.5 (NEW LINE) 解锁</span></span><br><span class="line">        sem_post(&amp;empty); <span class="comment">// Line C3</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最根本的区别在于，睡眠的线程不会释放锁，因此条件变量应该加到锁的外面</p>
<h2 id="Mutex-CV-amp-Semaphore"><a href="#Mutex-CV-amp-Semaphore" class="headerlink" title="Mutex + CV &amp; Semaphore"></a><code>Mutex + CV</code> &amp; <code>Semaphore</code></h2><table>
<thead>
<tr>
<th>特性</th>
<th>Mutex + Condition Variable</th>
<th>Semaphore</th>
</tr>
</thead>
<tbody><tr>
<td><strong>设计理念</strong></td>
<td>提供更高层次的<strong>条件等待机制</strong>，依赖互斥锁管理共享数据状态。</td>
<td>基于简单的<strong>计数器模型</strong>，直接控制资源可用数量。</td>
</tr>
<tr>
<td><strong>同步功能</strong></td>
<td>适合复杂条件等待或<strong>事件驱动</strong>的同步场景（例如生产者-消费者模型）。</td>
<td>控制固定数量的资源访问或线程数量（例如资源池管理）。</td>
</tr>
<tr>
<td><strong>互斥功能</strong></td>
<td>需要显式的 <code>Mutex</code> 实现互斥保护。</td>
<td>内部实现互斥，无需额外的互斥锁。</td>
</tr>
<tr>
<td><strong>跨进程支持</strong></td>
<td>仅支持线程级同步（同一进程内线程同步）。</td>
<td>支持跨进程和线程同步（POSIX 信号量支持跨进程）。</td>
</tr>
<tr>
<td><strong>复杂性</strong></td>
<td>支持复杂条件判断，但需要手动管理条件和唤醒逻辑。</td>
<td>简单直观，直接基于计数器操作，不需要条件管理。</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>条件变量需要多步操作（加锁、解锁、条件检查、等待），效率略低。</td>
<td>基于计数器原子操作，性能较高，适合高并发场景。</td>
</tr>
<tr>
<td><strong>复杂条件处理</strong></td>
<td>支持复杂条件和多条件组合判断，适合生产者-消费者问题。</td>
<td>只能处理简单的资源计数条件，不适合复杂条件判断。</td>
</tr>
</tbody></table>
<h3 id="Mutex-Condition-Variable"><a href="#Mutex-Condition-Variable" class="headerlink" title="Mutex + Condition Variable"></a>Mutex + Condition Variable</h3><ol>
<li><strong>互斥锁（Mutex）：</strong><ul>
<li>提供临界区保护，确保线程在访问共享资源时互斥执行。</li>
<li>底层依赖于操作系统内核的<strong>互斥量数据结构</strong>（如 Linux 的 Futex 或信号量实现）。</li>
</ul>
</li>
<li><strong>条件变量（Condition Variable）：</strong><ul>
<li>条件变量不会保存条件状态，而是通过线程阻塞和唤醒机制等待条件变化。</li>
<li>必须与互斥锁配合使用，防止条件检查过程中出现竞争条件。</li>
</ul>
</li>
</ol>
<ul>
<li>条件变量使用<strong>等待队列（Wait Queue）</strong>机制管理线程。</li>
<li>当线程调用<code>pthread_cond_wait</code>，它会：<ol>
<li>释放锁（解锁 mutex）。</li>
<li>将线程放入条件变量的等待队列中，并进入<strong>阻塞状态</strong>（睡眠）。</li>
<li>等待其他线程通过 <code>pthread_cond_signal</code> 或 <code>pthread_cond_broadcast</code> 唤醒它。</li>
<li>被唤醒后，重新尝试获取互斥锁并继续执行。</li>
</ol>
</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Thread</span> <span class="number">1</span><span class="operator">:</span>              <span class="built_in">Condition</span> <span class="variable">Variable</span><span class="operator">:</span></span><br><span class="line">  <span class="operator">-</span> <span class="variable">Acquire</span> <span class="variable">Lock</span>         <span class="punctuation">[</span> <span class="variable">Wait</span> <span class="variable">Queue</span> <span class="punctuation">]</span></span><br><span class="line">  <span class="operator">-</span> <span class="built_in">Check</span> <span class="built_in">Condition</span> <span class="operator">----&gt;</span> <span class="variable">Add</span> <span class="variable">to</span> <span class="variable">Queue</span></span><br><span class="line">  <span class="operator">-</span> <span class="variable">Wait</span> <span class="punctuation">(</span><span class="variable">Unlock</span><span class="punctuation">)</span>        <span class="punctuation">[</span> <span class="variable">Blocked</span> <span class="punctuation">]</span></span><br><span class="line">                         <span class="operator">&lt;-----</span> <span class="variable">Signal</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">Thread</span> <span class="number">2</span><span class="operator">:</span>               <span class="variable">Wake</span> <span class="built_in">Up</span> <span class="built_in">Thread</span> <span class="number">1</span></span><br><span class="line">  <span class="operator">-</span> <span class="variable">Modify</span> <span class="built_in">Condition</span></span><br><span class="line">  <span class="operator">-</span> <span class="variable">Signal</span></span><br><span class="line">  <span class="operator">-</span> <span class="built_in">Release</span> <span class="variable">Lock</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>条件变量没有条件状态：</strong> 共享条件需要程序员手动管理（例如标志位）。</li>
<li><strong>支持复杂条件判断：</strong> 等待某些条件的组合，例如缓冲区为空或满。</li>
<li><strong>虚假唤醒机制：</strong> 被唤醒后必须重新检查条件，避免不满足条件的线程继续执行。</li>
</ul>
<hr>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><ul>
<li>信号量直接依赖<strong>原子操作</strong>（如 CPU 指令 <code>Test-And-Set</code> 或 <code>Compare-And-Swap</code>）更新计数器，确保多线程安全。</li>
<li>阻塞线程会进入<strong>等待队列</strong>，操作系统负责调度。</li>
</ul>
<ol>
<li>信号量内部维护一个<strong>计数器变量（Counter）</strong>，表示可用资源的数量。</li>
<li>当调用 <code>sem_wait</code> 时：<ul>
<li>如果计数器 &gt; 0，直接减 1，线程继续执行。</li>
<li>如果计数器 == 0，线程阻塞，进入等待队列。</li>
</ul>
</li>
<li>当调用 <code>sem_post</code> 时：<ul>
<li>增加计数器值。</li>
<li>如果等待队列中有线程，则唤醒其中一个线程。</li>
</ul>
</li>
</ol>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Semaphore</span> <span class="variable">Counter</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="built_in">Thread</span> <span class="number">1</span><span class="operator">:</span> <span class="variable">P</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">----&gt;</span> <span class="variable">Counter</span><span class="operator">--</span> <span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">Thread</span> <span class="number">2</span><span class="operator">:</span> <span class="variable">P</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">----&gt;</span> <span class="variable">Counter</span><span class="operator">--</span> <span class="punctuation">(</span><span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">Thread</span> <span class="number">3</span><span class="operator">:</span> <span class="variable">P</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">----&gt;</span> <span class="variable">Blocked</span> <span class="punctuation">(</span><span class="variable">Counter</span> <span class="operator">==</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">Thread</span> <span class="number">1</span><span class="operator">:</span> <span class="variable">V</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">----&gt;</span> <span class="variable">Counter</span><span class="operator">++</span> <span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="variable">Wake</span> <span class="built_in">Up</span> <span class="built_in">Thread</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>信号量管理的是资源数量，而不是条件状态。</li>
<li>自带互斥特性，适合多个线程访问有限资源。</li>
<li><strong>适合计数型条件：</strong> 一次允许多个线程执行，而不是简单的互斥。</li>
</ul>
<h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><ol>
<li><strong>Semaphore 更像一个通用工具：</strong><ul>
<li>适合管理固定资源数量，如线程池、连接池、令牌桶等。</li>
<li>更简单、更高效，适合需要资源计数的场景。</li>
<li>支持跨进程同步需求。</li>
</ul>
</li>
<li><strong>Mutex + Condition Variable 提供更高级的同步机制：</strong><ul>
<li>适合复杂条件判断或事件驱动模型，如生产者/消费者问题，依赖互斥锁保证数据一致性。</li>
<li>支持灵活的条件管理，适合多条件组合。</li>
<li>更适合线程间等待和唤醒机制，不适合跨进程同步。</li>
</ul>
</li>
</ol>
<ul>
<li>在实际开发中，如果场景简单且需求是资源访问控制，选择<strong>信号量</strong>；</li>
<li>如果需要更复杂的条件管理和线程间事件通知，则选择<strong>条件变量 + 锁</strong>。</li>
</ul>
<h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><h3 id="Reader-Writer-Lock"><a href="#Reader-Writer-Lock" class="headerlink" title="Reader/Writer Lock"></a>Reader/Writer Lock</h3><p>读者只读不写，写者才需要修改。类似 Shared/eXclusion 共享锁和独占锁</p>
<p>RW 锁支持一个写者或者多个读者：</p>
<ul>
<li>第一个读者首先获取lock（保护reader）增加reader，获取writelock，释放lock进入临界区</li>
<li>之后其他的读者只要获取lock后增加reader个数，直接访问临界区即可</li>
<li>写者需要等待最后一个读者释放writelock</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rwlock_t</span>&#123;</span></span><br><span class="line">    <span class="type">sem_t</span> lock; <span class="comment">// basic lock  INIT: 1</span></span><br><span class="line">    <span class="type">sem_t</span> writelock;<span class="comment">//allow 1 writer / many readers INIT: 1</span></span><br><span class="line">    <span class="type">int</span> readers;<span class="comment">//number of readers  INIT:0</span></span><br><span class="line">&#125;<span class="type">rwlock_t</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span>&#123;</span><br><span class="line">    sem_wait(rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span>(readers == <span class="number">1</span>)</span><br><span class="line">        sem_wait(rw-&gt;writelock); <span class="comment">//第一个读者获取写锁</span></span><br><span class="line">    sem_post(rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span>&#123;</span><br><span class="line">    sem_wait(rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers;</span><br><span class="line">    <span class="keyword">if</span>(readers == <span class="number">0</span>)</span><br><span class="line">        sem_post(rw-&gt;writelock);<span class="comment">//最后一个读者释放写锁</span></span><br><span class="line">    sem_post(rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span>&#123;</span><br><span class="line">    sem_wait(rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers;</span><br><span class="line">    <span class="keyword">if</span>(readers == <span class="number">0</span>)</span><br><span class="line">        sem_post(rw-&gt;writelock);<span class="comment">//最后一个读者释放写锁</span></span><br><span class="line">    sem_post(rw-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种读写锁并不一定比自旋锁更快，并且公平性无法保证，过多读者通常会饿死写者，需要进一步进行优化。</p>
<h3 id="Dining-Philosopher’s-Problem"><a href="#Dining-Philosopher’s-Problem" class="headerlink" title="Dining Philosopher’s Problem"></a>Dining Philosopher’s Problem</h3><p><strong>问题描述</strong></p>
<ul>
<li>有 5 位哲学家围坐在一张圆桌旁，他们的生活方式是 <strong>思考</strong> 和 <strong>进餐</strong>。</li>
<li>桌子上摆放着 5 根筷子，每位哲学家左右各放一根。</li>
<li>哲学家要进餐时，需要同时拿起左右两根筷子。</li>
<li>哲学家只能在拿到两根筷子后才能吃饭，否则必须等待。</li>
</ul>
<p><strong>主要难题</strong>：</p>
<ul>
<li>**死锁 (Deadlock)**：所有哲学家都同时拿起左边的筷子，导致没有哲学家能拿到第二根筷子，进入无限等待状态。</li>
<li>**饥饿 (Starvation)**：某位哲学家可能永远无法获得两根筷子，从而无法进餐。</li>
<li><strong>并发控制</strong>：需要保证哲学家拿筷子和放筷子的动作是线程安全的。</li>
</ul>
<ul>
<li><strong>方案 1：引入顺序编号</strong><br>将哲学家编号为 0 到 4，规定编号为偶数的哲学家先拿左筷子，再拿右筷子；编号为奇数的哲学家先拿右筷子，再拿左筷子。或者，最后一个哲学家先拿右筷子，再拿左筷子。这样就不会互相卡住，打破了等待的循环。</li>
<li><strong>方案 2：限制最多 4 个哲学家进入用餐状态</strong><br>使用一个计数器，确保最多 4 位哲学家能尝试拿筷子，这样至少会有一根筷子空闲，避免死锁。</li>
</ul>
<h3 id="Thread-Throttling"><a href="#Thread-Throttling" class="headerlink" title="Thread Throttling"></a>Thread Throttling</h3><p>信号量比较适合<strong>资源数量有限制</strong>的情况：比如有一群线程，每个线程都需要申请一块很大的内存空间用于计算，用于计算的这片区域就是 <strong>内存密集型</strong> 区域，如果所有线程同时申请，就会造成内存抖动（不停地换出又换入页面导致程序以极慢的速度执行）。</p>
<p>一个简单的信号量就可以解决这个问题：通过将信号量的值初始化为您希望一次进入内存密集区域的最大线程数，然后在该区域周围放置 sem_wait() 和 sem_post()，信号量自然地限制那些并发地处于危险区域的线程数量。</p>
<h2 id="Implement-sem-using-mutex-amp-cond"><a href="#Implement-sem-using-mutex-amp-cond" class="headerlink" title="Implement sem using mutex &amp; cond"></a>Implement <code>sem</code> using <code>mutex</code> &amp; <code>cond</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Zem_t</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	<span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">	<span class="type">pthread_cond_t</span> cond;</span><br><span class="line">&#125; Zem_t;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_init</span><span class="params">(Zem_t *s, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">	s-&gt;value = value;</span><br><span class="line">	Cond_init(s-&gt;cond);</span><br><span class="line">	Mutex_init(s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_wait</span><span class="params">(Zem_t *s)</span>&#123;</span><br><span class="line">	Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line">	<span class="keyword">while</span>(s-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">		Cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);</span><br><span class="line">	s-&gt;value--;</span><br><span class="line">	Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_post</span><span class="params">(Zem_t *s)</span>&#123;</span><br><span class="line">	Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line">	s-&gt;value++;</span><br><span class="line">	Cond_signal(&amp;s-&gt;cond);</span><br><span class="line">	Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Common-Concurrency-Bugs"><a href="#Common-Concurrency-Bugs" class="headerlink" title="Common Concurrency Bugs"></a>Common Concurrency Bugs</h1><p>总的来说可以分为死锁(Deadlock)和非死锁(Non-deadlock)两种，其中后者占绝大多数</p>
<h2 id="Non-deadlock-Bugs"><a href="#Non-deadlock-Bugs" class="headerlink" title="Non-deadlock Bugs"></a>Non-deadlock Bugs</h2><h3 id="Atomicity-Violation-Lock"><a href="#Atomicity-Violation-Lock" class="headerlink" title="Atomicity-Violation(Lock)"></a>Atomicity-Violation(Lock)</h3><p>这种错误违反了<strong>原子性</strong>，下图的 <code>proc_info</code> 在刚进入 if 循环的时候被取消调度，线程2将其置为NULL，切换回去的时候导致空指针异常</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241225194108926.png" alt="image-20241225194108926"></p>
<p>解决方案：在访问共享资源的时候加锁</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241225194511624.png" alt="image-20241225194511624"></p>
<h3 id="Order-Violation-CV"><a href="#Order-Violation-CV" class="headerlink" title="Order-Violation(CV)"></a>Order-Violation(CV)</h3><p>模块化：不同线程承担不同职责，线程1负责初始化 <code>mThread</code> ，线程2访问 <code>mThread</code></p>
<p>如果<strong>乱序执行</strong>，就会出现线程2访问到空指针导致程序崩溃：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241225194032626-1735126873754-1.png" alt="image-20241225194032626"></p>
<p>因此，用一个状态变量或者<code>mThread</code>本身来代表初始化是否成功，然后用条件变量解决问题：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241225194350912.png" alt="image-20241225194350912"></p>
<h2 id="Deadlock-Bugs"><a href="#Deadlock-Bugs" class="headerlink" title="Deadlock Bugs"></a>Deadlock Bugs</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241225195039934.png" alt="image-20241225195039934"></p>
<p>死锁原因：获取锁的顺序相反</p>
<ol>
<li>在大型代码库中组件依赖复杂 循环依赖就会导致死锁的发生</li>
<li>模块化封装会隐藏底层的细节 <code>v1.addAll(v2)</code> <code>v2.addAll(v1)</code> 同时调用可能会发生死锁</li>
</ol>
<p>产生死锁的四个条件：</p>
<ol>
<li><strong>互斥</strong>：线程对资源进行互斥的访问</li>
<li><strong>持有并等待</strong>：线程在持有资源的同时也在等待其他资源</li>
<li><strong>非抢占</strong>：线程获得的资源（如锁）不能被抢占</li>
<li><strong>循环等待</strong>：线程之间存在环路，上面的每个线程都会额外持有下个线程想要申请的资源</li>
</ol>
<h3 id="Prevention"><a href="#Prevention" class="headerlink" title="Prevention"></a>Prevention</h3><h4 id="Circular-Wait-Forced-Order"><a href="#Circular-Wait-Forced-Order" class="headerlink" title="Circular Wait: Forced Order"></a>Circular Wait: Forced Order</h4><p>强制规定获取锁的顺序</p>
<p><strong>偏序锁：</strong>如果资源之间的依赖关系较少或依赖是局部的，偏序锁，提供更好的性能和灵活性。</p>
<p><strong>全序锁：</strong>如果资源之间的依赖关系复杂且必须确保一致性（如事务或分布式系统），全序锁更可靠</p>
<p>如果一个函数要抢多个锁，可以根据<strong>锁的地址</strong>作为锁的顺序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">do_something(mutex *m1,mutex *m2)&#123;</span><br><span class="line">	<span class="keyword">if</span>(m1 &lt; m2)&#123;</span><br><span class="line">		pthread_mutex_lock(*m1);</span><br><span class="line">		pthread_mutex_lock(*m2);</span><br><span class="line">	</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		pthread_mutex_lock(*m2);</span><br><span class="line">		pthread_mutex_lock(*m1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以保证 <code>do_something(&amp;m1,&amp;m2)</code> 和 <code>do_something(&amp;m2,&amp;m1)</code> 是同样的抢锁顺序</p>
<h4 id="Hold-and-wait-Atomic-Acquiring"><a href="#Hold-and-wait-Atomic-Acquiring" class="headerlink" title="Hold-and-wait: Atomic Acquiring"></a>Hold-and-wait: Atomic Acquiring</h4><p>在抢锁的最外层加一道锁（原子性抢锁）防止抢锁过程中突然被取消调度，切换到其他线程：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241225203212407.png" alt="image-20241225203212407"></p>
<p>缺点：不适合封装，因为需要准确知道要抢哪些锁并提前全部抢到（即使当前并不需要）</p>
<h4 id="No-Preemption-trylock"><a href="#No-Preemption-trylock" class="headerlink" title="No Preemption:trylock"></a>No Preemption:<code>trylock</code></h4><p>可以通过<code>trylock</code>这种非阻塞式抢锁来避免死锁，但是这种方法会导致活锁，对封装的支持也不好，代码抢完锁中途获取的资源（比如申请的内存空间），如果抢锁失败，还应该释放</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241225204421920.png" alt="image-20241225204421920"></p>
<h5 id="Livelock"><a href="#Livelock" class="headerlink" title="Livelock"></a>Livelock</h5><p><strong>死锁：</strong> 所有线程都进入等待状态，完全停止运行。</p>
<p><strong>活锁：</strong> 所有线程仍然在运行，但因为不断调整状态，始终无法完成任务。</p>
<p>解决方案：</p>
<ol>
<li>退避算法（Backoff）:在循环结束的时候，先随机等待一段时间再重复</li>
<li>引入有限重试机制: 因为线程一直在运行，因此可以限制最大重试次数</li>
<li>使用更高层次的同步机制,结合条件变量或阻塞队列</li>
</ol>
<h4 id="Mutual-Exclusion-Lock-free-CAS"><a href="#Mutual-Exclusion-Lock-free-CAS" class="headerlink" title="Mutual Exclusion: Lock-free(CAS)"></a>Mutual Exclusion: Lock-free(CAS)</h4><p>利用硬件指令的原子性，完全避免互斥区的存在：CAS 失败就不断重试，直到成功为止（乐观锁）</p>
<p>COMPARE AND SWAP 加之前看看是不是对应的正确的值，是的话再赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自增:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CAS</span><span class="params">(<span class="type">int</span> *address, <span class="type">int</span> expected, <span class="type">int</span> new)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(*address == expected)&#123;</span><br><span class="line">        *address = new;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> *value, <span class="type">int</span> amount)</span>&#123;</span><br><span class="line">    <span class="type">int</span> old;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">		old = *value;</span><br><span class="line">    &#125; <span class="keyword">while</span>(CAS(value, old, old + amount) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表插入</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CAS</span><span class="params">(<span class="type">node_t</span> **address, <span class="type">node_t</span> *expected, <span class="type">node_t</span> *new)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(*address == expected)&#123;</span><br><span class="line">        *address = new;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(n != <span class="literal">NULL</span>);</span><br><span class="line">    n-&gt;value = value;</span><br><span class="line">    pthread_mutex_lock(listlock); <span class="comment">// begin critical section</span></span><br><span class="line">    n-&gt;next = head;</span><br><span class="line">    head = n;</span><br><span class="line">    pthread_mutex_unlock(listlock); <span class="comment">// end critical section</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="type">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(n!=<span class="literal">NULL</span>);</span><br><span class="line">    n-&gt;value = value;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        n-&gt;next = head;<span class="comment">//新节点的下一个应该是现在的头</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(CAS(&amp;head, n-&gt;next, n) == <span class="number">0</span>);<span class="comment">//现在的头应该等于新节点的下一个,不等于</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Avoid-via-Scheduling"><a href="#Avoid-via-Scheduling" class="headerlink" title="Avoid via Scheduling"></a>Avoid via Scheduling</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241225213119760.png" alt="image-20241225213119760"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241225213105676.png" alt="image-20241225213105676"></p>
<p>不要同时并行执行需要获取完全相同锁的线程</p>
<h3 id="Detect-and-Recover"><a href="#Detect-and-Recover" class="headerlink" title="Detect and Recover"></a>Detect and Recover</h3><p>如果根除死锁实在很困难，可以定期检查死锁，并运行专门的程序来恢复</p>
<h1 id="Event-based-Concurrency"><a href="#Event-based-Concurrency" class="headerlink" title="Event-based Concurrency"></a>Event-based Concurrency</h1><p><strong>Event</strong> Loop: 等待事件-&gt;处理事件-&gt;等待事件，重点是如何获取事件？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	events = getEvents();</span><br><span class="line">    <span class="keyword">for</span> (e in events)</span><br><span class="line">    	processEvent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select"><a href="#select" class="headerlink" title="select()"></a><code>select()</code></h2><h3 id="API-Usage"><a href="#API-Usage" class="headerlink" title="API Usage"></a>API Usage</h3><ul>
<li><strong>Purpose</strong>: 监视 FD 是否准备好接受 I/O 操作</li>
<li><strong>Function Signature</strong>: <code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout)</code></li>
<li><strong>Parameters</strong>:<ul>
<li><code>nfds</code>: 检查集合中 [0,nfds-1] 的 FD</li>
<li><code>readfds</code>: 监控 readfds 中的可读事件(新的数据包到达，准备处理)</li>
<li><code>writefds</code>: 监控 writefds 中的可写事件(服务器回复需要写入队列有空)</li>
<li><code>errorfds</code>: 监控 errorfds 中的错误事件</li>
<li><code>timeout</code>: 最大等待时间</li>
</ul>
</li>
<li><strong>Return Value</strong>: 返回准备好 I/O 的 FDs</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241225225619265.png" alt="image-20241225225619265"></p>
<h3 id="Lock-free"><a href="#Lock-free" class="headerlink" title="Lock-free"></a>Lock-free</h3><p>有了单CPU和基于事件的应用程序，并发程序中的问题就不再存在。具体来说，因为一次只处理一个事件，所以不需要获取或释放锁；基于事件的服务器不能被另一个线程中断，因为它绝对是单线程的。因此，线程程序中常见的并发错误不会在基于事件的基本方法中体现出来。</p>
<h3 id="Problem-Blocking-Syscalls"><a href="#Problem-Blocking-Syscalls" class="headerlink" title="Problem: Blocking Syscalls"></a>Problem: Blocking Syscalls</h3><p>如果某个事件要求发出可能会阻塞的系统调用怎么办？ 例如，假设一个请求从客户端发送到服务器，以从磁盘读取文件并将其内容返回到请求客户端（非常类似于简单的 HTTP 请求）。为了服务这样的请求，某些事件处理程序最终必须发出 <code>open()</code> 系统调用来打开文件，然后执行一系列 <code>read()</code> 调用来读取文件。当文件被读入内存时，服务器可能会开始将结果发送到客户端。 <code>open()</code> 和 <code>read()</code> 调用都可能向存储系统发出 I/O 请求（当所需的元数据或数据尚未在内存中时），因此可能需要很长时间才能提供服务。对于基于线程的服务器，这不是问题：当发出 I/O 请求的线程挂起（等待 I/O 完成）时，其他线程可以运行，从而使服务器能够取得进展。事实上，I/O 和其他计算的这种自然重叠使得基于线程的编程变得非常自然和直接。</p>
<p>然而，使用基于事件的方法，没有其他线程可以运行：只有主事件循环。这意味着，如果事件处理程序发出阻塞调用，则整个服务器将执行此操作：阻塞直到调用完成。当事件循环阻塞时，系统处于空闲状态，因此潜在地浪费了巨大的资源。因此，我们在基于事件的系统中必须遵守一条规则：不允许阻塞调用。</p>
<h2 id="Asynchoronous-I-O"><a href="#Asynchoronous-I-O" class="headerlink" title="Asynchoronous I/O"></a>Asynchoronous I/O</h2><h3 id="API-Usage-1"><a href="#API-Usage-1" class="headerlink" title="API Usage"></a>API Usage</h3><p>要对文件发出异步读取，应用程序应首先使用相关信息填充此 AIO 控制块（aiocb）：</p>
<ul>
<li>要读取的文件的文件描述符 (aio fildes)</li>
<li>文件内的偏移量 (aio offset) </li>
<li>长度请求的长度 (aio nbytes)</li>
<li>读取结果应复制到的内存位置 (aio buf)</li>
</ul>
<p>填充该结构后，应用程序必须发出 AIO 来读取文件；在 Mac 上，此 API 是一个异步读取的 API： <code>int aio_read(struct aiocb *aiocbp</code>);  该调用尝试发出 I/O；如果成功，它会立即返回，并且应用程序（即基于事件的服务器）可以继续其工作。 </p>
<p>然而，我们必须解决最后一块难题。我们如何判断 I/O 何时完成，从而确定缓冲区（由 aiobuf 指向）现在已在其中包含所请求的数据？  还需要最后一个 API。在 Mac 上，它被称为 <code>aio_error()</code> API 如下所示： <code>int aio_error(const struct aiocb *aiocbp)</code>;  该系统调用检查 aiocbp 引用的请求是否已完成。如果是，则返回成功（用 0 表示）；  如果不是，则返回 <code>EINPROGRESS</code>。</p>
<h3 id="Poll-or-Interrupt"><a href="#Poll-or-Interrupt" class="headerlink" title="Poll or Interrupt"></a>Poll or Interrupt</h3><p>对于每个未完成的异步 I/O，应用程序可以通过调用 <code>aio_error()</code> 定期<strong>轮询</strong>系统，以确定所述 I/O 是否尚未完成。但是轮询很浪费CPU。为了解决这个问题，一些系统提供了基于中断的方法。此方法使用 UNIX Signals 来通知应用程序异步 I/O 何时完成，从而无需重复询问系统。</p>
<p>在没有异步I/O的系统中，无法实现纯粹的基于事件的方法。然而，出现了一些相当有效的混合方法。其中事件用于处理网络数据包，线程池用于管理未完成的 I/O。<strong>I/O 多路复用</strong></p>
<h4 id="UNIX-Signals"><a href="#UNIX-Signals" class="headerlink" title="UNIX Signals"></a>UNIX Signals</h4><p>所有现代 UNIX 变体中都存在一个巨大且令人着迷的基础设施，称为信号。最简单的是，信号提供了一种与进程通信的方式。具体来说，可以将信号传递给应用程序；这样做会阻止应用程序运行信号处理程序（即应用程序中处理该信号的某些代码）正在执行的任何操作。 完成后，该进程将恢复其之前的行为。 每个信号都有一个名称，如HUP（挂起）、INT（中断）、SEGV（分段违规）等</p>
<p>有趣的是，有时是内核本身发出信号。例如，当程序遇到 Segmentation Violation 时，操作系统会向其发送 <code>SIGSEGV</code>；如果程序调用了<code>signal(SIGSEV, handler)</code> 就可以运行一些代码（signal handler）来响应。当发送到没有配置响应信号的进程时，将执行默认行为；对于SEGV，该进程被终止。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> arg)</span> &#123;<span class="comment">//handler</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;stop wakin’ me up...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    signal(SIGHUP, handle);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// doin’ nothin’ except catchin’ some sigs</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>./main &amp;</code> 后台运行进程，随后返回pid；</p>
<p><code>kill -HUP [pid]</code> 给进程发送 SIGHUP 信号：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./main &amp;</span><br><span class="line">[<span class="number">3</span>] <span class="number">36705</span></span><br><span class="line">prompt&gt; <span class="built_in">kill</span> <span class="literal">-HUP</span> <span class="number">36705</span></span><br><span class="line">stop wakin’ me up...</span><br><span class="line">prompt&gt; <span class="built_in">kill</span> <span class="literal">-HUP</span> <span class="number">36705</span></span><br><span class="line">stop wakin’ me up...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Problem-State-Management"><a href="#Problem-State-Management" class="headerlink" title="Problem: State Management"></a>Problem: State Management</h3><p>在 Thread-based 服务器中，从<code>read</code>调用返回，程序可以直接从栈上知道 sd 是多少</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rc = read(fd, buffer, size);</span><br><span class="line">rc = write(sd, buffer, size);</span><br></pre></td></tr></table></figure>

<p>而在 Event-based 服务器中，从 <code>aio_read</code> 返回后，应当记录下在处理<code>read</code>事件时必要的信息(continuation)，比如将套接字描述符（sd）记录在某种数据结构（例如哈希表）中，并由文件描述符（fd）索引。</p>
<p>当<code>aio_error</code>显示成功读取后，事件处理器将使用 FD 来查找 continuation，这会将 sd 的值返回给调用者。最终，服务器可以完成最后一点工作，将数据写入套接字。</p>
<h2 id="Other-Problems-with-Events"><a href="#Other-Problems-with-Events" class="headerlink" title="Other Problems with Events"></a>Other Problems with Events</h2><ol>
<li><p>单核到多核将会有多个事件处理器同步运行的情况，会产生同步问题。不再可能进行无锁的简单事件处理。</p>
</li>
<li><p>不能与某些类型的系统活动（例如分页）很好地集成。例如，如果事件处理器发生Page Fault，这就会导致阻塞，因此服务器在Page Fault完成处理之前会一直阻塞。</p>
</li>
<li><p>随着各种程序的确切语义发生变化，基于事件的代码可能很难管理超时。例如，如果例程从非阻塞更改为阻塞，则调用该例程的事件处理程序也必须通过将自身分成两部分来进行更改以适应其新性质。由于阻塞对基于事件的服务器来说是灾难性的，因此程序员必须始终留意每个事件使用的 API 语义中的此类变化。 </p>
</li>
<li><p>异步磁盘 I/O 并未实现与异步网络 I/O 完全集成。例如，虽然人们只想使用 select() 接口来管理所有未完成的 I/O，但通常需要用于网络的 select() 和用于磁盘 I/O 的 AIO 调用的某种组合。</p>
</li>
</ol>
<h1 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h1><h2 id="Semaphore-amp-Monitor"><a href="#Semaphore-amp-Monitor" class="headerlink" title="Semaphore &amp; Monitor"></a>Semaphore &amp; Monitor</h2><ul>
<li>**信号量(Semaphere)**：操作系统提供的一种协调共享资源访问的方法。和用软件实现的同步比较，软件同步是平等线程间的的一种同步协商机制，不能保证原子性。而信号量则由操作系统进行管理，地位高于进程，操作系统保证信号量的原子性。</li>
<li>**管程(Monitor)**：解决信号量在临界区的 PV 操作上的配对的麻烦，把配对的 PV 操作集中在一起，生成的一种并发编程方法。其中使用了条件变量这种同步机制。</li>
</ul>
<p><strong>所谓管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。</strong>翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。一般采用 Mesa Semantic</p>
<p><strong>说明：</strong> 信号量将共享变量 S 封装起来，对共享变量 S 的所有操作都只能通过 PV 操作进行，这是不是和面向对象的思想是不是很像呢？事实上，封装共享变量是并发编程的常用手段。</p>
<p>在信号量中，当 P 操作无法获取到锁时，将当前线程添加到**同步队列(syncQueue)<strong>中。当其余线程 V 释放锁时，从同步队列中唤醒等待线程。但当有多个条件通过信号量 PV 配对时会异常复杂，所以管程中引入了</strong>等待队列(waitQueue)**的概念，进一步封装这些复杂的操作。</p>
<p>在用信号量实现的阻塞队列中，为了实现阻塞队列的功能，即等待-通知(wait-notify)，除了使用互斥锁 mutex 外，还需要两个判断队满和队空的资源信号量 full 和 empty，使用起来不仅复杂，还容易出错。管程在信号量的基础上，更进一步，增加了条件同步，对多个条件变量使用多个等待队列，将上述复杂的操作封装起来: <code>wait()</code> <code>notifyAll()</code> <code>notify()</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1322310-20200320081430470-1065805408.png" alt=" "></p>
<h3 id="API-Usage-2"><a href="#API-Usage-2" class="headerlink" title="API Usage"></a>API Usage</h3><h4 id="While-Loop-wait"><a href="#While-Loop-wait" class="headerlink" title="While Loop wait()"></a>While Loop <code>wait()</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/250px-Monitor_(synchronization)-Mesa.png" alt="img"></p>
<p>MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是<strong>当 T1 再次执行的时候，可能曾经满足的条件现在已经不满足了</strong>，所以需要以while循环方式检验条件变量。</p>
<p><code>notify()</code> or <code>notifyAll()</code> ？什么时候可以使用 <code>notify()</code> 呢？需要满足以下三个条件：</p>
<ol>
<li>所有等待线程拥有相同的等待条件；</li>
<li>所有等待线程被唤醒后，执行相同的操作；</li>
<li>只需要唤醒一个线程。</li>
</ol>
<p><code>notify()</code> 一般只适用于只有一个条件变量的情况，生产者和消费者等待在同一个条件上会导致错误唤醒同类，造成死锁。<code>notifyAll()</code> 类似于 <code>pthread_cond_broadcast()</code> 都可以用于唤醒多个等待在同一个条件变量上的线程。重点是 <strong>while 里面的等待条件是完全相同的。</strong></p>
<h2 id="BlockingQueue-Producer-Consumer"><a href="#BlockingQueue-Producer-Consumer" class="headerlink" title="BlockingQueue: Producer/Consumer"></a>BlockingQueue: Producer/Consumer</h2><p>Condition 能够更细粒度地进行编程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockedQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 条件变量：队列不满</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 条件变量：队列不空</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">enq</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (队列已满) &#123;</span><br><span class="line">                <span class="comment">// 等待队列不满</span></span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// add x to queue</span></span><br><span class="line">            <span class="comment">// 入队后,通知可出队</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deq</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (队列已空) &#123;</span><br><span class="line">                <span class="comment">// 等待队列不空</span></span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the first element from queue</span></span><br><span class="line">            <span class="comment">// 出队后，通知可入队</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AQS-amp-synchronized"><a href="#AQS-amp-synchronized" class="headerlink" title="AQS &amp; synchronized"></a>AQS &amp; synchronized</h2><p>JUC AQS 就是基于管程实现的，内部包含两个队列，一个是同步队列，一个是等待队列：</p>
<ol>
<li>同步队列：锁被占用时，会将该线程添加到同步队列中。当锁释放后，会从队列中唤醒一个线程，又分为公平和非公平两种。</li>
<li>等待队列：当调用 await 时，会将该线程添加到等待队列中。当其它线程调用 notify 时，会将该线程从等待队列移动到同步队列中，重新竞争锁。</li>
</ol>
<p>synchronized 也是基于管程实现的，核心的数据结构见 ObjectMonitor。AQS 和 synchronized 都是管程 MESA 模型在 Java 中的应用。一切都套路，有章可循。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/20/408-OS-%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/20/408-OS-%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="post-title-link" itemprop="url">虚拟机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-20T00:00:00+08:00">2025-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:51:29" itemprop="dateModified" datetime="2025-05-05T11:51:29+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hypervisor-VMM"><a href="#Hypervisor-VMM" class="headerlink" title="Hypervisor (VMM)"></a>Hypervisor (VMM)</h1><p>Hypervisor 是一种运行在基础硬件和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也可叫做虚拟机监视器，即 VMM（ virtual machine monitor ）。（操作系统的操作系统）</p>
<p>动机：</p>
<ol>
<li>提高硬件的利用率，一套硬件跑多个操作系统</li>
<li>方便多平台软件的开发与调试</li>
</ol>
<ul>
<li>当服务器启动并执行 Hypervisor 时，它会加载所有虚拟机客户端的操作系统同时会分配给每一台虚拟机适量的内存，CPU，网络和磁盘。它允许多个操作系统（称为<strong>Guest OS</strong>）在同一台物理机器（称为<strong>Host</strong>）上同时运行，每个操作系统被隔离在独立的虚拟机中。</li>
<li>Hypervisor 负责资源分配，如 CPU、内存和存储，协调着这些硬件资源的访问，而且在各个虚拟机之间施加防护，处理虚拟机之间的通信和安全隔离。</li>
</ul>
<h2 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/VMwarevsKVM1.png" alt="KVM vs VMware – Uma comparação de Hypervisors - Wintech"></p>
<ul>
<li><p><strong>Type 1 (裸机型):</strong> 直接运行在物理硬件上，例如 VMware ESXi、Microsoft Hyper-V、KVM。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/virtual-machine-diagram.svg" alt="体系结构图，显示 VM 如何运行完整的操作系统（独立于主机操作系统）"></p>
<p>KVM (Kernel-Based Virtual Machine) 是 x86 硬件上 Linux 的完整虚拟化解决方案。它由提供核心虚拟化基础设施的可加载内核模块 kvm.ko 和处理器特定模块 kvm-intel.ko 或 kvm-amd.ko 组成。采用硬件辅助虚拟化技术 Intel-VT、AMD-V，内存的相关如 Intel 的 EPT 和 AMD 的 RVI 技术</p>
</li>
<li><p><strong>Type 2 (托管型):</strong> 运行在操作系统之上，例如 VMware Workstation、Oracle VirtualBox。</p>
</li>
<li><p><strong>QEMU</strong>: </p>
<ul>
<li><p>最初 <strong>QEMU</strong>(Quick Emulator)是一个系统模拟器，它可以在一种体系结构的系统上模拟另一种体系结构的系统。不但模拟 CPU，还模拟各种外设。其中 CPU 的模拟主要是通过指令翻译的方式，所以速度比较慢：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/e45iakbuhu.jpeg" alt="img"></p>
</li>
<li><p>KVM 只靠上面的两个内核模块不能创建完整的虚拟机，KVM 是一种中间件，属于 Linux 的内核模块，将 Linux 变成一个 Hypervisor，可以虚拟化 CPU 和内存，在系统需要虚拟化功能的时候，内核把 KVM 模块调入内存中运行。但用户无法直接控制内核，所以需要一个处于内核和用户之间的一个桥梁 QEMU。KVM 团队 fork 了 QEMU 作为用户态的部分，一起实现了虚拟机(QEMU 模拟系统的其他组件如磁盘等；KVM 模拟 CPU 和内存)。</p>
</li>
<li><p>从 KVM 的角度看，它的用户态部分在 QEMU 里，一起虚拟出完整 Guest OS；</p>
</li>
<li><p>从 QEMU 的角度看，它有一个 Virtualization 模式，就是使用 KVM 来模拟 CPU 内存网络，实现加速。QEMU 通过 KVM 的用户态部分访问 KVM 的内核态部分。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/kvm-qemu-1735307591402-91.png" alt="figure1"></p>
</li>
</ul>
</li>
</ul>
<p>某些文献中，VMM 特指 Type 2 Hypervisor 中用于模拟 CPU 指令集和设备驱动的核心软件组件，特别是在微内核环境中，对 Hypervisor 和 VMM 进行了区分。在那里，两个组件形成了某个系统的整体虚拟化堆栈。 Hypervisor 指的是内核空间功能，VMM 指的是用户空间功能。具体来说，在这些上下文中，Hypervisor 是实现虚拟化基础设施的微内核，由于技术原因必须在内核空间中运行，例如 Intel VMX。实现虚拟化机制的微内核也称为微管理程序。将此术语应用到 Linux 中，KVM 是一个 Hypervisor，而 QEMU 是利用 KVM 作为 Hypervisor 的 VMM。</p>
<h2 id="CPU-Virtualization"><a href="#CPU-Virtualization" class="headerlink" title="CPU Virtualization"></a>CPU Virtualization</h2><h2 id="Memory-Virtualization"><a href="#Memory-Virtualization" class="headerlink" title="Memory Virtualization"></a>Memory Virtualization</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/8/">8</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
