<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/25/spring-circle-ref/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/25/spring-circle-ref/" class="post-title-link" itemprop="url">spring 循环依赖</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-25 00:00:00 / 修改时间：07:06:13" itemprop="dateCreated datePublished" datetime="2025-05-25T00:00:00+08:00">2025-05-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-循环依赖"><a href="#Spring-循环依赖" class="headerlink" title="Spring 循环依赖"></a>Spring 循环依赖</h1><h2 id="获取单例对象"><a href="#获取单例对象" class="headerlink" title="获取单例对象"></a>获取单例对象</h2><ol>
<li><strong>优先查询一级缓存（<code>singletonObjects</code>）</strong><ul>
<li>一级缓存也叫单例池，存储的是<strong>完全初始化</strong>的单例 Bean（例如已注入所有依赖且完成代理增强的对象）。</li>
<li><strong>作用</strong>：直接获取可用 Bean，避免重复创建。</li>
<li>优先级最高：如果找到直接返回，不触发后续缓存查询。</li>
</ul>
</li>
<li><strong>未找到则查询二级缓存（<code>earlySingletonObjects</code>）</strong><ul>
<li>二级缓存存储的是<strong>已实例化但未完成初始化</strong>的 Bean（半成品）。</li>
<li><strong>作用</strong>：在循环依赖中临时暴露早期引用（例如 A 依赖 B 时，B 可能正在创建中，需引用 A 的半成品）。</li>
<li>注意：若二级缓存中存在目标 Bean，则直接返回，但此时 Bean 可能尚未完成属性注入或代理。</li>
</ul>
</li>
<li><strong>最后查询三级缓存（<code>singletonFactories</code>）</strong><ul>
<li>三级缓存是 beanName 到 对象工厂（<code>ObjectFactory</code>）的映射，对象工厂是个函数式接口，这个接口用于动态生成 Bean 的早期引用或代理对象。</li>
<li>触发条件：仅当一、二级缓存均未找到时，调用工厂生成 Bean 实例，之后将其提升至二级缓存。</li>
<li><strong>关键作用</strong>：支持 AOP 代理的延迟生成（例如解决代理对象的循环依赖）。</li>
</ul>
</li>
</ol>
<h2 id="如果只有二级缓存，就可以解决问题"><a href="#如果只有二级缓存，就可以解决问题" class="headerlink" title="如果只有二级缓存，就可以解决问题"></a>如果只有二级缓存，就可以解决问题</h2><ul>
<li><code>getBean(a)</code>，实例化对象 A 以后放入二级缓存（裸对象），然后 A 开始属性注入</li>
<li>遇到一个属性 B，先从一级缓存里面拿发现没有，瞄一眼二级缓存里面也没有，于是开始 <code>getBean(b)</code>：</li>
<li>实例化对象B以后将其放入二级缓存（裸对象），B 开始属性注入，发现 A 不在一级缓存，但是从二级缓存里面拿到了 A 的裸对象注入 B，此时 B 算初始化完成，把 B 从二级缓存里面删掉，放到一级缓存里面，至此 B 创建完成。</li>
<li>最后 A 用于注入的方法就能返回一个从缓存里面拿到的 B 对象，A 的注入也就完成了。</li>
</ul>
<h3 id="二级缓存的不足"><a href="#二级缓存的不足" class="headerlink" title="二级缓存的不足"></a>二级缓存的不足</h3><p>但是二级缓存的问题是，A是代理，有B，B有需要注入A，首先A创建出实例，随后A就走到了populateBean这一步</p>
<p>然后去拿B，B创建，又想来获取A了，此时A那边属于是一个刚创建实例的状态，并未走到生成代理对象那一步，因此直接注入就会出问题，所以应该注册一个回调函数，把A的实例注册进去，函数的返回值是A的对象（实例/代理实例），所以就产生了三级缓存。三级缓存的 <code>ObjectFactory</code> 主要是用于提供一个钩子，这个接口的方法返回的就是bean对象，不同之处在于可以在返回裸对象前，给其套上一层代理再返回。如果只有二级缓存，就没有机会返回代理对象。</p>
<h2 id="源码流程"><a href="#源码流程" class="headerlink" title="源码流程"></a>源码流程</h2><blockquote>
<p><code>DefaultSingletonBeanRegistry#getSingleton(name,true)</code> DCL双重校验锁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="comment">// 快速从一二级缓存检查已有的单例</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="comment">// 加锁，从三级缓存创建单例对象</span></span><br><span class="line">                singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                        ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                            singletonObject = singletonFactory.getObject();</span><br><span class="line">                            <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                            <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>流程正式开始</p>
<p><code>DefaultListableBeanFactory#preInstantiateSingletons()</code> 用于对解析到的<code> beanNames</code> 一一进行 <code>getBean(beanName)</code></p>
<p><code>AbstractBeanFactory#doGetBean(name···)</code> </p>
</blockquote>
<ol>
<li><code>getSingleton(name,true)</code> 获取不到再往下走</li>
<li>类似双亲委派，找 parent，parent 找不到再自行寻找</li>
<li>自行寻找：(dependsOn) 然后 <code>getSingleton(name, singletonFactory)</code></li>
<li><code>getSingleton(name, singletonFactory)</code>: 先一级缓存找，找不到就真正开始<mark>创建工作</mark>：<ul>
<li>首先将其加到 CreationSet 表明其正在创建。</li>
<li><code>singletonFactory</code>实际上就是一个<code>ObjectFactory</code>，这个函数式接口实现方法通过<code>createBean(name···)</code>获取对象。</li>
<li>创建完成将其从 CreationSet 中移除，保证其只存在于一级缓存单例池中。最后返回创建好的 bean</li>
</ul>
</li>
</ol>
<blockquote>
<p><code>AbstractAutowireCapableBeanFactory#doCreateBean(name,mbd,args)</code> </p>
</blockquote>
<ol>
<li><p><code>createBeanInstance()</code>：创建出裸对象，此时未注入依赖。（实际上返回的是 BeanWrapper，有更完善的功能，本质还是对象实例）</p>
<ul>
<li>当且仅当<u>单例+允许循环依赖+这个bean在 CreationSet 中</u>，才加三级缓存<code>addSingletonFactory</code>，一定要保证一级和二级缓存里面没有，然后把ObjectFactory加到三级缓存里面。所以单例 bean 加入了三级缓存：lambda：<code>getEarlyBeanReference()</code>返回创建的裸/代理对象 <code>singletonObject</code></li>
</ul>
</li>
<li><p><code>populateBean()</code>：进行字段、方法注入。做一些<code> postProcessAfterInstantiation</code> 实例化之后初始化之前的工作。然后就是 <code>autowireByName/Name</code>，本质上就是通过 <code>getBean(name···)</code>获取实例。</p>
<ul>
<li>依赖注入就是这里遇到的问题，如果代理对象出现循环依赖，那么其生成应该是初始化之后，所以此阶段断然不能提供出代理对象，因此加入三级缓存提前暴露出一个引用，。</li>
</ul>
</li>
<li><p><code>initializeBean()</code>：</p>
<ul>
<li><p>调用 <code>BeanPostProcessor#postProcessBeforeInitialization</code>。</p>
</li>
<li><p>调用初始化方法。(PostConstruct-initMethod-afterPropertiesSet)</p>
</li>
<li><p>调用 <code>BeanPostProcessor#postProcessAfterInitialization</code>（<strong>一般到这里才生成代理对象</strong>）。</p>
</li>
</ul>
</li>
<li><p>完成上述工作之后，如果当前是存在于三级缓存，则调用下方的 <code>getSingleton(name,true)</code> ： true 代表允许早期引用（主要解决循环依赖）</p>
</li>
</ol>
<blockquote>
<p>代理：<code>AbstractAutoProxyCreator</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法是用于三级缓存生成对象的时候将bean放到earlyBeanReferences里面，</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="built_in">this</span>.getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="built_in">this</span>.earlyBeanReferences.put(cacheKey, bean);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="built_in">this</span>.getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.earlyBeanReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="comment">// wrap 包装成代理的核心方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="无法解决的循环引用"><a href="#无法解决的循环引用" class="headerlink" title="无法解决的循环引用"></a>无法解决的循环引用</h2><p>如果是 AB互相依赖，A只有含参构造，那么注入B完成之前就无法创建一个A实例出来，自然也没法加到缓存里面，A尝试注入B，B那边尝试注入A彻底卡死。</p>
<p>但是 从B开始又可以了，然而对于普通的bean来说，注册顺序并不是一个可控的状态，所以尽量避免含参构造的bean之间互相依赖</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/21/computer-system-structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/21/computer-system-structure/" class="post-title-link" itemprop="url">计算机体系结构突击</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-21 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-21T00:00:00+08:00">2025-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-22 18:54:41" itemprop="dateModified" datetime="2025-05-22T18:54:41+08:00">2025-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="性能、加速比、CPI"><a href="#性能、加速比、CPI" class="headerlink" title="性能、加速比、CPI"></a>性能、加速比、CPI</h1><h2 id="Amdahl-定律"><a href="#Amdahl-定律" class="headerlink" title="Amdahl 定律"></a>Amdahl 定律</h2><ul>
<li>主要针对传统机器级的体系结构，加快系统中某部件的执行速度活动的性能提升（加速比）受限于该部件的重要性（比例）</li>
<li>不超过 1/(1-可改进比例) </li>
<li><u>1/(1-可改进比例)+可改进比例/并行数量</u></li>
</ul>
<h2 id="CPU-性能指标：CPI计算"><a href="#CPU-性能指标：CPI计算" class="headerlink" title="CPU 性能指标：CPI计算"></a>CPU 性能指标：CPI计算</h2><ul>
<li>时钟周期（Time Per Cycle）、CPI（Cycles Per Instruction，取决于计算机组成和指令系统）、IC（Instruction Count，指令系统的结构和编译技术）。</li>
<li>CPI 计算：CPIi表示第i种指令有多少个时钟周期</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521192319868.png" alt="image-20250521192319868" style="zoom: 50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521192419723.png" alt="image-20250521192419723" style="zoom:50%;" />

<ul>
<li>执行时间和性能成反比</li>
</ul>
<h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><ul>
<li>局部优化：<u>单个线性程序段（基本块）</u>内进行的优化。复杂度较低、速度快、适用范围广<ul>
<li>常量传播、消除公共子表达式(Common Subexpression Elimination)、</li>
<li>消除死代码、削弱强度（位运算）</li>
<li><u>降低堆栈高度</u></li>
</ul>
</li>
<li>全局优化：<u>跨越多个基本块或者函数</u>，基于控制流图进行跨分支分析，分析复杂，提升也明显。<ul>
<li>若循环内不变则进行代码外提。</li>
<li>常量传播、消除公共子表达式 CSE</li>
<li>函数内联</li>
</ul>
</li>
<li>汇编语言经过汇编器的翻译为机器语言</li>
<li>翻译：源码一次性转成机器码，提前编译、生成独立可运行文件、依赖平台</li>
<li>解释：源码被逐句翻译执行，动态解析</li>
<li>混合：JIT编译，Java C#</li>
</ul>
<hr>
<h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521211823581.png" alt="image-20250521211823581" style="zoom:50%;" />

<ul>
<li>映象规则： 调入块可以放在哪些位置</li>
<li>查找算法： 如何在映象规则规定的候选位置查找</li>
<li>替换算法： 规定的候选位置均被别的块占用怎么办</li>
<li>写策略： 如何处理写操作</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521211957229.png" alt="image-20250521211957229" style="zoom:33%;" />

<p>平均访问时间 = 命中访问时间T1 + 失效率 × 失效开销</p>
<p>失效开销 = 从<strong>向下一级发出请求</strong>到<strong>把整个数据块调入</strong>经过的时间</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521212817490.png" alt="image-20250521212817490" style="zoom: 50%;" />

<h2 id="映射规则"><a href="#映射规则" class="headerlink" title="映射规则"></a>映射规则</h2><p>全相联：主存中的任一块可以 被放置到Cache中的任意一个 位置。 </p>
<ul>
<li>对比：阅览室位置── 随便坐 </li>
<li>特点：空间利用率最高，冲突概率最低，实现最复杂。</li>
</ul>
<p>直接映射：主存中的每一块只能被放置到 Cache中唯一的一个位置。</p>
<ul>
<li>对比：阅览室位置── 只有一个位置可以坐</li>
<li>特点：空间利用率最低，冲突概率最高， 实现最简单。</li>
<li>对于主存的第i 块，若它映象到Cache的第j 块，则: j＝i mod (M ) （M为Cache的块数，i是块地址）<ul>
<li>如果cache有2的m次方块，块j实际上就是地址i的低m位</li>
</ul>
</li>
</ul>
<p>组相联：折衷</p>
<ul>
<li><p>若主存第i 块映象到第k 组，则: k＝i mod（G） （G为Cache的组数）</p>
</li>
<li><p>设G＝2的g次方，则当表示为二进制数时，k 实际上就是i 的低 g 位。低g位以及直接映象中的低m位通常称为<u>索引</u>。</p>
</li>
<li><p>n路组相联：每组n个块。绝大多数时候，n ≤ 4</p>
</li>
</ul>
<h2 id="Cache-性能例题"><a href="#Cache-性能例题" class="headerlink" title="Cache 性能例题"></a>Cache 性能例题</h2><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521222845268.png" alt="image-20250521222845268" style="zoom:50%;" />

<h3 id="例题-5-1"><a href="#例题-5-1" class="headerlink" title="例题 5.1"></a>例题 5.1</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521222858450.png" alt="image-20250521222858450" style="zoom: 50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521222909212.png" alt=" " style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521222921303.png" style="zoom:50%;" />

<h3 id="例题-5-2"><a href="#例题-5-2" class="headerlink" title="例题 5.2"></a>例题 5.2</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521222936896.png" alt="image-20250521222936896" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521222944644.png" alt="image-20250521222944644" style="zoom:50%;" />

<h3 id="例题-5-3"><a href="#例题-5-3" class="headerlink" title="例题 5.3"></a>例题 5.3</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521222958536.png" alt="image-20250521222958536" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521223007219.png" alt="image-20250521223007219" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521223018048.png" alt="image-20250521223018048" style="zoom:50%;" />

<h2 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h2><ul>
<li>写直达法（write through） 执行“写”操作时，不仅写入Cache，而且也写入 下一级存储器。<ul>
<li>写失效时，直接写入下一级存储器，不调块。（no allocation）</li>
<li>速度快，所使用的存储器带宽较低。</li>
<li>采用写直达法时，若在进行“写”操作的 过程中CPU必须等待，直到“写”操作结 束，则称CPU写停顿。 减少写停顿的一种常用的优化技术是写缓冲器。</li>
<li><a href="#write-combine">写缓冲器合并</a></li>
</ul>
</li>
<li>写回法（write back） 执行“写”操作时，只写入Cache，标记脏位。仅当Cache中相应的块被置换时，才写回主存。 (设置“脏位”)<ul>
<li>写失效时，先把所写单元所在的块调入Cache， 再写cache，标记脏位。（with allocation）</li>
<li>易于实现，一致性好。</li>
</ul>
</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521222057245.png" alt="image-20250521222057245" style="zoom: 50%;" />

<h2 id="查找、替换算法"><a href="#查找、替换算法" class="headerlink" title="查找、替换算法"></a>查找、替换算法</h2><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521221844613.png" alt="image-20250521221844613" style="zoom: 33%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521221909067.png" alt="image-20250521221909067" style="zoom: 33%;" />

<h2 id="优化技术总结"><a href="#优化技术总结" class="headerlink" title="优化技术总结"></a>优化技术总结</h2><p>“＋”号：表示改进了相应指标。  “－”号：表示它使该指标变差。 空格：表示它对该指标无影响。 复杂度：0表示最容易，3表示最复杂。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521213839515.png" alt="image-20250521213839515" style="zoom: 33%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521213855039.png" alt="image-20250521213855039" style="zoom:33%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521213908725.png" alt="image-20250521213908725" style="zoom:33%;" />



<h2 id="降低失效率"><a href="#降低失效率" class="headerlink" title="降低失效率"></a>降低失效率</h2><p>三种失效：冲突失效、强制失效、容量失效。（Conflict、Compulsory、Capacity）</p>
<ul>
<li>强制：当第一次访问一个块时，该块不在Cache中，需从 下一级存储器中调入Cache，这就是强制性失效。 (冷启动失效，首次访问失效）<ul>
<li>解决：<u>增加块大小</u>、<u>硬件预取Prefetch</u>.</li>
<li><em>增加块大小会增加命开销</em></li>
</ul>
</li>
<li>容量：如果程序执行时所需的块不能全部调入Cache中， 则当某些块被替换后，若又重新被访问，就会发 生失效。这种失效称为容量失效。<ul>
<li>解决：<u>增加容量</u></li>
</ul>
</li>
<li>冲突：在组相联或直接映象Cache中，若太多的块映 象到同一组(块)中，则会出现该组中某个块被别 的块替换(即使别的组或块有空闲位置)，然后又 被重新访问的情况。这就是发生了冲突失效。 (碰撞失效，干扰失效) <ul>
<li>解决：<u>提高相联度</u>，理想情况是全相联。</li>
<li><em>增加相连度会增大命中时间</em></li>
</ul>
</li>
</ul>
<ol>
<li>大小为N的直接映象Cache的失效率约等于 大小为N/2的两路组相联Cache的失效率。</li>
<li>大小为N的<u>伪相联</u>和两路组相联的失效率相当。在逻辑上把直接映象Cache的空间上下平分为两个区。对于任何一 次访问，伪相联Cache先按直接映象Cache的方式去处理。若命中， 则其访问过程与直接映象Cache的情况一样。若失效，则再到另一区 相应的位置去查找。若找到，则发生了伪命中，否则就只好访问下一 级存储器。</li>
</ol>
<p>**<u>硬件预取</u>**：</p>
<p>预取：假设从预取缓冲器中找到所需指令需多花1个 时钟周期。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521223203358.png" alt="image-20250521223203358" style="zoom: 33%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521223228700.png" alt="image-20250521223228700" style="zoom:33%;" />

<p><u>编译器预取</u>、<u>编译器优化</u>：内外循环交换。</p>
<p>**<u>牺牲Cache</u>**：一种能减少冲突失效次数而又不影响时钟频 率的方法。 </p>
<p>基本思想：在Cache和它从下一级存储器调数据的通路之间设置一个全相联的小Cache，称为“牺牲”Cache（Victim Cache）。用于存放被替换出去的块(称为牺牲者)，以备重用。 对于减小冲突失效很有效，特别是对于小容 量的直接映象数据Cache，作用尤其明显。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521223451357.png" alt="image-20250521223451357" style="zoom:50%;" />

<h2 id="降低失效开销"><a href="#降低失效开销" class="headerlink" title="降低失效开销"></a>降低失效开销</h2><p>“子块放置技术”</p>
<ol>
<li><p><u>两级Cache</u>：第一级小而快，第二级容量更大。</p>
<ol>
<li>平均访存时间＝命中时间T1＋失效率F1 × 失效开M1 </li>
<li>失效开销M1＝命中时间T2＋失效率F2 × 失效开销M2</li>
<li>局部失效率：F1, F2  全局失效率 = F1 × F2</li>
<li>因此，平均访存时间 = T1 + F1 × T2 + F2 × M2</li>
</ol>
<p>当第二级Cache比第一级Cache大得多时， 两级Cache的全局失效率与容量和第二级 Cache 相同的单级Cache的失效率非常接近。</p>
</li>
</ol>
<h3 id="例-二级cache"><a href="#例-二级cache" class="headerlink" title="例 二级cache"></a>例 二级cache</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521215829463.png" alt="image-20250521215829463" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521215842673.png" alt="image-20250521215842673" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521215853347.png" alt="image-20250521215853347" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521215901791.png" alt="image-20250521215901791" style="zoom:50%;" />

<hr>
<ol start="2">
<li><strong>写缓冲合并</strong>，<span id="write-combine">提高写缓冲器的效率</span>。写直达Cache：依靠写缓冲来减少对下一级存储器写操作的时间。<ol>
<li>如果写缓冲器为空，就把数据和相应地址写入该缓冲器。 从CPU的角度来看，该写操作就算是完成了。</li>
<li>如果写缓冲器中已经有了待写入的数据，就要把这次的 写入地址与写缓冲器中已有的所有地址进行比较，看是 否有匹配的项。如果有地址匹配而对应的位置又是空闲 的，就把这次要写入的数据与该项合并。这就叫写缓冲合并。</li>
<li>如果写缓冲器满且又没有能进行写合并的项，就必须等待。</li>
</ol>
</li>
</ol>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521220447088.png" alt="image-20250521220447088" style="zoom:33%;" />



<ol start="3">
<li><strong>读失效优先于写</strong>。在读失效时，所读单元的最新值有可能还在Cache的写缓冲器中，尚未写入 主存。<ol>
<li> 推迟对读失效的处理 （缺点：读失效的开销增加）</li>
<li>检查写缓冲器中的内容</li>
</ol>
</li>
<li><strong>请求字处理</strong>。</li>
</ol>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521220110734.png" alt="image-20250521220110734" style="zoom:50%;" />

<ol start="5">
<li><strong>非阻塞Cache</strong>。Cache失效时仍允许CPU 进行其它的命中访问。即允许“失效下命中”。对于整数程序来说，重叠次数对性能提高影响不大，简 单的“一次失效下命中”就几乎可以得到所有的好处。最大的好处就是不影响<u>命中时间</u></li>
</ol>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521220225230.png" alt="image-20250521220225230" style="zoom:33%;" />

<h3 id="例-一次失效命中和组相联"><a href="#例-一次失效命中和组相联" class="headerlink" title="例 一次失效命中和组相联"></a>例 一次失效命中和组相联</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521220304904.png" alt="image-20250521220304904" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521220340533.png" alt="image-20250521220340533" style="zoom:50%;" />



<h2 id="减少命中时间"><a href="#减少命中时间" class="headerlink" title="减少命中时间"></a>减少命中时间</h2><p>命中时间直接影响到处理器的时钟频率。在当今的许多计算机中，往往是Cache的访问时间限制了处理器的时钟频率</p>
<ol>
<li><p>容量小、结构简单的Cache。<em>会增大失效率</em></p>
</li>
<li><p>虚拟Cache：可以直接用虚拟地址进行访问的Cache。tag 存储器中存放的是虚拟地址，进行地址检测用的也是虚拟地址。</p>
<ol>
<li>传统：虚拟地址先通过 MMU 转换成物理地址，再访问物理cache，串行。</li>
<li>在命中时不需要地址转换，省去了地址转换的 时间。即使失效，地址转换和访问Cache也是 并行进行的，其速度比物理Cache快很多。</li>
</ol>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521214559365.png" alt="image-20250521214559365" style="zoom:33%;" /></li>
<li><p>Cache访问流水化。提高时钟频率。并不能真正减少cache的命中时间，但可以提高访问Cache的带宽。访问Cache需要多个时钟周期才可以完成</p>
</li>
<li><p>踪迹 Cache。存放CPU所执行的动态指令序列，能够提高指令Cache的空间利用率， 地址映象机制复杂，相同的指令序列有可能被当作条件分支的不同选择而 重复存放</p>
</li>
</ol>
<hr>
<h1 id="体系结构基本概念"><a href="#体系结构基本概念" class="headerlink" title="体系结构基本概念"></a>体系结构基本概念</h1><h2 id="冯诺依曼、存储程序计算机"><a href="#冯诺依曼、存储程序计算机" class="headerlink" title="冯诺依曼、存储程序计算机"></a>冯诺依曼、存储程序计算机</h2><ul>
<li>冯诺依曼：存储程序计算机 (运算器、存储器、IO、控制器)<ul>
<li><u>以运算器为中心</u></li>
<li><u>控制流由指令流产生</u>，分解程序指令，形成控制上述部件的控制流。</li>
<li>存储程序的原理。<u>程序和数据在同一存储器</u><ul>
<li>局部性原理，时间/空间局部性。</li>
<li>信息按照边界存储：访存速度快</li>
</ul>
</li>
<li><u>存储器是按照地址访问，线性编址的空间。</u><ul>
<li>字节编址可以支持非数值型计算</li>
</ul>
</li>
<li><u>操作码+地址码 = 指令</u></li>
<li>数据使用<u>二进制编码</u>表示，采用<u>二进制</u>运算</li>
<li>加工运算数据，形成了数据流</li>
<li>取指、译码、取数、运算、写回</li>
</ul>
</li>
</ul>
<h2 id="计算机体系结构的概念"><a href="#计算机体系结构的概念" class="headerlink" title="计算机体系结构的概念"></a>计算机体系结构的概念</h2><ul>
<li><p>计算机体系结构是<u>程序员</u>所看到的计算机的属性，即<u>概念性结构</u>与<u>功能特性</u>。</p>
</li>
<li><p>计算机系统分层、程序员分层，所以<u>体系结构</u>也分层</p>
</li>
<li><p><strong>体系结构概念的实质</strong>：计算机系统中软硬件界面的确定，其界面之上的是软件的功能，界面之下的是硬件和固件的功能。中间向两边，体系结构就是中间，“中间”：层次结构中的<u>软硬件的交界面</u>，目前一 般是在传统机器语言机器级与操作系统机器级之间</p>
</li>
<li><p>计算机组成包括机器级内部的（数据流）和（控制流）的组成以及逻辑设计等。</p>
</li>
<li><p>系统结构、组成、实现</p>
<ul>
<li><u>计算机系统/体系结构</u>是系统的软硬件的界面</li>
<li><u>计算机组成</u>是系统结构的逻辑实现。</li>
<li><u>计算机实现</u>是组成的物理实现</li>
</ul>
</li>
<li><p>同一系统结构可以有不同的组成，同一组成可以有多种实现方式，指令集架构相同。只要是同一系统结构就是<u>系列机</u>，前提是一个厂家生产的。<u>向后兼容</u>必须做到，力争<u>向上兼容</u></p>
</li>
<li><p>软件实现的机器是<u>虚拟机</u></p>
</li>
</ul>
<h3 id="透明"><a href="#透明" class="headerlink" title="透明"></a>透明</h3><ul>
<li>低层次的机器属性对于高层次机器的程序员是 <strong>透明的</strong><ul>
<li>机器语言程序员看到的是编程的硬件组织。</li>
<li>浮点数据表示、乘法指令对于高级语言是透明的，对汇编人员不透明</li>
<li>数据总线宽度、微程序对机器、汇编语言透明，但是对硬件设计人员不透明</li>
<li>指令缓冲器对于系统结构透明</li>
</ul>
</li>
<li>应用、高级、汇编、OS、机器、微程序（逻辑程序员）、硬布线逻辑（硬件设计员）   OS 和机器之间就是系统结构</li>
</ul>
<h3 id="软件移植"><a href="#软件移植" class="headerlink" title="软件移植"></a>软件移植</h3><ul>
<li>一个软件可以<u>不经过修改或者少量修改</u>就能在另一台机器上运行，<u>结果相同，时间区别</u>。</li>
<li>使软件能在具有不同系统结构的机器之间 相互移植。 在一种系统结构上实现另一种系统结构。 从指令集的角度来看，就是要在一种机器上 实现另一种机器的指令集。</li>
<li>三种方式：<ul>
<li><u>统一高级语言</u>。缺点：需要争取汇编和机器语言的统一</li>
<li><u>模拟与仿真</u>：用于<u>不同系统结构</u>的机器<ul>
<li><strong>模拟</strong>：用软件的方法在一台现有的机器（ 称为宿主机）上实现另一台机器（称为虚 拟机）的指令集。 <u>机器模拟机器</u></li>
<li><strong>仿真</strong>：用一台现有机器（宿主机）上的微 程序去解释实现另一台机器（目标机）的 指令集。<u>微程序解释机器</u>，更快，要求系统结构差距不大。</li>
<li>缺点：结构差异比较大，效率低下</li>
</ul>
</li>
<li><u>系列机</u>：用于<u>相同系统结构</u>的机器<ul>
<li>缺点 汇编语言兼容的情况下系统结构发展有限</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="并行分类"><a href="#并行分类" class="headerlink" title="并行分类"></a>并行分类</h1><p><strong>并行概念</strong>：同一时刻/时间间隔内，完成两种或者两种以上的工作。（性质相同或者不相同）</p>
<ul>
<li>指令级并行</li>
<li>线程级并行</li>
<li>任务级/过程级并行：基本单元：进程、子程序</li>
</ul>
<p><strong>提升并行性</strong>：</p>
<ul>
<li><strong>时间重叠</strong>：时间片轮转【流水线处理机】</li>
<li><strong>资源重复</strong>：重复设置硬件资源（GPU 阵列处理机 多操作部件）</li>
<li><strong>资源共享</strong>：这是一种软件方法，它使多个任务按一定时间顺序轮流使用同 一套硬件设备。分时系统。</li>
<li><strong>单处理机</strong>：时间重叠（部件功能专一）、资源重复（多体存储器、多操作部件、阵列处理机）、资源共享（虚拟机、分时系统）</li>
</ul>
<p><strong>Flynn 数据并行、指令并行</strong>：</p>
<ul>
<li><p><strong>SISD</strong>：单核CPU</p>
</li>
<li><p><strong>MISD</strong>：少见</p>
</li>
<li><p><strong>SIMD</strong>：GPU（阵列处理机）、向量处理机。指令操作级并行</p>
<ul>
<li>阵列处理机：（分布式）存储器阵列   （集中式共享）存储器阵列</li>
</ul>
</li>
<li><p><strong>MIMD</strong>：多处理机。</p>
<ul>
<li>多机系统耦合度有<u>松、紧耦合</u>两大类。</li>
<li>同构型多处理机、异构型多处理机、分布式系统。</li>
<li>共享内存 SMP：多核CPU、SPARC。共享物理内存（受限于带宽，核心数有限）</li>
<li>分布式内存 MPP：分布式计算、超算。每个处理器都有自己的本地内存，通过消息传递来进行通信（共享开销大、复杂)</li>
</ul>
</li>
</ul>
<hr>
<h1 id="指令集结构"><a href="#指令集结构" class="headerlink" title="指令集结构"></a>指令集结构</h1><h2 id="CISC-RISC"><a href="#CISC-RISC" class="headerlink" title="CISC/RISC"></a>CISC/RISC</h2><ul>
<li><p><strong>RISC:</strong> </p>
<ul>
<li>指令长度固定，指令格式种类少，寻址方式少；</li>
<li>只使用LOAD STORE访存，通用寄存器较多；</li>
<li>流水线技术，一个时钟周期内完成一条指令；</li>
<li>控制器运用组合逻辑。</li>
<li>RISC利用VLSI芯片的面积，便于设计，降低成本，提高可靠性，但是不容易实现指令系统的兼容</li>
</ul>
</li>
<li><p><strong>CISC:</strong> </p>
<ul>
<li>指令庞杂复杂，指令使用频度相差悬殊，长度不固定，种类多。不利于用先进的体系结构技术提高性能，研制成本巨大</li>
<li>很多指令可以访存，CPU有专用寄存器</li>
<li>大部分指令都需要多个时钟周期完成</li>
<li>采用微程序控制。</li>
<li>不利于 VLSI设计和单片集成，但是兼容性很强</li>
</ul>
</li>
<li><p>值得注意的是，从指令系统兼容性看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但RISC简化了指令系统，指令条数少，格式也不同于老机器，因此大多数RISC机不能与老机器兼容。由于 RISC 具有更强的实用性，因此应该是未来处理器的发展方向。</p>
</li>
<li><p>但事实上，当今时代 x86 几乎一统江湖，且早期很多软件都是根据CISC 设计的，单纯的RISC将无法兼容。此外，现代CISC结构的CPU已经融合了很多RISC的成分，其性能差距已经越来越小。CISC可以提供更多的功能，这是程序设计所需要的。</p>
</li>
</ul>
<p><strong>RISC</strong>：<u>重叠寄存器窗口技术</u> 可以减少 <u>CALL(过程调用) 和 RETURN(返回指令)</u> 的执行时间。通过设置大量寄存器，将其分为多个组和全局区，每个组分为高区、<u>本地</u>区、低区，相邻的高低区重叠，加速<u>参数(对应call)和结果(对应return)</u>的传递。</p>
<p><strong>RISC-V</strong>: 寄存器寻址、立即数、偏移寻址、寄存器间接寻址</p>
<ul>
<li>R：寄存器寻址，数存在寄存器里</li>
<li>I：立即数寻址，其中一个操作是立即数</li>
<li>S：存储指令（将寄存器值存入内存），立即数用于地址偏移。</li>
<li>U：将高20位立即数加载到寄存器的高位，用于构造大常数或地址。<ul>
<li><strong>AUIPC</strong>（Add Upper Immediate to PC）：用于PC相对寻址（如跳转或全局数据访问）。</li>
</ul>
</li>
<li>B：条件分支</li>
<li>J：无条件跳转</li>
</ul>
<h2 id="操作数表示、操作数类型"><a href="#操作数表示、操作数类型" class="headerlink" title="操作数表示、操作数类型"></a>操作数表示、操作数类型</h2><ul>
<li><p>操作数表示：<u>计算机硬件能够直接识别、指令集可以直接调用</u>的数据类型。一般是所有数据类型中最常用、相对比较简单、用硬件实现比较容易的几种。</p>
<ul>
<li>引入数据表示的原则：<strong>缩短运行时间</strong>、减少 CPU和主存的通信量、通<strong>用性和利用率</strong>如何？</li>
<li>分为<u>定点、逻辑、浮点</u> 三种类型</li>
<li><strong>如何确定数据表示（软硬件取舍折中问题）</strong></li>
</ul>
</li>
<li><p>操作数类型： <u>由软件进行处理和实现</u>的各种数据类型。研究的是这些数据类型的逻辑结构和物理结构之间的关系并给出相应算法。</p>
</li>
<li><p><strong>操作数类型</strong>的表示：或者寻址类型</p>
<ul>
<li><strong>由操作码编码制定</strong><ul>
<li>好：字段少、简单</li>
<li>坏：指令条数增多，译码复杂</li>
</ul>
</li>
<li><strong>使用带标志符的数据类型</strong>（数据附上硬件解释的标记）<ul>
<li>好：简化指令系统设计，便于开发，支持数据类型于系统实现无关</li>
<li>坏：增加指令的字段数，操作数字段占用更多的位数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="指令集架构类型"><a href="#指令集架构类型" class="headerlink" title="指令集架构类型"></a>指令集架构类型</h2><ul>
<li>CPU 存放操作数的地方：<u>堆栈、累加器、通用寄存器</u></li>
<li>大多数通用型指令寄存器架构可以分为：</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521195708729.png" alt="image-20250521195708729" style="zoom: 50%;" />

<h2 id="指令格式：哈夫曼编码、扩展编码"><a href="#指令格式：哈夫曼编码、扩展编码" class="headerlink" title="指令格式：哈夫曼编码、扩展编码"></a>指令格式：哈夫曼编码、扩展编码</h2><p>指令格式的优化：如何用最短的位数来表示 指令的操作信息和地址信息。</p>
<ul>
<li><strong>哈夫曼编码</strong></li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521200908875.png" alt="image-20250521200908875" style="zoom: 50%;" />

<ul>
<li>信息熵: </li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521200757693.png" alt="image-20250521200757693" style="zoom:50%;" />

<ul>
<li>信息冗余量 = （平均码长 - 信息熵）/ 平均码长</li>
<li>可以减少操作码的平均位数，但所获得的编码是变长的，不规整，不利于硬件处理。</li>
<li><strong>扩展操作码</strong>：位于定长二进制编码和哈夫曼编码之间的一种编码 方案。 </li>
<li>采用有限几种固定长度的码长，仍然采用高概率的用短码、低概率用长码的哈夫曼压缩思想，使操作码平均长度缩短。 </li>
<li>接近全哈夫曼码的码长，具有定长码的规整性。</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521202254289.png" alt="image-20250521202254289" style="zoom:50%;" />

<p>图中的 3/3/3 表示，分成三组，那么就可以有三种长度，按照频率从高到低，3*3。</p>
<p>2/7同理，有两种长度，按照频率从高到低2+7。前面频率高的只需要两位就能区分了，因此是00和01 </p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521201332108.png" alt="image-20250521201332108" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521201521111.png" alt="image-20250521201521111" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521201531312.png" alt="image-20250521201531312" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250521201541376.png" alt="image-20250521201541376" style="zoom:50%;" />



<p><u>8位寄存器-寄存器型二地址指令3条</u></p>
<ul>
<li><strong>指令长度</strong>：8位（单字长）。</li>
<li>字段分配：<ul>
<li><strong>操作码（OP）</strong>：2位，用于区分3条指令。</li>
<li><strong>源寄存器（R1）</strong>：3位，支持8个通用寄存器（23=8）。</li>
<li><strong>目的寄存器（R2）</strong>：3位，与源寄存器编码方式相同。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| OP (2) | R1 (3) | R2 (3) |</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>指令1</strong>：<code>00</code> → 如加法指令 <code>ADD R1, R2</code></li>
<li><strong>指令2</strong>：<code>01</code> → 如减法指令 <code>SUB R1, R2</code></li>
<li><strong>指令3</strong>：<code>10</code> → 如逻辑与指令 <code>AND R1, R2</code></li>
</ul>
<p><u>16位寄存器-寄存器变址寻址指令4条</u> </p>
<ul>
<li><strong>指令长度</strong>：16位（双字长）。</li>
<li>字段分配：<strong>有效地址 = 变址寄存器内容 + 指令中给定的偏移量</strong><ul>
<li><strong>操作码（OP）</strong>：4位，用于区分4条指令。</li>
<li><strong>通用寄存器（R）</strong>：3位，支持8个通用寄存器。</li>
<li><strong>变址寄存器（V）</strong>：1位，支持2个变址寄存器（21=2）。</li>
<li><strong>偏移地址（Offset）</strong>：8位，满足变址范围 <strong>-127~+127</strong>（8位补码表示）。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| OP (4) | R (3) | V (1) | Offset (8) |</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>指令1</strong>：<code>1100</code> → 如取数指令 <code>LDA R, [V+Offset]</code></li>
<li><strong>指令2</strong>：<code>1101</code> → 如存数指令 <code>STA R, [V+Offset]</code></li>
<li><strong>指令3</strong>：<code>1110</code> → 如跳转指令 <code>JMP R, [V+Offset]</code></li>
<li><strong>指令4</strong>：<code>1111</code> → 如条件跳转指令 <code>JNZ R, [V+Offset]</code></li>
</ul>
<hr>
<h1 id="流水线、指令级并行"><a href="#流水线、指令级并行" class="headerlink" title="流水线、指令级并行"></a>流水线、指令级并行</h1><p>数据相关<u>不一定</u>都能用定向技术解决</p>
<p>多条向量指令之间不存在 <u>源向量寄存器冲突</u> 和 <u>功能部件冲突</u>，且只有 向量寄存器 的 <u>写后读相关</u>，那么可以通过<u>链接</u>技术实现这些指令的并行处理。</p>
<ol>
<li><p><strong>数据相关</strong>（Data Hazards）前一条指令还未写回结果，后一条指令就尝试使用了该结果。</p>
<ul>
<li>数据相关（数据冒险）：RAW、WAW、WAR。 DLX流水线是<u>RAW</u></li>
<li><strong>解决方法</strong>：前递或旁路（Forwarding，<strong>定向技术</strong>的原理【RAW】，减少 stall）、插入 NOP、使用 stall 等、。</li>
<li>RAW：在流水线中，不同指令同时处于不同阶段，如果一条指令还没将结果写回，下一条指令却已经开始读取这个结果，就会出现错误。前一条指令的结果是后一条的操作数。</li>
<li>定向技术用于解决流水线中的数据冒险问题，尤其是 RAW 类型，通过直接在流水线阶段间传递数据（直接从EX传递给后一条指令），减少或避免插入气泡，提高了性能。</li>
</ul>
</li>
<li><p><strong>控制相关</strong>（Control Hazards）例如<u>分支指令</u>（如 <code>beq</code>）执行时，下一条指令该不该执行不确定。</p>
<ul>
<li><strong>解决方法</strong>：<u>延迟分支</u>、<u>分支预测</u>、静态猜测等。</li>
</ul>
</li>
<li><p><strong>结构相关</strong>（Structural Hazards）<u>硬件资源</u>（如内存）被多个阶段同时访问产生冲突。</p>
<ul>
<li><strong>解决方法</strong>：使用独立的指令/数据 Cache、增加资源。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/18/git-usage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/18/git-usage/" class="post-title-link" itemprop="url">git 使用总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-18 00:00:00 / 修改时间：21:59:32" itemprop="dateCreated datePublished" datetime="2025-05-18T00:00:00+08:00">2025-05-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>第一次从远端复制项目： <code>git clone</code> GUI</p>
<p>想让本地仓库关联到远程仓库：<code>git remote add</code> 远程-&gt;添加远程存储库</p>
<p>更改加到暂存区：<code>git add</code>   GUI</p>
<p>更改提交到本地仓库：<code>git commit -M &quot;first commit&quot;</code></p>
<p>从本地仓库将提交推送到远程仓库：<code>git push</code></p>
<p>合并 merge 保留分叉，在原来远端的分支生成一个新的 M 合并提交。</p>
<p>变基 rebase 合并成线性</p>
<p>在 <code>feature</code> 分支上执行 <code>git rebase main</code>，<code>feature</code> 分支的提交被重演到 <code>main</code>，形成新的提交，</p>
<p>从远端拉取：<code>git pull</code> 默认会采用 merge 合并的方式，加<code>--rebase</code>改用 rebase 变基形式</p>
<p>回滚更改：<code>git reset</code></p>
<p>抓取/获取：<code>git fetch</code> 获取远程最新的提交，但是不合并，仅仅用作查看进度。</p>
<p>最佳实践：</p>
<p>fetch查看远端更改，看一下提交的内容以及结构，然后就可以 pull，这里可以选择 merge 或者 rebase 两种方式，都可以，注意处理冲突情况，在本地合并好就可以push到远端了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/17/leetcode-hot-100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/17/leetcode-hot-100/" class="post-title-link" itemprop="url">力扣热题100速通</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-17 00:00:00 / 修改时间：20:47:39" itemprop="dateCreated datePublished" datetime="2025-05-17T00:00:00+08:00">2025-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>转载自 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/458506664">力扣热题100 速通指南 - 小范同学</a> </p>
<p>思路总结，用于复习。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></p>
<p>解法1：暴力遍历 O(N^2)</p>
<p>解法2：字典。每遍历到一个数，先找目标值在不在字典里。若在，返回；若不在，当前数加入字典。</p>
<p>解法3：排序 + 双指针 O(nlogn)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></p>
<p>循环 while l1 or l2，adder1 = l1.val if l1 else 0，adder2也这样操作。循坏外设carry=0，当前位res = (adder1 + adder2) % 10，carry = (adder1 + adder2) // 10，新建一个节点保存当前res，后移。退出循环后如果有carry位就新建一个节点，如果没有就算。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p>
<p>同<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></p>
<p>解法1：dp+字典</p>
<p>dp[i]表示以i结尾的最长不含重复字符的子字符串，字典记录字符s[i]上一次出现的位置下标（如果没有出现过，默认值-1）。特别注意，<strong>是上一次出现</strong>，不是上一次在滑动窗口中出现，虽然我们也可以用i - dp[i-1]得到左端点，但这样比较麻烦。</p>
<p>判断上一次出现的位置是否在滑动窗口中：i-dict[i] &gt; dp[i-1]。前面这个数是[上一个s[i], s[i-1]]的长度，它大于dp[i-1]说明上一个s[i]在dp[i-1]左端点的左边</p>
<p>转移方程：</p>
<blockquote>
<p>下面这样写是不对的，因为dict应该是上一次出现，而不是上一次在滑动窗口中出现。<br>dp[i] = dp[i-1] + 1 if nums[i] not in dict<br>dp[i] = i - dict[nums[i]] if nums[i] in dict</p>
</blockquote>
<p>正确的转移方程</p>
<blockquote>
<p>dp[i] = dp[i-1] + 1 i-dict[i] &gt; dp[i-1]<br>dp[i] = i - dict[nums[i]] else</p>
</blockquote>
<p>完事更新hash表。最后输出dp[]最大值</p>
<p>解法2：双指针+字典，可以用双指针是因为我们发现右端点右移左端点也右移，有单调性。遍历right，left = max(left, dict[s.get(right, -1)]+1)，更新哈希表dict[s[right]] = right，更新结果res = max(res, right - left + 1)</p>
<p>ps. k神答案里给的左边界是开区间。</p>
<p>需要注意的是，由于ASCII码是0~127，所以两种解法空间复杂度是O(1)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></p>
<p>解法1：merge 时间空间都O(m+n)</p>
<p>解法2：二分查找 O(log(m+n)) TODO</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></p>
<p>解法1：dp（不推荐）<br>由于回文串必须要左右对称，很明显一个状态变量已经无法描述问题，所以使用二维dp。dp[i][j]表示字符串s[i,j]是否是回文串，转移方程是 P(i,j)=P(i+1,j−1)∧(Si​==Sj​)<br>边界条件：长度为1的子串是回文串，长度为2的看这两个字符是否相同<br>递推：从长度为1的开始<br>记录结果：只要dp[i][j] == True，比较长度，若为最长则记录长度和下标<br>时间空间都是O(N^2)，因为要给每个状态计算转移方程</p>
<p>解法2：中心扩展法（推荐）</p>
<ol>
<li>首先写一个中心扩展函数：输入扩展中心左右端点坐标，当左右端点相同时向外扩展，直到无法扩展时，输出最长扩展字串的左右端点</li>
<li>按照“串中每一个点”，“串中每相邻一对点”作为扩展中心，开始扩展，一旦返回的子串长度大于最大长度，将其记录下来。</li>
</ol>
<p>时间O(N^2)：长度为1的回文中心有n个，长度为2的回文中心有(n-1)个，每个回文中心最多向外扩展n次<br>空间O(1)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></p>
<p>由于是评估整个串是否匹配，使用动态规划。由于模式串和文本串各自有一个指针，所以应该是二维dp：</p>
<p>dp[i][j]表示文本串前i个位置，模式串前j个位置是否匹配。TODO</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></p>
<blockquote>
<p>注意这道题和<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a> 不同。本题是“板”，即相邻两板之间可以接水。42题是块，即相邻两块之间不能接雨水。这将引起x坐标计算的不同。</p>
</blockquote>
<p>这个问题是个具有单调性的问题，解法一定是首尾双指针。面积是(right - left) * min(height[left], height[right])</p>
<blockquote>
<p><strong>特别注意这里是right-left不是right-left+1</strong>，前者是right和left的间距，后者是left和right之间有几个数（包括端点）</p>
</blockquote>
<p>基本思想就<strong>是若向内移动长板，（由于min这部分要么变小要么不变）则面积一定缩小。若向内移动短板，它有可能变长，所以面积有可能变大。</strong></p>
<p>那么我们就不断移动短板，一直算面积，直到双指针汇聚，所有算过的这些面积里面最大的就是结果。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></p>
<p>TODO</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></p>
<p>标准试探回溯法</p>
<p>基本流程：找状态变量、明确退出条件、找选择列表、剪枝、做出选择并递归深入、撤销选择</p>
<p>这里首先来个map，记录每个数字对应的字符们</p>
<p>状态变量：电话号码的第几位curr。退出条件是curr=len(nums)，选择列表是迭代dict[curr]，不需要剪枝，做出选择是append当前字符并递归深入，撤销选择是pop当前元素</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></p>
<p>很简单，快慢双指针</p>
<p>需要注意的是退出条件。如果fast比slow快n步，fast是倒数第1个时slow是倒数第n个，此时fast.next==None，所以循环条件是while fast.next</p>
<p>另外一种方法比较取巧，链表头部弄个哑节点，slow从哑节点启动，循环条件为while fast，这时候fast比slow快(n+1)步</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></p>
<p>括号匹配问题。（由于需要倒序比较）使用栈。具体思路是：先建立一个左右括号匹配字典，遍历序列，如果遇到左括号就入栈，如果遇到右括号，若栈为空或者栈顶括号不与当前右括号匹配，返回false。最后来看栈是否为空。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></p>
<p>mergesort的合并一步。没什么难的，就是while l1 and l2: 拼接最小的到新链表，退出循环后if l1就把l1拼后面，if l2就把l2拼后面，最后return dummy.next</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></p>
<p>试探回溯法入门题。先回忆一下步骤：确定状态变量、确定退出条件 、确定选择列表、剪枝、做出选择并深入、撤销选择。</p>
<p>对这道题而言，由于我们要一个一个括号添加，而括号又分为左、右两种，因此以“左括号剩余个数”“右括号剩余个数”同时为状态变量。退出条件是左右括号个数均剩余为0。选择列表就是添加左括号or添加右括号。剪枝条件就是剩余左括号数大于剩余右括号数（说明已经摆放的右括号数大于已经摆放的左括号数），和剩余左右括号数小于0（说明有透支）</p>
<p>时间复杂度：取决于有多少个组合<br>空间复杂度：递归栈最深为2n，所以是O(n)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></p>
<p>方法1：以一个链表为结果链表，其他链表不断合并上来</p>
<p>方法2：类似数组归并排序一样，对所有链表头节点组成的数组分而治之，链表两两合并，最终得到一个大链表</p>
<p><strong>方法3（推荐）：</strong>使用堆。首先我们先把所有链表取出一个元素入堆（注意只有在if l的时候才入堆，要把空链表过滤掉），然后从堆里取出最值元素连在结果链表中，并将该元素的next节点入堆</p>
<p>需要注意的一点是，入堆的元素需要是(l.val, l_index, l)这种tuple，因为同值的时候堆会按照第二个元素排序，所以第二个位置要放index。第三个位置放节点本身，这是为了找他在链表中的next节点用。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></p>
<p>左边找一个较小数，右边找一个较大数，交换，排序交换后较大数的右侧。</p>
<p>具体而言：从右向左找第一个顺序对，其中较小那个就是我们需要的较小数。我们从这个数以右（从右向左，因为这个区间必然是大-&gt;小的）找第一个比他大的数，这个数就是较大数。交换这两个数，之后右边这个区间必然是逆序的，因此我们要翻转这个区间（首尾双指针）。</p>
<p>另外注意，对于已经是最大排列的这种情况，没有第一步和第二步，只有翻转区间。因此我们在做第一步和第二步的时候要先检验下标是否合法。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></p>
<p>这个题不同于剑指里的题，我们是搜索任意值target。但其基本思想一致，就是不断剔除单调区间。</p>
<p>TODO</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></p>
<blockquote>
<p>注意这道题和<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a> 不同。11题是“板”，即相邻两板之间可以接水。而这道题是块，即相邻两块之间不能接雨水。这将引起x坐标计算的不同。</p>
</blockquote>
<p>解法1：最值数组。加和每个位置正上方能接雨水的位置。发现一个规律，每个位置正上方能够接雨水的数量是min(left[i], right[i]) - height[i]。所以就是要先构建左起最大高度数组left、右起最大高度数组right。时间复杂度O(n)，空间复杂度O(n)</p>
<p>解法2：单调栈。逐层横向计算。利用单调栈，</p>
<p>解法3：双指针。</p>
<p>TODO</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></p>
<p>解法1：推公式（麻烦）</p>
<p>解法2：用翻转代替旋转。上下翻转一下，沿左上到右下的对角线翻转一下。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></p>
<p>dp。由于要连续，dp[i]表示以当前字母结尾的连续子数组最大和。那么状态转移方程就是看上一个位置的dp数组是否为正，从而决定子数组要不要之前的部分，还是从当前部分重新开始，即：</p>
<p>dp[i] = dp[i-1] + nums[i] if dp[i-1] &gt; 0<br>dp[i] = nums[i] else</p>
<p>另外注意一个技巧：我们可以在递推计算dp数组的同时记录数组最大值，这样就避免了重复遍历dp数组。最大值变量初始值可以置为-inf或者num[0]，注意不能置为0因为数组内可能全是负数。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></p>
<p>greedy TODO</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></p>
<p>排序+遍历。<strong>注意原始数组可能并不是有序的，因此先sort</strong>(nums, key=lambda elem:elem[0])，然后遍历。</p>
<ul>
<li>其实这里要用栈来处理，因为我们总是在修改最后一个元素。</li>
<li>遍历数据，如果栈不是空，pop出来一个元素，比较popped[1]和curr[0]，如果popped[1]&lt;curr[0]说明可以合并，新的左端点还是popped[0]，右端点是max(popped[1], curr[1])。</li>
<li>除此之外（即popped[1]&gt;=curr[0]），说明不能合并，直接把curr加到结果里</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></p>
<p>很明显是dp。由于每次只能爬1或2个台阶，dp[i] = dp[i-1] + dp[i-2]</p>
<p>需要注意的是边界条件。dp[0] = 0（没啥意义，数组里凑数的），dp[1] = 1，dp[2] = 2（因为不等于dp[0] + dp[1]）</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></p>
<p>方法1：暴力递归。这个问题很显然可以通过减而治之的方式化成规模更小的问题：</p>
<ul>
<li>递归基：只要有一个串是空，返回另一个串的长度max(len(word1), len(word2))</li>
<li>减而治之：<ul>
<li>如果两个串末尾字符相同：可以转化为两个串都去掉尾字符得到的子问题</li>
<li>如果两个串末尾字符不同：分为增（word2去掉尾）删（word1去掉尾）改（word1、word2都去尾）三种情况，那就是三个子问题中的最优者（min）得到的答案再+1</li>
</ul>
</li>
</ul>
<p><strong>方法2：动态规划（推荐）</strong></p>
<p>首先由于有两个串，长度还不一定一样长，应该是一个二维dp问题。dp[i][j]表示word1的前i个字符转变为word2的前j个字符需要的最小操作数。<br><strong>边界条件：</strong>如果一个字符串是空，答案就应是另一个字符串的长度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(len(word1)+1):</span><br><span class="line">    dp[i][0] = i</span><br><span class="line">for j in range(len(word2)+1):</span><br><span class="line">    dp[0][j] = j</span><br></pre></td></tr></table></figure>

<p>转移方程：和上面递归一样分为两种情况：</p>
<ul>
<li>两子串尾字符相同（表达成条件就是i&gt;0 and j &gt; 0 and word1[i-1] == word2[j-1]）：两串各去掉尾字符结果不变，因此dp[i][j] = dp[i-1][j-1]</li>
</ul>
<blockquote>
<p>注意这里的条件表达，dp[i][j]表示的是word1[0:i]与word2[0:j]（右边都是开区间），最后一个字符是word1[i-1]和word2[j-1]</p>
</blockquote>
<ul>
<li>两子串尾字符不同：增、删、改三种情况</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">creat = dp[i][j-1] + 1</span><br><span class="line">delete = dp[i-1][j] + 1</span><br><span class="line">update = dp[i-1][j-1] + 1</span><br><span class="line">dp[i][j] = min(creat, min(delete, update))</span><br></pre></td></tr></table></figure>

<p>返回：dp[-1][-1]</p>
<p>时间、空间复杂度都是O(mn)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></p>
<p>典型试探回溯。步骤：确定状态变量、确定结束条件、确定选择列表、剪枝、做出选择并递归深入、撤销选择</p>
<p>状态变量是在数组内的位置，结束不做任何事情（因为每个选择都需要被记录，因此一进递归函数就记录，注意要深拷贝），选择列表是当前字符后的所有字符，不需要剪枝，选择就是append，深入，撤销pop</p>
<p>复杂度？注意<strong>子集的数量是2^n</strong>，这是因为对于每个元素而言都有“在”和“不在”之一。我们每找到一个子集，需要O(n)时间将其拷贝进入结果，因此是O(n*2^n)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p>
<p>递归法就不说了</p>
<p>迭代法：</p>
<ul>
<li>特殊情况：空树直接返回</li>
<li>新建一个栈（用来保存待访问的根节点），新建一个curr节点并初始化为root（用来保存当前发现节点）</li>
<li>当栈不空或curr不空时循环<ul>
<li>如果curr节点存在，说明发现一个新节点，入栈并转向左子节点</li>
<li>否则，说明已经向左走到了尽头，此时从栈中pop出一个节点访问，并转向右子节点</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def inorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        if not root: return []</span><br><span class="line">        res = []</span><br><span class="line">        s = []</span><br><span class="line">        curr = root</span><br><span class="line">        while s or curr:</span><br><span class="line">            if curr:</span><br><span class="line">                s.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            else:</span><br><span class="line">                curr = s.pop()</span><br><span class="line">                res.append(curr.val)</span><br><span class="line">                curr = curr.right</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></p>
<p>该问题有最有子结构性质，因为以一个点为根节点的二叉搜索树数量，等于其不同的左子树数*不同的右子树数。因此只要让所有的点依次成为根节点，然后求和即可。</p>
<p>记G(i)为长度为i的序列有二叉搜索树的个数，则 G(i)=Σj=0iG(j−1)∗G(i−j)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def numTrees(self, n: int) -&gt; int:</span><br><span class="line">        G = [0] * (n+1)</span><br><span class="line">        G[0] = 1</span><br><span class="line">        G[1] = 1</span><br><span class="line">        for i in range(2, n+1):</span><br><span class="line">            for j in range(i+1): # 注意这里不能错，上面是加到n这里必须是i+1</span><br><span class="line">                G[i] += G[j-1] * G[i-j]</span><br><span class="line">        return G[n]</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p>
<p><strong>递归解法：</strong>记录中序遍历的前一个节点。全局变量self.pre = float(‘-inf’)，然后中序遍历。递归基返回True，进入左子树，当前节点比较，小于等于上一节点返回false，更新pre，进入右子树。递归回溯阶段返回左子树且右子树。<br>时间O(n)：因为每个节点最多被访问一次<br>空间O(n)：递归栈最深为整个树所有节点入栈（二叉树退化成链表）</p>
<p><strong>迭代解法：</strong>中序遍历迭代，记录上一个节点，在访问当前节点时作验证，且更新上一个节点！<br>时间O(n)：因为每个节点最多被访问一次<br>空间O(n)：栈最深为整个树所有节点入栈（二叉树退化成链表）</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></p>
<p><strong>递归法：</strong></p>
<p>双指针法。新定义一个递归函数，参数是两个指针。<br><strong>递归基：</strong>左右均空则返回true<br><strong>剪枝：</strong>左右一个空一个不空，或者左右值不相等返回false<br><strong>深入与回溯：</strong>深入左右，答案的and返回</p>
<p><strong>迭代法：</strong></p>
<p>层次遍历。当我们层次遍历的时候，一层的节点应该互为镜像。当一层只有两个节点的时候，他们应该相等。因此，如果我们层次遍历时对第一个节点的左右子节点正向入队，对第二个节点的左右子节点反向入队，则队列里相邻的两个节点都应该相等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode *u, TreeNode *v)</span> </span>&#123;</span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(u); q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            v = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!u &amp;&amp; !v) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((!u || !v) || (u-&gt;val != v-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(u-&gt;left); </span><br><span class="line">            q.<span class="built_in">push</span>(v-&gt;right);</span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(u-&gt;right); </span><br><span class="line">            q.<span class="built_in">push</span>(v-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<p>需要确定层，可以通过记录队列元素的做法。具体而言，可以利用双层循环，外层while queue，内层for _ in range(len(queue))，因此每打印完一层就会退出内层，就可以append结果。</p>
<p>记得<strong>from collections import deque</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p>
<p>法1：自上而下计算</p>
<p>法2：自下而上计算</p>
<p>法3：层次遍历</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></p>
<p>解法1：保存结果至列表，然后对结果列表的元素进行修改</p>
<blockquote>
<p>需要注意的是解法2和3中，需要开一个变量保存遍历序列中的上一个节点。<strong>我们每遍历到一个节点时，要连接这个节点和上一个节点</strong>（因为下一个节点尚未访问，修改它风险太大）。也就是说我们修改的是curr.left和prev.right。<br><strong>对于curr.left:</strong> 在本题中是先序遍历，肯定是不能修改curr.left的因为visit到当前节点时左节点还没被发现呢，但好在我们不需要做双向链表，只需要将left指针置空，因此我们每访问到一个节点将prev.left置空就可以了。<br><strong>对于prev.right:</strong> 由于是先序遍历，上一节点的right是还没被发现的，不能直接修改，所以需要先备份它</p>
</blockquote>
<p>解法2（推荐）–迭代先序遍历：在迭代版本压栈的时候，先压右再压左，prev.right的引用已经在栈里了，可以修改了</p>
<p>解法3（推荐）：递归先序遍历+存右节点引用：预先将prev.right的引用复制，因此可以修改。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></p>
<p>使用股票问题通解</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></p>
<p>解法1（暴力法，不合要求，仅提供思路）：<br>遍历序列，对每个元素num在序列中寻找num+1、num+2等，复杂度O(n^2)</p>
<p>解法2：集合hash（推荐）<br>上面的解法有两点可以改进：</p>
<ul>
<li>对于查找num+1、num+2 … 的方式，暴力遍历过于低效，可以使用哈希替代</li>
<li>不是每一个元素都需要成为查找的起点，只有每个连续序列的左端点应该成为查找起点。比如1234这个序列，以1开始查找234之后，就不要再以2开始查找34了。具体的办法就是仅有num-1不存在于序列中时（是连续序列左端点），才启动对num+1、num+2的查找</li>
</ul>
<p>所以具体做法就是：先把所有数加入set，然后开始对序列遍历，如果num-1在set中直接continue，否则开始记录长度并不断寻找num+1、num+2，直至num+n不在set中，此时将长度与最大长度对比</p>
<p>解法3：字典hash</p>
<p>basic idea：新来一个数，假如可以更新某个有序区间的长度，那一定与这个区间的端点相连。我们建立一个字典，字典中的每一个位置表示以该点为端点的区间最大的长度。</p>
<p>具体做法：新建一个<strong>空字典</strong>，遍历序列，如果序列中元素在字典里则跳过，否则计算该点造成的连续区间长度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left_len = mp.get(num-1, 0)</span><br><span class="line">right_len = mp.get(num+1, 0)</span><br><span class="line">total_len = left_len + right_len + 1</span><br></pre></td></tr></table></figure>

<p>然后更新左右端点的最大长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mp[num-left_len] = total_len</span><br><span class="line">mp[num] = total_len</span><br><span class="line">mp[num+right_len] = total_len</span><br></pre></td></tr></table></figure>

<p>然后比较该长度与最大长度</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></p>
<p>位运算 所有数字异或一遍，留下来的就是只出现一次的数字</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></p>
<p>本题只需要判断是否有环，不需要找环的位置</p>
<p>快慢指针：慢指针一次一步，快指针一次两步。如果有环，二者终会相遇。</p>
<p>注意循环条件是fast and fast.next因为fast每次走两步。而且如果fast.next不存在，说明也走到尽头了。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></p>
<p>要自己实现一个双向链表。需要功能：添加到首部（添加节点用到）、删除节点（移动时用到）、删除尾部（超出容量、移动节点时用到）、移动到首部（访问时用到）</p>
<p>TODO</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></p>
<p>dp。但需要注意，乘法不同于加法，一个负号就会使得最小值变成最大值。所以我们需要同时维护最小值数组和最大值数组。</p>
<p>fmax[i]表示前i个数的最大乘积，fmin[i]表示前i个数的最小乘积。<br><strong>边界条件：</strong>fmax[0]和fmin[0]都是nums[0]</p>
<p><strong>转移方程：</strong></p>
<ul>
<li>fmax[i]在fmax[i-1]*nums[i]、nums[i]、fmin[i-1]*nums[i]中取max</li>
<li>fmin[i]在fmax[i-1]*nums[i]、nums[i]、fmin[i-1]*nums[i]中取min</li>
</ul>
<p><strong>返回：</strong>max(fmax)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></p>
<p>双栈，一个存数据，一个存最小值，同步压栈弹栈</p>
<p><strong>简单方法：</strong>压栈时最小栈中压栈栈顶元素和将要入栈元素中的最小值。弹栈时最小栈和数据栈同时弹栈。</p>
<p><strong>复杂方法：</strong>压栈时只有待入栈元素小于等于栈顶元素时入栈。弹栈时如果待弹栈元素大于最小栈栈顶则最小栈不弹栈。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></p>
<p>解法1：栈</p>
<p>开两个栈，两个链表分别入栈。当栈顶元素相同时pop，不同时停止pop，最后一个弹出的元素就是交点。</p>
<p>解法2：双指针</p>
<p>p1和p2共同前进，一旦自己为空就进入另一个链表，直至p1==p2</p>
<p>解释：假设两链表的公共长度为c（可以为0），两链表本身长为a和b，公共节点为node（可以为none），那么p1和p2走到node时，各走了a-c+b和b-c+a，他们是相等的，所以一定是相遇了。此时返回p1或p2即可（如果没有交点，他们也同时为none）</p>
<p>循环条件是p1 != p2，return p1或者return p2都可以</p>
<blockquote>
<p>另外注意：<strong>要允许p1、p2为None</strong>。None的下一个再接另一个链表的头节点</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></p>
<p>摩尔投票。先判断为0，然后做加减。</p>
<p>具体实现：遍历整个数组，每个元素的处理分为两个部分，<strong>第一部分是majority的赋值，第二部分是票数的计算</strong>：</p>
<ul>
<li>majority的赋值：当票数为0时将majority的值赋为当前元素。</li>
<li>票数的计算：若当前元素==majority，则vote++，否则vote–</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></p>
<p>dfs/bfs/并查集</p>
<p>dfs：<br><strong>主函数：</strong>遍历整个矩阵，遇到1就count++，并发起一次dfs。<br><strong>dfs函数</strong>（只有一个作用就是尽可能多的把1置为0）：递归基：越界、当前是0，做出选择（当前位置置0），上下左右递归深入。</p>
<p>ps. 注意置为0之后就不再置回1了，以避免重复计数</p>
<p>bfs：关于bfs我们可以参考下这道题<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵</a> 。</p>
<blockquote>
<p>复习一下bfs的基本流程：首先找起点入队并标记发现状态启动bfs，然后队列中拿出一个节点作为当前节点，访问当前节点，<strong>将当前节点所有未发现的邻居入队并标记发现状态，同时标注邻居节点与当前节点的关系。</strong>所有节点有三种状态：未发现、已发现未访问（队列中，已标注发现状态）、已访问（所有邻居节点已入队，已标注当前节点与所有邻居节点的关系）</p>
</blockquote>
<p>TODO</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></p>
<p>因为要修改当前节点的next指针，因此需要备份下一个节点的引用。同时因为要把当前节点的next指针指向上一节点，因此需要备份上一节点prev。最后的时候curr为空，返回prev</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></p>
<p>虽然“第k”和“k个”看起来不同，但实际上等价于 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a> ，这是因为我们使用的是快排找轴点，轴点一侧的数必然比他大/小。</p>
<p>partition函数就是快排的partition。主函数可以按快排写，就是先partition再按照pivot递归二分（注意可以剪枝）。递归基是pivot==k（递归二分）。也可以直接迭代二分查找。partition函数在循环里，根据pivot与len-k的关系，做二分。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></p>
<p>易知，边长有最优子结构性质但面积没有。那么我们对变长dp，最后平方得面积。</p>
<p>二维dp，dp[i][j]表示位置(i, j)为右下角点的最大正方形边长。易知边界条件为第一排和第一列为1或0（取决于矩阵在该点的值），状态转移方程是当matrix[i][j] == 1时有dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1，当matrix[i][j]==0时dp[i][j] = 0</p>
<p><strong>注意这个转移方程要有三项！</strong>这是因为一个正方形左、上、左上三个位置有一个边长较小，都会影响到该正方形的边长。</p>
<p>相似题<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/">1277. 统计全为 1 的正方形子矩阵</a> 。这个题是求子矩阵的个数。特点在于，<strong>对于以(i, j)为右下角的最大正方形边长就等于以(i, j)为右下角的正方形子矩阵个数</strong>，那么最后我们把所有的dp[i][j]加起来就ok</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></p>
<p>选择任何一种遍历即可，visit当前节点时候把左右子树做下交换，然后按照正常遍历的方式进行递归，最后返回一下root</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></p>
<p>解法1：复制到数组中，首尾双指针</p>
<p>解法2：递归。但空间复杂度仍然没达标。</p>
<p>递归深入的目的是从后向前遍历，再开一个全局变量p（初始化为head）从前往后遍历。具体实现而言：</p>
<ul>
<li>递归基：当前节点为空，返回true</li>
<li>递归深入+剪枝：一旦上一层递归传出的结果是false，不再额外操作，直接返回false</li>
<li>剪枝：如果p的值和当前层指针的值不同，直接返回false</li>
<li>p前进</li>
<li>返回true</li>
</ul>
<p>解法3：<strong>翻转链表（推荐）</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></p>
<p>类似<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></p>
<p>其实就是快排的partition函数。partition函数有两种实现：快慢双指针和首尾双指针。由于需要保持相对顺序，那么只能用快慢双指针。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></p>
<p>这个题其实有难度。因为它要的是最长上升子序列的长度，新来一个字符他有可能跟之前的多个地方都构成新的上升子序列。所以直接dp需要两个for</p>
<p><strong>解法1：dp</strong>。dp[i]表示以nums[i]结尾的最长上升子序列长度。</p>
<ul>
<li><strong>初始化（边界条件）：</strong>每个数自己组成一个上升子序列，所以dp[i]=1</li>
<li><strong>状态转移：</strong>对于每一个数nums[i]，遍历j=0-&gt;i，如果nums[i]&gt;nums[j]说明能构成上升子序列且这个上升子序列结尾是nums[i]倒数第二个数是nums[j]，因此更新dp[i] = max(dp[i], dp[j]+1)</li>
<li><strong>最后返回：</strong>max(dp)</li>
</ul>
<p>解法2：贪心</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></p>
<p><strong>方法1：暴力遍历</strong></p>
<p>对每一个数都计算一下1的个数。具体计算的方法是，利用n&amp;(n-1)可以消除最低位的1</p>
<p>方法2：利用最高有效位做dp</p>
<p>方法3：利用最低有效位做dp</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></p>
<p>哈希计数：开一个长度为n的数组，遇到一个数就把他数组对应位置++，最后再遍历一遍这个数组，把为0的都添加到结果</p>
<p>原地哈希计数：由于最大为n，那么我们遇到一个数就可以把它%n的对应位置的数+n。那么只要出现过，对应位置的数必然&gt;n，那么我们就把&lt;=n的数下标全作为结果。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></p>
<p>异或，比特位计数</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></p>
<p>首先想到双指针，但其实不对，因为数组不是排序的。因此考虑使用<strong>前缀和数组</strong>。</p>
<p><strong>注意：快速实现滑动窗口累积值计算，要用前缀和数组！！！</strong></p>
<p>先弄一个前缀和数组pre。我们发现区间(i, j]等于k只需要pre[j] - pre[i] == k，这就成了两数之和问题。我们弄个字典来放该位置之前pre[]所有的取值，key是取值，value是个数。每次我们先累加结果，再把当前pre更新到dict中</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></p>
<p>这个题有个地方需要注意。当none了以后还需要访问其左右节点怎么办？答案是递归深入时做下判断。</p>
<p>递归基：两个树都为none。处理当前节点：新建一个node，如果指针1不为空，加指针1.如果指针2不为空，加指针2.递归深入：当前节点的左右引用=递归进入左右子树。注意只有当前节点存在时传入curr.left或curr.right，<strong>如果当前节点不存在，传入None。</strong>返回：返回当前刚新建的节点</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/447209490">小范同学：谈单调队列和单调栈</a> </p>
<p>单调栈。<strong>注意单调栈、单调队列里放的都是下标！！</strong></p>
<p>这道题求的是右边第一个更大值。用单调递增栈。</p>
<p>具体而言，回忆下单调栈流程：遍历数组：当栈不空，或者当前元素比新来元素小，循环弹出当前元素，标记当前元素的结果为新来元素下标-当前元素下标。循环退出后压栈当前元素下标。数组遍历完后，栈中元素依次弹栈，结果标记为0</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/16/example-consumer-producer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/16/example-consumer-producer/" class="post-title-link" itemprop="url">生产者-消费者(有界缓冲区)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-16 00:00:00 / 修改时间：22:53:32" itemprop="dateCreated datePublished" datetime="2025-05-16T00:00:00+08:00">2025-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedBuffer</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span>  <span class="operator">=</span> lock.newCondition(); </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition(); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> putptr, takeptr, count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E x)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">          notFull.await();</span><br><span class="line">        items[putptr] = x;</span><br><span class="line">        <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">        ++count;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">          notEmpty.await();</span><br><span class="line">        <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeptr];</span><br><span class="line">        <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">        --count;</span><br><span class="line">        notFull.signal();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/16/example-pub-sub/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/16/example-pub-sub/" class="post-title-link" itemprop="url">发布-订阅</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-16 00:00:00 / 修改时间：22:52:56" itemprop="dateCreated datePublished" datetime="2025-05-16T00:00:00+08:00">2025-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Event</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例事件类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageEvent</span> <span class="keyword">implements</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageEvent</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subscriber</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(T event)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件总线（中心）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt;, List&lt;Subscriber&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt;&gt;&gt; subscribers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Class&lt;T&gt; eventType, Subscriber&lt;T&gt; subscriber)</span> &#123;</span><br><span class="line">        subscribers.computeIfAbsent(eventType, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(T event)</span> &#123;</span><br><span class="line">        List&lt;Subscriber&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt;&gt; eventSubscribers = subscribers.get(event.getClass());</span><br><span class="line">        <span class="keyword">if</span> (eventSubscribers != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Subscriber&lt;? <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; sub : eventSubscribers) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Subscriber&lt;T&gt; typedSub = (Subscriber&lt;T&gt;) sub;</span><br><span class="line">                typedSub.onEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/14/408-%E8%AE%A1%E7%BD%91-HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/14/408-%E8%AE%A1%E7%BD%91-HTTP/" class="post-title-link" itemprop="url">HTTP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-05-14 00:00:00 / 修改时间：18:24:08" itemprop="dateCreated datePublished" datetime="2025-05-14T00:00:00+08:00">2025-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote class="blockquote-center"><a target="_blank" rel="noopener" href="https://hpbn.co/">High Performance Browser Networking</a></blockquote>

<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h2><p><strong>HyperText Transfer Protocol</strong> based on TCP port 80</p>
<p>TCP/IP 协议四层架构的最上层 规定了服务器和浏览器之间传输数据的规则</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">HTTP | MDN (mozilla.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h3 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h3><p><strong>超文本</strong>（英语：<strong>Hypertext</strong>）是一种可以显示在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E9%A1%AF%E7%A4%BA%E5%99%A8">电脑显示器</a>或其他<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E8%A3%9D%E7%BD%AE">电子设备</a>上的文本，普遍以<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E6%AA%94">电子文档</a>的方式存在，其中的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E5%AD%97">超文本</a>包含有可以链接到其他<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件</a>/<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A0%81%E9%9D%A2">文件页面</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E9%93%BE%E6%8E%A5">超链接</a>，允许从当前阅读的文字直接切换到超链接所指向的所有文字。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/4/41/Sistema_hipertextual.jpg"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>基于TCP，面向连接，安全</li>
<li>基于请求-响应模型：1Request1Response</li>
<li>HTTP是无状态协议，对事务处理没有记忆能力，每次RR都是独立的<ul>
<li>缺点：多次请求之间不能共享数据，用会话技术（cookie session）解决这个问题</li>
<li>优点：速度快，没有存储状态的开销</li>
</ul>
</li>
</ul>
<p>HTTP 协议基于 TCP 协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p>
<h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><p><strong>请求行</strong>：第一行，<code>GET</code>(请求方式) 后面的<code>/</code>表示请求资源的路径，HTTP/1.1表示协议版本</p>
<p><strong>请求头</strong>：第二行开始 key: value形式</p>
<p><strong>请求体</strong>：POST请求的最后一部分，存放请求参数</p>
<p>GET请求参数在请求行中，没有请求体，参数大小有限制(URL长度限制) POST请求的参数在请求体中，参数大小无限制</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926220614547.png" alt="image-20240926220614547"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926221417729.png" alt="image-20240926221417729"></p>
<p><strong>Host</strong>: 请求的主机名</p>
<p><strong>User-Agent</strong>: 浏览器版本</p>
<p><strong>Accept</strong>: 浏览器能接受的资源类型，如text/* image/* */* </p>
<p><strong>Accept-Language</strong>: 浏览器的偏好语言</p>
<p><strong>Accept-Encoding</strong>: 浏览器支持的压缩类型</p>
<h3 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h3><p><strong>响应行</strong>：响应数据的第一行，HTTP/1.1表示协议版本，下一个是响应状态码，OK表示状态码描述</p>
<p><strong>响应头</strong>：key value</p>
<p><strong>响应体</strong>：最后一部分，存放响应数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926221630980.png" alt="image-20240926221630980"></p>
<p><strong>Content-Type</strong>：响应内容类型，比如text/html image/jpeg</p>
<p><strong>Content-Length</strong>：响应内容长度（bytes）</p>
<p><strong>Content-Encoding</strong>：响应压缩算法 gzip等</p>
<p><strong>Cache-Control</strong>: 指示客户端如何缓存，例如max-age=300 表示最多缓存300s</p>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/http-status-codes.html">HTTP 常见状态码总结（应用层） | JavaGuide</a> </p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/http-status-code.png" alt="常见 HTTP 状态码" style="zoom:67%;" />

<h5 id="2xx-Success"><a href="#2xx-Success" class="headerlink" title="2xx Success"></a>2xx Success</h5><ul>
<li><mark>200 OK</mark>：请求被成功处理。例如，发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</li>
<li><strong>201 Created</strong>：请求被成功处理并且在服务端创建了一个新的资源。例如，通过 POST 请求创建一个新的用户。</li>
<li><strong>202 Accepted</strong>：服务端已经接收到了请求，但是还未处理。例如，发送一个需要服务端花费较长时间处理的请求（如报告生成、Excel 导出），服务端接收了请求但尚未处理完毕。</li>
<li><strong>204 No Content</strong>：服务端已经成功处理了请求，但是没有返回任何内容。例如，发送请求删除一个用户，服务器成功处理了删除操作但没有返回任何内容。（也就是 true or false）</li>
</ul>
<h5 id="3xx-Redirection"><a href="#3xx-Redirection" class="headerlink" title="3xx Redirection"></a>3xx Redirection</h5><ul>
<li><strong>301 Moved Permanently</strong>：资源被永久重定向了。比如你的网站的网址更换了。</li>
<li><strong>302 Found</strong>：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</li>
<li><strong>304 Not Modified</strong>：表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后，未曾被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。</li>
</ul>
<h5 id="4xx-Client-Error"><a href="#4xx-Client-Error" class="headerlink" title="4xx Client Error"></a>4xx Client Error</h5><ul>
<li><strong>400 Bad Request</strong>：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。</li>
<li><strong>401 Unauthorized</strong>：未认证却请求需要认证之后才能访问的资源。</li>
<li><strong>403 Forbidden</strong>：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。</li>
<li><strong>404 Not Found</strong>：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</li>
<li><strong>409 Conflict</strong>：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</li>
</ul>
<h5 id="5xx-Server-Error"><a href="#5xx-Server-Error" class="headerlink" title="5xx Server Error"></a>5xx Server Error</h5><ul>
<li><strong>500 Internal Error</strong>：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</li>
<li><strong>503 Service Unavailable</strong>：由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。</li>
<li><strong>502 Bad Gateway</strong>：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</li>
</ul>
<p>Java程序中，如果直接用自带的javawebsocketAPI 代码会变得异常繁琐，要注意请求和响应的格式要求，因此要用web服务器软件进行开发—-Tomcat</p>
<h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_interview.html#http-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF">HTTP 缓存</a></h3><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>响应头里有 <code>Cache-control</code>：提供了多种指令，用于精确控制缓存行为（时间段）。如 <code>max-age</code>、<code>no-cache</code>、<code>no-store</code>、<code>must-revalidate</code> 等。示例：<code>Cache-Control: max-age=3600</code>（资源有效期 3600 秒），其优先级高于 <code>Expires</code>（绝对时间）。</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小； </li>
<li>浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用本地缓存，否则重新请求服务器； </li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>
</ul>
<p>可以看到响应的结果 (from disk cache)。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1cb6bc37597e4af8adfef412bfc57a42.png" alt="img"></p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p><strong>协商缓存只有在未命中强制缓存的时候才能使用，因此必须依赖于 之前 Cache-control 的缓存。</strong></p>
<p>条件请求 Etag 的优先级高于 Last-Modified，因为 Last-Modified 是秒级粒度，而 Etag 更能准确判断是否被修改</p>
<ul>
<li>服务器响应中带上Last-Modified:x </li>
<li>客户端下次请求就带上If-Modified-Since:x</li>
<li>如果服务器看鉴定没有过期，回复一个HTTP 304 允许使用缓存，过期就回复HTTP 200发送最新数据。</li>
</ul>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png" alt="img" style="zoom: 50%;" />

<p>许多<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF">CDN</a>和网络设备制造商已经用动态缓存取代了这个标准的HTTP缓存控制。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/http-vs-https.html">HTTP vs HTTPS（应用层） | JavaGuide</a> </p>
<p><a href="https://scatteredream.github.io/2025/05/12/408-%E8%AE%A1%E7%BD%91-HTTPS/">HTTPS in one - scatteredream’s blog</a> </p>
<h1 id="HTTP-1-0-到-HTTP-3"><a href="#HTTP-1-0-到-HTTP-3" class="headerlink" title="HTTP/1.0 到 HTTP/3"></a>HTTP/1.0 到 HTTP/3</h1><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_interview.html#http-1-1%E3%80%81http-2%E3%80%81http-3-%E6%BC%94%E5%8F%98">HTTP/1.1、HTTP/2、HTTP/3 演变 - 小林 coding</a> </p>
<h2 id="早期版本"><a href="#早期版本" class="headerlink" title="早期版本"></a>早期版本</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>只支持 GET 请求，不支持请求头。</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>基本成型，支持富文本、请求头、状态码、缓存。第一个在通讯协议中使用版本号的协议，状态码、请求方式比较少。</p>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/http1.0-vs-http1.1.html">HTTP 1.0 vs HTTP 1.1（应用层） | JavaGuide</a> </p>
<h3 id="持久连接-默认开启-Connection-keep-alive"><a href="#持久连接-默认开启-Connection-keep-alive" class="headerlink" title="持久连接 (默认开启 Connection: keep-alive)"></a>持久连接 (默认开启 <code>Connection: keep-alive</code>)</h3><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/HTTP_persistent_connection.svg/2560px-HTTP_persistent_connection.svg.png" style="zoom:25%;" />

<p>在 HTTP 1.0 中，每次请求 - 响应完成后，连接就会被关闭。这意味着如果客户端需要再次请求服务器上的其他资源，就需要重新建立连接，而建立连接需要消耗额外的时间和资源，包括 DNS 查询、TCP 握手等过程。HTTP 1.0协议中并未定义持久连接的实现方式，但是一些服务端和客户端开始使用这种方式交互。如果浏览器支持keep-alive，它会在请求头添加<code>Connection: keep-alive</code> 服务器也会在响应头中添加相同的字段。</p>
<p>在HTTP 1.1中，除非任意一方在请求时明确声明不支持，否则所有的连接默认都是持续连接，即一次连接可以在多个请求 - 响应之间复用。这样可以显著减少连接建立的开销，提高性能，特别是对于包含多个资源的网页（如包含多个图片、脚本、样式表等），可以大大加快页面的加载速度。</p>
<h3 id="管道化-Pipelining"><a href="#管道化-Pipelining" class="headerlink" title="管道化 (Pipelining)"></a>管道化 (Pipelining)</h3><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/HTTP_pipelining.svg/2560px-HTTP_pipelining.svg.png" alt="undefined" style="zoom: 25%;" />

<p>HTTP 1.0 那样必须等待前一个请求的响应返回后才能发送新的请求。</p>
<p>在持久连接的基础上，HTTP 1.1 还支持管道化。管道化允许客户端在未收到前一个请求的响应时，就可以发送下一个请求。这样可以进一步提高效率，减少整体的请求 - 响应时间。例如，客户端可以连续发送多个对不同资源的请求，服务器按照请求的顺序依次响应，客户端可以在接收响应的同时继续发送新的请求，充分利用连接的带宽。长连接会复用一个 TCP 连接。</p>
<ul>
<li>服务端要遵循 HTTP/1.1 协议，必须按照客户端发送的请求顺序来回复请求。</li>
<li>一般又允许每个主机建立6个TCP连接，这样可以更加充分的利用带宽资源。</li>
<li>但每个连接中队头阻塞的问题还是存在的。这样整个连接还是先进先出的，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E">队头阻塞</a>（HOL blocking）可能会发生，造成延迟。</li>
</ul>
<h3 id="更好的缓存机制-Expires-Last-Modified-gt-Cache-Control-ETag"><a href="#更好的缓存机制-Expires-Last-Modified-gt-Cache-Control-ETag" class="headerlink" title="更好的缓存机制 (Expires,Last-Modified-&gt;Cache-Control,ETag)"></a>更好的缓存机制 (<code>Expires,Last-Modified-&gt;Cache-Control,ETag</code>)</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Thu, 01 Jan 1970 00:00:00 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 15 Jun 2022 12:00:00 GMT</span><br></pre></td></tr></table></figure>

<p>在 HTTP 1.0 中，主要通过<code>Expires</code>, <code>Last-Modified</code> , <code>If-Modified-Since</code> 实现缓存机制。服务器可以在响应头中设置<code>Expires</code>字段，指定资源的过期时间。客户端在请求资源时，会检查本地缓存中资源的过期时间。如果未过期，客户端就可以直接使用缓存中的资源，而不必再次向服务器发送请求，从而提高了性能和减少了网络带宽的占用。Expires 字段依赖于服务器和客户端的时钟同步，如果两者的时钟不一致，可能会导致缓存策略出现偏差。对于缓存的控制相对简单，不够灵活，无法满足复杂的缓存需求。</p>
<ul>
<li>使用 <code>Last-Modified</code> 和 <code>If-Modified-Since</code> 实现条件请求。</li>
<li>服务器返回资源的最后修改时间（<code>Last-Modified</code>），客户端下次请求时通过 <code>If-Modified-Since</code> 询问资源是否有更新。</li>
</ul>
<hr>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=3600, public</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;abc123&quot;</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 15 Jun 2022 12:00:00 GMT</span><br></pre></td></tr></table></figure>

<p>相比之下，HTTP 1.1 引入了更强大和灵活的缓存机制，如<code>Cache - Control</code>头字段，提供了更多的缓存控制选项，能够更精确地管理缓存行为。</p>
<ul>
<li>新增 <code>ETag</code>（实体标签）和 <code>If-None-Match</code> 作为条件请求更可靠的验证方式。优先使用 <code>ETag</code>，其次才是 <code>Last-Modified</code>，提高验证准确性。</li>
<li><code>ETag</code> 是资源的唯一标识符（如哈希值），即使资源修改时间未变，内容变化也会导致 <code>ETag</code> 变化，避免误判。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>增加了更多的请求方法（如 PUT、DELETE 等）和状态码</p>
</li>
<li><p>支持断点续传（通过 Range 头字段，它允许只请求资源的某个部分，即返回码是 206（Partial Content），方便了开发者自由的选择以便于充分利用带宽和连接。</p>
</li>
<li><p><strong>Host 头处理</strong> : HTTP/1.1 在请求头中加入了<code>Host</code>字段。</p>
</li>
<li><p>支持分块发送（应用层的分块）</p>
</li>
</ul>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a><a target="_blank" rel="noopener" href="https://hpbn.co/http2/">HTTP/2</a></h2><blockquote>
<p>From <em>High Performance Browser Networking</em></p>
</blockquote>
<p>HTTP/2 [2015] 的前身是 SPDY[2009]</p>
<h3 id="多路复用（Stream）"><a href="#多路复用（Stream）" class="headerlink" title="多路复用（Stream）"></a>多路复用（Stream）</h3><p>HTTP 1.1 对于连续多个请求可能会开启<strong>并行的最多6个TCP连接</strong>，用来提高带宽利用率。另外，<strong>管道化</strong>虽然也能实现同时发送多个请求，但是返回的时候是会阻塞的，<strong>受限于其请求-响应的基本模型</strong>，谁先到达，谁先返回，顺序绝对不能乱，因此造成了<strong>队头阻塞</strong>。HTTP 1.1还有另一个限制，只有幂等请求（get、head等）才能使用，大部分浏览器默认是关闭管道化的。</p>
<hr>
<p>HTTP/2中，浏览器针对同一个域名的资源，只建立一个 TCP 通道，所有的针对这个域名的请求全部在这个通道中完成，并且引入了<strong>流（Stream）</strong>的机制，如下图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8e6931bb40fc26c511ad15645e7b6113.svg" alt="Figure 12-2. HTTP/2 streams, messages, and frames"></p>
<ul>
<li><strong>流</strong>（Stream）：在一个 TCP 连接中进行的一个独立的、双向的、按序的数据交换。换句话说，流就对应着一个 <strong>请求-响应对</strong>。所有的流共享同一个 TCP 连接。</li>
<li><strong>流编号</strong>（Stream ID）：是一个 31 位的无符号整数（最高位保留），用于唯一标识每个流。客户端发起的流编号是奇数，服务器发起的是偶数。</li>
<li><strong>帧</strong>（Frame）：协议将每个请求/响应（Message）分割为二进制头帧与数据帧。并且帧有所属的流编号，帧可以乱序传输，减轻<strong>应用层</strong>的<strong>队头阻塞</strong>。</li>
<li>举例：客户端发送 1 3 5 号请求，如下图，请求5的数据帧还在途中，服务端同时处理了请求1 3，可以看到是乱序的实现了多路复用：</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/47ba5b32e42cf5a06c3741d29ef9b94a.svg"  />



<h3 id="以二进制帧为单位的流"><a href="#以二进制帧为单位的流" class="headerlink" title="以二进制帧为单位的流"></a>以二进制帧为单位的流</h3><p><strong>帧是原子单位</strong>：HTTP/2 协议规定，每个帧（包括 <code>HEADERS</code> 和 <code>DATA</code>）必须作为一个完整单元发送和接收。帧头（Frame Header）明确定义了帧的长度（Length 字段，占 3 字节），接收方必须读取完整的帧后才能处理。</p>
<ul>
<li>例如：一个 <code>DATA</code> 帧若声明长度为 1000 字节，则必须完整传输这 1000 字节的数据。</li>
<li>HTTP/2 Flow control只对<code>DATA</code>帧生效，<code>HEADERS</code>作为元数据始终处于高优先级</li>
</ul>
<img src="https://hpbn.co/assets/diagrams/ae09920e853bee0b21be83f8e770ba01.svg" alt="img"  />

<h4 id="DATA-帧：载荷分块传输"><a href="#DATA-帧：载荷分块传输" class="headerlink" title="DATA 帧：载荷分块传输"></a>DATA 帧：载荷分块传输</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8199bc14fc3e692d5ea83792822d5def.png" alt="Figure 12-9. DATA frame"></p>
<p><code>DATA</code>帧的的<strong>载荷</strong>（Payload）可能会因底层限制（如 TCP MSS、流控等）被<strong>间接拆分或分片</strong></p>
<ul>
<li>**HTTP/1.1 的 <code>Transfer-Encoding: chunked</code>**：显式将响应体拆分为多个块（每个块包含长度前缀），是应用层行为。</li>
<li><strong>HTTP/2 的 二进制帧</strong>：天然支持分块传输，可以将负载拆到多个帧里。最后一帧将 <code>END_STREAM</code>字段设置为true，false 表明表明负载尚未完成传输，更多的数据帧即将到来。</li>
</ul>
<h4 id="HEADER-帧编码：HPACK-算法"><a href="#HEADER-帧编码：HPACK-算法" class="headerlink" title="HEADER 帧编码：HPACK 算法"></a>HEADER 帧编码：HPACK 算法</h4><p>双方共同维护字典（静态表、动态表及 Huffman 编码），将HEADER中的重复出现的常见部分进行编码，取代之前的ASCII文本。图中 1 号流和 3 号流分别对共享字典进行了更新。（path 更新到动态表）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/feb142f82737d148ed5bcefd91915276.svg" alt="Figure 12-6. HPACK: Header Compression for HTTP/2"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/61dc2bae615536155a5af7203ad191fd.png" alt="Figure 12-8. Decoded HEADERS frame in Wireshark"></p>
<h3 id="服务器推送-Server-Push"><a href="#服务器推送-Server-Push" class="headerlink" title="服务器推送 (Server Push)"></a>服务器推送 (Server Push)</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/d759887277b266a42c526643285dd244.svg" alt="Figure 12-5. Server initiates new streams (promises) for push resources"  />

<p>网站为了使请求数减少，通常采用对页面上的图片、脚本进行极简化处理。但是，这一举措十分不方便，也不高效，依然需要诸多HTTP链接来加载页面和页面资源。</p>
<p>HTTP/2引入了<strong>服务器推送</strong>，即服务端向客户端发送比客户端请求更多的数据。服务器根据HTML的内容解析需要发送哪些内容，直接提供浏览器渲染页面所需要的资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。</p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul>
<li>HTTP/2禁用了诸多加密包</li>
<li><strong>允许设置请求优先级</strong>，服务器根据优先级响应</li>
</ul>
<h2 id="HTTP-3-QUIC"><a href="#HTTP-3-QUIC" class="headerlink" title="HTTP/3 (QUIC)"></a>HTTP/3 (QUIC)</h2><p>HTTP2协议虽然大幅提升了 HTTP/1.1 的性能，然而，基于TCP实现的HTTP/2遗留下3个问题：</p>
<ul>
<li><p><strong>TCP</strong> 的有序字节流导致丢包就会出现<strong>传输层</strong>队头阻塞（Head-of-line blocking），使得HTTP2的多路复用能力大打折扣</p>
</li>
<li><p>TCP与TLS叠加握手时延</p>
<ul>
<li>HTTPS 需要经过<a href="https://scatteredream.github.io/2025/05/11/408-%E8%AE%A1%E7%BD%91-TCP+UDP/">三次TCP握手</a>和<a href="https://scatteredream.github.io/2025/05/12/408-%E8%AE%A1%E7%BD%91-HTTPS/">四次TLS握手（TLS v1.2）</a>总共3个RTT才能发送数据。</li>
<li>TCP连接的慢启动拖延连接建立</li>
</ul>
</li>
<li><p>基于TCP四元组确定一个连接，这种诞生于有线网络的设计，并不适合移动状态下的无线网络，这意味着IP地址的频繁变动会导致TCP连接、TLS会话反复握手，成本高昂。</p>
</li>
</ul>
<img src="https://miro.medium.com/v2/resize:fit:1875/1*uk5OZPL7gtUwqRLwaoGyFw.png" alt="img" style="zoom:67%;" />



<p>HTTP/3 的 QUIC 实现了 <strong>多个stream的拥塞控制与可靠传输</strong>、<strong>原生加密</strong>、<strong>连接迁移</strong> </p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/quic-fig1.png" alt="A quick look at QUIC | APNIC Blog" style="zoom: 80%;" />

<h3 id="HTTP-3-帧：简化帧头、升级压缩算法"><a href="#HTTP-3-帧：简化帧头、升级压缩算法" class="headerlink" title="HTTP/3 帧：简化帧头、升级压缩算法"></a>HTTP/3 帧：简化帧头、升级压缩算法</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240105144457456.png" alt="image-20240105144457456" style="zoom: 33%;" />

<p>HTTP/3 延续了 HTTP/2 的帧结构设计，仍通过 <strong>DATA帧</strong> 传输请求/响应的正文内容，通过 <strong>HEADERS帧</strong> 传输经过 <strong>QPACK</strong> (HTTP/2 为 HPACK) 压缩的 HTTP 头部信息，其他帧类型（如 SETTINGS、CANCEL_PUSH 等）也得到保留，但部分功能因 QUIC 的特性有所调整。</p>
<p>封装：HTTP/3 帧 → 封装到 QUIC STREAM 帧 → 封装到 QUIC 包 → 通过 UDP 发送。</p>
<ul>
<li><strong>HTTP/2</strong>：基于 TCP，帧在流（Stream）上传输，流由 HTTP/2 自身管理，存在队头阻塞问题</li>
<li><strong>HTTP/3</strong>：基于 QUIC，直接复用 QUIC 的流机制，帧通过 QUIC 流传输。QUIC 的流相互独立，避免了 TCP 层的队头阻塞。<ol>
<li>HTTP/3 的<strong>帧头仅包含类型和长度字段</strong>，比 HTTP/2 更简洁，因为 Stream 管理转移给了 QUIC。</li>
<li>HPACK 升级为 QPACK，增加静态表的同时改进动态表：</li>
</ol>
</li>
</ul>
<blockquote>
<p>所谓的动态表，在首次请求-响应后，双方会将未包含在静态表中的 Header 项更新各自的动态表，接着后续传输时仅用 1 个数字表示，然后对方可以根据这 1 个数字从动态表查到对应的数据，就不必每次都传输长长的数据，大大提升了编码效率。动态表是具有<strong>时序性</strong>的，如果首次出现的请求<strong>发生丢包</strong>，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞直到首次请求中丢失的数据包重传过来。</p>
</blockquote>
<p>HTTP/3 使用两个单向流，一个叫 <strong>QPACK Encoder Stream</strong>，用于将一个字典（Key-Value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；一个叫 <strong>QPACK Decoder Stream</strong>，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。这两个单向流同步双方的动态表，编码方收到解码方的确认通知以后才使用动态表编码头帧。解决了HTTP/2的HPACK队头阻塞（也是因为TCP）</p>
<h3 id="UDP-上实现基于-Stream-的可靠传输"><a href="#UDP-上实现基于-Stream-的可靠传输" class="headerlink" title="UDP 上实现基于 Stream 的可靠传输"></a>UDP 上实现基于 Stream 的可靠传输</h3><p><a target="_blank" rel="noopener" href="https://cabulous.medium.com/http-3-quic-and-how-it-works-c5ffdb6735b4">HTTP/3, QUIC, and How it Works. Though HTTP/3 is still in draft today… | by Carson | Medium</a> </p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-49a6be0d647f0f9241a122971166ea23_1440w.jpg" alt="金山视频云推出QUIC+ ，畅快直播再升级（技术篇） - 知乎" style="zoom:67%;" />

<table>
<thead>
<tr>
<th>特性</th>
<th>HTTP/2 的 stream</th>
<th>HTTP/3 (QUIC) 的 stream</th>
</tr>
</thead>
<tbody><tr>
<td>属于哪一层</td>
<td>应用层</td>
<td>传输层（QUIC）</td>
</tr>
<tr>
<td>是否独立传输</td>
<td>否，共用 TCP 的一个流</td>
<td>是， stream 为传输层的基本单位，天然支持多路复用</td>
</tr>
<tr>
<td>队头阻塞问题</td>
<td>有，TCP 一丢包，所有 stream 都阻塞</td>
<td>无，哪个流丢包只影响该流</td>
</tr>
<tr>
<td>序号机制</td>
<td>Stream ID（奇偶区分）</td>
<td>Stream ID（可双向并发）</td>
</tr>
<tr>
<td>对应</td>
<td>一个请求/响应对</td>
<td>一个请求/响应对</td>
</tr>
</tbody></table>
<h4 id="QUIC-Packet：传输层单元"><a href="#QUIC-Packet：传输层单元" class="headerlink" title="QUIC Packet：传输层单元"></a>QUIC Packet：传输层单元</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-60231adb6c7014c7f043712839f77ab5_1440w.jpg" alt="img" style="zoom: 50%;" />

<ul>
<li>Packet 数据包是 QUIC 的传输单元，负责在 UDP 上可靠传输数据，一个 UDP 数据报里可以有一个或者多个 QUIC Packet。</li>
<li><strong>作用</strong>：用来可靠传输 Frame（包括加密、确认、重传）</li>
<li><strong>构成</strong>：包含 <strong>头部（Header）</strong> 和 <strong>负载（Payload）</strong>。</li>
<li><strong>头部</strong>：连接 ID（标识终点和起点，将 HTTP 连接和 UDP 四元组解耦）、QUIC 版本、Public Flags、<strong>Packet Number</strong>。明文。</li>
<li><strong>负载</strong>：可能包含一个或多个 <strong>QUIC 帧</strong>（QUIC Frames）。密文。</li>
</ul>
<h4 id="QUIC-Frame：协议层单元"><a href="#QUIC-Frame：协议层单元" class="headerlink" title="QUIC Frame：协议层单元"></a>QUIC Frame：协议层单元</h4><p><strong>作用</strong>：QUIC 协议的最小数据单元，用于实现连接控制、流管理、ACK、和数据传输等。</p>
<p><strong>​关键帧类型​</strong>​：</p>
<ul>
<li><strong>STREAM 帧</strong>：传输应用层数据（如 HTTP/3 的帧）。</li>
<li><strong>CRYPTO 帧</strong>：传输 TLS 握手数据。</li>
<li><strong>ACK 帧</strong>：确认收到的包号（替代 TCP 的 ACK）。</li>
<li><strong>MAX_DATA 帧</strong>：流量控制（类似 TCP 的窗口机制）。</li>
</ul>
<h5 id="STREAM-帧：传输应用层数据"><a href="#STREAM-帧：传输应用层数据" class="headerlink" title="STREAM 帧：传输应用层数据"></a>STREAM 帧：传输应用层数据</h5><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-f1cb88ac186e851a724a85dbd4f3de01_r.jpg" alt="img" style="zoom: 40%;" />

<ul>
<li><strong>Frame Type</strong>：标识帧类型。</li>
<li><strong>Stream ID</strong>: 唯一标识 Stream，因此一个 QUIC Stream ID 就对应唯一一个 HTTP 请求-响应对。</li>
<li><strong>offset</strong>：偏移量，用于排序。</li>
<li><strong>Data Length</strong>：data长度。</li>
</ul>
<h5 id="ACK-帧：可靠传输"><a href="#ACK-帧：可靠传输" class="headerlink" title="ACK 帧：可靠传输"></a>ACK 帧：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/405387352">可靠传输</a></h5><p><strong>问题 1：发送端怎么知道发出的包是否被接收端收到了？</strong></p>
<p>解决方案：通过包号（PKN）和选择确认（Selective-ACK）</p>
<ol>
<li>客户端：发送 3 个数据包给服务器（PKN = 1,2,3）</li>
<li>服务器：通过 SACK 告知客户端已经收到了 1 和 3，没有收到 2</li>
<li>客户端：重传第 2 个数据包（PKN=4）</li>
</ol>
<p>由此可以看出，QUIC 的PKN是单调递增的。也就是说，之前发送的数据包（PKN=2）和重传的数据包（PKN=4），虽然数据一样，但包号不同。</p>
<p><strong>问题 2：既然包号是单调递增的，那接收端怎么保证数据的有序性呢？</strong></p>
<p>解决方案：通过数据偏移量 offset</p>
<ol>
<li>每个数据包都有一个 offset 字段，表示在整个数据中的偏移量，比如 PKN 1,2,3 分别对应 offset 0,1,2，重传包 PKN=4, offset=1。</li>
<li>接收端根据 offset 字段就可以对异步到达的数据包进行排序了。</li>
</ol>
<p><strong>为什么 QUIC 要将 PKN 设计为单调递增？</strong></p>
<p>解决 TCP 的重传歧义问题：由于原始包和重传包的序列号是一样的，客户端不知道服务器返回的 ACK 包到底是原始包的，还是重传包的。但 QUIC 的原始包和重传包的序列号是不同的，也就能够判断 ACK 包的归属。</p>
<h4 id="可靠传输防止不同-Stream-之间的队头阻塞"><a href="#可靠传输防止不同-Stream-之间的队头阻塞" class="headerlink" title="可靠传输防止不同 Stream 之间的队头阻塞"></a>可靠传输防止不同 Stream 之间的队头阻塞</h4><p>QUIC 协议会保证数据包的可靠性，每个数据包都有一个 Packet Number 唯一标识。 <strong>QUIC 的 packet 是以 frame 为单位封装的，frame 可跨 stream 独立发送</strong></p>
<p>当某个包丢失，里面帧所对应的流就会影响，即使该流的其他帧到达了，数据也无法被 HTTP/3 读取，流内部仍然会阻塞，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。而其他跟这个包没关系的流完全不受影响，HTTP/3 可以读取到数据。</p>
<p>因此，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流所在的包发生丢包，只会影响该流，其他流不受影响。HTTP/2 就会互相影响，因为基于 TCP</p>
<h3 id="建立连接速度快、原生加密"><a href="#建立连接速度快、原生加密" class="headerlink" title="建立连接速度快、原生加密"></a>建立连接速度快、原生加密</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/QUIC-PICTURE-04-1024x553.jpg" alt="QUIC-PICTURE-04-1024x553.jpg"></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>使用协议</td>
<td><strong>TLS 1.3</strong>（不是 TCP 上的 TLS，而是集成到 QUIC 内部）</td>
</tr>
<tr>
<td>加密内容</td>
<td>所有 <strong>QUIC Packet 的 Payload（Frame）</strong> 都会加密；只有 <strong>部分 Header 字段明文</strong></td>
</tr>
<tr>
<td>握手流程</td>
<td>连接建立阶段使用 <strong>QUIC CRYPTO Frame</strong> 承载 TLS 1.3 的握手数据</td>
</tr>
<tr>
<td>对称密钥生成</td>
<td>通过 TLS 1.3 完成密钥协商（ECDHE）</td>
</tr>
<tr>
<td>后续通信加密</td>
<td>使用 <strong>AEAD 算法</strong>（如 AES-GCM 或 ChaCha20-Poly1305）加密 QUIC Packet 的 payload</td>
</tr>
<tr>
<td>Header 保护</td>
<td>QUIC 还对部分 Header 字段进行加密混淆，防止中间人分析</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>握手步骤</th>
<th>内容</th>
<th>QUIC 特点</th>
</tr>
</thead>
<tbody><tr>
<td>Client Hello</td>
<td>用 CRYPTO frame 承载 TLS ClientHello</td>
<td>无需 TCP Handshake</td>
</tr>
<tr>
<td>Server Hello</td>
<td>返回证书、公钥等</td>
<td>建立早期密钥</td>
</tr>
<tr>
<td>完成握手</td>
<td>双方完成密钥协商</td>
<td>建立 0-RTT/1-RTT 数据加密通道</td>
</tr>
</tbody></table>
<p>对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、OpenSSL 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p>
<p>QUIC 默认包含并开启 TLS 1.3，仅需 1 RTT 即可完成连接的建立和密钥协商，第二次连接，在握手完成之前，客户端就能基于缓存密钥发送部分早期加密应用数据。达到 0 RTT 的效果。</p>
<h3 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h3><p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「<strong>连接 ID</strong> 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有<strong>上下文信息（比如连接 ID、TLS 密钥等）</strong>，就可以<strong>无缝复用</strong>原连接，消除重连成本。</p>
<hr>
<h1 id="服务器推送（Server-Push）"><a href="#服务器推送（Server-Push）" class="headerlink" title="服务器推送（Server Push）"></a>服务器推送（Server Push）</h1><img src="https://hpbn.co/assets/diagrams/1a8db2948eb2aad0dd47470c6c011a42.svg" alt="Figure 17-2. Communication flow of XHR, SSE, and WebSocket"  />

<p>方法主要有 长轮询、SSE、WebSocket三种</p>
<h2 id="长轮询-Long-polling"><a href="#长轮询-Long-polling" class="headerlink" title="长轮询 (Long-polling)"></a>长轮询 (Long-polling)</h2><img src="https://websocket.org/_astro/long-polling.d7000adb_Vn4A9.webp" style="zoom:67%;" />

<p>从本质上讲，长轮询是一种更有效的轮询形式，是一项服务器选择尽可能长时间保持客户连接的技术，服务器仅在请求的数据可用或达到超时门槛后才提供响应。收到服务器响应后，客户端通常立即发出另一个请求。本质还是客户端发起请求。</p>
<h2 id="服务器发送事件-Server-Sent-Events"><a href="#服务器发送事件-Server-Sent-Events" class="headerlink" title="服务器发送事件 (Server-Sent Events)"></a>服务器发送事件 (Server-Sent Events)</h2><p>SSE是一种通常用于将消息更新或连续数据流发送给浏览器客户端的服务器推送技术。 SSE旨在通过称为EventSource的JavaScript API来增强本地的、跨浏览器的、Server-to-Client的推送，是 HTML5 的一部分。本质是服务器这边专门开一条 HTTP 链接，这条链接里面服务器和客户端的角色互换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&#x27;URL_TO_EVENT_STREAM&#x27;</span>);</span><br><span class="line">source.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;connection to stream has been opened&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">source.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;An error has occurred while receiving stream&#x27;</span>, error);</span><br><span class="line">&#125;;</span><br><span class="line">source.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">stream</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;received stream&#x27;</span>, stream);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_websocket.html">WebSocket</a></h2><p>WebSocket 是一种基于 TCP 连接的<strong>全双工通信协议</strong>，即客户端和服务器可以同时发送和接收数据。WebSocket 协议在 2008 年诞生，2011 年成为国际标准，几乎所有主流较新版本的浏览器都支持该协议。不过，WebSocket 不只能在基于浏览器的应用程序中使用，很多编程语言、框架和服务器都提供了 WebSocket 支持。WebSocket 协议本质上是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 常见应用场景：视频弹幕、实时消息推送，详见<a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/web-real-time-message-push.html">Web 实时消息推送详解</a>这篇文章、实时游戏对战、多用户协同编辑、社交聊天。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>WebSockets</strong></th>
<th><strong>HTTP/1.1</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>通信形式</strong></td>
<td>全双工</td>
<td>半双工</td>
</tr>
<tr>
<td><strong>信息交换方式</strong></td>
<td>双向通信</td>
<td>基于请求-响应对</td>
</tr>
<tr>
<td><strong>服务器推送</strong></td>
<td>核心特色</td>
<td>原生不支持</td>
</tr>
<tr>
<td><strong>开销</strong></td>
<td>连接建立有一定开销，信息开销极小</td>
<td>每条信息都有一定开销</td>
</tr>
<tr>
<td><strong>状态</strong></td>
<td>有状态</td>
<td>无状态</td>
</tr>
</tbody></table>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/websocket-vs-http.be03ced1_sWP4f.webp" alt="Websocket 示意图" style="zoom: 67%;" />

<p>WebSocket 的工作过程可以分为以下几个步骤：</p>
<ol>
<li>客户端向服务器发送一个 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Sec-WebSocket-Key</code> 等字段，表示要求升级协议为 WebSocket；</li>
<li>服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，<code>Connection: Upgrade</code>和 <code>Sec-WebSocket-Accept: xxx</code> 等字段、表示成功升级到 WebSocket 协议。</li>
<li>客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。数据以帧（frames）的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。</li>
<li>客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。</li>
</ol>
<p>另外，建立 WebSocket 连接之后，通过心跳机制来保持 WebSocket 连接的稳定性和活跃性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/13/408-data-structure-sort-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/13/408-data-structure-sort-algorithm/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-13 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-13T00:00:00+08:00">2025-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-15 18:59:30" itemprop="dateModified" datetime="2025-05-15T18:59:30+08:00">2025-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Serial-Sort-Algorithm"><a href="#Serial-Sort-Algorithm" class="headerlink" title="Serial Sort Algorithm"></a>Serial Sort Algorithm</h1><h2 id="HEAP-SORT"><a href="#HEAP-SORT" class="headerlink" title="HEAP SORT"></a>HEAP SORT</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 时间复杂度:</span></span><br><span class="line"><span class="comment">   构建堆：O(n)</span></span><br><span class="line"><span class="comment">   每次调整堆：O(log n)</span></span><br><span class="line"><span class="comment">   总时间复杂度：O(n log n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间复杂度</span></span><br><span class="line"><span class="comment">// O(1)（原地排序）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定性</span></span><br><span class="line"><span class="comment">// 不稳定：交换操作可能破坏相同元素的顺序。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 构建最大堆（从最后一个非叶子节点开始调整）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, n, i); <span class="comment">// 将无序数组调整为满足父节点 ≥ 子节点的堆结构。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 逐步将堆顶元素与末尾交换，并调整堆，重复此过程直到堆的大小为 1。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 交换堆顶和当前未排序部分的末尾</span></span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 调整堆顶元素，使其下沉到正确位置</span></span><br><span class="line">            heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对以 i 为根的子树执行下沉操作（确保最大堆性质）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;       <span class="comment">// 初始化最大值的索引为根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 左子节点索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左子节点存在且大于当前最大值</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果右子节点存在且大于当前最大值</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最大值不在根节点，则交换并递归调整子树</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line">            heapify(arr, n, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MERGE-SORT-DIVISION"><a href="#MERGE-SORT-DIVISION" class="headerlink" title="MERGE SORT(DIVISION)"></a>MERGE SORT(DIVISION)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分治法：将数组递归分成两半，分别排序后合并。</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n log n) 空间复杂度 O(n)（合并时需要辅助数组）稳定 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> arr.length / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] left = Arrays.copyOfRange(arr, <span class="number">0</span>, mid);</span><br><span class="line">        <span class="type">int</span>[] right = Arrays.copyOfRange(arr, mid, arr.length);</span><br><span class="line">        mergeSort(left);</span><br><span class="line">        mergeSort(right);</span><br><span class="line">        merge(arr, left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] left, <span class="type">int</span>[] right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] &lt;= right[j]) &#123;</span><br><span class="line">                arr[k++] = left[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k++] = right[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理剩余元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; left.length) arr[k++] = left[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt; right.length) arr[k++] = right[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        mergeSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="QUICK-SORT-DIVISION"><a href="#QUICK-SORT-DIVISION" class="headerlink" title="QUICK SORT(DIVISION)"></a>QUICK SORT(DIVISION)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 分治法：选择一个基准元素（pivot），将数组分为两部分，左边元素 ≤ 基准，右边元素 ≥ 基准，递归处理子数组。</span></span><br><span class="line"><span class="comment">    关键步骤：分区（Partition） 操作。</span></span><br><span class="line"><span class="comment">    时间复杂度：平均：O(n log n)   最坏（如已排序数组）：O(n²)（可通过随机选择基准优化）</span></span><br><span class="line"><span class="comment">    空间复杂度：O(log n)（递归栈）</span></span><br><span class="line"><span class="comment">    稳定性：不稳定（交换可能破坏顺序）**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">            quickSort(arr, low, pivotIndex - <span class="number">1</span>);  <span class="comment">// 递归左半部分</span></span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, high); <span class="comment">// 递归右半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[(low + high) / <span class="number">2</span>]; <span class="comment">// 选择中间元素为基准（可优化为随机选择）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low, j = high;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[i] &lt; pivot) i++; <span class="comment">// 找左边大于基准的元素</span></span><br><span class="line">            <span class="keyword">while</span> (arr[j] &gt; pivot) j--; <span class="comment">// 找右边小于基准的元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">// 返回分区点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RADIX-SORT"><a href="#RADIX-SORT" class="headerlink" title="RADIX SORT"></a>RADIX SORT</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非比较排序：按数字的每一位（从低位到高位）进行排序，每次使用稳定的子排序（如计数排序）。</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(d(n+k))  d 是数字的最大位数，k 是基数（例如，对于十进制数，k=10）</span></span><br><span class="line"><span class="comment">// 空间复杂度 O(n+k) 额外空间用于存储计数和输出数组</span></span><br><span class="line"><span class="comment">// 稳定 适用于整数或定长字符串排序，位数较少时高效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Arrays.stream(arr).max().getAsInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 当前处理的位数（个位开始）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从低位到高位依次排序</span></span><br><span class="line">        <span class="keyword">while</span> (max / exp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            countingSortByDigit(arr, exp);</span><br><span class="line">            exp *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSortByDigit</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> exp)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] output = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]; <span class="comment">// 0-9的计数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> (num / exp) % <span class="number">10</span>;</span><br><span class="line">            count[digit]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算累计位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后向前填充output数组（保证稳定性）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> (arr[i] / exp) % <span class="number">10</span>;</span><br><span class="line">            output[count[digit] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            count[digit]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将排序结果复制回原数组</span></span><br><span class="line">        System.arraycopy(output, <span class="number">0</span>, arr, <span class="number">0</span>, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">170</span>, <span class="number">45</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span>&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [2, 24, 45, 66, 75, 90, 170, 802]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SELECTION-SORT"><a href="#SELECTION-SORT" class="headerlink" title="SELECTION SORT"></a>SELECTION SORT</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n^2) 空间复杂度 O(1) 不稳定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 找未排序部分的最小值索引</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换最小值到正确位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="INSERTION-SORT"><a href="#INSERTION-SORT" class="headerlink" title="INSERTION SORT"></a>INSERTION SORT</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 最好-有序 O(n) 平均 O(n^2) 最坏 O(n^2) 空间复杂度 O(1) 稳定</span></span><br><span class="line"><span class="comment">// 插入排序：逐步构建有序序列，将未排序元素逐个插入到已排序部分的正确位置。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 将比key大的元素后移</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = key; <span class="comment">// 插入到正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        insertionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SHELL-SORT-OPTIMIZED-INSERTION"><a href="#SHELL-SORT-OPTIMIZED-INSERTION" class="headerlink" title="SHELL SORT(OPTIMIZED INSERTION)"></a>SHELL SORT(OPTIMIZED INSERTION)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序的变种：通过分组插入排序逐步减少间隔（gap），最终进行一次标准插入排序。</span></span><br><span class="line"><span class="comment">// 关键步骤：动态调整间隔序列（如 Knuth 序列）</span></span><br><span class="line"><span class="comment">// 时间复杂度取决于间隔序列，通常为 O(n log² n) ~ O(n²)。 最优可达到 O(n log n)。</span></span><br><span class="line"><span class="comment">// 空间复杂度 O(1) </span></span><br><span class="line"><span class="comment">// 不稳定（分组交换可能破坏顺序）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">// 初始间隔使用 Knuth 序列（h = 3*h + 1）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (gap &lt; n / <span class="number">3</span>) gap = <span class="number">3</span> * gap + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 对每个间隔分组进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp) &#123;</span><br><span class="line">                    arr[j] = arr[j - gap];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            gap /= <span class="number">3</span>; <span class="comment">// 缩小间隔</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Parallel-Sort-Algorithm"><a href="#Parallel-Sort-Algorithm" class="headerlink" title="Parallel Sort Algorithm"></a><a href="https://scatteredream.github.io/2025/04/14/cpp_cuda_parallel_programming/#%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95">Parallel Sort Algorithm</a></h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/12/408-%E8%AE%A1%E7%BD%91-HTTPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/12/408-%E8%AE%A1%E7%BD%91-HTTPS/" class="post-title-link" itemprop="url">HTTPS(TLS)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-12 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-12T00:00:00+08:00">2025-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-14 15:48:43" itemprop="dateModified" datetime="2025-05-14T15:48:43+08:00">2025-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机面临的安全威胁"><a href="#计算机面临的安全威胁" class="headerlink" title="计算机面临的安全威胁"></a>计算机面临的安全威胁</h1><h2 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/network-attack-means.html">网络攻击常见手段总结 | JavaGuide</a> </p>
<p><strong>被动攻击</strong>：也叫截获，流量分析。</p>
<p><strong>主动攻击</strong>：</p>
<ul>
<li><p><strong>篡改报文</strong>。</p>
</li>
<li><p><strong>恶意程序</strong>（病毒、蠕虫、木马、流氓软件、漏洞入侵、逻辑炸弹）</p>
</li>
<li><p><strong>拒绝服务</strong>（DoS, Denial of Service）：从互联网的一个服务器A发送大量信息到另一个服务器B，使得服务器B崩溃，拒绝服务。从多个服务器发分组又叫做分布式拒绝服务（DDoS, Distributed DoS）。负载均衡（anycast…）</p>
</li>
<li><p><strong>交换机中毒</strong>：发送大量伪造MAC帧，迅速填满交换机的交换表，使交换机无法正常提供服务。</p>
</li>
</ul>
<h2 id="安全措施"><a href="#安全措施" class="headerlink" title="安全措施"></a>安全措施</h2><ul>
<li><strong>机密性</strong>：密码技术，加密报文信息；对称加密</li>
<li><strong>信息完整性</strong>：防止报文信息被篡改；非对称加密，签名-鉴别</li>
<li><strong>端点鉴别</strong>（Authentication）：鉴别对方的真实身份；</li>
</ul>
<ul>
<li><strong>访问控制</strong>（Authorization）：确认用户的权限级别，能够进行什么样的操作。</li>
</ul>
<h3 id="Authentication（身份验证）"><a href="#Authentication（身份验证）" class="headerlink" title="Authentication（身份验证）"></a>Authentication（身份验证）</h3><p>确认用户的身份，确保用户是他声称的那个人。</p>
<p>验证用户的凭证（如用户名/密码、指纹、OTP 等）。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>登录网站时输入用户名和密码。</li>
<li>使用指纹、面部识别或其他生物识别方式解锁设备。</li>
<li>输入短信验证码进行二次验证。</li>
</ul>
<h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><ul>
<li>“你是谁？”</li>
<li>解决的是<strong>身份问题</strong>。</li>
</ul>
<h3 id="Authorization（授权）"><a href="#Authorization（授权）" class="headerlink" title="Authorization（授权）"></a>Authorization（授权）</h3><p>确定已经通过身份验证的用户是否有权访问某资源或执行某操作。</p>
<p>控制用户能访问的资源或功能。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><ul>
<li>一个普通用户登录后不能访问管理员控制面板。</li>
<li>文件系统中，只有特定权限的用户可以修改文件。</li>
<li>云服务中，用户可能只能管理自己的项目，不能访问其他人的数据。</li>
</ul>
<h4 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h4><ul>
<li>“你可以做什么？”</li>
<li>解决的是<strong>权限问题</strong>。</li>
</ul>
<h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>Authentication（身份验证）</strong></th>
<th><strong>Authorization（授权）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>目的</strong></td>
<td>确认用户身份</td>
<td>确定用户访问权限</td>
</tr>
<tr>
<td><strong>处理对象</strong></td>
<td>用户的身份</td>
<td>用户的权限</td>
</tr>
<tr>
<td><strong>执行顺序</strong></td>
<td>先进行身份验证</td>
<td>只有通过身份验证后才能进行授权</td>
</tr>
<tr>
<td><strong>核心问题</strong></td>
<td>用户是否真实有效？</td>
<td>用户能访问哪些资源或执行哪些操作？</td>
</tr>
<tr>
<td><strong>技术示例</strong></td>
<td>密码验证、2FA、OAuth 登录</td>
<td>角色权限分配（RBAC）、ACL、API Token</td>
</tr>
</tbody></table>
<p><code>Authentication</code> 是 <code>Authorization</code> 的前提。<br> 一个用户必须先证明“自己是谁”，然后才能被系统允许或限制访问某些资源或执行操作。</p>
<h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="两类密钥体制"><a href="#两类密钥体制" class="headerlink" title="两类密钥体制"></a>两类密钥体制</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86">对称加密</a></h3><p>双方使用同一把密钥，不对外公开，使用密钥将报文信息进行加密或者进行解密。</p>
<ul>
<li><p><strong>DES</strong>：密钥共64位，8位用于奇偶校验，实际为56位有效。</p>
</li>
<li><p><strong>3DES</strong>：使用两个DES密钥，先用K1加密，再用K2解密，再用K1加密</p>
</li>
<li><p><strong>AES</strong>：使用分组加密，密钥长度为128 192 256三种</p>
</li>
<li><p><strong>一个传统保管箱，开门和关门都是使用同一条钥匙，这是对称加密</strong> </p>
</li>
<li><p>只支持一对一通信。</p>
</li>
</ul>
<h3 id="公钥加密（非对称加密）"><a href="#公钥加密（非对称加密）" class="headerlink" title="公钥加密（非对称加密）"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">公钥加密（非对称加密）</a></h3><ul>
<li><p>使用密钥生成器生成密钥对，一个是公钥（对外公开），一个是私钥（自己保留）。</p>
</li>
<li><p>已知其中一个密钥的情况下，几乎不可能知道另外一个密钥。</p>
</li>
<li><p>私钥加密的数据，只能用公钥解密。公钥加密的数据，只能用私钥解密。</p>
<ul>
<li>其实不应该叫做加密和解密，应该称作D运算和E运算这两个互逆的运算，没有规定他们谁先谁后。</li>
<li>更准确的说法是私钥参与D运算，公钥参与E运算。</li>
</ul>
</li>
<li><p><strong>一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；</strong></p>
</li>
<li><p><strong>而只有信箱主人拥有钥匙可以打开信箱，这就视为私钥。</strong></p>
</li>
<li><p>支持多对一的通信。</p>
</li>
</ul>
<h2 id="鉴别（Authentication）"><a href="#鉴别（Authentication）" class="headerlink" title="鉴别（Authentication）"></a>鉴别（Authentication）</h2><h3 id="报文鉴别"><a href="#报文鉴别" class="headerlink" title="报文鉴别"></a>报文鉴别</h3><p>主要是鉴别报文是否被篡改。</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>decryption and encryption</p>
<p>A要发出信息，并进行数字签名，将报文用私钥SK<del>A</del>进行D运算（签名），其他人只能用公钥PK<del>A</del>进行E运算（鉴别）。</p>
<ul>
<li><strong>防止篡改报文</strong>：没人知道A的私钥SK<del>A</del>，窃听者使用公钥PK<del>A</del>进行E运算得出明文，篡改报文之后再D运算，另一边使用公钥PK<del>A</del>解析出的明文将会是不可读的，因此不会被欺骗。</li>
<li><strong>不可否认</strong>：既然信息明文可读，就说明没有被篡改过，而拥有私钥的只有A一个人，A就不能抵赖自己曾经的签名。</li>
</ul>
<p>上述方法是对报文本身进行了私钥加密，公钥直接可以解出报文具体内容，如果要用非对称加密实现报文内容的保密，可以在A用私钥D运算之后，再用B的公钥E运算，这样就彻底加密了报文内容，B收到以后先用B的私钥D运算，再用A的公钥E运算。</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>是一种摘要算法，将任意长度的报文经过哈希函数可以的到固定长度的字符串。</p>
<h4 id="结合报文鉴别码（MAC）实现数字签名报文鉴别"><a href="#结合报文鉴别码（MAC）实现数字签名报文鉴别" class="headerlink" title="结合报文鉴别码（MAC）实现数字签名报文鉴别"></a>结合报文鉴别码（MAC）实现数字签名报文鉴别</h4><p>Message Authentication Code, MAC</p>
<p>H(X) 代表 X 的哈希值；D(X) 代表 X 经过私钥的D运算以后的结果；E(X) 代表 X 经过 公钥的E运算之后的结果</p>
<p>$D(E(X)) = X$          $E(D(X)) = X$ </p>
<p>扩展报文实现的数字签名可以分为三类：</p>
<p>$A + H(A)$ ：只篡改报文A或者H(A)可以鉴别出来，但是直接换一个 X + H(X) 直接会蒙混过关，由此引出了使用密钥K来进行哈希运算的方法。</p>
<p>$A + H(A,K)$： 使用对称密钥$K$，如果报文$A$被篡改成$X$，但是攻击者不知道密钥，因此无法伪造出哈希值$H(X,K)$，另一边根据密钥计算出$H(X,K)$，就能发现报文被篡改过。这样将密钥拼接在正文之后，得出的散列值就是<strong>HMAC</strong>。JWT(Json Web Token)采用的数字签发就可以采用这样的方式 （HS256 代表 HMAC 散列函数为SHA-256）**对密钥K<u>严格要求保密</u>**。<a target="_blank" rel="noopener" href="https://ryan4yin.space/posts/jwt-algorithm-key-generation/">JWT 签名算法 HS256、RS256 及 ES256 及密钥生成 - This Cute World</a> </p>
<p>$A + D(H(A))$：使用私钥对报文的哈希进行D运算，其他人使用公钥对密文进行E运算能够得出哈希值，将这个哈希值和报文段的哈希值比较即可。如果$A$被篡改为$X$，攻击者因为不知道发送者的私钥，因此无法得出一个正确的$D(H(X))$，这时候发给接收者，接受者再对攻击者伪造的哈希值密文进行E运算，得出哈希值肯定和真正的$H(X)$不同，这就是RS256和ES256的原理。**由此方法扩展出的报文<u>不可伪造，也不可否认</u>**，同时可以运用到分布式架构中，一个服务签发，其他服务验证只需要公钥即可。ES256（ECDSA）使用椭圆曲线计算公钥。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kirito-c/p/12402066.html">JWT 签名算法 HS256、RS256 及 ES256 及密钥生成 - 於清樂 - 博客园</a> </p>
<h3 id="实体鉴别"><a href="#实体鉴别" class="headerlink" title="实体鉴别"></a>实体鉴别</h3><h4 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h4><p>主要是验证来访者的确是访问者，也就是鉴别身份。</p>
<p>相比于报文鉴别，实体鉴别只需要鉴别一次发送者即可，后续传输不需要鉴别，使用<strong>共享对称密钥</strong>，如果第三方C截获了A发给B的验证信息，并未破译报文，而是直接伪装成A给B发消息，这样B就会错误地与C建立起联系。把以前窃听到的数据原封不动地重新发送给接收方，这就叫 <strong>重放攻击</strong>。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/2229240">重放攻击_百度百科</a> </p>
<p>重放攻击的基本原理就是把以前<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%AA%83%E5%90%AC/1624599?fromModule=lemma_inlink">窃听</a>到的数据原封不动地重新发送给接收方。很多时候，网络上传输的数据是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86/752748?fromModule=lemma_inlink">加密</a>过的，此时窃听者无法得到数据的准确意义。但如果他知道这些数据的作用，就可以在不知道数据内容的情况下通过再次发送这些数据达到愚弄接收端的目的。例如，有的系统会将鉴别信息进行简单加密后进行传输，这时攻击者虽然无法窃听<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%86%E7%A0%81/65553?fromModule=lemma_inlink">密码</a>，但他们却可以首先截取加密后的口令然后将其重放，从而利用这种方式进行有效的攻击。再比如，假设网上存款系统中，一条消息表示用户支取了一笔存款，攻击者完全可以多次发送这条消息而偷窃存款。</p>
</blockquote>
<p>因此采取的措施就是尽量能够让B端验证清楚A的身份。K(X)表示用密钥加密过的X</p>
<p>A先发身份信息 + 一个大随机不重复数<code>RA</code>，B收到后响应一个<code>RB</code>和<code>K(RA)</code>，因此对于A端而言B端是可信的；A端再发送<code>K(RB)</code>，因此对于B端而言A端是可信的。需要注意的是每次会话都都需要重新验证，并且需要有足够的空间存储不同会话的不同随机数。</p>
<h4 id="非对称密钥"><a href="#非对称密钥" class="headerlink" title="非对称密钥"></a>非对称密钥</h4><p>对于上文的不重复随机数，B可以用B自己的私钥加密RA，A用B的公钥解密得出RA；A用自己的私钥加密RB，B用A的公钥解密RB。这里C可以生成自己的私钥和公钥，分别截获RA和RB，仍然能够冒充A，与B进行通信。不过A与B根本没有进行通信，A端很容易察觉到。</p>
<p><strong>中间人攻击</strong>：假设AB通信双方并没有提前知道对方的公钥是什么。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241129155621051.png" alt="image-20241129155621051"></p>
<p>C截获A的身份验证信息和RB，用自己的私钥加密RB得到D<del>C</del>(RB)返回给B，同时把RB转发给A，A向对方索取公钥，C就把自己的公钥发给A，但是仍然把公钥的请求转发给A，A发出了自己的D<del>A</del>(RB)和公钥，但均被C所截获。</p>
<p>A跟B开始建立通信，B就把发送的数据用C的公钥加密，C直接可以用自己的私钥解密，解密出来以后再用A的公钥加密，发给A，看似A和B建立了保密通信，实际上C能够神不知鬼不觉地窃取信息。</p>
<blockquote>
<p>SSL劫持</p>
<p>当今绝大部分网站采用HTTPS方式进行访问，也就是用户与网站服务器间建立<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/SSL.html">SSL</a>连接，基于SSL证书进行数据验证和加密。HTTPS可以在一定程度上减少中间人攻击，但是攻击者还是会使用各种技术尝试破坏HTTPS，SSL劫持就是其中的一种。SSL劫持也称为SSL证书欺骗，攻击者伪造网站服务器证书，公钥替换为自己的公钥，然后将虚假证书发给用户。此时用户浏览器会提示不安全，但是如果用户安全意识不强继续浏览，攻击者就可以控制用户和服务器之间的通信，解密流量，窃取甚至篡改数据。</p>
</blockquote>
<h2 id="密钥分配与管理"><a href="#密钥分配与管理" class="headerlink" title="密钥分配与管理"></a>密钥分配与管理</h2><h3 id="对称密钥交换"><a href="#对称密钥交换" class="headerlink" title="对称密钥交换"></a>对称密钥交换</h3><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><h5 id="难点：大数因式分解"><a href="#难点：大数因式分解" class="headerlink" title="难点：大数因式分解"></a>难点：大数因式分解</h5><p>公开的数字：公钥D，N</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241129230424076-1732894652386-1.png" alt="image-20241129230424076"></p>
<p>难点：算出T的值，也就是要分解N。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241129230521315-1732944264022-8.png" alt="image-20241129230521315"></p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>使用场景较广泛，适合需要加密数据、验证签名的场合。</li>
<li>不适合直接交换大数据（效率较低）。</li>
</ul>
<h5 id="RSA-的缺陷"><a href="#RSA-的缺陷" class="headerlink" title="RSA 的缺陷"></a>RSA 的缺陷</h5><p>没有前向保密性，所有的数字（质数乘积N，公钥E）必须提前沟通好，依赖于长期的静态密钥对（公钥和私钥）来交换对称密钥，而没有使用每次会话生成的临时密钥对。在 RSA 密钥交换过程中，如果服务器的私钥被泄露，攻击者可以解密所有使用该私钥加密的对称密钥，进而恢复以前的会话数据，从而破坏了前向保密性。</p>
<h4 id="Diffle-Hellman-密钥交换"><a href="#Diffle-Hellman-密钥交换" class="headerlink" title="Diffle-Hellman 密钥交换"></a>Diffle-Hellman 密钥交换</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/599518034">一文搞懂Diffie-Hellman密钥交换协议 - 知乎</a> </p>
<h5 id="难点：离散对数"><a href="#难点：离散对数" class="headerlink" title="难点：离散对数"></a>难点：离散对数</h5><p>公开的数字：P、G、双方的公钥。</p>
<ul>
<li><p>正向计算简单，逆向计算难（即在有限域上计算  $g^x \mod p$ 的逆运算很难）</p>
</li>
<li><p>依赖于离散对数的计算难度，使用的素数位数越长，安全性越高。</p>
</li>
<li><p>易受中间人攻击，因此通常结合认证机制（如数字签名）使用。</p>
</li>
</ul>
<h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>专用于安全密钥交换，通常与对称加密算法结合使用。</li>
<li>不支持数据加密或签名。</li>
</ul>
<p>由8和19无法逆推回x与y，由$19^x \mod 23 = 8^y \mod 23$ 也无法推出x和y的值</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241129230002490.png" alt="image-20241129230002490"></p>
<h5 id="ECDHE"><a href="#ECDHE" class="headerlink" title="ECDHE"></a>ECDHE</h5><p>static DH算法 – &gt; DHE算法 – &gt; ECDHE算法</p>
<p><strong>static DH</strong> 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。 于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 static DH 算法<strong>不具备前向安全性</strong>。</p>
<p><strong>DHE</strong> </p>
<ul>
<li><strong>Ephemeral（临时密钥）</strong>：在 DHE 中，”Ephemeral” 表示每次会话都生成新的密钥对（临时密钥）。因此，即使密钥在某一时刻被泄露，它也无法用于恢复以前的通信，增强了前向保密性（forward secrecy）。</li>
</ul>
<p>G、P可以固定，DHE 每次需要传递的数据就是计算出来的公钥，不过大数乘除性能不好，于是有了ECDHE，用ECC提高性能。</p>
<p><strong>ECDHE</strong>（Elliptic Curve Diffie-Hellman Ephemeral） 是 Diffie-Hellman 协议的椭圆曲线版本，使用椭圆曲线加密（ECC，Elliptic Curve Cryptography）来代替传统的基于大数的计算。椭圆曲线加密在相同的安全级别下，所需的密钥长度比传统的 DH 小得多，从而提高了计算效率。</p>
<h4 id="密钥分发中心（KDC）"><a href="#密钥分发中心（KDC）" class="headerlink" title="密钥分发中心（KDC）"></a>密钥分发中心（KDC）</h4><p>Key Distribution Center</p>
<h3 id="公钥体制：CA"><a href="#公钥体制：CA" class="headerlink" title="公钥体制：CA"></a>公钥体制：CA</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89">Certificate Authority 证书权威机构</a></p>
<p>除非A与B线下沟通好公钥，不然总是有可能会被中间人攻击（即中间人会截获请求者的公钥，替换成自己的公钥），那么如何保证B的公钥能准确无误传到A手上不被篡改呢？需要第三方进行数字签名，CA用自己的私钥将报文信息数字签名，也就是MAC报文鉴别码。最终报文鉴别码附在报文后面$B + D(H(B))$</p>
<p>这里的报文B包含：</p>
<ul>
<li>B的身份验证信息（我是B）</li>
<li>B的公钥（我的公钥是xxx）</li>
</ul>
<p>因此，B需要提供证书，A需要把证书的报文部分进行哈希运算，然后用报文中B提供的公钥进行E运算，看得出的结果是否相同，如果不同说明证书被篡改，不可信。一切的基础是建立在CA上面，CA是一个大家都认可的权威机构</p>
<h4 id="CA-标准：X-509（PKI）"><a href="#CA-标准：X-509（PKI）" class="headerlink" title="CA 标准：X.509（PKI）"></a>CA 标准：X.509（PKI）</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89">公开密钥认证 - 维基百科，自由的百科全书</a> Public Key Infrastructure</p>
<p><strong>数字证书标准</strong>：</p>
<ul>
<li>X.509 版本</li>
<li>数字证书名称、序列号</li>
<li>本数字签名证书使用的签名算法（CA进行数字签名的非对称算法）</li>
<li>数字签名的公钥（私钥由签发者保存）</li>
<li>签发者的唯一标识符</li>
<li>数字证书的有效期</li>
<li>数字证书的主体名（数字证书拥有者及其拥有的公钥的唯一标识符）</li>
</ul>
<h4 id="CA-信任链：多级认证系统"><a href="#CA-信任链：多级认证系统" class="headerlink" title="CA 信任链：多级认证系统"></a>CA 信任链：多级认证系统</h4><p>万一中级证书不能信任了，还可以让根证书再找一个中级证书，因为信任根证书，也自然信任这个新的中级证书，但如果根证书直接信任某个网站的证书，万一根证书被攻破不能信任了，那就找不到可以信任的了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241129222025691.png" alt="image-20241129222025691"></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E8%AF%81%E4%B9%A6">根证书</a>：所有信任链的起点，使用私钥自签。根证书获得广泛认可，通常已预先安装在各种软件（包括<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">浏览器</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6%E7%94%A8%E6%88%B6%E7%AB%AF">电邮软件</a>等），作为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E4%BB%BB%E9%8F%88">信任链</a>的起点，来自于公认可靠的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%94%BF%E5%BA%9C%E6%9C%BA%E5%85%B3">政府机关</a>（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A6%99%E6%B8%AF%E9%83%B5%E6%94%BF">香港邮政</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%B0%E7%81%A3%E7%B6%B2%E8%B7%AF%E8%B3%87%E8%A8%8A%E4%B8%AD%E5%BF%83">台湾网络信息中心</a>）、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84">证书颁发机构</a>公司（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DigiCert">DigiCert</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Google">Google</a>）、非营利组织（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Let's_Encrypt">Let’s Encrypt</a>）等，与各大软件商透过严谨的核认程序才在不同的软件广泛部署。由于部署程序复杂费时，需要行政人员的授权及机构法人身份的核认，一张根证书有效期可能长达二十年以上。在某些企业，也可能会在内部电脑自行安装企业自签的根证书，以支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%86%85%E9%83%A8%E7%BD%91">内部网</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%BD%AF%E4%BB%B6">企业级软件</a>；但是这些证书可能未被广泛认可，只在企业内部适用。</p>
<p><strong>中介证书</strong>：认证机构的一个重要任务就是为客户签发证书，虽然广泛认可的认证机构都已拥有根证书，相对应的私钥可用以签署其他证书，但因为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86">密钥管理</a>和行政考虑，一般会先行签发中介证书，才为客户作数字签署。中介证书的有效期会较根证书为短，并可能对不同类别的客户有不同的中介证书作分工。</p>
<p><strong>TLS 服务器证书</strong>：服务器通常以域名形式在互联网上提供服务，服务器证书上<strong>主体</strong>的<strong>通用名称</strong>就会是相应的域名，相关机构名称则写在<strong>组织</strong>或<strong>单位</strong>一栏上。服务器证书（包括公钥）和私钥会安装于服务器（例如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Apache_HTTP_Server">Apache</a>），等待客户端连接时<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8F%A1%E6%89%8B_(%E6%8A%80%E6%9C%AF)">协议加密细节</a>。客户端的软件（如浏览器）会执行<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%AA%8D%E8%AD%89%E8%B7%AF%E5%BE%91%E9%A9%97%E8%AD%89%E7%AE%97%E6%B3%95&action=edit&redlink=1">认证路径验证算法</a>以确保安全，如果未能肯定加密通道是否安全（例如证书上的主体名称不对应网站域名、服务器使用了自签证书、或加密算法不够强），可能会警告用户。</p>
<p><strong>TLS 客户端证书</strong>：有时候，某些TLS服务器可能会在建立加密通道时，要求客户端提供客户端证书，以验证<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD">身份</a>及<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6">控制访问权限</a>。客户端证书包含电子邮件地址或个人姓名，而不是主机名。但客户端证书比较不常见，因为考虑到技术门槛及成本因素，通常都是由服务提供者验证客户身份，而不是依赖第三方认证机构。通常，需要使用到客户端证书的服务都是内部网的企业级软件，他们会设立自己的内部根证书，由企业的技术人员在企业内部的电脑安装相关客户端证书以便使用。在公开的互联网，大多数网站都是使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC_(%E8%AA%8D%E8%AD%89)">登录密码</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Cookie">Cookie</a>来验证用户，而不是客户端证书。客户端证书在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">RPC系统</a>中更常见，用于验证连接设备的许可授权。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6">自签证书</a>：在用于小范围测试等目的的时候，用户也可以自己生成数字证书，但没有任何可信赖的人签名，这种自签名证书通常不会被广泛信任，使用时可能会遇到电脑软件的安全警告。</p>
<h4 id="CA-撤销名单"><a href="#CA-撤销名单" class="headerlink" title="CA 撤销名单"></a>CA 撤销名单</h4><p>CA 撤销名单：尚未到期就被<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84">证书颁发机构</a>吊销的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6">数字证书</a>的名单。</p>
<ul>
<li>吊销：该证书被不可逆的吊销。例如，它被不当的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84">证书颁发机构</a>颁发了证书，或者私钥被认为已经破坏。被吊销的最常见的原因是用户不再独有私钥，而私钥则被窃取。</li>
<li>吊扣：这个状态是可逆的。</li>
</ul>
<p>每个CA都有对应的CA证书撤销名单，里面包含着证书的序列号。有 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%A8%E7%BA%BF%E8%AF%81%E4%B9%A6%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE">OCSP</a> 和 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E5%90%8A%E9%94%80%E5%88%97%E8%A1%A8">CRL</a> 两种形式</p>
<blockquote>
<p>非关键 CA 颁发者: URI: <a target="_blank" rel="noopener" href="http://secure.globalsign.com/cacert/gsrsaovsslca2018.crt">http://secure.globalsign.com/cacert/gsrsaovsslca2018.crt</a> </p>
<p>OCSP 响应者: URI: <a target="_blank" rel="noopener" href="http://ocsp.globalsign.com/gsrsaovsslca2018">http://ocsp.globalsign.com/gsrsaovsslca2018</a></p>
</blockquote>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/crl.png" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ocsp.png" alt="img"></p>
<h1 id="HTTPS-SSL-TLS"><a href="#HTTPS-SSL-TLS" class="headerlink" title="HTTPS (SSL/TLS)"></a>HTTPS (SSL/TLS)</h1><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_interview.html#http-%E4%B8%8E-https">HTTPS  HTTP</a> </p>
<h2 id="传输层安全（TLS）"><a href="#传输层安全（TLS）" class="headerlink" title="传输层安全（TLS）"></a>传输层安全（TLS）</h2><p>Transport Layer Security</p>
<h3 id="TLS-握手（TLS-1-2）"><a href="#TLS-握手（TLS-1-2）" class="headerlink" title="TLS 握手（TLS 1.2）"></a>TLS 握手（TLS 1.2）</h3><p>在TCP threeway handshake之后，就会开始TLS handshake</p>
<p>两种交换会话密钥的算法：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html#rsa-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">RSA 握手</a> 和 <a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 握手</a> 后者支持前向安全，现在使用更加广泛</p>
<h4 id="RSA-握手"><a href="#RSA-握手" class="headerlink" title="RSA 握手"></a>RSA 握手</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241130161720294.png" alt="image-20241130161720294"></p>
<ol>
<li><strong>ClientHello</strong>: 客户端向服务器发送随机数<code>client random</code>，TLS版本，支持的加密套件列表。</li>
<li><strong>ServerHello</strong>: 服务器响应随机数<code>server random</code>，确认好加密套件，下发服务器证书(<code>Certificate</code>)。<ul>
<li>证书里有用于<code>premaster</code>加密的服务器公钥</li>
</ul>
</li>
<li><strong>Client Key Exchange</strong>: 客户端证书验证通过后，生成另一个随机数<code>premaster secret</code>，通过<strong>服务器证书的公钥</strong>加密</li>
<li>服务器用私钥解密获取<code>premaster secret</code>，双方根据<code>premaster secret</code>和两个随机数生成<code>session key</code> </li>
<li><strong>Change Cipher Spec</strong>: 客户端通知接下来要使用会话密钥进行通信了，之前都是明文通信。切换加密标准</li>
<li><strong>Finishd</strong>: 客户端计算之前发出的明文消息的摘要（Hash），再用<code>session key</code>加密后发给服务端</li>
<li>服务端重复5,6步，双方认证加解密无问题，则可以开始正式发送用<code>session key</code>加密后的<code>application data</code> </li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/e6zkf4qwi7.jpeg" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/https_rsa.png" alt="img"> </p>
<h5 id="加密套件（Cipher-Suite）"><a href="#加密套件（Cipher-Suite）" class="headerlink" title="加密套件（Cipher Suite）"></a>加密套件（Cipher Suite）</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43408952/article/details/124715927">TLS 各种加密套件_tls加密套件-CSDN博客</a> </p>
<p><strong>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</strong> </p>
<ul>
<li><strong>密钥交换策略</strong>（Key Exchange/Arrangement）：用于交换对称密钥。<strong>RSA</strong>、DH、DHE、<strong>ECDHE</strong>、PSK</li>
<li><strong>数字签名算法</strong>（Authentication）：用于验证证书。<strong>RSA</strong>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95"><strong>DSA</strong></a> 、ECDSA</li>
<li><strong>对称加密算法</strong>（Block/stream ciphers）：用于加密消息流。<strong>ChaCha20</strong>、<strong>AES</strong>、DES等</li>
<li><strong>MAC 算法</strong>（Message authentication）：用于创建报文鉴别码，例如<strong>SHA-256</strong>，MD5，消息流每个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%9D%97">数据块</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86%E6%95%A3%E5%88%97">加密散列</a>。(分块加密信息以后的报文摘要)</li>
</ul>
<h5 id="前向安全性（Forward-Secrecy）"><a href="#前向安全性（Forward-Secrecy）" class="headerlink" title="前向安全性（Forward Secrecy）"></a>前向安全性（Forward Secrecy）</h5><p>共享密钥被攻破不会导致之前的会话信息全部泄露。Perfect Forward Secrecy</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/45203206">如何理解前向安全性？和完美前向保密（perfect forward secrecy）区别？ - 知乎</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/348420897">有了共享密钥为什么还需要会话密钥？ - 知乎</a> </p>
<p><strong>有了premaster key为什么要session key？</strong> </p>
<p>RSA握手中不把premaster key直接当做对称密钥，单次session key泄露不会造成之前的会话信息都泄露。</p>
<p>前向安全性问题出在共享密钥上，RSA握手的共享公-私密钥对是长期不变的，也就是说如果服务端用于RSA加密的私钥泄露会导致之前的会话信息全部暴露。如果对每次会话都生成一对RSA密钥对，理论可行，但是性能不如后面要介绍的ECDHE。</p>
<p> 双<strong>RSA</strong>虽然也能实现<strong>PFS</strong>，但是效率太差，没有公司会采用， 基本都是<strong>RSA + ECDHE</strong>。 </p>
<h4 id="ECDHE-握手"><a href="#ECDHE-握手" class="headerlink" title="ECDHE 握手"></a>ECDHE 握手</h4><p>椭圆曲线最重要的参数是<strong>椭圆曲线类型</strong>（基点G）[RSA 算法的替代品：X25519/Ed25519 使用记录 | 存在感消失的地方|ω•`)](<a target="_blank" rel="noopener" href="https://akarin.dev/2021/09/16/a-taste-of-curve25519/">https://akarin.dev/2021/09/16/a-taste-of-curve25519/</a>)  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241130165130228.png" alt="image-20241130165130228"></p>
<ol>
<li><strong>ClientHello</strong>: 客户端向服务器发送<strong>随机数</strong>client random，TLS版本，支持的加密套件列表</li>
<li><strong>ServerHello</strong>: 服务器响应<strong>随机数</strong>server random，确认好双方都支持的加密套件，同时下发服务器<strong>证书</strong>(<code>certificate</code>)<ul>
<li>证书中的公钥用于鉴别自己发出的签名有效。</li>
</ul>
</li>
<li><strong>Server Key Exchange</strong>: 生成随机数作为<strong>临时私钥</strong>，保留在本地。公开<strong>椭圆曲线</strong>基点G，一般是X25519，根据G和临时生成的私钥，算出<strong>公钥</strong>发给客户端。为了保证公钥不被篡改，同时会使用RSA进行数字签名。</li>
<li><strong>Client Key Exchange</strong>: 客户端验证通过后，生成自己临时私钥，根据基点G算出<strong>公钥</strong>，发送给服务器。</li>
<li>这样，双方知道了对方的公钥，就可以开始算共享密钥了。</li>
<li>之后的步骤就是互相发送change cipher spec+finished，ECDHE可以在客户端发完信息之后可以直接开始发送<code>application data</code> </li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/0mhr8kq63w.jpeg" alt="img"></p>
<p>==抓包实战== </p>
<p><u>搭建https server（springboot）</u></p>
<ol>
<li><strong>生成自签名证书</strong>，使用jdk的keytool生成证书</li>
</ol>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -<span class="keyword">alias</span> wxl -keyalg RSA -keysize <span class="number">2048</span> -storetype PKCS12 -keystore wxl-ssl-<span class="keyword">key</span>.p12 -validity <span class="number">3650</span></span><br></pre></td></tr></table></figure>

<ul>
<li>-genkey：表示要创建一个新的密钥</li>
<li>-alias：keystore别名</li>
<li>-keyalg：加密算法</li>
<li>-keysize：密钥长度</li>
<li>-storetype：密钥类型</li>
<li>-keystore：文件存放位置</li>
<li>-validity：密钥有效期，单位为天</li>
</ul>
<ol start="2">
<li><strong>springboot配置https</strong></li>
</ol>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">classpath:wxl-ssl-key.p12</span></span><br><span class="line">    <span class="attr">key-store-password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">key-store-type:</span> <span class="string">PKCS12</span></span><br><span class="line">    <span class="attr">enabled-protocols:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TLSv1.2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>enabled-protocols表示支持启用的TLS版本，这里配置仅TLS1.2</li>
</ul>
<p><u>请求并抓包</u></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://localhost:8443/hello -k</span><br></pre></td></tr></table></figure>

<p>tcp.port == 8443</p>
<h5 id="TLS-False-Start"><a href="#TLS-False-Start" class="headerlink" title="TLS False Start"></a>TLS False Start</h5><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004003319">https - TLS False Start究竟是如何加速网站的 - 野狗科技官方专栏 - SegmentFault 思否</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/0mhr8kq63w.jpeg" alt="img"></p>
<blockquote>
<p>The recommended whitelists are such that if cryptographic algorithms suitable for forward secrecy would possibly be negotiated, no False Start will take place if the current handshake fails to provide forward secrecy.</p>
<p><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7918">RFC 7918 - Transport Layer Security (TLS) False Start</a> </p>
</blockquote>
<p>ECDHE和DHE支持前向保密，所以可以使用TLS抢跑。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1420297">90%的人都不懂的TLS握手优化-腾讯云开发者社区-腾讯云</a> </p>
<h3 id="TLS-记录"><a href="#TLS-记录" class="headerlink" title="TLS 记录"></a>TLS 记录</h3><p>TLS 握手主要用来解决服务器的可信度问题，TLS 记录可以解决报文的压缩、加密和数据认证的问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241130224715135.png" alt="image-20241130224715135"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.png" alt="img"></p>
<h3 id="TLS-漏洞"><a href="#TLS-漏洞" class="headerlink" title="TLS 漏洞"></a>TLS 漏洞</h3><hr>
<p><u><strong>协议设计上的漏洞</strong></u>：一些漏洞源于TLS协议本身的设计缺陷，通常会在新版本中修复：</p>
<p><strong>BEAST（Browser Exploit Against SSL/TLS）</strong></p>
<ul>
<li><strong>描述</strong>：BEAST 攻击利用 TLS 1.0 中的 CBC 模式实现的设计缺陷，通过中间人攻击窃取加密数据。</li>
<li><strong>修复</strong>：TLS 1.1 和更高版本已经修复了该问题，同时推荐使用 AES-GCM 等替代的加密模式。</li>
</ul>
<p><strong>CRIME（Compression Ratio Info-leak Made Easy）</strong></p>
<ul>
<li><strong>描述</strong>：通过利用TLS压缩功能，攻击者可以猜测敏感数据（如会话Cookie）。</li>
<li><strong>修复</strong>：禁用TLS压缩功能。</li>
</ul>
<p><strong>POODLE（Padding Oracle On Downgraded Legacy Encryption）</strong></p>
<ul>
<li><strong>描述</strong>：POODLE 利用 SSL 3.0 中的填充漏洞进行攻击，针对使用CBC模式的实现。</li>
<li><strong>修复</strong>：废弃 SSL 3.0 并采用更安全的协议版本（如 TLS 1.2+）。</li>
</ul>
<p><strong>Downgrade Attacks</strong></p>
<ul>
<li><strong>描述</strong>：攻击者通过中间人攻击强制客户端和服务器降级到不安全的协议版本（如 SSL 3.0 或早期 TLS 版本）。</li>
<li><strong>修复</strong>：使用 <strong>TLS_FALLBACK_SCSV</strong> 标记防止协议降级攻击。</li>
</ul>
<p><strong>Logjam</strong></p>
<ul>
<li><strong>描述</strong>：Logjam 攻击利用 Diffie-Hellman 密钥交换中的弱参数（512位素数），允许攻击者破解加密。</li>
<li><strong>修复</strong>：升级到更强的密钥（2048位或以上），并禁用弱算法。</li>
</ul>
<hr>
<p><u><strong>实现上的漏洞</strong></u>：许多漏洞是由于TLS库实现中存在的错误或疏漏，而不是协议本身的问题。</p>
<p><strong>Heartbleed</strong></p>
<ul>
<li><strong>描述</strong>：这是 OpenSSL 的实现漏洞，允许攻击者通过 Heartbeat 扩展读取服务器内存中的敏感数据（如私钥）。</li>
<li><strong>修复</strong>：修复受影响的 OpenSSL 版本，更新到无漏洞的版本。</li>
</ul>
<p><strong>ROBOT（Return Of Bleichenbacher’s Oracle Threat）</strong></p>
<ul>
<li><strong>描述</strong>：利用某些TLS实现中的 RSA 加密模式缺陷，通过构造恶意数据包破解私钥。</li>
<li><strong>修复</strong>：修复实现并采用更安全的加密模式。</li>
</ul>
<p><strong>Zero-Length Padding</strong></p>
<ul>
<li><strong>描述</strong>：某些TLS实现接受零长度的填充，可能被攻击者利用进行漏洞利用。</li>
<li><strong>修复</strong>：严格遵循协议规范，确保填充字段符合要求。</li>
</ul>
<hr>
<p><u><strong>配置和使用上的问题</strong></u>：即使TLS协议和实现没有漏洞，不当的配置或使用也可能导致安全隐患。</p>
<p><strong>弱密码套件</strong></p>
<ul>
<li>使用已知不安全的加密算法或过短的密钥长度（如RC4或1024位RSA）。</li>
<li><strong>解决方法</strong>：禁用弱密码套件，使用推荐的安全算法（如 AES-GCM、ChaCha20-Poly1305）。</li>
</ul>
<p><strong>过期或伪造的证书</strong></p>
<ul>
<li>如果服务器使用过期、伪造或不可信的证书，攻击者可以进行中间人攻击。</li>
<li><strong>解决方法</strong>：确保证书可信且未过期，并使用 Certificate Transparency 来检测伪造证书。</li>
</ul>
<p><strong>主机名验证问题</strong></p>
<ul>
<li>一些TLS实现未正确验证证书中的主机名，可能导致攻击者伪装成合法服务器。</li>
<li><strong>解决方法</strong>：强制严格的主机名验证。</li>
</ul>
<p><strong>会话恢复漏洞</strong></p>
<ul>
<li>TLS会话恢复功能（如会话ID或会话票据）在设计或实现上可能存在漏洞，导致会话劫持。</li>
<li><strong>解决方法</strong>：确保会话恢复机制的实现安全，并定期刷新密钥。</li>
</ul>
<hr>
<p><u><strong>环境相关漏洞</strong></u></p>
<p><strong>硬件漏洞</strong></p>
<ul>
<li>硬件加速器或HSM（硬件安全模块）可能存在漏洞，攻击者可以利用其生成弱密钥或泄露数据。</li>
</ul>
<p><strong>随机数生成问题</strong></p>
<ul>
<li>如果随机数生成器的质量不足，攻击者可能预测到密钥。</li>
<li><strong>解决方法</strong>：使用高质量的随机数生成器（如 /dev/urandom 或硬件随机数生成器）。</li>
</ul>
<p><strong>中间人攻击</strong></p>
<ul>
<li>攻击者通过篡改DNS或ARP欺骗迫使客户端连接到恶意服务器，伪装成合法的TLS服务。</li>
<li><strong>解决方法</strong>：使用 HSTS（HTTP Strict Transport Security）和证书锁定（Certificate Pinning）。</li>
</ul>
<hr>
<p><u><strong>社会工程和弱安全操作</strong></u>：即使TLS协议本身非常安全，攻击者可能利用社会工程或操作疏漏来绕过安全机制</p>
<ul>
<li>攻击者诱骗用户接受不可信的证书。</li>
<li>管理员错误配置服务器，允许使用过时的协议版本。</li>
</ul>
<hr>
<h4 id="如何应对TLS漏洞？"><a href="#如何应对TLS漏洞？" class="headerlink" title="如何应对TLS漏洞？"></a>如何应对TLS漏洞？</h4><ol>
<li><strong>升级协议和实现</strong><ul>
<li>确保使用最新版本的TLS（推荐TLS 1.2或TLS 1.3）。</li>
<li>定期更新TLS库（如OpenSSL、BoringSSL、GnuTLS）。</li>
</ul>
</li>
<li><strong>禁用弱配置</strong><ul>
<li>禁用SSL 2.0、SSL 3.0和TLS 1.0。</li>
<li>禁用RC4和其他已知不安全的密码套件。</li>
</ul>
</li>
<li><strong>安全的服务器配置</strong><ul>
<li>强制使用强加密算法。</li>
<li>使用2048位以上的密钥和推荐的椭圆曲线（如 P-256）。</li>
</ul>
</li>
<li><strong>监控和检测</strong><ul>
<li>定期扫描服务器的TLS配置，使用工具如 SSL Labs 的服务器测试工具。</li>
<li>监控网络流量中的潜在攻击行为。</li>
</ul>
</li>
</ol>
<h3 id="TLS-1-3"><a href="#TLS-1-3" class="headerlink" title="TLS 1.3"></a>TLS 1.3</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/0877fe78380bf34ad3b28768e59fb53a.png" alt="图片"></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28850798">TLS 1.3科普——新特性与协议实现 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/187262056">TLS 1.3 进行时 - 知乎</a> </p>
<h4 id="2-RTT（TLS-1-2）"><a href="#2-RTT（TLS-1-2）" class="headerlink" title="2-RTT（TLS 1.2）"></a>2-RTT（TLS 1.2）</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wusanga/p/17386098.html">TLS1.2握手流程分析（RSA，ECDHE），和TLS1.3区别 - wuworker - 博客园</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-485b564d2209a3108575a1b13a52d715_1440w.jpg" alt="img"></p>
<h4 id="1-RTT"><a href="#1-RTT" class="headerlink" title="1-RTT"></a>1-RTT</h4><p>TLS1.2 为了考虑各种兼容性，保留了许多加密套件，这就使得客户端必须提前和服务端协商好用哪一种加密套件，这也导致了必须空出一个RTT专门协商，因此变成2-RTT。1.3只剩下5种，省去协商步骤，变成了1-RTT。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TLS_AES_256_GCM_SHA384</span><br><span class="line">TLS_CHACHA20_POLY1305_SHA256</span><br><span class="line">TLS_AES_128_GCM_SHA256</span><br><span class="line">TLS_AES_128_CCM_8_SHA256</span><br><span class="line">TLS_AES_128_CCM_SHA256</span><br></pre></td></tr></table></figure>

<p>TLS 1.3 在之前版本的基础上删除了那些不安全的加密算法，这些加密算法包括：</p>
<ul>
<li>RSA 密钥传输 —— 不支持前向安全性</li>
<li>CBC 模式密码 —— 易受 BEAST 和 Lucky 13 攻击</li>
<li>RC4 流密码 —— 在 HTTPS 中使用并不安全</li>
<li>SHA-1 哈希函数 —— 建议以 SHA-2 取而代之</li>
<li>任意 Diffie-Hellman 组—— CVE-2016-0701 漏洞</li>
<li>输出密码 —— 易受 FREAK 和 LogJam 攻击</li>
</ul>
<p>TLS 1.3 只支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86">AEAD认证模式</a> 同时完成加密和完整性校验，不再允许对加密报文进行压缩、不再允许双方发起重协商，密钥的改变不再需要发送change_cipher_spec报文给对方。对称加密算法只有AES，Chacha20，摘要算法只有 SHA，密钥交换算法只有ECDHE。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-91669b8728eb5b0fa2d88730425f9391_1440w.jpg" alt="img"></p>
<h4 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-083c00146d71e75adbcab401e57c90e1_1440w.jpg" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/59539201f006d7dc0a06333617e5ea85.png" alt="图片"></p>
<h2 id="HTTPS-优化（TLS-性能优化）"><a href="#HTTPS-优化（TLS-性能优化）" class="headerlink" title="HTTPS 优化（TLS 性能优化）"></a><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1420297">HTTPS 优化（TLS 性能优化）</a></h2><p>上文的TLS漏洞已经说明了提高安全性的措施，下列措施为提高TLS性能的措施</p>
<h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><ul>
<li>计算密集型任务，升级的是<strong>CPU</strong>而不是网卡等IO设备，如果CPU有针对 <strong>AES-NI</strong> 的特性，可以使用AES，否则可以选择chacha20</li>
</ul>
<h3 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h3><ul>
<li>升级Linux，升级OpenSSL</li>
</ul>
<h3 id="协议优化：节省RTT"><a href="#协议优化：节省RTT" class="headerlink" title="协议优化：节省RTT"></a>协议优化：节省RTT</h3><p>（整体的握手过程还是需要的）</p>
<ul>
<li><strong>密钥交换算法</strong>：使用<code>ECDHE</code>而不是<code>RSA</code>，<code>ECDHE</code>支持前向安全，因此也支持 <code>TLS False Start</code>，发送ClientKeyExchange的同时可以开始发送<code>application data</code>节省 <code>1 RTT</code>。</li>
<li><strong>升级TLS版本</strong>：TLS 1.3 相比于 TLS 1.2 废除了不安全的加密套件，总数变少，因此不需要协商套件的过程，可以节省<code>1 RTT</code>。</li>
</ul>
<h3 id="证书优化：节省客户端验证时间"><a href="#证书优化：节省客户端验证时间" class="headerlink" title="证书优化：节省客户端验证时间"></a>证书优化：节省客户端验证时间</h3><ul>
<li><strong>证书类型</strong>：在相同的安全强度下，<code>ECDSA</code> 椭圆曲线证书相比于 <code>RSA</code> 证书的密钥长度减少很多，减少了验证证书完整性的时间。</li>
<li><strong>证书验证流程</strong>：验证证书信任链的时候，<code>OCSP</code> 相比于 <code>CRL</code> 实时性更高，不用逐行读取文件；<ul>
<li>进一步提升性能可以启用<code>OCSP Stapling</code>，服务器周期性地向 CA 获取证书状态，CA会在状态上签名防止篡改，在发出ServerHello的同时也把有效信息发给客户端。</li>
</ul>
</li>
</ul>
<h3 id="会话复用：复用会话密钥"><a href="#会话复用：复用会话密钥" class="headerlink" title="会话复用：复用会话密钥"></a>会话复用：复用会话密钥</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mrpre/article/details/77868669">TLS/SSL 协议详解 (22)会话复用_ssl会话复用-CSDN博客</a> 抓包</p>
<p><strong>以下技术都是建立在已经建立过一次连接的基础上的，可以节省第一次以后会话的RTT，是用来免去握手过程的</strong></p>
<ul>
<li><strong>Session ID</strong>：将与每个客户端的会话密钥缓存在服务器内存里，形成 id-key的键值对形式，ClientHello带上session id，节省<code>1 RTT</code>，缺点是不支持分布式和消耗服务器内存。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/sessionid.png" alt="img"></p>
<ul>
<li><strong>Session Ticket</strong>：服务器可以将会话密钥再次用<strong>只有自己知道的密钥</strong>加密，然后附上有效期进行签发，以session ticket的形式交给客户端进行缓存，ClientHello带上ticket，服务器验证有效期（类似JWT）也能节省 <code>1 RTT</code> ，分布式之间需要共享这个密钥。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ticket.png" alt="img"></p>
<ul>
<li><strong>Pre-shared Key</strong>：TLS 1.3 引入的新特性，将 Session Ticket 和 早期的 application data 一并发送给服务器 直接变成<code>0-RTT</code> ，因为不用协商套件。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241130172210036.png" alt="image-20241130172210036"></p>
<p>会话复用会影响前向安全性，还可能会受到重放攻击，解决方案：</p>
<ul>
<li>只对幂等请求（GET）开放0-RTT；</li>
<li>对session ticket添加有效期；</li>
</ul>
<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Secure_Shell">SSH</a> （Secure Shell）</strong> 基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13P4y1o76u">SSH 握手详解 - bilibili 技术蛋老师</a> </p>
<p>SSH 的经典用途是登录到远程电脑中执行命令。除此之外，SSH 也支持隧道协议、端口映射和 X11 连接（允许用户在本地运行远程服务器上的图形应用程序）。借助 SFTP（SSH File Transfer Protocol） 或 SCP（Secure Copy Protocol） 协议，SSH 还可以安全传输文件。</p>
<p>SSH 使用客户端-服务器模型，默认端口是 22。SSH 是一个守护进程，负责实时监听客户端请求，并进行处理。大多数现代操作系统都提供了 SSH。</p>
<p>如下图所示，SSH Client（SSH 客户端）和 SSH Server（SSH 服务器）通过公钥交换生成共享的对称加密密钥，用于后续的加密通信。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ssh-client-server.png" alt="SSH:安全的网络传输协议"></p>
<p>SSH以<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">非对称加密</a>实现<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81">身份验证</a>：</p>
<p>身份验证有多种途径，例如其中一种方法是使用自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录；另一种方法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。</p>
<h1 id="IPsec"><a href="#IPsec" class="headerlink" title="IPsec"></a>IPsec</h1><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/download" alt="IPsec加密验证过程" style="zoom:150%;" />


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/05/11/408-%E8%AE%A1%E7%BD%91-TCP+UDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/11/408-%E8%AE%A1%E7%BD%91-TCP+UDP/" class="post-title-link" itemprop="url">传输层(TCP+UDP)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-11 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-11T00:00:00+08:00">2025-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-14 15:51:50" itemprop="dateModified" datetime="2025-05-14T15:51:50+08:00">2025-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>LAB：<a target="_blank" rel="noopener" href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/">Student Resources | Kurose/Ross, Computer Networking: a Top-Down Approach, 8/e</a> </p>
<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><h2 id="port"><a href="#port" class="headerlink" title="port"></a>port</h2><p>0-65536 TCP Header中为16位无符号整数</p>
<p>IP地址能够标识主机，但是通信是由主机中的应用进程发起和接收的，必须让应用进程拥有一个标识，而本地进程ID（PID）在各个OS之间并不统一（因为要写入TCP头部，而各个OS发送的TCPHeader必须统一），如果是给特定的应用进程分配一个特定的ID，显然也不行，因为通信双方并不必须知道对方的真正身份，因此，最后的结果就是在传输层和应用层的界面上开一些特定的“门”，进程需要的时候就分配给他，这就是软件端口（port）的由来。</p>
<h3 id="服务器端口号"><a href="#服务器端口号" class="headerlink" title="服务器端口号"></a>服务器端口号</h3><ul>
<li>1-1023: 标准规定的应用强制占用。</li>
</ul>
<table>
<thead>
<tr>
<th>HTTP</th>
<th>HTTPS</th>
<th>DNS</th>
<th>RIP</th>
<th>BGP</th>
<th>Telnet</th>
<th>FTP</th>
<th>SMTP</th>
<th>SSH</th>
<th>RMI</th>
</tr>
</thead>
<tbody><tr>
<td>80</td>
<td>443</td>
<td>53</td>
<td>520</td>
<td>179</td>
<td>23</td>
<td>21</td>
<td>25</td>
<td>22</td>
<td>111</td>
</tr>
</tbody></table>
<ul>
<li>1024-49151: 登记端口。</li>
</ul>
<h3 id="客户端端口"><a href="#客户端端口" class="headerlink" title="客户端端口"></a>客户端端口</h3><ul>
<li><p>49152-65535(16384个): 客户端发起connect动态分配，属于临时端口号，断开连接或者通信结束就会收回。</p>
</li>
<li><p>一些系统中可能会出现超过65536的情况，但是由于TCP Header的限制，必须要对端口号 % 65536</p>
</li>
</ul>
<h4 id="如何提高服务器并发能力"><a href="#如何提高服务器并发能力" class="headerlink" title="如何提高服务器并发能力"></a>如何提高服务器并发能力</h4><p>一般来讲，通过增加服务器内存、修改最大FD个数等，可以做到单台服务器支持10万+的TCP并发。当然，在真实的商用场景下，单台服务器都会编入<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=231771466&content_type=Article&match_order=1&q=%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4&zhida_source=entity">分布式集群</a>，通过负载均衡算法动态的调度不同用户的请求给最空闲的服务器，如果服务器平均内存使用超过80%的警戒线，那么就会及时采用限流或者扩展集群的方式来保证服务，绝对不会出现服务器的内存被耗尽的情况，那样就算事故了。</p>
<h2 id="TCP-UDP绑定相同端口"><a href="#TCP-UDP绑定相同端口" class="headerlink" title="TCP UDP绑定相同端口"></a>TCP UDP绑定相同端口</h2><p>IP数据报中的协议字段可以区分TCP还是UDP，因此靠这个字段就能将IP数据报准确交给对应的协议软件实现，然后软件根据抽象的端口找到应用进程，两个协议的端口并不是一个域。</p>
<h2 id="多个TCP-服务进程绑定相同端口"><a href="#多个TCP-服务进程绑定相同端口" class="headerlink" title="多个TCP 服务进程绑定相同端口"></a>多个TCP 服务进程绑定相同端口</h2><p>IP不同，端口相同，也是可以的。</p>
<p>0.0.0.0:8888 表示监听所有IP地址的8888端口</p>
<h2 id="客户端端口的复用"><a href="#客户端端口的复用" class="headerlink" title="客户端端口的复用"></a>客户端端口的复用</h2><p>可以，因为TCP连接有4个元素才能唯一确定，只要有一个不一样就是不同的TCP连接</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/quic.html">4.17 如何基于 UDP 协议实现可靠传输？ | 小林coding</a> </p>
<p>User Datagram Protocol 用户数据报协议</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><strong>无连接</strong>：传输数据之前不需要建立起连接，直接发送即可，可以是一对一，多对一，一对多，多对多。</li>
<li><strong>不可靠</strong>：可能出现差错，丢失，重复，不能保证按序到达，也就是<strong>尽最大努力交付</strong>，这也使得首部开销比较小。</li>
<li><strong>面向数据报</strong>：无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 TCP 无穷无尽的二进制流那样不清楚啥时候能结束。</li>
<li>没有拥塞控制</li>
</ul>
<p>优点还有可扩展性强：TCP实现固化在操作系统中，有时性能可能不能满足部分需求，开发者可以利用UDP的特性，在应用层实现可靠传输，比如QUIC协议</p>
<h2 id="UDP-Datagram"><a href="#UDP-Datagram" class="headerlink" title="UDP Datagram"></a>UDP Datagram</h2><p>总长度8B，源端口和目的端口各占2B，然后是UDP的PDU长度（2B），最后是检验和（2B）。</p>
<ul>
<li><strong>udp长度</strong>：max: 65535B min: 8B 整个UDP数据报的长度</li>
<li><strong>检验和</strong>：添加伪首部[<strong>源IP</strong>(4B), <strong>目的IP</strong>(4B), <strong>全0</strong>(1B), <strong>17</strong>[1B,表示UDP协议类型], <strong>UDP长度</strong>(2B)]，计算检验和先将检验和位置0，然后将添加了伪首部的<strong>整个UDP数据报</strong>划分成若干个16位字，不够补零，最后将这些字按位相加，高位进位溢出进到低位，最后取反码放到检验和。IP packet只检验首部，而UDP datagram全部都检验。</li>
</ul>
<table>
<thead>
<tr>
<th>源端口</th>
<th>目的端口</th>
<th>UDP数据报长度</th>
<th>检验和</th>
</tr>
</thead>
<tbody><tr>
<td>2B</td>
<td>2B</td>
<td>2B</td>
<td>2B</td>
</tr>
</tbody></table>
<p>如果UDP发现检验和不正确，就直接丢弃数据报</p>
<p>如果UDP发现目的端口不准确，就丢弃数据报，随后由ICMP发送一条“终点不可达”的差错报告报文（traceroute）</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>Transmission Control Protocol，传输控制协议</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li><strong>面向连接</strong>：传输数据之前必须建立起双方的连接，传输完双方应该断开连接，只能是点对点通信。</li>
<li><strong>可靠</strong>：通过TCP传送的数据，无差错，不丢失，不重复，按序到达，这也使得首部开销比较大。</li>
<li><strong>全双工</strong>：双方可以同时收发信息，设有接收和发送缓冲区</li>
<li><strong>面向字节流</strong>：将应用层交下来的数据不是以<strong>消息报为单位</strong>向目的主机发送，而是看作无结构的字节流，TCP不懂字节流的含义是什么，这些数据可能被<strong>切割和组装</strong>成各种数据包，但是发送者发出的字节流和接受者收到的字节流必须一样，并且应用能够正确识别这些无意义字节流的含义，将其还原为有意义的应用层数据。接收端收到这些数据包后没有正确还原原来的消息，就会有“粘包”的现象。</li>
</ul>
<h2 id="可靠传输协议：ARQ"><a href="#可靠传输协议：ARQ" class="headerlink" title="可靠传输协议：ARQ"></a>可靠传输协议：ARQ</h2><p>ARQ（Automatic Repeat reQuest，自动重传请求）是计算机网络中用于确保数据可靠传输的一种关键技术。它主要通过确认（ACK）和超时重传两种机制，在不可靠的网络服务上实现可靠的数据传输。当发送方在一定时间内未收到确认帧时，它会自动重发数据包，直到收到确认为止。ARQ协议分为<strong>停止等待ARQ</strong>和<strong>连续ARQ</strong>两种类型，每种都有其特定的应用场景和优缺点。</p>
<ol>
<li>ARQ是一种可以在不可靠的数据通道上可靠地传输数据的方案，所以其实链路层和传输层都用了ARQ，并不专属某一层。</li>
<li>并不是一条连接只要有一层用了ARQ，它的上层的通信就是可靠的。因为ARQ只保证使用它的点到点是可靠的，比如数据链路层只保证你和你的路由器通信可靠，你的路由器到小区的路由器通信也可靠， 但是路由器本身会故障，会拥塞丢包，也就是点本身会产生问题。</li>
<li>所以需要在传输层或者应用层再加一层ARQ保障整条数据通道的可靠性。比如你自己写程序要在应用层通信，但传输层不用tcp想用udp，也可以在你程序里用ARQ协来实现可靠性。</li>
<li><strong>注意：</strong> 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。<ul>
<li>分组和确认分组都必须进行编号。</li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li>
</ul>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241203213134835.png" alt="image-20241203213134835"></p>
<h3 id="停止-等待ARQ的逐步优化"><a href="#停止-等待ARQ的逐步优化" class="headerlink" title="停止-等待ARQ的逐步优化"></a>停止-等待ARQ的逐步优化</h3><h4 id="v2-x"><a href="#v2-x" class="headerlink" title="v2.x"></a>v2.x</h4><h5 id="v2-0：给数据包加上校验和，防止数据包出现比特差错"><a href="#v2-0：给数据包加上校验和，防止数据包出现比特差错" class="headerlink" title="v2.0：给数据包加上校验和，防止数据包出现比特差错"></a>v2.0：给数据包加上校验和，防止数据包出现比特差错</h5><ul>
<li>2.0的第一个问题：<strong>接收方的ACK可能有比特差错</strong></li>
<li>2.0的第二个问题：<strong>发送方未正确接收ACK直接重发，接收方不会区分是不是重传的包，导致交给上层重复的数据。</strong></li>
</ul>
<h5 id="v2-1如何解决v2-0问题？"><a href="#v2-1如何解决v2-0问题？" class="headerlink" title="v2.1如何解决v2.0问题？"></a>v2.1如何解决v2.0问题？</h5><ol>
<li><strong>给ACK加一个校验和。</strong></li>
</ol>
<ul>
<li>发送方收到ACK，说明是接收方正确收到了，发送下一个数据包。</li>
<li>发送方收到NAK或者校验和出错的包，选择重发这个数据包。</li>
</ul>
<p>此时还没有解决第二个问题，接收方正常接收发出ACK，如果发送方收到一个校验和错误的响应（本来应该是ACK）然后重传，但是接收方会把重传的包当成全新的，这样就导致了重复的问题。</p>
<ol start="2">
<li><strong>在不丢包的情况下，给数据包附上一bit标识符，让接收方区分是否为重发的数据包。</strong></li>
</ol>
<ul>
<li>发送方发的时候就注明是0号数据包，接收方鉴别无误就可以转换到准备接收下一个数据包的状态并发送ACK，如果发送方收到了ACK，皆大欢喜继续发下一个数据包</li>
<li>如果发送方并未正确收到ACK，则需要重发此包，而接收方早就转换到准备接收新数据包的状态了，再次接收到旧数据包直接选择丢弃，但也要记得再发一下ACK，提醒发送者可以发送新数据包了。</li>
</ul>
<h5 id="v2-2：改善接收方的响应结构"><a href="#v2-2：改善接收方的响应结构" class="headerlink" title="v2.2：改善接收方的响应结构"></a>v2.2：改善接收方的响应结构</h5><p><strong>去除NAK，在ACK内部用一个比特位表示ACK或者NAK</strong></p>
<ul>
<li>接收方准备接收0号，如果出错，则发送ACK<del>1</del>，发送方仍处于等待ACK<del>0</del>的状态，收到的只要不是ACK<del>0</del>，就会重发。</li>
<li>接收方准备接收0号，如果正确，则发送ACK<del>0</del>，准备接收新数据包，而发送方如果没有正确收到这个ACK<del>0</del>，会再次重发，这时候接收方会再次发送ACK<del>0</del>让发送方知晓 上个数据包已经被正确接收，提醒发送者可以开始新数据包，然后把这个重复的丢弃。</li>
</ul>
<h5 id="v2-x的问题"><a href="#v2-x的问题" class="headerlink" title="v2.x的问题"></a>v2.x的问题</h5><p>如果<strong>数据包丢了</strong>，接收方收不到自然也谈不上响应，再如果，<strong>响应丢了</strong>，<strong>响应迟到了</strong>，发送者就会陷入空等状态</p>
<h4 id="v3-0：比特交换协议"><a href="#v3-0：比特交换协议" class="headerlink" title="v3.0：比特交换协议"></a>v3.0：比特交换协议</h4><p>可靠的传输协议，也叫比特交换协议，在在v2可以解决丢包和迟到的问题。</p>
<ol>
<li>从<strong>发送方角度</strong>考虑，<strong>把超时作为重传的唯一根据</strong>。</li>
</ol>
<ul>
<li><p>如果在准备接收ACK<del>1</del>的情况下收到<strong>错误响应</strong>（ACK<del>0</del>或者校验和错误），则什么也不做，等待超时重发</p>
</li>
<li><p>发出分组即启动timer，一定时间内没有收到<strong>正确的响应</strong>到了timeout，则重发并重启timer；</p>
</li>
<li><p><strong>收到正确的响应</strong>就停止timer，转换到准备发下一个分组的状态，如果有这个如果这时有响应发来，肯定是迟到的响应，不予理会。</p>
</li>
</ul>
<ol start="2">
<li>因为有传播时延和排队处理时延，所以可能会出现过早超时然后重发的情况</li>
</ol>
<ul>
<li><p>接受者的角度肯定是收到1，ACK<del>1</del>然后准备接收0，这时候再次接到1，此时回答一个ACK<del>1</del>，然后丢弃重复的1。</p>
</li>
<li><p>发送者如果在等待上方传下来数据的情况下收到了响应，说明这肯定是一个迟到的响应，不予理会。</p>
</li>
</ul>
<p>v3总结：</p>
<p>发一个数据包，等对应的ACK，超时了就重发，必须且只能收到一次对应的ACK，收到就转变状态不等了，来再多也没用。</p>
<h5 id="v3-0的问题"><a href="#v3-0的问题" class="headerlink" title="v3.0的问题"></a>v3.0的问题</h5><ul>
<li>时间利用上不如v2，但是基于时间的重传和基于ACK比特位的重传是冲突的，因此问题不算大。</li>
<li>最根本的还是停止等待对时间资源的浪费。</li>
</ul>
<h3 id="Go-Back-N（回退N步）：流水线式的发送与接收"><a href="#Go-Back-N（回退N步）：流水线式的发送与接收" class="headerlink" title="Go Back N（回退N步）：流水线式的发送与接收"></a>Go Back N（回退N步）：流水线式的发送与接收</h3><p>Go Back N：发送窗口，累计确认，超时重传。</p>
<p><strong>发送方</strong>：</p>
<ol>
<li>维护一个发送窗口(N)，用来限制一次最多发送的包数目，基于超时重传</li>
</ol>
<ul>
<li>在窗口以前的默认已经成功发送了(0-base)，窗口内部有的已经发送处于等待响应的状态(base-nextseqnum)，有的还没有发送过(nextseqnum+1 - base+N-1)。</li>
<li>应用层传下来的data，如果分配到的序号超过窗口，拒绝（或者缓存一下），在窗口内，填到nextseqnum++处。</li>
<li>在发送窗口中的包，发送base时start timer，一直把从base到nextseqnum的包都发出去，如果timeout就把这些包全部重发一遍。</li>
</ul>
<ol start="2">
<li>接收ACK</li>
</ol>
<ul>
<li>根据ACK中的编号滑动窗口边缘(base=getacknum+1) 这里的ACK包含的序号是接收方封装的，接收方的逻辑可以保证此序号之前的全部正确传输。</li>
<li>如果滑动窗口之后，base = nextseqnum 说明窗口内已经没有要发送的分组，stop timer，如果还有，那就restart timer，继续等待。</li>
</ul>
<p><strong>接收方</strong>：</p>
<ol>
<li><strong>累计确认</strong>：只需要维护一个序号expectedseqnum，顾名思义，接收方必须按序ACK，按序递交给上层。</li>
</ol>
<ul>
<li>收到的包确实是自己想要的，于是就发一个ACK<del>expectedseqnum</del>，随后递交给应用层，然后ex…num自增，表明自己要接收下一个包<ul>
<li>假定ACK响应中的序号N，对于接收方来说序号&lt;=N的全部正确递交给上层了。</li>
</ul>
</li>
<li>没有收到自己想要的包，就丢弃，并把上次制作好的ACK重新发送，提醒发送方该滑动窗口了。（<strong>可能是因为发送方没有正确识别ACK造成的冗余分组</strong>）</li>
</ul>
<p>意味着即使之前已经接受过正确的分组也要丢弃，expectedseqnum之后的情况是未知的，因此只能回退重传。</p>
<p>单个分组的错传，会引起之后的大量分组重传。</p>
<h3 id="Selective-Repeat（选择重传）：无需按序ACK，不累计确认"><a href="#Selective-Repeat（选择重传）：无需按序ACK，不累计确认" class="headerlink" title="Selective Repeat（选择重传）：无需按序ACK，不累计确认"></a>Selective Repeat（选择重传）：无需按序ACK，不累计确认</h3><p>Selective Repeat 特点：接收窗口，乱序ACK，按序交付上层</p>
<p>接收方不丢弃正确的乱序分组，而是先进行ACK然后缓存，并不直接交给上层。</p>
<ul>
<li>对于发送方来说，对方对base序号的ACK是发送窗口滑动的唯一标准。</li>
<li>对于接收方来说，成功按序递交给上层是接收窗口滑动的唯一标准。</li>
</ul>
<p><strong>发送方</strong>：</p>
<ol>
<li>维护发送窗口：</li>
</ol>
<ul>
<li>对于应用层传下来的数据，仍然不变。</li>
<li>在发送窗口的包，为每一个包都设置一个timer，单独计时。</li>
</ul>
<ol start="2">
<li>接收ACK：</li>
</ol>
<ul>
<li>ACK对应编号标记为已ACK，</li>
<li>如果ACKnum = send_base，则说明可以移动了，移动到第一个未ACK的序号处<ul>
<li>例子：窗口变成OOOOXXXXOXX，则滑动后的窗口为XXXXOXXXXXX</li>
</ul>
</li>
</ul>
<p><strong>接收方</strong>：可以不按序ACK，但是递交给上层需要按序，维护一个接收窗口</p>
<ul>
<li>序号在窗口里面的，没问题的就发个ACK<ul>
<li>失序的（在窗口中间的）先缓存好，等于rcv_base则准备交付给应用层，将从rcv_base开始所有缓存好的包 连续、按序交给应用层</li>
</ul>
</li>
</ul>
<p><strong>冗余分组</strong>：</p>
<p>对于接收者来说，ACKnum=rcv_base就可以开始滑动了，表明rcv_base之前的数据肯定已经正确交付给应用层了，但是并不能保证这个ACK就一定能被正确解析，因此发送窗口可能会迟迟不滑动导致一直重传（冗余分组）</p>
<ul>
<li>如果序号是[base-N 到 base-1]的，即使之前ACK过了，也还是会回复ACK，不断尝试提醒发送方滑动发送窗口。</li>
</ul>
<h4 id="窗口注意事项"><a href="#窗口注意事项" class="headerlink" title="窗口注意事项"></a>窗口注意事项</h4><ul>
<li><strong>接收窗口与发送窗口并不总是完全的同步，可能会错开一部分，不过接收窗口的base也不会完全超过发送窗口，毕竟如果还没发送，也就谈不上接收过了。</strong></li>
</ul>
<ul>
<li><p><strong>序号范围与窗口大小</strong>序号是循环利用的，如果窗口太大，序号范围太小，就有可能发生重传的分组被当成是新分组的情况</p>
<ul>
<li><p>序号是0~3 窗口大小为3，0 1 2 ACK过了传给上层，接收窗口滑动变成 3 0 1</p>
</li>
<li><p>ACK没有被正确接收，因此0,1,2重传，此时0和1就被当成是<strong>全新</strong>的数据了。</p>
</li>
</ul>
</li>
</ul>
<p><strong>窗口大小与序号的关系计算</strong></p>
<p>假设序号0-N-1，窗口大小为M，M &lt;= N 发送窗口为序号0到M-1</p>
<ul>
<li>对于SR来说，最坏的情况，接收窗口为序号M到M+M-1(一共M个)，而2M-1不能超过序号N-1，否则就会有上面的问题，因此$M\le \frac{N}{2}$ </li>
<li>对于GBN来说，窗口只有一个宽度，因此$M\le N-1$ </li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241203204645293.png" alt="image-20241203204645293"></p>
<h3 id="可靠传输协议的关键"><a href="#可靠传输协议的关键" class="headerlink" title="可靠传输协议的关键"></a>可靠传输协议的关键</h3><ul>
<li><p>确认机制：没差错要ACK</p>
<ul>
<li>保证没有比特差错：分组和ACK都要有校验位。</li>
</ul>
</li>
<li><p>对于超时（未得到正确的ACK）重传</p>
<ul>
<li>发送时使用timer进行计时，超时则重传，</li>
<li>可能带来的冗余分组问题，要让接收方能分辨出冗余分组<ul>
<li>接收方如何对待冗余分组：发送者给分组添加序号，接收方根据序号分辨这是一个重传的还是新的分组。<ul>
<li>并且发出的ACK也要携带序号，提醒哪个分组被正确收到了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>窗口、流水线发送：提高信道利用率</p>
<ul>
<li>窗口大小：窗口之间不同步（无法避免）但是窗口太大，导致重传分组被当做新的分组。</li>
</ul>
</li>
</ul>
<p>一个默认的假设：除了丢包，包并不会被重新排序。</p>
<p>而现实是传输层下方是不可靠信道，并不保证数据准确无误并且一定按序到达，因此应当将互联网看成是一个不定时发送的缓存，由于序号复用，这样可能会有相同序列号的分组出现在信道中，产生冲突。假定一个分组在网络中有TTL，超过TTL，序号就一定能够被再次使用。</p>
<h3 id="GBN-vs-SR"><a href="#GBN-vs-SR" class="headerlink" title="GBN vs SR"></a>GBN vs SR</h3><table>
<thead>
<tr>
<th>特性</th>
<th>GBN</th>
<th>SR</th>
</tr>
</thead>
<tbody><tr>
<td>重传策略</td>
<td>从丢失的分组开始，重新发送整个窗口</td>
<td>仅重传出错或超时的分组</td>
</tr>
<tr>
<td>接收端处理</td>
<td>按顺序接收分组，否则丢弃</td>
<td>接收乱序分组并缓存</td>
</tr>
<tr>
<td>计时器数量</td>
<td>1 个计时器</td>
<td>N 个计时器（每个分组一个计时器）</td>
</tr>
<tr>
<td>适用场景</td>
<td>高丢包率但传输顺序严格的环境</td>
<td>低丢包率，允许乱序接收的环境</td>
</tr>
<tr>
<td>发送窗口</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>接收窗口</td>
<td>1</td>
<td>N</td>
</tr>
</tbody></table>
<h4 id="Go-Back-N-GBN"><a href="#Go-Back-N-GBN" class="headerlink" title="Go-Back-N (GBN)"></a>Go-Back-N (GBN)</h4><ul>
<li><strong>特点</strong>：<ol>
<li>发送端最多可以连续发送 <strong>N 个未确认的分组</strong>。</li>
<li>如果在超时时间内没有收到某个分组的确认，应从该分组开始 <strong>重新发送其后所有分组</strong>。</li>
</ol>
</li>
<li><strong>计时器需求</strong>：<br>GBN 协议只需要一个 **==全局计时器==**，用于跟踪 <strong>最早发送但尚未确认的分组（窗口起点）</strong>。<ul>
<li>一旦计时器超时，直接 <strong>回退到该分组并重传整个窗口</strong>，不需要为每个分组单独计时。</li>
<li>原因是 GBN 要求分组必须 <strong>按顺序到达</strong>，只要有一个分组超时，所有后续分组都需要重发。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Selective-Repeat-SR"><a href="#Selective-Repeat-SR" class="headerlink" title="Selective Repeat (SR)"></a>Selective Repeat (SR)</h4><ul>
<li><strong>特点</strong>：<ol>
<li>支持接收端 <strong>乱序接收</strong>，允许正确接收的分组先缓存。</li>
<li>发送端只重传超时或出错的分组，而不是整个窗口。</li>
</ol>
</li>
<li><strong>计时器需求</strong>：<br>由于 SR 可以 <strong>选择性重传特定分组</strong>，每个分组都需要一个 **==独立的计时器==**。<ul>
<li>如果某个分组超时，只重传该分组，而不影响其他分组。</li>
<li>因此，发送端必须为 <strong>窗口内的每个分组维护单独的计时器</strong>，以便精确控制每个分组的超时和重传行为。</li>
</ul>
</li>
</ul>
<h2 id="基于字节流"><a href="#基于字节流" class="headerlink" title="基于字节流"></a>基于字节流</h2><h3 id="数据包分片"><a href="#数据包分片" class="headerlink" title="数据包分片"></a>数据包分片</h3><ul>
<li>以太网帧总长度至少64B，数据负载不能超过MTU，首部+FCS 18 因此要求 IP数据报长度在 <code>46~1500</code>Byte</li>
</ul>
<ul>
<li><p>IP首部至少20B，因此传输层数据包为<code>26~1480</code> Byte</p>
</li>
<li><p>TCP首部20B TCP报文段的数据部分为<code>6~1460</code>Byte</p>
</li>
<li><p>UDP首部8B UDP数据报的数据部分为<code>18~1472</code>Byte</p>
</li>
<li><p>这些都是为了迎合以太网帧的帧大小限制。当超过了这个限制，就要对IP数据包进行分片。</p>
</li>
</ul>
<h3 id="UDP：无法在传输层分片"><a href="#UDP：无法在传输层分片" class="headerlink" title="UDP：无法在传输层分片"></a>UDP：无法在传输层分片</h3><p>超过了数据部分的大小只能通过IP进行分片，分多个IP数据报发送。</p>
<p>它并没有协商的能力，所以它只能直接把用户发送的数据，传给网络层（<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=105481550&content_type=Article&match_order=1&q=IP%E5%B1%82&zhida_source=entity">IP层</a>），由网络层来进行分片。</p>
<p>对 网络层（IP层）来说：它并不知道上层传过来的数据，到底是 TCP 还是 UDP，它并不关心也没有能力区分。</p>
<p>如果发现数据过大，那么 IP 层会自动对数据进行切割，分片。用 UDP 协议发送，那么如果网络发生了波动，丢失了某个 IP 包分片， 对于 UDP 而言， 它没有反馈丢失了哪个分片给发送方的能力，这就意味着：50k 的数据全都丢失了，如果需要重传，就得再次完整的传递这 50k 的数据。</p>
<blockquote>
<p>UDP 协议头有 2 byte 表示长度的字段。所以实际 UDP 数据包的长度不能超过65507字节（65,535 − 8字节UDP报头 − 20字节IP头部）</p>
<p>TCP 是<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=105481550&content_type=Article&match_order=1&q=%E6%B5%81%E6%95%B0%E6%8D%AE&zhida_source=entity">流数据</a>，没有该限制。</p>
</blockquote>
<p>而 TCP 只会重传这一个丢失的分片包。</p>
<p>所以如果一个应用采用 UDP 来通讯，一般都会特意控制下单个包体的大小，从而提高传输效率。</p>
<h3 id="TCP：可以在传输层协商自行分片"><a href="#TCP：可以在传输层协商自行分片" class="headerlink" title="TCP：可以在传输层协商自行分片"></a>TCP：可以在传输层协商自行分片</h3><h4 id="最大分段大小（Maxitum-Segment-Size-MSS）"><a href="#最大分段大小（Maxitum-Segment-Size-MSS）" class="headerlink" title="最大分段大小（Maxitum Segment Size, MSS）"></a>最大分段大小（Maxitum Segment Size, MSS）</h4><p>这里首先要说下：MSS（Maxitum Segment Size）最大分段大小，它是 TCP 协议里面的一个概念。</p>
<p>MSS 要保证一个TCP报文段，加上TCPIP首部长度以后，适合单个链路层帧。</p>
<p>TCP 在建立连接的时候，会协商双方的MSS值，通常这个 MSS 会控制在 MTU 以内：最大 IP 包大小减去 IP 和 TCP 协议头的大小。（其最终目的：<strong>就是尽量避免 IP 分片</strong>）1500-20-20 = 1460 </p>
<p>这样 TCP 就可以在自己这一层，把用户发送的数据，预先分成多个大小限制在 MTU 里的 TCP 包。每个 TCP 的分片包，都完整了包含了 TCP 头信息，方便在接收方重组。</p>
<blockquote>
<p>如果某些情况导致：已经分好的 TCP 分片，还是大于了 MTU，那就在 IP 层中，再执行一次分片。<br>这个时候如果数据丢了，那也只需要重传这一个 TCP 的分片，而不是整个原始的 50k 数据。</p>
</blockquote>
<p>而 IP（<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc791#section-3.1">RFC 791</a>）中规定所有主机或路由器必须能够接受576字节以内的数据报，576字节以上不保证能接受，有一定可能会分片。<a target="_blank" rel="noopener" href="https://blog.csdn.net/BuquTianya/article/details/88136381">RFC791（IP协议）——协议格式_rfc 791-CSDN博客</a> </p>
<p>严格讲，这并非是协商出来一个统一的MSS值，TCP允许连接两端使用各自不同的MSS值。例如，这会发生在参与TCP连接的一台设备使用非常少的内存处理到来的TCP分组。</p>
<h4 id="基于字节流的解决方案"><a href="#基于字节流的解决方案" class="headerlink" title="基于字节流的解决方案"></a>基于字节流的解决方案</h4><p>应用层传到 TCP 协议的数据，不是以<strong>数据报为单位</strong>向目的主机发送，而是以<strong>字节流</strong>的方式发送到下游，这些数据可能被<strong>切割和组装</strong>成各种数据包，接收端（应用层）收到这些数据包后没有正确还原原来的消息，因此出现粘包现象。</p>
<p>正因为<strong>基于数据报</strong>和<strong>基于字节流</strong>的差异，<strong>TCP 发送端发 10 次字节流数据，而这时候接收端可以分 100 次去取数据，每次取数据的长度可以根据处理能力作调整；但 UDP 发送端发了 10 次数据报，那接收端就要在 10 次收完，且发了多少，就取多少，确保每次都是一个完整的数据报。</strong></p>
<p>根本原因是应用层不知道消息的边界在哪里，不知道字节流的开始和结束位置，错误地划分了数据包序列中间的边界</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241127185012804.png" alt="image-20241127185012804"></p>
<ul>
<li>定长：FTP</li>
</ul>
<ul>
<li><p>分隔符：SMTP HTTP</p>
<p>可以通过特殊的标志作为头尾，比如当收到了<code>0xfffffe</code>或者回车符，则认为收到了新消息的头，此时继续取数据，直到收到下一个头标志<code>0xfffffe</code>或者尾部标记，才认为是一个完整消息。类似的像 HTTP 协议里当使用 <strong>chunked 编码</strong> 传输时，使用若干个 chunk 组成消息，最后由一个标明长度为 0 的 chunk 结束。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241127215347024.png" alt="image-20241127215347024"></p>
</li>
<li><p>TLV：HTTP Content-Length  WebSocket Protobuf Thrift</p>
<p>这个一般配合上面的特殊标志一起使用，在收到头标志时，里面还可以带上消息长度，以此表明在这之后多少 byte 都是属于这个消息的。如果在这之后正好有符合长度的 byte，则取走，作为一个完整消息给应用层使用。在实际场景中，HTTP 中的<code>Content-Length</code>就起了类似的作用，当接收端收到的消息长度小于 Content-Length 时，说明还有些消息没收到。那接收端会一直等，直到拿够了消息或超时，关于这一点<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247484204&idx=1&sn=0e83aabb2a48570b5bec563a777f4d26&scene=21#wechat_redirect">上一篇文章</a>里有更详细的说明</p>
<p>基于<a target="_blank" rel="noopener" href="https://search.bilibili.com/all?from_source=webcommentline_search&keyword=TLV&seid=7175035739223351950">TLV</a>的协议，接收段不断的检查Tag，如果收到tag就会去取length，这里面有一个点就是tag和length是定长的，比如tag是四个字符，length占4个字节。取到length以后就读取length个字节的<a target="_blank" rel="noopener" href="https://search.bilibili.com/all?from_source=webcommentline_search&keyword=value&seid=7175035739223351950">value</a>。理论上value后面接着的就是下一个tag</p>
</li>
</ul>
<p>Netty <strong>解决方案</strong></p>
<ul>
<li><p>定长解码器 <code>FixedLengthFrameDecoder</code> </p>
</li>
<li><p>分割字符解码器 <code>DelimeterBasedFrameDecoder</code></p>
</li>
<li><p>长度字段解码器 <code>LengthFieldBasedFrameDecoder</code></p>
</li>
</ul>
<h2 id="面向连接的-TCP-协议实现"><a href="#面向连接的-TCP-协议实现" class="headerlink" title="面向连接的 TCP 协议实现"></a>面向连接的 TCP 协议实现</h2><p>TCP连接可以由一个四元组（源IP, 源PORT, 目的IP, 目的PORT）唯一确定服务器的目的IP, 目的PORT一般是不会变化的，因此理论上TCP最大支持的连接数是 $2^{32} \times 2^{16} = 2^{48}$个，而TCP在linux系统中的实现用的是一个叫socket的编程接口实现的，socket本身就是一个文件，一个TCP连接就创建一个SOCKET FD因此还应该考虑服务器最大的内存大小。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/31b78572f43299995ba9b1b2988928c5.jpg" alt="31b78572f43299995ba9b1b2988928c5"></p>
<h3 id="TCP-Segment"><a href="#TCP-Segment" class="headerlink" title="TCP Segment"></a>TCP Segment</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241204212832687.png" alt="image-20241204212832687"></p>
<p>PSH = 1，数据不会缓存，立即交给上层（PUSH）</p>
<p>URG = 1，紧急数据指针指定了</p>
<h3 id="可靠传输（reliable-transmission）"><a href="#可靠传输（reliable-transmission）" class="headerlink" title="可靠传输（reliable transmission）"></a>可靠传输（reliable transmission）</h3><p>一个TCP报文段中的数据部分长度不能超过MSS，可以包含若干字节。</p>
<h4 id="累积确认（cumulative-acknowledgement）"><a href="#累积确认（cumulative-acknowledgement）" class="headerlink" title="累积确认（cumulative acknowledgement）"></a>累积确认（cumulative acknowledgement）</h4><p>在TCP中并无数据长度的说法，在接收端和发送端眼中数据是没有边界、没有长度、但<strong>有序</strong>的字节流，用序号来标识字节。</p>
<ul>
<li>TCP Segment中的<strong>序号</strong>（Seq）<strong>代表第一个字节在<u>发送端</u>的序号</strong>。<ul>
<li>初始序号可以是随机的</li>
</ul>
</li>
<li><u>发送者</u>用<strong>确认号</strong>（ACK）来提醒对方，<strong>自己下一个想要接收对方的Seq = ACK的字节</strong>。</li>
</ul>
<h5 id="按序接收"><a href="#按序接收" class="headerlink" title="按序接收"></a>按序接收</h5><p>TCP只记录第一个字节流是有序的，因此TCP也应按序接收，ACK = n，代表着序号n以前的数据都被正确接收。只确认到第一个丢失字节为止的位置。</p>
<p><strong>失序</strong>：回顾可靠传输协议GBN与SR，一个重要的区别就是SR对于失序的报文会选择先缓存再发送ACK，而GBN会直接丢弃，TCP的实现就是先保留，然后等待缺少的字节填补间隔</p>
<p><strong>捎带确认</strong>：发送数据方同时也可以是接收数据方，这样可以在携带数据的报文中捎带进行确认。比如 Telnet <code>echo</code> 功能中，服务端会把确认号装在回复给客户端的报文中，与此同时还运输了数据</p>
<p><strong>无数据的ACK报文</strong>：有的报文只是有一个确认的功能，没有带任何数据，但是Seq字段也不能空，所以还是会填Seq字段，只是一个逻辑上的标号</p>
<h4 id="超时重传（timeout-retransmission）"><a href="#超时重传（timeout-retransmission）" class="headerlink" title="超时重传（timeout retransmission）"></a>超时重传（timeout retransmission）</h4><ul>
<li><p>RTO（Retransmission Time Out）：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。</p>
</li>
<li><p>RTO 的确定是一个关键问题，因为它直接影响到 TCP 的性能和效率。如果 RTO 设置得太小，会导致不必要的重传，增加网络负担；如果 RTO 设置得太大，会导致数据传输的延迟，降低吞吐量。因此，RTO 应该根据网络的实际状况，动态地进行调整。</p>
</li>
<li><p>RTT 的值会随着网络的波动而变化，所以 TCP 不能直接使用 RTT 作为 RTO。为了动态地调整 RTO，TCP 协议采用了一些算法，如加权移动平均（EWMA）算法，Karn 算法，Jacobson 算法等，这些算法都是根据往返时延（RTT）的测量和变化来估计 RTO 的值。</p>
</li>
<li><p>超时间隔是通过统计学加上适当的估计算出来的，但是必须大于 1 RTT+路由器处理时延。</p>
</li>
<li><p>不采用重传后的样本（Karn 算法）因为不知道这个ACK是对重传的ACK还是迟到的ACK，因此不统计重传的RTT</p>
</li>
<li><p>如果突然变得拥塞，导致大量超时重传，无法统计样本的RTT，造成RTT无法及时更新，因此每次重传都把RTO翻倍，也是一种拥塞控制的机制，防止过度阻塞</p>
</li>
</ul>
<h5 id="快速重传（fast-retransmit）"><a href="#快速重传（fast-retransmit）" class="headerlink" title="快速重传（fast retransmit）"></a>快速重传（fast retransmit）</h5><p>防止间隔加倍导致网络时延过大，<strong>乱序到达则发送冗余ACK</strong>，收到3次冗余ACK，就重传一次对应ACK序号的数据。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>TCP 接收方操作</th>
</tr>
</thead>
<tbody><tr>
<td>收到按顺序的分段，其序列号是接收方期望的。所有数据的序列号都小于或等于期望的序列号并已被确认。</td>
<td>延迟发送ACK。等待最多500毫秒以接收下一个按顺序到达的分段。如果在此时间间隔内未接收到下一个分段，则发送一个ACK。</td>
</tr>
<tr>
<td>收到按顺序的分段，其序列号是接收方期望的，并且有另一个按顺序的分段正在等待ACK发送。</td>
<td>立即发送单个累计ACK，确认两个按顺序的分段。</td>
</tr>
<tr>
<td>收到乱序的分段，其序列号大于期望的序列号。检测到数据的缺口（gap）。</td>
<td>立即发送冗余ACK，表明<strong>下一期望接收的字节的序列号</strong>（即<strong>缺口的起始序列号</strong>）。</td>
</tr>
<tr>
<td>收到的分段能够部分或完全填补接收数据中的缺口。</td>
<td>立即发送ACK，前提是该分段的起始序列号正好是<strong>缺口的起始序列号</strong>。</td>
</tr>
</tbody></table>
<p>GBN协议中，用变量expectedseqnum表示expectedseqnum以前的数据都已经正确接收， 接收方将不停发送具有expectedseqnum<del>1</del>的ACK（之前已经发过了，因此是冗余ACK），直到正确收到具有expectedseqnum<del>1</del>的数据。==GBN== </p>
<h5 id="选择重传-SACK"><a href="#选择重传-SACK" class="headerlink" title="选择重传 SACK"></a>选择重传 SACK</h5><p>改进的方法就是 SACK（Selective Acknowledgment），简单来讲就是在快速重传的基础上，<strong>返回最近收到的报文段的序列号范围</strong>，这样客户端就知道，哪些数据包已经到达服务器了。</p>
<p>**冗余SACK ** </p>
<p>DSACK，即重复 SACK，这个机制是在 SACK 的基础上，额外携带信息，<strong>告知发送方有哪些数据包自己重复接收了</strong>。DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。</p>
<h4 id="GBN-or-SR"><a href="#GBN-or-SR" class="headerlink" title="GBN or SR?"></a>GBN or SR?</h4><p><strong>累计确认</strong></p>
<p>TCP实现中包含了累计确认这个GBN的要素，但是TCP对于失序的部分不会直接丢弃，也不回复ACK，而是暂存形成一个数据缺口。</p>
<p>对于超时重传，TCP只会让流水线发送中第一个未确认的字节重传，并且如果接受到了序号更大的ACK，连重传也不需要；而GBN规定只要没有收到第一个的ACK，后面不管是否收到必须全部重传。</p>
<p>一些TCP实现中也可以采用SR，不必使用累计确认。</p>
<p><strong>接收窗口</strong></p>
<p>TCP有接收窗口，GBN的接收窗口宽度只有1，SR也有接收窗口，但是SR并不是累计确认。</p>
<h3 id="流量控制（flow-control）"><a href="#流量控制（flow-control）" class="headerlink" title="流量控制（flow control）"></a>流量控制（flow control）</h3><p>不同于网络中的拥塞控制机制，流量控制是用来使发送方与接收方速率相匹配的机制，提醒发送方能发多少避免接收方缓冲区溢出。</p>
<h4 id="接收窗口（rwnd）"><a href="#接收窗口（rwnd）" class="headerlink" title="接收窗口（rwnd）"></a>接收窗口（rwnd）</h4><ul>
<li><p>TCP接收方维护 <code>lastByteRcvd</code>（最后一个递交给应用进程的）与 <code>lastByteRead</code>（最后一个确认的，rcv_base或expectedseqnum）二者差值即为接收缓冲区中的现有字节数，由此可以计算出缓冲区的可用字节数字rwnd。<code>rwnd = RcvBufferSize - (lastByteRcvd - lastByteRead)</code> </p>
</li>
<li><p>TCP发送方维护<code>lastByteSent</code>（最后一个发送的nextSeqnum，）与<code>lastByteAck</code>（最后一个确认的，send_base）二者差值即为所有已发送但未收到确认的字节数，<code>lastByteSent - lastByteAck &lt;= rwnd</code> 否则就阻塞发送方，也就是说发送窗口和接收窗口是一个概念。</p>
</li>
</ul>
<h5 id="TCP-零窗口探测"><a href="#TCP-零窗口探测" class="headerlink" title="TCP 零窗口探测"></a>TCP 零窗口探测</h5><ul>
<li>如果rwnd = 0，发送方仍会发送一个特殊的1字节的段（就是下一字节的数据，没新的数据段发送的时候发一个ack），强制接收端重新宣布下一个期望的字节和窗口大小（rwnd），与此同时启动一个探测定时器（persistence timer）</li>
<li>如果接收方回复的窗口rwnd仍然为0，则发送方的探测定时器加倍。</li>
<li>没有收到ACK，在发送探测包的最大次数之后连接超时（Reset或者关闭TCP连接）</li>
</ul>
<h4 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h4><h5 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h5><p>如果数据段只有1个字符，21字节的报文段只有1B的数据，带宽利用率就很低</p>
<p>Nagle算法：如果连续发字节，先发一个，收到确认之后把缓存的一连串一起发出去；一旦到达发送窗口或者MSS就立即发出。</p>
<h5 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h5><ul>
<li>接收窗口空出1字节就急忙通知对方，对方发过来1字节又占满缓冲区</li>
<li>接收方有足够的接收缓存再去通知，rwnd = Rcvbuffer/2 或 MSS即可通知</li>
<li>尽可能地在MSS范围内提升报文段内数据的比例，提升利用率</li>
</ul>
<h3 id="连接管理（connection-management）"><a href="#连接管理（connection-management）" class="headerlink" title="连接管理（connection management）"></a>连接管理（connection management）</h3><h4 id="连接建立：三次握手（three-way-handshake）"><a href="#连接建立：三次握手（three-way-handshake）" class="headerlink" title="连接建立：三次握手（three-way handshake）"></a>连接建立：三次握手（three-way handshake）</h4><p>ACK比特用于表示ACK确认号字段有效</p>
<ol>
<li>客户端发送<strong>SYN</strong>报文：Seq = x，SYN = 1 (ACK比特 = 0) </li>
<li>服务器<strong>SYNACK</strong>报文：Seq = y，SYN = 1，ACK确认号 = x + 1 (ACK比特 = 1)</li>
<li>客户端<strong>ACK</strong>报文 ：Seq = x + 1，SYN = 0，ACK确认号 = y + 1 (ACK比特 = 1)</li>
</ol>
<h5 id="SYN-泛洪-SYN-cookie"><a href="#SYN-泛洪-SYN-cookie" class="headerlink" title="SYN 泛洪: SYN cookie"></a>SYN 泛洪: SYN cookie</h5><p>服务器收到SYN报文将会缓存y，用于核对下一个ACK的值是否为y+1，存到内存中，SYN攻击的原理就是不发送ACK，因此服务器会不断缓存y，建立许多半连接，最终不堪重负。解决方法就是服务器不去储存y，而是用特别的方法生成，y = H(IP1, IP2, key) 关键在于只有服务器知道的key，而合法的客户端会回复ACK报文，服务端接收以后只需要用相同的哈希函数再次计算y，看看是不是和ACK报文中的y相同，如果相同，则建立连接。</p>
<h5 id="RST-连接重置"><a href="#RST-连接重置" class="headerlink" title="RST 连接重置"></a>RST 连接重置</h5><p>用于强制中断当前的连接，如果SYN报文的目的端口并未有套接字在监听，说明这个请求非法，于是响应报文RST置1</p>
<p>在 <strong>TCP</strong> 重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断。正常情况下，如果客户端收发现到达的报文段对于相关连接而言是不正确的，<strong>TCP</strong> 就会发送一个重置报文段，从而导致 <strong>TCP</strong> 连接的快速拆卸。</p>
<p><strong>TCP</strong> 重置攻击利用这一机制，通过向通信方发送伪造的重置报文段，欺骗通信双方提前关闭 TCP 连接。如果伪造的重置报文段完全逼真，接收者就会认为它有效，并关闭 <strong>TCP</strong> 连接，防止连接被用来进一步交换信息。服务端可以创建一个新的 <strong>TCP</strong> 连接来恢复通信，但仍然可能会被攻击者重置连接。万幸的是，攻击者需要一定的时间来组装和发送伪造的报文，所以一般情况下这种攻击只对长连接有杀伤力，对于短连接而言，你还没攻击呢，人家已经完成了信息交换。</p>
<p>从某种意义上来说，伪造 <strong>TCP</strong> 报文段是很容易的，因为 <strong>TCP/IP</strong> 都没有任何内置的方法来验证服务端的身份。有些特殊的 IP 扩展协议（例如 <code>IPSec</code>）确实可以验证身份，但并没有被广泛使用。客户端只能接收报文段，并在可能的情况下使用更高级别的协议（如 <code>TLS</code>）来验证服务端的身份。但这个方法对 <strong>TCP</strong> 重置包并不适用，因为 <strong>TCP</strong> 重置包是 <strong>TCP</strong> 协议本身的一部分，无法使用更高级别的协议进行验证</p>
<h4 id="连接断开：四次挥手（four-way-handshake）"><a href="#连接断开：四次挥手（four-way-handshake）" class="headerlink" title="连接断开：四次挥手（four-way handshake）"></a>连接断开：四次挥手（four-way handshake）</h4><p>FIN比特 置1</p>
<ol>
<li>客户端发送FIN，提醒服务器要断开连接，</li>
<li>服务器随即回复ACK，表示已经收到消息准备断开，发送完剩余数据之后，在发送FIN并关闭连接，告知客户端，服务器这边已经关闭了，服务器等待最后一个ACK</li>
<li>客户端收到FIN以后开始定时并回复ACK，超时即CLOSED。服务端收到客户端ACK之后正式CLOSED</li>
</ol>
<p>TIME-WAIT timer：如果客户端发的ack丢失，服务器还得重传Fin，如果客户端这边早早CLOSED，就收不到服务器Fin，也就发不出ack，服务器的套接字状态无法正式CLOSED</p>
<h4 id="TCP-状态转换"><a href="#TCP-状态转换" class="headerlink" title="TCP 状态转换"></a>TCP 状态转换</h4><h5 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/10d2447d4713399745cdb4937cf56a41.jpg" alt="10d2447d4713399745cdb4937cf56a41"></p>
<h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/05f6445ba70b616b59a5c690c306d522.jpg" alt="05f6445ba70b616b59a5c690c306d522"></p>
<h3 id="拥塞控制（congestion-control）"><a href="#拥塞控制（congestion-control）" class="headerlink" title="拥塞控制（congestion control）"></a>拥塞控制（congestion control）</h3><h4 id="拥塞窗口（cwnd）"><a href="#拥塞窗口（cwnd）" class="headerlink" title="拥塞窗口（cwnd）"></a>拥塞窗口（cwnd）</h4><ul>
<li><strong>拥塞窗口</strong>（congestion window, cwnd）：取决于中间的网络条件，由发送方控制，cwnd/RTT就是发送速率。</li>
<li><strong>接收窗口</strong>（receive window, rwnd）：由接收方可用缓存控制的，限制发送速率。</li>
<li><strong>对于发送方</strong>：<code>lastByteSent - lastByteAck &lt;= min(cwnd,rwnd)</code>  </li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241205212918399.png" alt="image-20241205212918399"></p>
<p>下面为了方便研究，将cwnd作为TCP发送的主要瓶颈。</p>
<h4 id="基于丢包的拥塞控制（loss-based）"><a href="#基于丢包的拥塞控制（loss-based）" class="headerlink" title="基于丢包的拥塞控制（loss-based）"></a>基于丢包的拥塞控制（loss-based）</h4><p>TCP 对于拥塞控制给出如下三个<strong>指导性原则</strong>：</p>
<ul>
<li><p>如果出现丢包（冗余ACK或超时重传），那说明网络可能出现了拥塞状况，将缩短拥塞窗口，限制发送量</p>
</li>
<li><p>如果出现正常ACK，说明对方正确接收了，网络状况良好，将扩大拥塞窗口，增加发送量</p>
</li>
<li><p>带宽探测：探测拥塞开始的速率，增加发送速率以与ACK匹配，出现丢包则从该速率回退，然后继续探测。</p>
</li>
</ul>
<p>拥塞控制算法有慢启动-拥塞避免-快速恢复三个状态，下图为FSM:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241205213030112.png" alt="image-20241205213030112"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241205212615649.png"></p>
<h5 id="慢启动（slow-start）"><a href="#慢启动（slow-start）" class="headerlink" title="慢启动（slow-start）"></a>慢启动（slow-start）</h5><p>初始cwnd = 1 MSS，发送1个字节，得到1 ACK, cwnd增大1 MSS，第二次发送2个字节，1个ACK增大1 MSS，呈<strong>指数增长</strong>。（2^n^ MSS per RTT）</p>
<p>cwnd是动态变化的，只要接收到ACK就会让cwnd增大，即使上一个RTT的ACK还没接收完，也对下一个RTT的能发送的字节数影响不大，因为接收完上一个RTT的所有ACK，意味着cwnd已经在上一RTT的基础上翻倍了，而此时肯定CWND还没被占满。</p>
<p>慢启动阈值ssthresh：阈值内部慢启动，超出阈值则拥塞避免</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241205220630888.png" alt="image-20241205220630888"></p>
<p><strong>三种结束慢启动的方式</strong>：</p>
<ul>
<li><p><strong>超时重传</strong>：<strong>timeout</strong>，则将 <strong>ssthresh</strong>(slow-start threshold)设置为cwnd/2，重置 cwnd = 1 MSS，重新开始<strong>慢启动过程</strong>，然后执行重传。</p>
</li>
<li><p><strong>可能再次发生拥塞</strong>： <strong>cwnd &gt;= ssthresh</strong>，说明再增大可能就要再次拥塞了，应该更加谨慎地增加cwnd，进入<strong>拥塞避免</strong>模式。</p>
</li>
<li><p><strong>快速重传</strong>：<strong>冗余ACK = 3</strong>（连续收到4个相同的ACK）触发快速重传<u>之前</u>，ssthresh设置为cwnd/2，cwnd减半并加上3 MSS，进入<strong>快速恢复</strong>模式。</p>
</li>
</ul>
<p>因此，cwnd &lt; ssthresh 仍然处于慢启动的状态。</p>
<h5 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h5><p>ssthresh 是导致拥塞的cwnd / 2，因此到了第二次cwnd增大到ssthresh就应当减小增加的速度，呈<strong>线性增长</strong>（1 MSS per RTT）</p>
<p>如果cwnd是10个MSS大小，则在一次 RTT中发10MSS字节，假如一个报文段是1MSS，每个ACK加十分之一MSS，这些报文段全部确认之后，cwnd总共加了1MSS </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241205215843491-1733407571075-4.png" alt="image-20241205215843491"></p>
<p><strong>两种结束拥塞避免的方式</strong>：</p>
<ul>
<li><strong>超时重传</strong>：<strong>timeout</strong>，则将ssthresh(slow-start threshold)设置为cwnd/2，重置 cwnd = 1 MSS，重新开始<strong>慢启动过程</strong>，然后执行重传。重新回到<strong>慢启动</strong>。</li>
<li><strong>快速重传</strong>：<strong>冗余ACK = 3</strong>（连续收到4个相同的ACK）触发快速重传<u>之前</u>，ssthresh设置为cwnd/2，cwnd减半并加上3 MSS，进入<strong>快速恢复</strong>模式。</li>
</ul>
<h5 id="快速恢复（fast-recovery）"><a href="#快速恢复（fast-recovery）" class="headerlink" title="快速恢复（fast recovery）"></a>快速恢复（fast recovery）</h5><p>快速重传以后进入快速恢复状态，既然发的是冗余ACK，说明收到的是失序的正确报文段，加3MSS更加接近实际结果。</p>
<h6 id="TCP-Reno-vs-TCP-Tahoe"><a href="#TCP-Reno-vs-TCP-Tahoe" class="headerlink" title="TCP Reno vs TCP Tahoe"></a>TCP Reno vs TCP Tahoe</h6><ul>
<li>Tahoe: Cut to 1 MSS when loss detected (either t-d-ACK or timeout)</li>
<li>Reno: Cut to roughly half on loss detected by triple duplicate ACK </li>
</ul>
<p>TCP Reno会在快速重传之后进入快速恢复状态，TCP Tahoe则没有快速恢复状态</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241205223629221.png" alt="image-20241205223629221"></p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><h5 id="AIMD：加性增乘性减"><a href="#AIMD：加性增乘性减" class="headerlink" title="AIMD：加性增乘性减"></a>AIMD：加性增乘性减</h5><p>Additive-Increase, Multiplicative-Decrease 增加是一个一个加上去的，减少是立马减半的。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241205225111917.png" alt="image-20241205225111917"></p>
<h5 id="TCP-CUBIC：更加激进但有效地探测带宽"><a href="#TCP-CUBIC：更加激进但有效地探测带宽" class="headerlink" title="TCP CUBIC：更加激进但有效地探测带宽"></a>TCP CUBIC：更加激进但有效地探测带宽</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241205225702555.png" alt="image-20241205225702555"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241205225712876.png" alt="image-20241205225712876"><br>$$<br>W = { \vert K - t \vert } ^3+W_{max}<br>$$<br>在Linux默认开启，在拥塞避免阶段，用一个立方函数来代替线性增长，能够在即将可能发生拥塞（到达上次开始丢包的cwnd）时放慢增长速率</p>
<h4 id="其他拥塞控制方法"><a href="#其他拥塞控制方法" class="headerlink" title="其他拥塞控制方法"></a>其他拥塞控制方法</h4><h5 id="基于时延的拥塞控制（delay）"><a href="#基于时延的拥塞控制（delay）" class="headerlink" title="基于时延的拥塞控制（delay）"></a>基于时延的拥塞控制（delay）</h5><p>Loss-based: Increase sending rate until a loss (timeout) and then cut back</p>
<p>Delay-based: Do the same until RTT reaches RTTcongested</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241206202843219.png" alt="image-20241206202843219"></p>
<h5 id="基于网络协作的拥塞控制（network-assisted）"><a href="#基于网络协作的拥塞控制（network-assisted）" class="headerlink" title="基于网络协作的拥塞控制（network-assisted）"></a>基于网络协作的拥塞控制（network-assisted）</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241206202921921.png" alt="image-20241206202921921"></p>
<h5 id="TCP-公平性"><a href="#TCP-公平性" class="headerlink" title="TCP 公平性"></a>TCP 公平性</h5><p>if $K$ TCP sessions share same bottleneck link  of bandwidth $R$, each should have average rate of $R/K$</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241206203243736.png" alt="image-20241206203243736"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241206203312056.png" alt="image-20241206203312056"></p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_optimize.html">如何优化 TCP? | 小林coding</a> </p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_problem.html">TCP 协议有什么缺陷？ | 小林coding</a> </p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html">TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_drop.html">用了 TCP 协议，数据一定不会丢吗？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_tls.html#tcp-fast-open">HTTPS 中 TLS 和 TCP 能同时握手吗？TCP FastOpen  | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_unplug_the_network_cable.html">拔掉网线后， 原本的 TCP 连接还存在吗？ | 小林coding</a> </p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html">TCP 连接，一端断电和进程崩溃有什么区别？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html">TCP 半连接队列和全连接队列 | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html">4.1 TCP 三次握手与四次挥手面试题 | 小林coding</a> </p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html">TCP 四次挥手，可以变成三次吗？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/out_of_order_fin.html">四次挥手中收到乱序的 FIN 包会如何处理？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/isn_deff.html">为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/syn_drop.html">SYN 报文什么时候情况下会被丢弃？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#%E5%85%88%E8%AF%B4%E7%BB%93%E8%AE%BA">在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_tw_reuse_close.html">tcp_tw_reuse 为什么默认是关闭的？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？ | 小林coding</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/9/">9</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
