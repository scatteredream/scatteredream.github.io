<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/25/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-03-25T08:39:51.604Z" itemprop="datePublished">2025-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/25/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/25/hello-world/" data-id="cm8pkpl4d00004stvhhad6yzs" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-classfile" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/13/classfile/" class="article-date">
  <time class="dt-published" datetime="2024-09-12T16:00:00.000Z" itemprop="datePublished">2024-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/13/classfile/">ClassFile</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ClassFile-字节码"><a href="#ClassFile-字节码" class="headerlink" title="ClassFile 字节码"></a>ClassFile 字节码</h1><p>Java 字节码是 Java 编译器将 Java 源代码编译成的 <strong>中间表示格式</strong>，它运行在 <strong>Java 虚拟机（JVM）</strong> 上。Java 字节码文件的扩展名为 **<code>.class</code>**，可以通过 <strong><code>javap -c</code></strong> 命令查看其内容。</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。本章中， 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它完全不 需要以磁盘文件的形式存在。</p>
<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。</p>
<h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BytecodeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译和查看字节码指令</strong> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac BytecodeExample.java</span><br><span class="line">javap -c BytecodeExample</span><br><span class="line"><span class="comment"># 打印类中每个方法的反汇编代码，例如组成 Java 字节码的指令。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCodeExample</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> MAX;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ByteCodeExample</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iload_0</span><br><span class="line">       <span class="number">1</span>: iload_1</span><br><span class="line">       <span class="number">2</span>: iadd</span><br><span class="line">       <span class="number">3</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_2</span><br><span class="line">       <span class="number">1</span>: iconst_3</span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method add:(II)I</span></span><br><span class="line">       <span class="number">5</span>: istore_1</span><br><span class="line">       <span class="number">6</span>: getstatic     #<span class="number">13</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">9</span>: iload_1</span><br><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">19</span>                 <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节码指令解释"><a href="#字节码指令解释" class="headerlink" title="字节码指令解释"></a><span id="code">字节码指令解释</span></h3><h4 id="构造方法：BytecodeExample"><a href="#构造方法：BytecodeExample" class="headerlink" title="构造方法：BytecodeExample()"></a>构造方法：BytecodeExample()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ByteCodeExample</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0           <span class="comment">// 将 this 引用加载到操作数栈</span></span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>			<span class="comment">// 返回</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：自动生成的默认构造函数，调用 <code>Object</code> 的构造函数。</p>
<h4 id="add-方法：add-int-int"><a href="#add-方法：add-int-int" class="headerlink" title="add 方法：add(int, int)"></a>add 方法：add(int, int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iload_0              <span class="comment">// 加载第一个参数 a</span></span><br><span class="line">       <span class="number">1</span>: iload_1              <span class="comment">// 加载第二个参数 b</span></span><br><span class="line">       <span class="number">2</span>: iadd                 <span class="comment">// 执行整数相加</span></span><br><span class="line">       <span class="number">3</span>: ireturn              <span class="comment">// 返回结果</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ol>
<li>**<code>iload_0</code>、<code>iload_1</code>**：将参数加载到操作数栈。</li>
<li>**<code>iadd</code>**：弹出栈顶两个整数并执行加法运算，再将结果压入栈顶。</li>
<li>**<code>ireturn</code>**：将栈顶的结果返回给调用者。</li>
</ol>
<h4 id="main-方法：main-String"><a href="#main-方法：main-String" class="headerlink" title="main 方法：main(String[])"></a>main 方法：main(String[])</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_2           <span class="comment">// 将常量 2 压入栈</span></span><br><span class="line">       <span class="number">1</span>: iconst_3           <span class="comment">// 将常量 3 压入栈</span></span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">7</span>   <span class="comment">// 调用静态方法 add(2, 3)</span></span><br><span class="line">       <span class="number">5</span>: istore_1           <span class="comment">// 将结果保存到局部变量表中的索引 1</span></span><br><span class="line">       <span class="number">6</span>: getstatic     #<span class="number">13</span>  <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">9</span>: iload_1            <span class="comment">// 加载变量 result</span></span><br><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">19</span>  <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span>             <span class="comment">// 结束 main 方法</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>**<code>iconst_2</code> 和 <code>iconst_3</code>**：将常量 2 和 3 压入栈顶。</li>
<li>**<code>invokestatic</code>**：调用静态方法 <code>add</code>，返回结果并压入栈顶。</li>
<li>**<code>istore_1</code>**：将结果存入局部变量表的索引 1（变量 result）。</li>
<li>**<code>getstatic</code>**：加载 <code>System.out</code> 对象到栈顶，用于后续方法调用。</li>
<li>**<code>invokevirtual</code>**：调用 <code>println</code> 方法打印结果。</li>
</ul>
<h3 id="常见字节码指令表"><a href="#常见字节码指令表" class="headerlink" title="常见字节码指令表"></a>常见字节码指令表</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>aload_x</strong></td>
<td>将引用变量加载到操作数栈</td>
</tr>
<tr>
<td><strong>iload_x</strong></td>
<td>将 int 型变量加载到操作数栈</td>
</tr>
<tr>
<td><strong>istore_x</strong></td>
<td>将 int 型值从栈顶存入局部变量表</td>
</tr>
<tr>
<td><strong>iconst_x</strong></td>
<td>将常量 x 压入操作数栈</td>
</tr>
<tr>
<td><strong>iadd</strong></td>
<td>执行整数加法</td>
</tr>
<tr>
<td><strong>isub</strong></td>
<td>执行整数减法</td>
</tr>
<tr>
<td><strong>invokestatic</strong></td>
<td>调用静态方法</td>
</tr>
<tr>
<td><strong>invokevirtual</strong></td>
<td>调用对象的实例方法</td>
</tr>
<tr>
<td><strong>return</strong></td>
<td>方法结束，返回 void</td>
</tr>
<tr>
<td><strong>ireturn</strong></td>
<td>方法结束，返回 int 值</td>
</tr>
</tbody></table>
<h2 id="class-文件结构-ClassFile"><a href="#class-文件结构-ClassFile" class="headerlink" title=".class 文件结构(ClassFile)"></a>.class 文件结构(ClassFile)</h2><p>ClassFile 结构定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;<span class="comment">// first 4 bytes of the file must be 0xCAFEBABE</span></span><br><span class="line">    u2             minor_version;<span class="comment">// 次版本号                        2 bytes</span></span><br><span class="line">    u2             major_version;<span class="comment">// 主版本号 比如 JDK 21 对应 65.0   2 bytes </span></span><br><span class="line">    </span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量 2 bytes</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    </span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记   </span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    </span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口数量</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//字段数量</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/16d5ec47609818fc.jpeg" alt="ClassFile 内容分析"></p>
<h3 id="常量池-cp-info-constant-pool-constant-pool-count-1"><a href="#常量池-cp-info-constant-pool-constant-pool-count-1" class="headerlink" title="常量池 cp_info constant_pool[constant_pool_count-1]"></a>常量池 <code>cp_info constant_pool[constant_pool_count-1]</code></h3><p>常量池是 ClassFile 的核心，存储类的常量信息，如字符串、字段名、方法名和方法描述符等。</p>
<p>计数器 constant_pool_count 表示常量池项的数量（从 1 开始计数）。（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp_info <span class="punctuation">&#123;</span></span><br><span class="line">    u1 tag;                  <span class="comment">// 常量类型标志      1 byte</span></span><br><span class="line">    u1 info<span class="punctuation">[</span><span class="punctuation">]</span>;               <span class="comment">// 常量值或引用      1 byte</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">标志（tag）</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_utf8_info</td>
<td align="center">1</td>
<td align="center">UTF-8 编码的字符串</td>
</tr>
<tr>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">3</td>
<td align="center">整形字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Float_info</td>
<td align="center">4</td>
<td align="center">浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Long_info</td>
<td align="center">5</td>
<td align="center">长整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Double_info</td>
<td align="center">6</td>
<td align="center">双精度浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Class_info</td>
<td align="center">7</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_String_info</td>
<td align="center">8</td>
<td align="center">字符串类型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_FieldRef_info</td>
<td align="center">9</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodRef_info</td>
<td align="center">10</td>
<td align="center">类中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_InterfaceMethodRef_info</td>
<td align="center">11</td>
<td align="center">接口中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">12</td>
<td align="center">字段或方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodType_info</td>
<td align="center">16</td>
<td align="center">标志方法类型</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodHandle_info</td>
<td align="center">15</td>
<td align="center">表示方法句柄</td>
</tr>
<tr>
<td align="center">CONSTANT_InvokeDynamic_info</td>
<td align="center">18</td>
<td align="center">表示一个动态方法调用点</td>
</tr>
</tbody></table>
<h3 id="类访问标志-access-flags"><a href="#类访问标志-access-flags" class="headerlink" title="类访问标志 access flags"></a>类访问标志 <code>access flags</code></h3><p>定义类或接口的修饰符：</p>
<table>
<thead>
<tr>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x0001 (ACC_PUBLIC)</td>
<td>公共类。</td>
</tr>
<tr>
<td>0x0010 (ACC_FINAL)</td>
<td>不可继承（final）。</td>
</tr>
<tr>
<td>0x0020 (ACC_SUPER)</td>
<td>支持 invokespecial。</td>
</tr>
<tr>
<td>0x0200 (ACC_INTERFACE)</td>
<td>接口。</td>
</tr>
<tr>
<td>0x0400 (ACC_ABSTRACT)</td>
<td>抽象类或接口。</td>
</tr>
<tr>
<td>0x1000 (ACC_SYNTHETIC)</td>
<td>编译器自动生成的类或方法。</td>
</tr>
<tr>
<td>0x2000 (ACC_ANNOTATION)</td>
<td>注解类。</td>
</tr>
<tr>
<td>0x4000 (ACC_ENUM)</td>
<td>枚举类。</td>
</tr>
</tbody></table>
<h3 id="当前类和父类的索引-this-class-super-class"><a href="#当前类和父类的索引-this-class-super-class" class="headerlink" title="当前类和父类的索引 this_class super_class"></a>当前类和父类的索引 <code>this_class</code> <code>super_class</code></h3><ul>
<li><strong>this_class</strong> 指向当前类在常量池中的索引，描述类名。</li>
<li>super_class 指向父类的索引。<ul>
<li>如果父类是 <code>java.lang.Object</code>，其值为 0。</li>
</ul>
</li>
</ul>
<h4 id="接口索引集合-interfaces-interface-count"><a href="#接口索引集合-interfaces-interface-count" class="headerlink" title="接口索引集合 interfaces[interface_count]"></a>接口索引集合 <code>interfaces[interface_count]</code></h4><p>接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p>
<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h4 id="字段集合-field-info-fields-fields-count"><a href="#字段集合-field-info-fields-fields-count" class="headerlink" title="字段集合 field_info fields[fields_count]"></a>字段集合 <code>field_info fields[fields_count]</code></h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">field_info <span class="punctuation">&#123;</span></span><br><span class="line">    u2 access_flags;       <span class="comment">// 访问标志字段的作用域（public ,private,protected修饰符），是实例变量还是类变量（static修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</span></span><br><span class="line">    u2 name_index;         <span class="comment">// 字段名称 对常量池的引用</span></span><br><span class="line">    u2 descriptor_index;   <span class="comment">// 描述符 对常量池的引用</span></span><br><span class="line">    u2 attributes_count;   <span class="comment">// 属性计数器</span></span><br><span class="line">    attribute_info attributes<span class="punctuation">[</span><span class="punctuation">]</span>; <span class="comment">// 属性表</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p>
<p>字段的访问标志位：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20201031084342859.png" alt="字段的 access_flag 的取值"></p>
<h4 id="方法表-method-info-methods-methods-count"><a href="#方法表-method-info-methods-methods-count" class="headerlink" title="方法表 method_info methods[methods_count]"></a>方法表 <code>method_info methods[methods_count]</code></h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info <span class="punctuation">&#123;</span></span><br><span class="line">    u2 access_flags;       <span class="comment">// </span></span><br><span class="line">    u2 name_index;         <span class="comment">// 方法名 对常量池的引用</span></span><br><span class="line">    u2 descriptor_index;   <span class="comment">// 描述符 对常量池的引用</span></span><br><span class="line">    u2 attributes_count;   <span class="comment">// 属性计数器</span></span><br><span class="line">    attribute_info attributes<span class="punctuation">[</span><span class="punctuation">]</span>; <span class="comment">// 属性表</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
<p>方法的访问标志位：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20201031084248965.png" alt="方法表的 access_flag 取值"></p>
<h4 id="属性表-attribute-info-attributes-attributes-count"><a href="#属性表-attribute-info-attributes-attributes-count" class="headerlink" title="属性表 attribute_info attributes[attributes_count]"></a>属性表 <code>attribute_info attributes[attributes_count]</code></h4><p>存储与类、字段或方法相关的附加信息，如注解、调试信息等。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>存储方法的字节码指令。</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>常量值属性（如 static final 常量）。</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>行号表，用于调试信息映射源代码行。</td>
</tr>
<tr>
<td>SourceFile</td>
<td>源文件名属性，用于调试信息。</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法抛出的异常信息。</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>方法中局部变量的信息（调试用途）。</td>
</tr>
<tr>
<td>Deprecated</td>
<td>标记类、方法或字段为废弃。</td>
</tr>
</tbody></table>
<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<p>比如在上文<a href="#code">字节码指令解释</a>的部分，方法的Code属性就是字节码指令</p>
<h2 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose BytecodeExample <span class="comment">// 打印有关所选类别的附加信息</span></span><br><span class="line"></span><br><span class="line">Classfile /C<span class="punctuation">:</span>/Users/Lenovo/Desktop/coding/JavaSingle/BytecodeExample.class</span><br><span class="line">  Last modified <span class="number">2025</span>年<span class="number">1</span>月<span class="number">3</span>日; size <span class="number">555</span> bytes</span><br><span class="line">  SHA<span class="number">-256</span> checksum <span class="number">2</span>ade518b0d7194939efe9f3eefc0d055e21b70bab639130f050bc35282fa976b</span><br><span class="line">  Compiled from <span class="string">&quot;ByteCodeExample.java&quot;</span></span><br><span class="line">public class ByteCodeExample</span><br><span class="line">  minor version<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  major version<span class="punctuation">:</span> <span class="number">65</span></span><br><span class="line">  flags<span class="punctuation">:</span> (<span class="number">0x0021</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_SUPER</span><br><span class="line">  this_class<span class="punctuation">:</span> #<span class="number">8</span>                          <span class="comment">// ByteCodeExample</span></span><br><span class="line">  super_class<span class="punctuation">:</span> #<span class="number">2</span>                         <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 实现了0个接口</span></span><br><span class="line">  fields<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span>    <span class="comment">// 有3个字段 （成员变量）</span></span><br><span class="line">  methods<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span>  <span class="comment">// 有3个方法</span></span><br><span class="line">  attributes<span class="punctuation">:</span> <span class="number">1</span>  </span><br><span class="line">Constant pool<span class="punctuation">:</span></span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">2.</span>#<span class="number">3</span>          <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">4</span>             <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">3</span> = NameAndType        #<span class="number">5</span><span class="punctuation">:</span>#<span class="number">6</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">4</span> = Utf8               java/lang/Object</span><br><span class="line">   #<span class="number">5</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">6</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">8.</span>#<span class="number">9</span>          <span class="comment">// ByteCodeExample.add:(II)I</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">10</span>            <span class="comment">// ByteCodeExample</span></span><br><span class="line">   #<span class="number">9</span> = NameAndType        #<span class="number">11</span><span class="punctuation">:</span>#<span class="number">12</span>        <span class="comment">// add:(II)I</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               ByteCodeExample</span><br><span class="line">  #<span class="number">11</span> = Utf8               add</span><br><span class="line">  #<span class="number">12</span> = Utf8               (II)I</span><br><span class="line">  #<span class="number">13</span> = Fieldref           #<span class="number">14.</span>#<span class="number">15</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">14</span> = Class              #<span class="number">16</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">17</span><span class="punctuation">:</span>#<span class="number">18</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">17</span> = Utf8               out</span><br><span class="line">  #<span class="number">18</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">19</span> = Methodref          #<span class="number">20.</span>#<span class="number">21</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">  #<span class="number">20</span> = Class              #<span class="number">22</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">21</span> = NameAndType        #<span class="number">23</span><span class="punctuation">:</span>#<span class="number">24</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">22</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">23</span> = Utf8               println</span><br><span class="line">  #<span class="number">24</span> = Utf8               (I)V</span><br><span class="line">  #<span class="number">25</span> = Utf8               a</span><br><span class="line">  #<span class="number">26</span> = Utf8               I</span><br><span class="line">  #<span class="number">27</span> = Utf8               b</span><br><span class="line">  #<span class="number">28</span> = Utf8               MAX</span><br><span class="line">  #<span class="number">29</span> = Utf8               D</span><br><span class="line">  #<span class="number">30</span> = Utf8               ConstantValue</span><br><span class="line">  #<span class="number">31</span> = Double             <span class="number">12.0</span>d</span><br><span class="line">  #<span class="number">33</span> = Utf8               Code</span><br><span class="line">  #<span class="number">34</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">35</span> = Utf8               main</span><br><span class="line">  #<span class="number">36</span> = Utf8               (<span class="punctuation">[</span>Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">37</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">38</span> = Utf8               ByteCodeExample.java</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  int a;</span><br><span class="line">    descriptor<span class="punctuation">:</span> I</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0000</span>)</span><br><span class="line"></span><br><span class="line">  int b;</span><br><span class="line">    descriptor<span class="punctuation">:</span> I</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0000</span>)</span><br><span class="line"></span><br><span class="line">  public static final double MAX;</span><br><span class="line">    descriptor<span class="punctuation">:</span> D</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0019</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_STATIC<span class="punctuation">,</span> ACC_FINAL</span><br><span class="line">    ConstantValue<span class="punctuation">:</span> double <span class="number">12.0</span>d</span><br><span class="line"></span><br><span class="line">  public ByteCodeExample();</span><br><span class="line">    descriptor<span class="punctuation">:</span> ()V</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code<span class="punctuation">:</span></span><br><span class="line">      stack=<span class="number">1</span><span class="punctuation">,</span> locals=<span class="number">1</span><span class="punctuation">,</span> args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span><span class="punctuation">:</span> aload_0</span><br><span class="line">         <span class="number">1</span><span class="punctuation">:</span> invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span><span class="punctuation">:</span> return</span><br><span class="line">      LineNumberTable<span class="punctuation">:</span></span><br><span class="line">        line <span class="number">1</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  public static int add(int<span class="punctuation">,</span> int);</span><br><span class="line">    descriptor<span class="punctuation">:</span> (II)I</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0009</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_STATIC</span><br><span class="line">    Code<span class="punctuation">:</span></span><br><span class="line">      stack=<span class="number">2</span><span class="punctuation">,</span> locals=<span class="number">2</span><span class="punctuation">,</span> args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span><span class="punctuation">:</span> iload_0</span><br><span class="line">         <span class="number">1</span><span class="punctuation">:</span> iload_1</span><br><span class="line">         <span class="number">2</span><span class="punctuation">:</span> iadd</span><br><span class="line">         <span class="number">3</span><span class="punctuation">:</span> ireturn</span><br><span class="line">      LineNumberTable<span class="punctuation">:</span></span><br><span class="line">        line <span class="number">6</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String<span class="punctuation">[</span><span class="punctuation">]</span>);</span><br><span class="line">    descriptor<span class="punctuation">:</span> (<span class="punctuation">[</span>Ljava/lang/String;)V</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0009</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_STATIC</span><br><span class="line">    Code<span class="punctuation">:</span></span><br><span class="line">      stack=<span class="number">2</span><span class="punctuation">,</span> locals=<span class="number">2</span><span class="punctuation">,</span> args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span><span class="punctuation">:</span> iconst_2</span><br><span class="line">         <span class="number">1</span><span class="punctuation">:</span> iconst_3</span><br><span class="line">         <span class="number">2</span><span class="punctuation">:</span> invokestatic  #<span class="number">7</span>                  <span class="comment">// Method add:(II)I</span></span><br><span class="line">         <span class="number">5</span><span class="punctuation">:</span> istore_1</span><br><span class="line">         <span class="number">6</span><span class="punctuation">:</span> getstatic     #<span class="number">13</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">9</span><span class="punctuation">:</span> iload_1</span><br><span class="line">        <span class="number">10</span><span class="punctuation">:</span> invokevirtual #<span class="number">19</span>                 <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">13</span><span class="punctuation">:</span> return</span><br><span class="line">      LineNumberTable<span class="punctuation">:</span></span><br><span class="line">        line <span class="number">10</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span><span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line">        line <span class="number">12</span><span class="punctuation">:</span> <span class="number">13</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">SourceFile<span class="punctuation">:</span> <span class="string">&quot;ByteCodeExample.java&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="ClassLoading"><a href="#ClassLoading" class="headerlink" title="ClassLoading"></a>ClassLoading</h1><h2 id="One-main-to-one-JVM-process"><a href="#One-main-to-one-JVM-process" class="headerlink" title="One main to one JVM process"></a>One main to one JVM process</h2><p>当我们启动一个Java程序，即启动一个main方法时，都将启动一个Java虚拟机进程，不管这个进程有多么复杂。而不同的JVM进程之间是不会相互影响的。这也就是为什么说，Java程序只有一个入口——main方法，让虚拟机调用。而两个main方法，对应的是2个JVM进程，启动的是两个不同的类加载器，操作的实际上是不同的类。故而不会互相影响。</p>
<h2 id="ClassLoading-Workflow"><a href="#ClassLoading-Workflow" class="headerlink" title="ClassLoading Workflow"></a>ClassLoading Workflow</h2><p>当我们使用一个类，如果这个类还未加载到内存中，系统会通过加载、连接、初始化对类进行初始化。完成后可以使用Using和卸载Unloading。</p>
<h3 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载(Loading)"></a>加载(Loading)</h3><p><strong>目的</strong>：将类的字节码文件从持久存储加载到内存的方法区，并生成对应的 <strong>Class 对象</strong>。</p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li>通过类名查找 <code>.class</code> 文件，并将其二进制字节码读入内存</li>
<li>将字节码中的静态存储结构转换为方法区中的 <strong>运行时数据结构</strong>。</li>
<li>在堆内存中创建一个 <strong>java.lang.Class</strong> 对象，作为对方法区载入数据的访问入口。</li>
</ol>
<p>类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定（不过，我们也能打破由双亲委派模型）。</p>
<p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>
<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。默认的loadClass方法最后就是Link的</p>
<h3 id="连接-Linking"><a href="#连接-Linking" class="headerlink" title="连接(Linking)"></a>连接(Linking)</h3><p>类连接：指的是把类的二进制数据合并到 JRE 中，这又分为 3 个阶段：</p>
<h4 id="验证-Verification"><a href="#验证-Verification" class="headerlink" title="验证(Verification)"></a>验证(Verification)</h4><p><strong>目的</strong>：检查载入Class文件数据的正确性，确保字节码文件符合 JVM 要求，不会危害虚拟机安全。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/class-loading-process-verification.png" alt="验证阶段示意图"></p>
<p><strong>具体检查</strong>：</p>
<ol>
<li><strong>文件格式验证</strong>：是否符合 Class 文件格式规范。</li>
<li><strong>元数据验证</strong>：类继承、接口实现是否正确。</li>
<li><strong>字节码验证</strong>：指令流是否合法，如变量初始化和栈操作正确。</li>
<li><strong>符号引用验证</strong>：类、字段、方法等是否存在。</li>
</ol>
<p><strong>结果</strong>：不合法的字节码会抛出 <strong>VerifyError</strong>。</p>
<p>文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候（解析阶段会介绍符号引用和直接引用）。</p>
<p>符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常NoSuchFieldError NoSuchMethodError IllegalAccessError。</p>
<h4 id="准备-Preparation"><a href="#准备-Preparation" class="headerlink" title="准备(Preparation)"></a>准备(Preparation)</h4><p>给类的==静态变量==分配存储空间，并进行==默认初始化，赋零值==。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p>
<p><strong>目的</strong>：为类的静态变量分配内存，并设置默认值（不会执行静态初始化）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行阶段</strong>：</p>
<ul>
<li>分配内存，并将 <code>a</code> 的初始值设为 <code>0</code>（默认值）。</li>
<li>注意：这里不会执行 <code>= 10</code>，赋值在初始化阶段完成。</li>
</ul>
<p>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</p>
<h4 id="解析-Resolution"><a href="#解析-Resolution" class="headerlink" title="解析(Resolution)"></a>解析(Resolution)</h4><p><strong>目的</strong>：将类的二进制数据中 常量池的 <strong>符号引用</strong> 替换为 <strong>直接引用</strong>。</p>
<ul>
<li><strong>符号引用</strong>：类、方法、字段等以字符串形式存在于常量池中。<ul>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</li>
<li>符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。</li>
</ul>
</li>
<li><strong>直接引用</strong>：实际内存地址或偏移量。<ul>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。</li>
<li>在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</li>
</ul>
</li>
</ul>
<h3 id="初始化-Initialization"><a href="#初始化-Initialization" class="headerlink" title="初始化(Initialization)"></a>初始化(Initialization)</h3><p>对类的静态变量、静态初始化块进行初始化，因此不是必须的。<strong>这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong> </p>
<p>初始化阶段就是执行类构造器<code>&lt;clinit&gt; ()</code>方法的过程。<code>&lt;clinit&gt; ()</code>并不是程序员在Java代码中直接编写 的方法，它是Javac编译器的自动生成物</p>
<p>对于<code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。</p>
<p>由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的 语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能<strong>访问到定义在静态语句块之前的变量，</strong> 在前面的静态语句块可以赋值定义在其后的变量，但是不能访问它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">         System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>&lt;clinit&gt; ()</code>方法与类的构造函数（即在虚拟机视角中的实例构造器<code>&lt;init&gt; ()</code>方法）不同，它不需要显 式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt; ()</code>方法执行前，父类的<code>&lt;init&gt; ()</code>方法已经执行 完毕。因此在Java虚拟机中第一个被执行的()方法的类型肯定是java.lang.Object</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250104142317079.png" alt="clinit"></p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li>按照声明顺序依次执行静态变量赋值和静态代码块。</li>
<li>若父类未初始化，会先初始化父类。</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123; a = <span class="number">20</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong>：<code>a = 20</code>（因为静态代码块会覆盖前面的赋值）。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>初始化是类加载的最后阶段，只有在首次使用类时触发。</li>
<li>使用场景：实例化对象、调用静态方法、访问静态变量等。</li>
</ul>
<h4 id="初始化的触发条件-主动"><a href="#初始化的触发条件-主动" class="headerlink" title="初始化的触发条件(主动)"></a>初始化的触发条件(主动)</h4><p>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行 强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》 则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之 前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始 化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ol>
<li>创建该类的实例对象</li>
<li>访问static变量</li>
<li>调用static方法</li>
</ol>
</li>
<li>反射调用时如 <code>Class.forName(&quot;...&quot;)</code>, <code>newInstance()</code> 等<ul>
<li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类</li>
</ul>
</li>
<li>初始化子类会触发父类的初始化</li>
<li>有 <code>default</code> 方法的接口实现类初始化，接口也要初始化</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li>
</ol>
<p>被动访问不会触发初始化：</p>
<ol>
<li>访问类的 <strong>常量</strong>（<code>static final</code> 修饰）因为常量位于 运行时常量池<ul>
<li>在编译阶段通过常量传播优化，已经将常量的值“hello world”直接存储在NotInitialization类的常量池中，以后NotInitialization对常量 ConstClass.HELLOWORLD的引用，实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成 Class文件后就已不存在任何联系了。</li>
</ul>
</li>
<li>通过 <strong>数组定义类引用</strong>（如 <code>Test[] arr</code>）。<ul>
<li>运行之后发现没有输出“SuperClass init！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。但是这段代码里面触发了 另一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是 一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由 字节码指令newarray触发。</li>
</ul>
</li>
<li>对于静态字段， 只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发 父类的初始化而不会触发子类的初始化。</li>
</ol>
<p>（注意：一个final类型的静态属性，如果在编译时已经得到了属性值，那么调用该属性时，不会导致该类初始化，因为这个相当于使用常量；使用ClassLoader()方法，只是加载该类，并未初始化。）</p>
<h3 id="使用-Using"><a href="#使用-Using" class="headerlink" title="使用(Using)"></a>使用(Using)</h3><p>类加载完成后，可以使用类创建实例、调用方法或访问字段。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>使用过程中 JVM 可能会进行 <strong>动态绑定</strong>（如多态方法调用）和 <strong>反射机制</strong>。 </li>
</ul>
<h3 id="卸载-Unloading"><a href="#卸载-Unloading" class="headerlink" title="卸载(Unloading)"></a>卸载(Unloading)</h3><p><strong>目的</strong>：当某些类不再被使用时，将其从内存中移除。</p>
<p><strong>条件</strong>：</p>
<ul>
<li>该类的所有实例已被回收。</li>
<li>该类的 ClassLoader 实例已被回收。</li>
<li>JVM 中没有该类的任何引用。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>卸载阶段只针对用户的使用自定义类加载器加载的类，Bootstrap 引导加载器加载的类不会被卸载。</li>
<li>GC 会回收 <strong>Class 对象</strong> 和相关的元数据。</li>
</ul>
<p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>类加载器是一个负责加载类的对象。<code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象。</p>
<p>在 Java 中，一个类用其全限定类名（即包名+类名）作为标识。</p>
<p>而在 JVM 中，一个类用其全限定类名和其类加载器作为标识。</p>
<h3 id="dynamic-lazy-loading-only-once"><a href="#dynamic-lazy-loading-only-once" class="headerlink" title="dynamic lazy loading, only once"></a>dynamic lazy loading, only once</h3><p>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。加载时机并没有明确的要求。</p>
<p>对于已经加载的类会被放在 <code>ClassLoader</code> 中的 <code>classes</code> 字段，这是一个存放Class对象的容器。在类加载的时候，首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p>
<p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="comment">// 由这个类加载器加载的类。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 由VM调用，用此类加载器记录每个已加载类。</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">        classes.addElement(c);</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><strong>Bootstrap ClassLoader</strong>（引导类加载器）：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级。加载核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类）。<ul>
<li>**<code>rt.jar</code>**：rt 代表“RunTime”，<code>rt.jar</code>是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</li>
</ul>
</li>
<li><strong>Extension ClassLoader</strong>（扩展类加载器）：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。<ul>
<li>Java 9 引入了模块系统，并且略微更改了上述的类加载器。Extension ClassLoader被改名为平台类加载器（Platform Classloader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由 Bootstrap ClassLoader 加载之外，其他的模块均由 Platform Classloader 所加载。</li>
</ul>
</li>
<li><strong>Application ClassLoader</strong>（应用类加载器）：加载应用程序的 <code>classpath</code> 下的类。</li>
<li><strong>自定义类加载器</strong>：用户实现的特殊需求类加载器。</li>
</ul>
<p>除了 <code>BootstrapClassLoader</code> 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 <code>ClassLoader</code>抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p>
<h3 id="加载器调用顺序"><a href="#加载器调用顺序" class="headerlink" title="加载器调用顺序"></a>加载器调用顺序</h3><p>每个 <code>ClassLoader</code> 可以通过<code>getParent()</code>获取其父 <code>ClassLoader</code>，如果获取到 <code>ClassLoader</code> 为<code>null</code>的话，那么该类是通过 <code>BootstrapClassLoader</code> 加载的。</p>
<ul>
<li>我们编写的 Java 类 <code>PrintClassLoaderTree</code> 的 <code>ClassLoader</code> 是<code>AppClassLoader</code>；</li>
<li><code>AppClassLoader</code>的父 <code>ClassLoader</code> 是 <code>ExtClassLoader</code>；</li>
<li><code>ExtClassLoader</code>的父 <code>ClassLoader</code> 是 <code>Bootstrap ClassLoader</code> </li>
</ul>
<p>其中，<code>BootstrapClassLoader</code>负责加载JRE的核心类库，它不是<code>ClassLoader</code>的子类，使用C++编写，因此我们在Java中看不到它，通过其子类的<code>getParent()</code>方法获取时，将返回<code>null</code>。</p>
<p><code>ExtClassLoader</code>和<code>AppClassLoader</code>为<code>ClassLoader</code>的子类。在 API 中看不到它们，他们位于 rt.jar 文件中，因此由<code>BootstrapClassLoader</code>进行加载，全限定类名分别为：</p>
<ul>
<li><p><code>sun.misc.Launcher$AppClassLoader</code> </p>
<ul>
<li><code>jdk.internal.loader.ClassLoaders$AppClassLoader</code> </li>
</ul>
</li>
<li><p><code>sun.misc.Launcher$ExtClassLoader</code> </p>
<ul>
<li><code>jdk.internal.loader.ClassLoaders$PlatformClassLoader</code> </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.stopTalking.crazy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="comment">//获取当前线程的类装载器 </span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader(); </span><br><span class="line">        <span class="comment">//获取System类的类装载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> System.class.getClassLoader(); </span><br><span class="line">        <span class="comment">//获取本类TestClassLoader的类加载器loader2 </span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> TestClassLoader.class.getClassLoader(); </span><br><span class="line">        <span class="comment">//获取loader2的父加载器 </span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader3</span> <span class="operator">=</span> loader2.getParent(); </span><br><span class="line">        <span class="comment">//获取loader2的父加载器的父加载器 </span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader4</span> <span class="operator">=</span> loader3.getParent(); </span><br><span class="line">        System.out.println(loader); </span><br><span class="line">        System.out.println(loader1); </span><br><span class="line">        System.out.println(loader2); </span><br><span class="line">        System.out.println(loader3); </span><br><span class="line">        System.out.println(loader4); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前线程类获取的类加载器是AppClassLoader</span></span><br><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@4aa298b7</span><br><span class="line"><span class="comment">//System类为根装载器加载，java中访问不到，所以为null</span></span><br><span class="line"><span class="literal">null</span> </span><br><span class="line"><span class="comment">//本类的类加载器当然也是AppClassLoader    </span></span><br><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@4aa298b7</span><br><span class="line">jdk.internal.loader.ClassLoaders$PlatformClassLoader@5caf905d</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义-ClassLoader"><a href="#自定义-ClassLoader" class="headerlink" title="自定义 ClassLoader"></a>自定义 ClassLoader</h3><p>需要继承 <code>ClassLoader</code>抽象类。<code>ClassLoader</code> 类有两个关键方法：</p>
<ul>
<li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li>
<li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li>
</ul>
<blockquote>
<p>建议 <code>ClassLoader</code>的子类重写 <code>findClass(String name)</code>方法而不是<code>loadClass(String name, boolean resolve)</code> 方法。</p>
</blockquote>
<p>如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p>
<h2 id="Parents-Delegation-Model"><a href="#Parents-Delegation-Model" class="headerlink" title="Parents Delegation Model"></a>Parents Delegation Model</h2><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</p>
<p>父辈委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
<p><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</p>
<p>父辈委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/class-loader-parents-delegation-model-1735908352601-36.png" alt="类加载器层次关系图"></p>
<p>另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承，多用组合少用继承。</strong></p>
<h3 id="java-lang-ClassLoader-loadClass"><a href="#java-lang-ClassLoader-loadClass" class="headerlink" title="java.lang.ClassLoader.loadClass()"></a><code>java.lang.ClassLoader.loadClass()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过，自底向上</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">        		<span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行连接操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li>
<li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li>
<li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li>
<li>如果子类加载器也无法加载这个类，那么它会抛出一个 <code>ClassNotFoundException</code> 异常。</li>
</ul>
<p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 <code>Class</code> 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</p>
<p>双亲委派很好地解决了各个类 加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被 称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变 的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p>
<blockquote>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务， 它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型 了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程 序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启 动类加载器是绝不可能认识、加载这些代码的，那该怎么办？ 为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方 法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内 都没有设置过的话，那这个类加载器默认就是应用程序类加载器。 有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类 加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行 为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性 原则，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、 JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供 者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了 java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加 载提供了一种相对合理的解决方案。</p>
</blockquote>
<p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p>
<p>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</p>
<p>但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。重写 <code>loadClass()</code>方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。另外，仅仅自定义加载器也不能够满足全部的要求。</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/classloader.html#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%96%B9%E6%B3%95">打破双亲委派模型方法 | JavaGuide</a> </p>
<h2 id="Classpath"><a href="#Classpath" class="headerlink" title="Classpath"></a>Classpath</h2><p><strong>Classpath</strong> 是 Java 应用程序运行时用来查找 <strong>类文件（.class）</strong> 和 <strong>资源文件</strong> 的路径。它定义了 JVM 加载类和资源的搜索目录。<strong>Classpath</strong> 指定了 JVM 在加载类时搜索的目录或 JAR 包路径。</p>
<p><strong>Classpath</strong> 是 JVM 加载类和资源的搜索路径，通常包括：</p>
<ol>
<li>当前目录 (<code>.</code>)。</li>
<li>指定的文件夹（包含 <code>.class</code> 文件或 JAR 包）。</li>
<li>第三方库文件（如 <code>lib/*.jar</code>）。</li>
</ol>
<p>在开发和运行 Java 程序时，可以通过命令行、环境变量或 IDE 设置 Classpath，以确保依赖文件和类可以正确加载。</p>
<h3 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h3><ol>
<li><p><strong>命令行设置：</strong><br>使用 <code>-classpath</code> 或 <code>-cp</code> 参数指定路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .;lib/* com.example.Main</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>“.”</strong> 表示当前目录。</li>
<li><strong>“lib/*”</strong> 表示 <code>lib</code> 文件夹下的所有 JAR 文件。</li>
</ul>
</li>
<li><p><strong>环境变量设置：</strong><br>设置全局环境变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CLASSPATH=/usr/local/app/classes:/usr/local/app/lib/*</span><br></pre></td></tr></table></figure>

<p>或 Windows 下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set CLASSPATH=.;lib\*</span><br></pre></td></tr></table></figure></li>
<li><p><strong>IDE 设置：</strong><br>在 IDE（如 IntelliJ IDEA、Eclipse）中，classpath 默认包含 <strong>src/main/java</strong> 和 <strong>target/classes</strong>，以及项目引用的依赖项。</p>
</li>
</ol>
<h3 id="Classpath-路径内容"><a href="#Classpath-路径内容" class="headerlink" title="Classpath 路径内容"></a>Classpath 路径内容</h3><p>Classpath 支持以下类型的路径：</p>
<ol>
<li><p><strong>目录路径：</strong></p>
<ul>
<li><p>包含编译好的类文件，如：<code>/home/user/classes</code>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp /home/user/classes Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>JAR 文件路径：</strong></p>
<ul>
<li><p>支持直接引用 JAR 包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp lib/example.jar Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>通配符路径：</strong></p>
<ul>
<li><p>可使用 <code>*</code> 引用多个 JAR 包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp lib/* Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>相对路径或绝对路径：</strong></p>
<ul>
<li>相对路径：<code>./lib</code>（当前目录）。</li>
<li>绝对路径：<code>/usr/lib/java/</code>.</li>
</ul>
</li>
</ol>
<h3 id="默认-Classpath-设置"><a href="#默认-Classpath-设置" class="headerlink" title="默认 Classpath 设置"></a>默认 Classpath 设置</h3><ol>
<li><p>如果未显式设置 <code>-classpath</code> 或 <code>CLASSPATH</code> 环境变量，JVM 默认搜索 <strong>当前目录（.）</strong>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java</span><br><span class="line">java Test</span><br></pre></td></tr></table></figure>

<p>默认会从当前目录加载 <code>Test.class</code> 文件。</p>
</li>
</ol>
<h3 id="示例-1：单个类文件"><a href="#示例-1：单个类文件" class="headerlink" title="示例 1：单个类文件"></a>示例 1：单个类文件</h3><p>假设有以下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/project/</span><br><span class="line">  Main.java</span><br></pre></td></tr></table></figure>

<p>编译与运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br><span class="line">java Main</span><br></pre></td></tr></table></figure>

<h3 id="示例-2：JAR-包依赖"><a href="#示例-2：JAR-包依赖" class="headerlink" title="示例 2：JAR 包依赖"></a>示例 2：JAR 包依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/project/</span><br><span class="line">  lib/</span><br><span class="line">    gson.jar</span><br><span class="line">  Main.java</span><br></pre></td></tr></table></figure>

<p>编译与运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac -cp lib/gson.jar Main.java</span><br><span class="line">java -cp lib/gson.jar:. Main</span><br></pre></td></tr></table></figure>

<h3 id="示例-3：多个-JAR-包"><a href="#示例-3：多个-JAR-包" class="headerlink" title="示例 3：多个 JAR 包"></a>示例 3：多个 JAR 包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp &quot;lib/*&quot; com.example.Main</span><br></pre></td></tr></table></figure>

<h2 id="加载顺序demo"><a href="#加载顺序demo" class="headerlink" title="加载顺序demo"></a>加载顺序demo</h2><p>这其实是去年校招时我遇到的一道阿里巴巴的笔试题(承认有点久远了-。-)，嗯，如果我没记错的话，当时是作为java方向的一道选做大题。当然题意没有这么直白，题目只要求你写出程序运行后所有system.out.println的输出结果，其中程序是题目给的，而各个system.out.println的执行顺序不同会导致最后程序输出的结果也不同。</p>
<p>具体的题目我肯定记不清，不过我们可以换个直接的问法，如果类A和类B中有静态变量，静态语句块，非静态变量，非静态语句块，构造函数，静态方法，非静态方法，同时类A继承类B，请问当实例化A时，类内部的加载顺序是什么?</p>
<p>当时我也是一头雾水，事后我就自己写了一个小Demo，这才知道了类内部的实际加载顺，测试代码如下：</p>
<p>Class B:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//静态变量 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;  System.out.println(<span class="string">&quot;Class B1:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//非静态变量</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;  i++;  System.out.println(<span class="string">&quot;Class B2:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  j++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;constructor B: &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态语句块</span></span><br><span class="line">    &#123; </span><br><span class="line">        i++; j++; </span><br><span class="line">        System.out.println(<span class="string">&quot;Class B:common blocks&quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bDisplay</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class B:static void bDisplay(): &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bTest</span><span class="params">()</span>&#123; </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class B:static void bTest():  &quot;</span>+<span class="string">&quot;i=&quot;</span>+i);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class A:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//静态变量 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;  System.out.println(<span class="string">&quot;Class A1:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//非静态变量</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;  i++;  System.out.println(<span class="string">&quot;Class A2:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="built_in">super</span>();  i++;  j++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;constructor A: &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态语句块</span></span><br><span class="line">    &#123; </span><br><span class="line">        i++; j++; </span><br><span class="line">        System.out.println(<span class="string">&quot;Class A:common blocks&quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aDisplay</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class A:static void aDisplay(): &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">aTest</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class A:static void aTest():  &quot;</span>+<span class="string">&quot;i=&quot;</span>+i);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class ClassLoading :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoading</span> &#123;      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span> &#123;    </span><br><span class="line">        A a=<span class="keyword">new</span> <span class="title class_">A</span>();    </span><br><span class="line">        a.aDisplay();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1484270652220239.jpg" alt="Java中类的加载顺序剖析（常用于面试题）"></p>
<p>通过上述示图，我们可以比较清晰的看出java类的整个加载过程。</p>
<ol>
<li>若要加载类A，则先加载执行其父类B(Object)的静态变量以及静态语句块(执行先后顺序按排列的先后顺序)。</li>
<li>然后再加载执行类A的静态变量以及静态语句块。(并且1、2步骤只会执行1次)</li>
<li>若需实例化类A，则先调用其父类B的构造函数,并且在调用其父类B的构造函数前,依次先调用父类B中的非静态变量及非静态语句块.最后再调用父类B中的构造函数初始化。</li>
<li>然后再依次调用类A中的非静态变量及非静态语句块.最后调用A中的构造函数初始化。( 并且3、4步骤可以重复执行)</li>
<li>而对于静态方法和非静态方法都是被动调用,即系统不会自动调用执行,所以用户没有调用时都不执行,主要区别在于静态方法可以直接用类名直接调用(实例化对象也可以),而非静态方法只能先实例化对象后才能调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父类--静态变量</span><br><span class="line">父类--静态初始化块</span><br><span class="line">子类--静态变量</span><br><span class="line">子类--静态初始化块</span><br><span class="line">*************in main***************</span><br><span class="line">父类--变量</span><br><span class="line">父类--初始化块</span><br><span class="line">父类--构造器</span><br><span class="line">子类--变量</span><br><span class="line">子类--初始化块</span><br><span class="line">子类--构造器</span><br><span class="line">*************second subclass***************</span><br><span class="line">父类--变量</span><br><span class="line">父类--初始化块</span><br><span class="line">父类--构造器</span><br><span class="line">子类--变量</span><br><span class="line">子类--初始化块</span><br><span class="line">子类--构造器</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<p>很显然在加载main方法后，静态变量不管父类还是子类的都执行了，然后才是父类和子类的的普通变量和构造器。这是因为，当要创建子类这个对象时，发现这个类需要一个父类，所以把父类的.class加载进来，然后依次初始化其普通变量和初始化代码块，最后其构造器，然后可以开始子类的工作，把子类的.class加载进来，在做子类的工作。</p>
<p>另外在 Java 中子类中都会有默认的调用父类的默认构造函数即super() 如果父类声明了有参构造函数，那么如果没有显式声明无参构造，子类就会爆出语法错误，无法调用父类的无参构造。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/13/classfile/" data-id="cm8pkpl4j00024stvbiz64csz" data-title="ClassFile" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/" rel="tag">字节码</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-G1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/12/G1/" class="article-date">
  <time class="dt-published" datetime="2024-09-11T16:00:00.000Z" itemprop="datePublished">2024-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/12/G1/">G1 垃圾收集器介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>之前根据 Sun 的内存管理白皮书介绍了在 HotSpot JVM 分代算法中的几个垃圾收集器，本文将介绍 G1 垃圾收集器。</p>
<p>G1 的主要关注点在于达到<strong>可控的停顿时间</strong>，在这个基础上尽可能提高吞吐量，这一点非常重要。</p>
<p>G1 被设计用来长期取代 CMS 收集器，和 CMS 相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。区别在于，G1 没有 CMS 的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间。</p>
<p>如果你的应用使用了较大的堆（如 6GB 及以上）而且还要求有较低的垃圾收集停顿时间（如 0.5 秒），那么 G1 是你绝佳的选择，是时候放弃 CMS 了。</p>
<p><strong>阅读建议</strong>：本文力求用简单的话介绍清楚 G1 收集器，但是并不会重复介绍每一个细节，所以希望读者了解其他几个收集器的工作过程，尤其是 CMS 收集器。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3-1742964906329-3.png" alt="G1 收集器"></p>
<h2 id="G1-总览"><a href="#G1-总览" class="headerlink" title="G1 总览"></a>G1 总览</h2><p>首先是内存划分上，之前介绍的分代收集器将整个堆分为年轻代、老年代和永久代，每个代的空间是确定的。</p>
<p>而 G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3-1742964906329-3.png" alt="内存划分"></p>
<p>执行垃圾收集时，和 CMS 一样，G1 收集线程在标记阶段和应用程序线程<strong>并发</strong>执行，标记结束后，G1 也就知道哪些区块基本上是垃圾，存活对象极少，G1 会先从这些区块下手，因为从这些区块能很快释放得到很大的可用空间，<strong>这也是为什么 G1 被取名为 Garbage-First 的原因</strong>。</p>
<blockquote>
<p>这里只不过是先介绍些概念，没看懂没关系，往下看</p>
</blockquote>
<p>在 G1 中，目标停顿时间非常非常重要，用 -XX:MaxGCPauseMillis=200 指定期望的停顿时间。</p>
<p>G1 使用了<strong>停顿预测模型</strong>来满足用户指定的停顿时间目标，并基于目标来选择进行垃圾回收的区块数量。G1 采用增量回收的方式，每次回收一些区块，而不是整堆回收。</p>
<p>我们要知道 G1 不是一个实时收集器，它会尽力满足我们的停顿时间要求，但也不是绝对的，它基于之前垃圾收集的数据统计，估计出在用户指定的停顿时间内能收集多少个区块。</p>
<p><strong>注意：</strong>G1 有和应用程序一起运行的并发阶段，也有 stop-the-world 的并行阶段。但是，<strong>Full GC 的时候还是单线程运行的</strong>，所以我们应该尽量避免发生 Full GC，后面我们也会介绍什么时候会触发 Full GC。</p>
<p><strong>G1 内存占用</strong></p>
<p>G1 比 ParallelOld 和 CMS 会需要更多的内存消耗，那是因为有部分内存消耗于簿记（accounting）上，如以下两个数据结构：</p>
<ul>
<li><strong>Remembered Sets</strong>：每个区块都有一个 RSet，用于记录进入该区块的对象引用（如区块 A 中的对象引用了区块 B，区块 B 的 Rset 需要记录这个信息），它用于实现收集过程的并行化以及使得区块能进行独立收集。总体上 Remembered Sets 消耗的内存小于 5%。</li>
<li><strong>Collection Sets</strong>：将要被回收的区块集合。GC 时，在这些区块中的对象会被复制到其他区块中，总体上 Collection Sets 消耗的内存小于 1%。</li>
</ul>
<h2 id="G1-工作流程"><a href="#G1-工作流程" class="headerlink" title="G1 工作流程"></a>G1 工作流程</h2><p>前面啰里啰嗦说了挺多的，唯一要记住的就是，G1 的设计目标就是尽力满足我们的目标停顿时间上的要求。</p>
<p>本节介绍 G1 的收集过程，G1 收集器主要包括了以下 4 种操作：</p>
<ul>
<li>1、年轻代收集</li>
<li>2、并发收集，和应用线程同时执行</li>
<li>3、混合式垃圾收集</li>
<li>*、必要时的 Full GC</li>
</ul>
<p>接下来，我们进行一一介绍。</p>
<h3 id="年轻代收集"><a href="#年轻代收集" class="headerlink" title="年轻代收集"></a>年轻代收集</h3><p>首先，我们来看下 G1 的堆结构：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8ca16868.png" alt="G1 GC 内存布局"></p>
<p>年轻代中的垃圾收集流程（Young GC）：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2.png" alt="Young GC"></p>
<p>我们可以看到，年轻代收集概念上和之前介绍的其他分代收集器大差不差的，但是它的年轻代会动态调整。</p>
<h3 id="Old-GC-并发标记周期"><a href="#Old-GC-并发标记周期" class="headerlink" title="Old GC / 并发标记周期"></a>Old GC / 并发标记周期</h3><p>接下来是 Old GC 的流程（含 Young GC 阶段），其实把 Old GC  理解为<strong>并发周期</strong>是比较合理的，不要单纯地认为是清理老年代的区块，因为这一步和年轻代收集也是相关的。下面我们介绍主要流程：</p>
<ol>
<li><p>初始标记：stop-the-world，它伴随着一次普通的 Young GC 发生，然后对 Survivor 区（root region）进行标记，因为该区可能存在对老年代的引用。</p>
<blockquote>
<p>因为 Young GC 是需要 stop-the-world 的，所以并发周期直接重用这个阶段，虽然会增加 CPU 开销，但是停顿时间只是增加了一小部分。</p>
</blockquote>
</li>
<li><p>扫描根引用区：因为先进行了一次 YGC，所以当前年轻代只有 Survivor 区有存活对象，它被称为根引用区。扫描 Survivor 到老年代的引用，该阶段必须在下一次 Young GC 发生前结束。</p>
<blockquote>
<p>这个阶段不能发生年轻代收集，如果中途 Eden 区真的满了，也要等待这个阶段结束才能进行 Young GC。</p>
</blockquote>
</li>
<li><p>并发标记：寻找整个堆的存活对象，该阶段可以被 Young GC 中断。</p>
<blockquote>
<p>这个阶段是并发执行的，中间可以发生多次 Young GC，Young GC 会中断标记过程</p>
</blockquote>
</li>
<li><p>重新标记：stop-the-world，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法。</p>
<blockquote>
<p>Oracle 的资料显示，这个阶段会回收完全空闲的区块</p>
</blockquote>
</li>
<li><p>清理：清理阶段真正回收的内存很少。</p>
</li>
</ol>
<p>到这里，G1 的一个并发周期就算结束了，其实就是主要完成了垃圾定位的工作，定位出了哪些分区是垃圾最多的。因为整堆一般比较大，所以这个周期应该会比较长，中间可能会被多次 stop-the-world 的 Young GC 打断。</p>
<h3 id="混合垃圾回收周期"><a href="#混合垃圾回收周期" class="headerlink" title="混合垃圾回收周期"></a>混合垃圾回收周期</h3><p>并发周期结束后是混合垃圾回收周期，不仅进行年轻代垃圾收集，而且回收之前标记出来的老年代的垃圾最多的部分区块。</p>
<p>混合垃圾回收周期会持续进行，直到几乎所有的被标记出来的分区（垃圾占比大的分区）都得到回收，然后恢复到常规的年轻代垃圾收集，最终再次启动并发周期。</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>到这里我们已经说了年轻代收集、并发周期、混合回收周期了，大家要熟悉这几个阶段的工作。</p>
<p>下面我们来介绍特殊情况，那就是会导致 <strong>Full GC</strong> 的情况，也是我们需要极力避免的：</p>
<ol>
<li><p>concurrent mode failure：并发模式失败，CMS 收集器也有同样的概念。G1 并发标记期间，如果在标记结束前，老年代被填满，G1 会放弃标记。</p>
<blockquote>
<p>这个时候说明</p>
<ul>
<li>堆需要增加了，</li>
<li>或者需要调整并发周期，如增加并发标记的线程数量，让并发标记尽快结束</li>
<li>或者就是更早地进行并发周期，默认是整堆内存的 45% 被占用就开始进行并发周期。</li>
</ul>
</blockquote>
</li>
<li><p>晋升失败：并发周期结束后，是混合垃圾回收周期，伴随着年轻代垃圾收集，进行清理老年代空间，如果这个时候清理的速度小于消耗的速度，导致老年代不够用，那么会发生晋升失败。</p>
<blockquote>
<p>说明混合垃圾回收需要更迅速完成垃圾收集，也就是说在混合回收阶段，每次年轻代的收集应该处理更多的老年代已标记区块。</p>
</blockquote>
</li>
<li><p>疏散失败：年轻代垃圾收集的时候，如果 Survivor 和 Old 区没有足够的空间容纳所有的存活对象。这种情况肯定是非常致命的，因为基本上已经没有多少空间可以用了，这个时候会触发 Full GC 也是很合理的。</p>
<blockquote>
<p>最简单的就是增加堆大小</p>
</blockquote>
</li>
<li><p>大对象分配失败，我们应该尽可能地不创建大对象，尤其是大于一个区块大小的那种对象。</p>
</li>
</ol>
<h3 id="简单小结"><a href="#简单小结" class="headerlink" title="简单小结"></a>简单小结</h3><p>看完上面的 Young GC 和 Old GC 等，很多读者可能还是很懵的，这里说几句不严谨的白话文帮助读者进行理解：</p>
<p>首先，最好不要把上面的 Old GC 当做是一次 GC 来看，而应该当做<strong>并发标记周期</strong>来理解，虽然它确实会释放出一些内存。</p>
<p>并发标记结束后，G1 也就知道了哪些区块是最适合被回收的，那些完全空闲的区块会在这这个阶段被回收。如果这个阶段释放了足够的内存出来，其实也就可以认为结束了一次 GC。</p>
<p>我们假设并发标记结束了，那么下次 GC 的时候，还是会先回收年轻代，如果从年轻代中得到了足够的内存，那么结束；过了几次后，年轻代垃圾收集不能满足需要了，那么就需要利用之前并发标记的结果，选择一些活跃度最低的老年代区块进行回收。直到最后，老年代会进入下一个并发周期。</p>
<p>那么什么时候会启动并发标记周期呢？这个是通过参数控制的，下面马上要介绍这个参数了，此参数默认值是 45，也就是说当堆空间使用了 45% 后，G1 就会进入并发标记周期。</p>
<h2 id="G1-参数配置和最佳实践"><a href="#G1-参数配置和最佳实践" class="headerlink" title="G1 参数配置和最佳实践"></a>G1 参数配置和最佳实践</h2><p>G1 调优的目标是尽量避免出现 Full GC，其实就是给老年代足够的空间，或相对更多的空间。</p>
<p>有以下几点我们可以进行调整的方向：</p>
<ul>
<li>增加堆大小，或调整老年代和年轻代的比例，这个很好理解</li>
<li>增加并发周期的线程数量，其实就是为了加快并发周期快点结束</li>
<li>让并发周期尽早开始，这个是通过设置堆使用占比来调整的（默认 45%）</li>
<li>在混合垃圾回收周期中回收更多的老年代区块</li>
</ul>
<p>G1 的很重要的目标是达到可控的停顿时间，所以很多的行为都以这个目标为出发点开展的。</p>
<p>我们通过设置 -XX:MaxGCPauseMillis=N 来指定停顿时间（单位 ms，默认 200ms），如果没有达到这个目标，G1 会通过各种方式来补救：调整年轻代和老年代的比例，调整堆大小，调整晋升的年龄阈值，调整混合垃圾回收周期中处理的老年代的区块数量等等。</p>
<p>当然了，调整每个参数满足了一个条件的同时往往也会引入另一个问题，比如为了降低停顿时间，我们可以减小年轻代的大小，可是这样的话就会增加年轻代垃圾收集的频率。如果我们减少混合垃圾回收周期处理的老年代区块数量，虽然可以更容易满足停顿时间要求，可是这样就会增加 Full GC 的风险等等。</p>
<p>下面介绍最常用也是最基础的一些参数的设置，涉及到更高级的调优参数设置，请读者自行参阅其他资料。</p>
<p><strong>参数介绍</strong>：</p>
<ul>
<li><p><strong>-XX:+UseG1GC</strong></p>
<p>使用 G1 收集器</p>
</li>
<li><p><strong>-XX:MaxGCPauseMillis=200</strong></p>
<p>指定目标停顿时间，默认值 200 毫秒。</p>
<blockquote>
<p>在设置 -XX:MaxGCPauseMillis 值的时候，不要指定为平均时间，而应该指定为满足 90% 的停顿在这个时间之内。记住，停顿时间目标是我们的目标，不是每次都一定能满足的。</p>
</blockquote>
</li>
<li><p><strong>-XX:InitiatingHeapOccupancyPercent=45</strong></p>
<p>整堆使用达到这个比例后，触发并发 GC 周期，默认 45%。</p>
<blockquote>
<p>如果要降低晋升失败的话，通常可以调整这个数值，使得并发周期提前进行</p>
</blockquote>
</li>
<li><p><strong>-XX:NewRatio=n</strong></p>
<p>老年代/年轻代，默认值 2，即 1/3 的年轻代，2/3 的老年代</p>
<blockquote>
<p>不要设置年轻代为固定大小，否则：</p>
<ul>
<li>G1 不再需要满足我们的停顿时间目标</li>
<li>不能再按需扩容或缩容年轻代大小</li>
</ul>
</blockquote>
</li>
<li><p><strong>-XX:SurvivorRatio=n</strong></p>
<p>Eden/Survivor，默认值 8，这个和其他分代收集器是一样的</p>
</li>
<li><p><strong>-XX:MaxTenuringThreshold =n</strong></p>
<p>从年轻代晋升到老年代的年龄阈值，也是和其他分代收集器一样的</p>
</li>
<li><p><strong>-XX:ParallelGCThreads=n</strong></p>
<p>并行收集时候的垃圾收集线程数</p>
</li>
<li><p><strong>-XX:ConcGCThreads=n</strong></p>
<p>并发标记阶段的垃圾收集线程数</p>
<blockquote>
<p>增加这个值可以让并发标记更快完成，如果没有指定这个值，JVM 会通过以下公式计算得到：</p>
<p>ConcGCThreads=(ParallelGCThreads + 2) / 4^3</p>
</blockquote>
</li>
<li><p><strong>-XX:G1ReservePercent=n</strong></p>
<p>堆内存的预留空间百分比，默认 10，用于降低晋升失败的风险，即默认地会将 10% 的堆内存预留下来。</p>
</li>
<li><p><strong>-XX:G1HeapRegionSize=n</strong></p>
<p>每一个 region 的大小，默认值为根据堆大小计算出来，取值 1MB~32MB，这个我们通常指定整堆大小就好了。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我自己仔细检查了几遍，主要内容都囊括了，我也不知道读者看完本文会不会是一脸懵逼。</p>
<p>如果有什么问题，可以在留言板上给我留言，<strong>我是 GC 的门外汉</strong>，如果有些问题我觉得自己能解答，我会尽力帮助大家。</p>
<p>最后，在这里推荐一些资料给感兴趣的读者：</p>
<p>Oracle 官方出品，本文的很多内容是翻译并解读这篇文章的：</p>
<p><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">Getting Started with the G1 Garbage Collector</a></p>
<p>帮助大家理解 G1 的日志：</p>
<p><a target="_blank" rel="noopener" href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs">Understanding G1 GC Logs</a></p>
<p>这里介绍 GC 的内容非常好：</p>
<p><a target="_blank" rel="noopener" href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1">https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1</a></p>
<p>《Java 性能权威指南》：非常好的一本书，建议读者有时间可以看看这本书中关于 GC 的介绍。</p>
<p>（全文完）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/12/G1/" data-id="cm8pkpl4h00014stv61uu34gh" data-title="G1 垃圾收集器介绍" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/G1/" rel="tag">G1</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/G1/" rel="tag">G1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/" rel="tag">字节码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/G1/" style="font-size: 10px;">G1</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/JVM/" style="font-size: 20px;">JVM</a> <a href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/" style="font-size: 10px;">字节码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/25/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2024/09/13/classfile/">ClassFile</a>
          </li>
        
          <li>
            <a href="/2024/09/12/G1/">G1 垃圾收集器介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>