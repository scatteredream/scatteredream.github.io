<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/25/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-03-25T08:39:51.604Z" itemprop="datePublished">2025-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/25/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/25/hello-world/" data-id="cm8pkpl4d00004stvhhad6yzs" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-classfile" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/13/classfile/" class="article-date">
  <time class="dt-published" datetime="2024-09-12T16:00:00.000Z" itemprop="datePublished">2024-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/13/classfile/">ClassFile</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ClassFile-字节码"><a href="#ClassFile-字节码" class="headerlink" title="ClassFile 字节码"></a>ClassFile 字节码</h1><p>Java 字节码是 Java 编译器将 Java 源代码编译成的 <strong>中间表示格式</strong>，它运行在 <strong>Java 虚拟机（JVM）</strong> 上。Java 字节码文件的扩展名为 **<code>.class</code>**，可以通过 <strong><code>javap -c</code></strong> 命令查看其内容。</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。本章中， 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它完全不 需要以磁盘文件的形式存在。</p>
<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。</p>
<h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BytecodeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译和查看字节码指令</strong> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac BytecodeExample.java</span><br><span class="line">javap -c BytecodeExample</span><br><span class="line"><span class="comment"># 打印类中每个方法的反汇编代码，例如组成 Java 字节码的指令。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCodeExample</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> MAX;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ByteCodeExample</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iload_0</span><br><span class="line">       <span class="number">1</span>: iload_1</span><br><span class="line">       <span class="number">2</span>: iadd</span><br><span class="line">       <span class="number">3</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_2</span><br><span class="line">       <span class="number">1</span>: iconst_3</span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method add:(II)I</span></span><br><span class="line">       <span class="number">5</span>: istore_1</span><br><span class="line">       <span class="number">6</span>: getstatic     #<span class="number">13</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">9</span>: iload_1</span><br><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">19</span>                 <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节码指令解释"><a href="#字节码指令解释" class="headerlink" title="字节码指令解释"></a><span id="code">字节码指令解释</span></h3><h4 id="构造方法：BytecodeExample"><a href="#构造方法：BytecodeExample" class="headerlink" title="构造方法：BytecodeExample()"></a>构造方法：BytecodeExample()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ByteCodeExample</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0           <span class="comment">// 将 this 引用加载到操作数栈</span></span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>			<span class="comment">// 返回</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：自动生成的默认构造函数，调用 <code>Object</code> 的构造函数。</p>
<h4 id="add-方法：add-int-int"><a href="#add-方法：add-int-int" class="headerlink" title="add 方法：add(int, int)"></a>add 方法：add(int, int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iload_0              <span class="comment">// 加载第一个参数 a</span></span><br><span class="line">       <span class="number">1</span>: iload_1              <span class="comment">// 加载第二个参数 b</span></span><br><span class="line">       <span class="number">2</span>: iadd                 <span class="comment">// 执行整数相加</span></span><br><span class="line">       <span class="number">3</span>: ireturn              <span class="comment">// 返回结果</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ol>
<li>**<code>iload_0</code>、<code>iload_1</code>**：将参数加载到操作数栈。</li>
<li>**<code>iadd</code>**：弹出栈顶两个整数并执行加法运算，再将结果压入栈顶。</li>
<li>**<code>ireturn</code>**：将栈顶的结果返回给调用者。</li>
</ol>
<h4 id="main-方法：main-String"><a href="#main-方法：main-String" class="headerlink" title="main 方法：main(String[])"></a>main 方法：main(String[])</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_2           <span class="comment">// 将常量 2 压入栈</span></span><br><span class="line">       <span class="number">1</span>: iconst_3           <span class="comment">// 将常量 3 压入栈</span></span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">7</span>   <span class="comment">// 调用静态方法 add(2, 3)</span></span><br><span class="line">       <span class="number">5</span>: istore_1           <span class="comment">// 将结果保存到局部变量表中的索引 1</span></span><br><span class="line">       <span class="number">6</span>: getstatic     #<span class="number">13</span>  <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">9</span>: iload_1            <span class="comment">// 加载变量 result</span></span><br><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">19</span>  <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span>             <span class="comment">// 结束 main 方法</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>**<code>iconst_2</code> 和 <code>iconst_3</code>**：将常量 2 和 3 压入栈顶。</li>
<li>**<code>invokestatic</code>**：调用静态方法 <code>add</code>，返回结果并压入栈顶。</li>
<li>**<code>istore_1</code>**：将结果存入局部变量表的索引 1（变量 result）。</li>
<li>**<code>getstatic</code>**：加载 <code>System.out</code> 对象到栈顶，用于后续方法调用。</li>
<li>**<code>invokevirtual</code>**：调用 <code>println</code> 方法打印结果。</li>
</ul>
<h3 id="常见字节码指令表"><a href="#常见字节码指令表" class="headerlink" title="常见字节码指令表"></a>常见字节码指令表</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>aload_x</strong></td>
<td>将引用变量加载到操作数栈</td>
</tr>
<tr>
<td><strong>iload_x</strong></td>
<td>将 int 型变量加载到操作数栈</td>
</tr>
<tr>
<td><strong>istore_x</strong></td>
<td>将 int 型值从栈顶存入局部变量表</td>
</tr>
<tr>
<td><strong>iconst_x</strong></td>
<td>将常量 x 压入操作数栈</td>
</tr>
<tr>
<td><strong>iadd</strong></td>
<td>执行整数加法</td>
</tr>
<tr>
<td><strong>isub</strong></td>
<td>执行整数减法</td>
</tr>
<tr>
<td><strong>invokestatic</strong></td>
<td>调用静态方法</td>
</tr>
<tr>
<td><strong>invokevirtual</strong></td>
<td>调用对象的实例方法</td>
</tr>
<tr>
<td><strong>return</strong></td>
<td>方法结束，返回 void</td>
</tr>
<tr>
<td><strong>ireturn</strong></td>
<td>方法结束，返回 int 值</td>
</tr>
</tbody></table>
<h2 id="class-文件结构-ClassFile"><a href="#class-文件结构-ClassFile" class="headerlink" title=".class 文件结构(ClassFile)"></a>.class 文件结构(ClassFile)</h2><p>ClassFile 结构定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;<span class="comment">// first 4 bytes of the file must be 0xCAFEBABE</span></span><br><span class="line">    u2             minor_version;<span class="comment">// 次版本号                        2 bytes</span></span><br><span class="line">    u2             major_version;<span class="comment">// 主版本号 比如 JDK 21 对应 65.0   2 bytes </span></span><br><span class="line">    </span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量 2 bytes</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    </span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记   </span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    </span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口数量</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//字段数量</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/16d5ec47609818fc.jpeg" alt="ClassFile 内容分析"></p>
<h3 id="常量池-cp-info-constant-pool-constant-pool-count-1"><a href="#常量池-cp-info-constant-pool-constant-pool-count-1" class="headerlink" title="常量池 cp_info constant_pool[constant_pool_count-1]"></a>常量池 <code>cp_info constant_pool[constant_pool_count-1]</code></h3><p>常量池是 ClassFile 的核心，存储类的常量信息，如字符串、字段名、方法名和方法描述符等。</p>
<p>计数器 constant_pool_count 表示常量池项的数量（从 1 开始计数）。（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp_info <span class="punctuation">&#123;</span></span><br><span class="line">    u1 tag;                  <span class="comment">// 常量类型标志      1 byte</span></span><br><span class="line">    u1 info<span class="punctuation">[</span><span class="punctuation">]</span>;               <span class="comment">// 常量值或引用      1 byte</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">标志（tag）</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_utf8_info</td>
<td align="center">1</td>
<td align="center">UTF-8 编码的字符串</td>
</tr>
<tr>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">3</td>
<td align="center">整形字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Float_info</td>
<td align="center">4</td>
<td align="center">浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Long_info</td>
<td align="center">5</td>
<td align="center">长整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Double_info</td>
<td align="center">6</td>
<td align="center">双精度浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Class_info</td>
<td align="center">7</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_String_info</td>
<td align="center">8</td>
<td align="center">字符串类型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_FieldRef_info</td>
<td align="center">9</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodRef_info</td>
<td align="center">10</td>
<td align="center">类中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_InterfaceMethodRef_info</td>
<td align="center">11</td>
<td align="center">接口中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">12</td>
<td align="center">字段或方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodType_info</td>
<td align="center">16</td>
<td align="center">标志方法类型</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodHandle_info</td>
<td align="center">15</td>
<td align="center">表示方法句柄</td>
</tr>
<tr>
<td align="center">CONSTANT_InvokeDynamic_info</td>
<td align="center">18</td>
<td align="center">表示一个动态方法调用点</td>
</tr>
</tbody></table>
<h3 id="类访问标志-access-flags"><a href="#类访问标志-access-flags" class="headerlink" title="类访问标志 access flags"></a>类访问标志 <code>access flags</code></h3><p>定义类或接口的修饰符：</p>
<table>
<thead>
<tr>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x0001 (ACC_PUBLIC)</td>
<td>公共类。</td>
</tr>
<tr>
<td>0x0010 (ACC_FINAL)</td>
<td>不可继承（final）。</td>
</tr>
<tr>
<td>0x0020 (ACC_SUPER)</td>
<td>支持 invokespecial。</td>
</tr>
<tr>
<td>0x0200 (ACC_INTERFACE)</td>
<td>接口。</td>
</tr>
<tr>
<td>0x0400 (ACC_ABSTRACT)</td>
<td>抽象类或接口。</td>
</tr>
<tr>
<td>0x1000 (ACC_SYNTHETIC)</td>
<td>编译器自动生成的类或方法。</td>
</tr>
<tr>
<td>0x2000 (ACC_ANNOTATION)</td>
<td>注解类。</td>
</tr>
<tr>
<td>0x4000 (ACC_ENUM)</td>
<td>枚举类。</td>
</tr>
</tbody></table>
<h3 id="当前类和父类的索引-this-class-super-class"><a href="#当前类和父类的索引-this-class-super-class" class="headerlink" title="当前类和父类的索引 this_class super_class"></a>当前类和父类的索引 <code>this_class</code> <code>super_class</code></h3><ul>
<li><strong>this_class</strong> 指向当前类在常量池中的索引，描述类名。</li>
<li>super_class 指向父类的索引。<ul>
<li>如果父类是 <code>java.lang.Object</code>，其值为 0。</li>
</ul>
</li>
</ul>
<h4 id="接口索引集合-interfaces-interface-count"><a href="#接口索引集合-interfaces-interface-count" class="headerlink" title="接口索引集合 interfaces[interface_count]"></a>接口索引集合 <code>interfaces[interface_count]</code></h4><p>接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p>
<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h4 id="字段集合-field-info-fields-fields-count"><a href="#字段集合-field-info-fields-fields-count" class="headerlink" title="字段集合 field_info fields[fields_count]"></a>字段集合 <code>field_info fields[fields_count]</code></h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">field_info <span class="punctuation">&#123;</span></span><br><span class="line">    u2 access_flags;       <span class="comment">// 访问标志字段的作用域（public ,private,protected修饰符），是实例变量还是类变量（static修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</span></span><br><span class="line">    u2 name_index;         <span class="comment">// 字段名称 对常量池的引用</span></span><br><span class="line">    u2 descriptor_index;   <span class="comment">// 描述符 对常量池的引用</span></span><br><span class="line">    u2 attributes_count;   <span class="comment">// 属性计数器</span></span><br><span class="line">    attribute_info attributes<span class="punctuation">[</span><span class="punctuation">]</span>; <span class="comment">// 属性表</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p>
<p>字段的访问标志位：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20201031084342859.png" alt="字段的 access_flag 的取值"></p>
<h4 id="方法表-method-info-methods-methods-count"><a href="#方法表-method-info-methods-methods-count" class="headerlink" title="方法表 method_info methods[methods_count]"></a>方法表 <code>method_info methods[methods_count]</code></h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info <span class="punctuation">&#123;</span></span><br><span class="line">    u2 access_flags;       <span class="comment">// </span></span><br><span class="line">    u2 name_index;         <span class="comment">// 方法名 对常量池的引用</span></span><br><span class="line">    u2 descriptor_index;   <span class="comment">// 描述符 对常量池的引用</span></span><br><span class="line">    u2 attributes_count;   <span class="comment">// 属性计数器</span></span><br><span class="line">    attribute_info attributes<span class="punctuation">[</span><span class="punctuation">]</span>; <span class="comment">// 属性表</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
<p>方法的访问标志位：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20201031084248965.png" alt="方法表的 access_flag 取值"></p>
<h4 id="属性表-attribute-info-attributes-attributes-count"><a href="#属性表-attribute-info-attributes-attributes-count" class="headerlink" title="属性表 attribute_info attributes[attributes_count]"></a>属性表 <code>attribute_info attributes[attributes_count]</code></h4><p>存储与类、字段或方法相关的附加信息，如注解、调试信息等。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>存储方法的字节码指令。</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>常量值属性（如 static final 常量）。</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>行号表，用于调试信息映射源代码行。</td>
</tr>
<tr>
<td>SourceFile</td>
<td>源文件名属性，用于调试信息。</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法抛出的异常信息。</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>方法中局部变量的信息（调试用途）。</td>
</tr>
<tr>
<td>Deprecated</td>
<td>标记类、方法或字段为废弃。</td>
</tr>
</tbody></table>
<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<p>比如在上文<a href="#code">字节码指令解释</a>的部分，方法的Code属性就是字节码指令</p>
<h2 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose BytecodeExample <span class="comment">// 打印有关所选类别的附加信息</span></span><br><span class="line"></span><br><span class="line">Classfile /C<span class="punctuation">:</span>/Users/Lenovo/Desktop/coding/JavaSingle/BytecodeExample.class</span><br><span class="line">  Last modified <span class="number">2025</span>年<span class="number">1</span>月<span class="number">3</span>日; size <span class="number">555</span> bytes</span><br><span class="line">  SHA<span class="number">-256</span> checksum <span class="number">2</span>ade518b0d7194939efe9f3eefc0d055e21b70bab639130f050bc35282fa976b</span><br><span class="line">  Compiled from <span class="string">&quot;ByteCodeExample.java&quot;</span></span><br><span class="line">public class ByteCodeExample</span><br><span class="line">  minor version<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  major version<span class="punctuation">:</span> <span class="number">65</span></span><br><span class="line">  flags<span class="punctuation">:</span> (<span class="number">0x0021</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_SUPER</span><br><span class="line">  this_class<span class="punctuation">:</span> #<span class="number">8</span>                          <span class="comment">// ByteCodeExample</span></span><br><span class="line">  super_class<span class="punctuation">:</span> #<span class="number">2</span>                         <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 实现了0个接口</span></span><br><span class="line">  fields<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span>    <span class="comment">// 有3个字段 （成员变量）</span></span><br><span class="line">  methods<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span>  <span class="comment">// 有3个方法</span></span><br><span class="line">  attributes<span class="punctuation">:</span> <span class="number">1</span>  </span><br><span class="line">Constant pool<span class="punctuation">:</span></span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">2.</span>#<span class="number">3</span>          <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">4</span>             <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">3</span> = NameAndType        #<span class="number">5</span><span class="punctuation">:</span>#<span class="number">6</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">4</span> = Utf8               java/lang/Object</span><br><span class="line">   #<span class="number">5</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">6</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">8.</span>#<span class="number">9</span>          <span class="comment">// ByteCodeExample.add:(II)I</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">10</span>            <span class="comment">// ByteCodeExample</span></span><br><span class="line">   #<span class="number">9</span> = NameAndType        #<span class="number">11</span><span class="punctuation">:</span>#<span class="number">12</span>        <span class="comment">// add:(II)I</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               ByteCodeExample</span><br><span class="line">  #<span class="number">11</span> = Utf8               add</span><br><span class="line">  #<span class="number">12</span> = Utf8               (II)I</span><br><span class="line">  #<span class="number">13</span> = Fieldref           #<span class="number">14.</span>#<span class="number">15</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">14</span> = Class              #<span class="number">16</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">17</span><span class="punctuation">:</span>#<span class="number">18</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">17</span> = Utf8               out</span><br><span class="line">  #<span class="number">18</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">19</span> = Methodref          #<span class="number">20.</span>#<span class="number">21</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">  #<span class="number">20</span> = Class              #<span class="number">22</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">21</span> = NameAndType        #<span class="number">23</span><span class="punctuation">:</span>#<span class="number">24</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">22</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">23</span> = Utf8               println</span><br><span class="line">  #<span class="number">24</span> = Utf8               (I)V</span><br><span class="line">  #<span class="number">25</span> = Utf8               a</span><br><span class="line">  #<span class="number">26</span> = Utf8               I</span><br><span class="line">  #<span class="number">27</span> = Utf8               b</span><br><span class="line">  #<span class="number">28</span> = Utf8               MAX</span><br><span class="line">  #<span class="number">29</span> = Utf8               D</span><br><span class="line">  #<span class="number">30</span> = Utf8               ConstantValue</span><br><span class="line">  #<span class="number">31</span> = Double             <span class="number">12.0</span>d</span><br><span class="line">  #<span class="number">33</span> = Utf8               Code</span><br><span class="line">  #<span class="number">34</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">35</span> = Utf8               main</span><br><span class="line">  #<span class="number">36</span> = Utf8               (<span class="punctuation">[</span>Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">37</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">38</span> = Utf8               ByteCodeExample.java</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  int a;</span><br><span class="line">    descriptor<span class="punctuation">:</span> I</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0000</span>)</span><br><span class="line"></span><br><span class="line">  int b;</span><br><span class="line">    descriptor<span class="punctuation">:</span> I</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0000</span>)</span><br><span class="line"></span><br><span class="line">  public static final double MAX;</span><br><span class="line">    descriptor<span class="punctuation">:</span> D</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0019</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_STATIC<span class="punctuation">,</span> ACC_FINAL</span><br><span class="line">    ConstantValue<span class="punctuation">:</span> double <span class="number">12.0</span>d</span><br><span class="line"></span><br><span class="line">  public ByteCodeExample();</span><br><span class="line">    descriptor<span class="punctuation">:</span> ()V</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code<span class="punctuation">:</span></span><br><span class="line">      stack=<span class="number">1</span><span class="punctuation">,</span> locals=<span class="number">1</span><span class="punctuation">,</span> args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span><span class="punctuation">:</span> aload_0</span><br><span class="line">         <span class="number">1</span><span class="punctuation">:</span> invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span><span class="punctuation">:</span> return</span><br><span class="line">      LineNumberTable<span class="punctuation">:</span></span><br><span class="line">        line <span class="number">1</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  public static int add(int<span class="punctuation">,</span> int);</span><br><span class="line">    descriptor<span class="punctuation">:</span> (II)I</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0009</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_STATIC</span><br><span class="line">    Code<span class="punctuation">:</span></span><br><span class="line">      stack=<span class="number">2</span><span class="punctuation">,</span> locals=<span class="number">2</span><span class="punctuation">,</span> args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span><span class="punctuation">:</span> iload_0</span><br><span class="line">         <span class="number">1</span><span class="punctuation">:</span> iload_1</span><br><span class="line">         <span class="number">2</span><span class="punctuation">:</span> iadd</span><br><span class="line">         <span class="number">3</span><span class="punctuation">:</span> ireturn</span><br><span class="line">      LineNumberTable<span class="punctuation">:</span></span><br><span class="line">        line <span class="number">6</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String<span class="punctuation">[</span><span class="punctuation">]</span>);</span><br><span class="line">    descriptor<span class="punctuation">:</span> (<span class="punctuation">[</span>Ljava/lang/String;)V</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0009</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_STATIC</span><br><span class="line">    Code<span class="punctuation">:</span></span><br><span class="line">      stack=<span class="number">2</span><span class="punctuation">,</span> locals=<span class="number">2</span><span class="punctuation">,</span> args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span><span class="punctuation">:</span> iconst_2</span><br><span class="line">         <span class="number">1</span><span class="punctuation">:</span> iconst_3</span><br><span class="line">         <span class="number">2</span><span class="punctuation">:</span> invokestatic  #<span class="number">7</span>                  <span class="comment">// Method add:(II)I</span></span><br><span class="line">         <span class="number">5</span><span class="punctuation">:</span> istore_1</span><br><span class="line">         <span class="number">6</span><span class="punctuation">:</span> getstatic     #<span class="number">13</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">9</span><span class="punctuation">:</span> iload_1</span><br><span class="line">        <span class="number">10</span><span class="punctuation">:</span> invokevirtual #<span class="number">19</span>                 <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">13</span><span class="punctuation">:</span> return</span><br><span class="line">      LineNumberTable<span class="punctuation">:</span></span><br><span class="line">        line <span class="number">10</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span><span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line">        line <span class="number">12</span><span class="punctuation">:</span> <span class="number">13</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">SourceFile<span class="punctuation">:</span> <span class="string">&quot;ByteCodeExample.java&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="ClassLoading"><a href="#ClassLoading" class="headerlink" title="ClassLoading"></a>ClassLoading</h1><h2 id="One-main-to-one-JVM-process"><a href="#One-main-to-one-JVM-process" class="headerlink" title="One main to one JVM process"></a>One main to one JVM process</h2><p>当我们启动一个Java程序，即启动一个main方法时，都将启动一个Java虚拟机进程，不管这个进程有多么复杂。而不同的JVM进程之间是不会相互影响的。这也就是为什么说，Java程序只有一个入口——main方法，让虚拟机调用。而两个main方法，对应的是2个JVM进程，启动的是两个不同的类加载器，操作的实际上是不同的类。故而不会互相影响。</p>
<h2 id="ClassLoading-Workflow"><a href="#ClassLoading-Workflow" class="headerlink" title="ClassLoading Workflow"></a>ClassLoading Workflow</h2><p>当我们使用一个类，如果这个类还未加载到内存中，系统会通过加载、连接、初始化对类进行初始化。完成后可以使用Using和卸载Unloading。</p>
<h3 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载(Loading)"></a>加载(Loading)</h3><p><strong>目的</strong>：将类的字节码文件从持久存储加载到内存的方法区，并生成对应的 <strong>Class 对象</strong>。</p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li>通过类名查找 <code>.class</code> 文件，并将其二进制字节码读入内存</li>
<li>将字节码中的静态存储结构转换为方法区中的 <strong>运行时数据结构</strong>。</li>
<li>在堆内存中创建一个 <strong>java.lang.Class</strong> 对象，作为对方法区载入数据的访问入口。</li>
</ol>
<p>类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定（不过，我们也能打破由双亲委派模型）。</p>
<p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>
<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。默认的loadClass方法最后就是Link的</p>
<h3 id="连接-Linking"><a href="#连接-Linking" class="headerlink" title="连接(Linking)"></a>连接(Linking)</h3><p>类连接：指的是把类的二进制数据合并到 JRE 中，这又分为 3 个阶段：</p>
<h4 id="验证-Verification"><a href="#验证-Verification" class="headerlink" title="验证(Verification)"></a>验证(Verification)</h4><p><strong>目的</strong>：检查载入Class文件数据的正确性，确保字节码文件符合 JVM 要求，不会危害虚拟机安全。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/class-loading-process-verification.png" alt="验证阶段示意图"></p>
<p><strong>具体检查</strong>：</p>
<ol>
<li><strong>文件格式验证</strong>：是否符合 Class 文件格式规范。</li>
<li><strong>元数据验证</strong>：类继承、接口实现是否正确。</li>
<li><strong>字节码验证</strong>：指令流是否合法，如变量初始化和栈操作正确。</li>
<li><strong>符号引用验证</strong>：类、字段、方法等是否存在。</li>
</ol>
<p><strong>结果</strong>：不合法的字节码会抛出 <strong>VerifyError</strong>。</p>
<p>文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候（解析阶段会介绍符号引用和直接引用）。</p>
<p>符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常NoSuchFieldError NoSuchMethodError IllegalAccessError。</p>
<h4 id="准备-Preparation"><a href="#准备-Preparation" class="headerlink" title="准备(Preparation)"></a>准备(Preparation)</h4><p>给类的==静态变量==分配存储空间，并进行==默认初始化，赋零值==。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p>
<p><strong>目的</strong>：为类的静态变量分配内存，并设置默认值（不会执行静态初始化）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行阶段</strong>：</p>
<ul>
<li>分配内存，并将 <code>a</code> 的初始值设为 <code>0</code>（默认值）。</li>
<li>注意：这里不会执行 <code>= 10</code>，赋值在初始化阶段完成。</li>
</ul>
<p>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</p>
<h4 id="解析-Resolution"><a href="#解析-Resolution" class="headerlink" title="解析(Resolution)"></a>解析(Resolution)</h4><p><strong>目的</strong>：将类的二进制数据中 常量池的 <strong>符号引用</strong> 替换为 <strong>直接引用</strong>。</p>
<ul>
<li><strong>符号引用</strong>：类、方法、字段等以字符串形式存在于常量池中。<ul>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</li>
<li>符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。</li>
</ul>
</li>
<li><strong>直接引用</strong>：实际内存地址或偏移量。<ul>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。</li>
<li>在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</li>
</ul>
</li>
</ul>
<h3 id="初始化-Initialization"><a href="#初始化-Initialization" class="headerlink" title="初始化(Initialization)"></a>初始化(Initialization)</h3><p>对类的静态变量、静态初始化块进行初始化，因此不是必须的。<strong>这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong> </p>
<p>初始化阶段就是执行类构造器<code>&lt;clinit&gt; ()</code>方法的过程。<code>&lt;clinit&gt; ()</code>并不是程序员在Java代码中直接编写 的方法，它是Javac编译器的自动生成物</p>
<p>对于<code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。</p>
<p>由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的 语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能<strong>访问到定义在静态语句块之前的变量，</strong> 在前面的静态语句块可以赋值定义在其后的变量，但是不能访问它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">         System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>&lt;clinit&gt; ()</code>方法与类的构造函数（即在虚拟机视角中的实例构造器<code>&lt;init&gt; ()</code>方法）不同，它不需要显 式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt; ()</code>方法执行前，父类的<code>&lt;init&gt; ()</code>方法已经执行 完毕。因此在Java虚拟机中第一个被执行的()方法的类型肯定是java.lang.Object</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250104142317079.png" alt="clinit"></p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li>按照声明顺序依次执行静态变量赋值和静态代码块。</li>
<li>若父类未初始化，会先初始化父类。</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123; a = <span class="number">20</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong>：<code>a = 20</code>（因为静态代码块会覆盖前面的赋值）。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>初始化是类加载的最后阶段，只有在首次使用类时触发。</li>
<li>使用场景：实例化对象、调用静态方法、访问静态变量等。</li>
</ul>
<h4 id="初始化的触发条件-主动"><a href="#初始化的触发条件-主动" class="headerlink" title="初始化的触发条件(主动)"></a>初始化的触发条件(主动)</h4><p>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行 强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》 则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之 前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始 化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ol>
<li>创建该类的实例对象</li>
<li>访问static变量</li>
<li>调用static方法</li>
</ol>
</li>
<li>反射调用时如 <code>Class.forName(&quot;...&quot;)</code>, <code>newInstance()</code> 等<ul>
<li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类</li>
</ul>
</li>
<li>初始化子类会触发父类的初始化</li>
<li>有 <code>default</code> 方法的接口实现类初始化，接口也要初始化</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li>
</ol>
<p>被动访问不会触发初始化：</p>
<ol>
<li>访问类的 <strong>常量</strong>（<code>static final</code> 修饰）因为常量位于 运行时常量池<ul>
<li>在编译阶段通过常量传播优化，已经将常量的值“hello world”直接存储在NotInitialization类的常量池中，以后NotInitialization对常量 ConstClass.HELLOWORLD的引用，实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成 Class文件后就已不存在任何联系了。</li>
</ul>
</li>
<li>通过 <strong>数组定义类引用</strong>（如 <code>Test[] arr</code>）。<ul>
<li>运行之后发现没有输出“SuperClass init！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。但是这段代码里面触发了 另一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是 一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由 字节码指令newarray触发。</li>
</ul>
</li>
<li>对于静态字段， 只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发 父类的初始化而不会触发子类的初始化。</li>
</ol>
<p>（注意：一个final类型的静态属性，如果在编译时已经得到了属性值，那么调用该属性时，不会导致该类初始化，因为这个相当于使用常量；使用ClassLoader()方法，只是加载该类，并未初始化。）</p>
<h3 id="使用-Using"><a href="#使用-Using" class="headerlink" title="使用(Using)"></a>使用(Using)</h3><p>类加载完成后，可以使用类创建实例、调用方法或访问字段。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>使用过程中 JVM 可能会进行 <strong>动态绑定</strong>（如多态方法调用）和 <strong>反射机制</strong>。 </li>
</ul>
<h3 id="卸载-Unloading"><a href="#卸载-Unloading" class="headerlink" title="卸载(Unloading)"></a>卸载(Unloading)</h3><p><strong>目的</strong>：当某些类不再被使用时，将其从内存中移除。</p>
<p><strong>条件</strong>：</p>
<ul>
<li>该类的所有实例已被回收。</li>
<li>该类的 ClassLoader 实例已被回收。</li>
<li>JVM 中没有该类的任何引用。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>卸载阶段只针对用户的使用自定义类加载器加载的类，Bootstrap 引导加载器加载的类不会被卸载。</li>
<li>GC 会回收 <strong>Class 对象</strong> 和相关的元数据。</li>
</ul>
<p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>类加载器是一个负责加载类的对象。<code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象。</p>
<p>在 Java 中，一个类用其全限定类名（即包名+类名）作为标识。</p>
<p>而在 JVM 中，一个类用其全限定类名和其类加载器作为标识。</p>
<h3 id="dynamic-lazy-loading-only-once"><a href="#dynamic-lazy-loading-only-once" class="headerlink" title="dynamic lazy loading, only once"></a>dynamic lazy loading, only once</h3><p>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。加载时机并没有明确的要求。</p>
<p>对于已经加载的类会被放在 <code>ClassLoader</code> 中的 <code>classes</code> 字段，这是一个存放Class对象的容器。在类加载的时候，首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p>
<p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="comment">// 由这个类加载器加载的类。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 由VM调用，用此类加载器记录每个已加载类。</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">        classes.addElement(c);</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><strong>Bootstrap ClassLoader</strong>（引导类加载器）：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级。加载核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类）。<ul>
<li>**<code>rt.jar</code>**：rt 代表“RunTime”，<code>rt.jar</code>是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</li>
</ul>
</li>
<li><strong>Extension ClassLoader</strong>（扩展类加载器）：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。<ul>
<li>Java 9 引入了模块系统，并且略微更改了上述的类加载器。Extension ClassLoader被改名为平台类加载器（Platform Classloader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由 Bootstrap ClassLoader 加载之外，其他的模块均由 Platform Classloader 所加载。</li>
</ul>
</li>
<li><strong>Application ClassLoader</strong>（应用类加载器）：加载应用程序的 <code>classpath</code> 下的类。</li>
<li><strong>自定义类加载器</strong>：用户实现的特殊需求类加载器。</li>
</ul>
<p>除了 <code>BootstrapClassLoader</code> 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 <code>ClassLoader</code>抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p>
<h3 id="加载器调用顺序"><a href="#加载器调用顺序" class="headerlink" title="加载器调用顺序"></a>加载器调用顺序</h3><p>每个 <code>ClassLoader</code> 可以通过<code>getParent()</code>获取其父 <code>ClassLoader</code>，如果获取到 <code>ClassLoader</code> 为<code>null</code>的话，那么该类是通过 <code>BootstrapClassLoader</code> 加载的。</p>
<ul>
<li>我们编写的 Java 类 <code>PrintClassLoaderTree</code> 的 <code>ClassLoader</code> 是<code>AppClassLoader</code>；</li>
<li><code>AppClassLoader</code>的父 <code>ClassLoader</code> 是 <code>ExtClassLoader</code>；</li>
<li><code>ExtClassLoader</code>的父 <code>ClassLoader</code> 是 <code>Bootstrap ClassLoader</code> </li>
</ul>
<p>其中，<code>BootstrapClassLoader</code>负责加载JRE的核心类库，它不是<code>ClassLoader</code>的子类，使用C++编写，因此我们在Java中看不到它，通过其子类的<code>getParent()</code>方法获取时，将返回<code>null</code>。</p>
<p><code>ExtClassLoader</code>和<code>AppClassLoader</code>为<code>ClassLoader</code>的子类。在 API 中看不到它们，他们位于 rt.jar 文件中，因此由<code>BootstrapClassLoader</code>进行加载，全限定类名分别为：</p>
<ul>
<li><p><code>sun.misc.Launcher$AppClassLoader</code> </p>
<ul>
<li><code>jdk.internal.loader.ClassLoaders$AppClassLoader</code> </li>
</ul>
</li>
<li><p><code>sun.misc.Launcher$ExtClassLoader</code> </p>
<ul>
<li><code>jdk.internal.loader.ClassLoaders$PlatformClassLoader</code> </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.stopTalking.crazy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="comment">//获取当前线程的类装载器 </span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader(); </span><br><span class="line">        <span class="comment">//获取System类的类装载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> System.class.getClassLoader(); </span><br><span class="line">        <span class="comment">//获取本类TestClassLoader的类加载器loader2 </span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> TestClassLoader.class.getClassLoader(); </span><br><span class="line">        <span class="comment">//获取loader2的父加载器 </span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader3</span> <span class="operator">=</span> loader2.getParent(); </span><br><span class="line">        <span class="comment">//获取loader2的父加载器的父加载器 </span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader4</span> <span class="operator">=</span> loader3.getParent(); </span><br><span class="line">        System.out.println(loader); </span><br><span class="line">        System.out.println(loader1); </span><br><span class="line">        System.out.println(loader2); </span><br><span class="line">        System.out.println(loader3); </span><br><span class="line">        System.out.println(loader4); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前线程类获取的类加载器是AppClassLoader</span></span><br><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@4aa298b7</span><br><span class="line"><span class="comment">//System类为根装载器加载，java中访问不到，所以为null</span></span><br><span class="line"><span class="literal">null</span> </span><br><span class="line"><span class="comment">//本类的类加载器当然也是AppClassLoader    </span></span><br><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@4aa298b7</span><br><span class="line">jdk.internal.loader.ClassLoaders$PlatformClassLoader@5caf905d</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义-ClassLoader"><a href="#自定义-ClassLoader" class="headerlink" title="自定义 ClassLoader"></a>自定义 ClassLoader</h3><p>需要继承 <code>ClassLoader</code>抽象类。<code>ClassLoader</code> 类有两个关键方法：</p>
<ul>
<li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li>
<li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li>
</ul>
<blockquote>
<p>建议 <code>ClassLoader</code>的子类重写 <code>findClass(String name)</code>方法而不是<code>loadClass(String name, boolean resolve)</code> 方法。</p>
</blockquote>
<p>如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p>
<h2 id="Parents-Delegation-Model"><a href="#Parents-Delegation-Model" class="headerlink" title="Parents Delegation Model"></a>Parents Delegation Model</h2><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</p>
<p>父辈委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
<p><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</p>
<p>父辈委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/class-loader-parents-delegation-model-1735908352601-36.png" alt="类加载器层次关系图"></p>
<p>另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承，多用组合少用继承。</strong></p>
<h3 id="java-lang-ClassLoader-loadClass"><a href="#java-lang-ClassLoader-loadClass" class="headerlink" title="java.lang.ClassLoader.loadClass()"></a><code>java.lang.ClassLoader.loadClass()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过，自底向上</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">        		<span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行连接操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li>
<li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li>
<li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li>
<li>如果子类加载器也无法加载这个类，那么它会抛出一个 <code>ClassNotFoundException</code> 异常。</li>
</ul>
<p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 <code>Class</code> 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</p>
<p>双亲委派很好地解决了各个类 加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被 称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变 的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p>
<blockquote>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务， 它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型 了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程 序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启 动类加载器是绝不可能认识、加载这些代码的，那该怎么办？ 为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方 法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内 都没有设置过的话，那这个类加载器默认就是应用程序类加载器。 有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类 加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行 为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性 原则，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、 JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供 者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了 java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加 载提供了一种相对合理的解决方案。</p>
</blockquote>
<p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p>
<p>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</p>
<p>但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。重写 <code>loadClass()</code>方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。另外，仅仅自定义加载器也不能够满足全部的要求。</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/classloader.html#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%96%B9%E6%B3%95">打破双亲委派模型方法 | JavaGuide</a> </p>
<h2 id="Classpath"><a href="#Classpath" class="headerlink" title="Classpath"></a>Classpath</h2><p><strong>Classpath</strong> 是 Java 应用程序运行时用来查找 <strong>类文件（.class）</strong> 和 <strong>资源文件</strong> 的路径。它定义了 JVM 加载类和资源的搜索目录。<strong>Classpath</strong> 指定了 JVM 在加载类时搜索的目录或 JAR 包路径。</p>
<p><strong>Classpath</strong> 是 JVM 加载类和资源的搜索路径，通常包括：</p>
<ol>
<li>当前目录 (<code>.</code>)。</li>
<li>指定的文件夹（包含 <code>.class</code> 文件或 JAR 包）。</li>
<li>第三方库文件（如 <code>lib/*.jar</code>）。</li>
</ol>
<p>在开发和运行 Java 程序时，可以通过命令行、环境变量或 IDE 设置 Classpath，以确保依赖文件和类可以正确加载。</p>
<h3 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h3><ol>
<li><p><strong>命令行设置：</strong><br>使用 <code>-classpath</code> 或 <code>-cp</code> 参数指定路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .;lib/* com.example.Main</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>“.”</strong> 表示当前目录。</li>
<li><strong>“lib/*”</strong> 表示 <code>lib</code> 文件夹下的所有 JAR 文件。</li>
</ul>
</li>
<li><p><strong>环境变量设置：</strong><br>设置全局环境变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CLASSPATH=/usr/local/app/classes:/usr/local/app/lib/*</span><br></pre></td></tr></table></figure>

<p>或 Windows 下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set CLASSPATH=.;lib\*</span><br></pre></td></tr></table></figure></li>
<li><p><strong>IDE 设置：</strong><br>在 IDE（如 IntelliJ IDEA、Eclipse）中，classpath 默认包含 <strong>src/main/java</strong> 和 <strong>target/classes</strong>，以及项目引用的依赖项。</p>
</li>
</ol>
<h3 id="Classpath-路径内容"><a href="#Classpath-路径内容" class="headerlink" title="Classpath 路径内容"></a>Classpath 路径内容</h3><p>Classpath 支持以下类型的路径：</p>
<ol>
<li><p><strong>目录路径：</strong></p>
<ul>
<li><p>包含编译好的类文件，如：<code>/home/user/classes</code>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp /home/user/classes Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>JAR 文件路径：</strong></p>
<ul>
<li><p>支持直接引用 JAR 包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp lib/example.jar Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>通配符路径：</strong></p>
<ul>
<li><p>可使用 <code>*</code> 引用多个 JAR 包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp lib/* Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>相对路径或绝对路径：</strong></p>
<ul>
<li>相对路径：<code>./lib</code>（当前目录）。</li>
<li>绝对路径：<code>/usr/lib/java/</code>.</li>
</ul>
</li>
</ol>
<h3 id="默认-Classpath-设置"><a href="#默认-Classpath-设置" class="headerlink" title="默认 Classpath 设置"></a>默认 Classpath 设置</h3><ol>
<li><p>如果未显式设置 <code>-classpath</code> 或 <code>CLASSPATH</code> 环境变量，JVM 默认搜索 <strong>当前目录（.）</strong>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java</span><br><span class="line">java Test</span><br></pre></td></tr></table></figure>

<p>默认会从当前目录加载 <code>Test.class</code> 文件。</p>
</li>
</ol>
<h3 id="示例-1：单个类文件"><a href="#示例-1：单个类文件" class="headerlink" title="示例 1：单个类文件"></a>示例 1：单个类文件</h3><p>假设有以下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/project/</span><br><span class="line">  Main.java</span><br></pre></td></tr></table></figure>

<p>编译与运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br><span class="line">java Main</span><br></pre></td></tr></table></figure>

<h3 id="示例-2：JAR-包依赖"><a href="#示例-2：JAR-包依赖" class="headerlink" title="示例 2：JAR 包依赖"></a>示例 2：JAR 包依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/project/</span><br><span class="line">  lib/</span><br><span class="line">    gson.jar</span><br><span class="line">  Main.java</span><br></pre></td></tr></table></figure>

<p>编译与运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac -cp lib/gson.jar Main.java</span><br><span class="line">java -cp lib/gson.jar:. Main</span><br></pre></td></tr></table></figure>

<h3 id="示例-3：多个-JAR-包"><a href="#示例-3：多个-JAR-包" class="headerlink" title="示例 3：多个 JAR 包"></a>示例 3：多个 JAR 包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp &quot;lib/*&quot; com.example.Main</span><br></pre></td></tr></table></figure>

<h2 id="加载顺序demo"><a href="#加载顺序demo" class="headerlink" title="加载顺序demo"></a>加载顺序demo</h2><p>这其实是去年校招时我遇到的一道阿里巴巴的笔试题(承认有点久远了-。-)，嗯，如果我没记错的话，当时是作为java方向的一道选做大题。当然题意没有这么直白，题目只要求你写出程序运行后所有system.out.println的输出结果，其中程序是题目给的，而各个system.out.println的执行顺序不同会导致最后程序输出的结果也不同。</p>
<p>具体的题目我肯定记不清，不过我们可以换个直接的问法，如果类A和类B中有静态变量，静态语句块，非静态变量，非静态语句块，构造函数，静态方法，非静态方法，同时类A继承类B，请问当实例化A时，类内部的加载顺序是什么?</p>
<p>当时我也是一头雾水，事后我就自己写了一个小Demo，这才知道了类内部的实际加载顺，测试代码如下：</p>
<p>Class B:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//静态变量 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;  System.out.println(<span class="string">&quot;Class B1:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//非静态变量</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;  i++;  System.out.println(<span class="string">&quot;Class B2:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  j++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;constructor B: &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态语句块</span></span><br><span class="line">    &#123; </span><br><span class="line">        i++; j++; </span><br><span class="line">        System.out.println(<span class="string">&quot;Class B:common blocks&quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bDisplay</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class B:static void bDisplay(): &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bTest</span><span class="params">()</span>&#123; </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class B:static void bTest():  &quot;</span>+<span class="string">&quot;i=&quot;</span>+i);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class A:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//静态变量 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;  System.out.println(<span class="string">&quot;Class A1:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//非静态变量</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;  i++;  System.out.println(<span class="string">&quot;Class A2:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="built_in">super</span>();  i++;  j++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;constructor A: &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态语句块</span></span><br><span class="line">    &#123; </span><br><span class="line">        i++; j++; </span><br><span class="line">        System.out.println(<span class="string">&quot;Class A:common blocks&quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aDisplay</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class A:static void aDisplay(): &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">aTest</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class A:static void aTest():  &quot;</span>+<span class="string">&quot;i=&quot;</span>+i);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class ClassLoading :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoading</span> &#123;      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span> &#123;    </span><br><span class="line">        A a=<span class="keyword">new</span> <span class="title class_">A</span>();    </span><br><span class="line">        a.aDisplay();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1484270652220239.jpg" alt="Java中类的加载顺序剖析（常用于面试题）"></p>
<p>通过上述示图，我们可以比较清晰的看出java类的整个加载过程。</p>
<ol>
<li>若要加载类A，则先加载执行其父类B(Object)的静态变量以及静态语句块(执行先后顺序按排列的先后顺序)。</li>
<li>然后再加载执行类A的静态变量以及静态语句块。(并且1、2步骤只会执行1次)</li>
<li>若需实例化类A，则先调用其父类B的构造函数,并且在调用其父类B的构造函数前,依次先调用父类B中的非静态变量及非静态语句块.最后再调用父类B中的构造函数初始化。</li>
<li>然后再依次调用类A中的非静态变量及非静态语句块.最后调用A中的构造函数初始化。( 并且3、4步骤可以重复执行)</li>
<li>而对于静态方法和非静态方法都是被动调用,即系统不会自动调用执行,所以用户没有调用时都不执行,主要区别在于静态方法可以直接用类名直接调用(实例化对象也可以),而非静态方法只能先实例化对象后才能调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父类--静态变量</span><br><span class="line">父类--静态初始化块</span><br><span class="line">子类--静态变量</span><br><span class="line">子类--静态初始化块</span><br><span class="line">*************in main***************</span><br><span class="line">父类--变量</span><br><span class="line">父类--初始化块</span><br><span class="line">父类--构造器</span><br><span class="line">子类--变量</span><br><span class="line">子类--初始化块</span><br><span class="line">子类--构造器</span><br><span class="line">*************second subclass***************</span><br><span class="line">父类--变量</span><br><span class="line">父类--初始化块</span><br><span class="line">父类--构造器</span><br><span class="line">子类--变量</span><br><span class="line">子类--初始化块</span><br><span class="line">子类--构造器</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<p>很显然在加载main方法后，静态变量不管父类还是子类的都执行了，然后才是父类和子类的的普通变量和构造器。这是因为，当要创建子类这个对象时，发现这个类需要一个父类，所以把父类的.class加载进来，然后依次初始化其普通变量和初始化代码块，最后其构造器，然后可以开始子类的工作，把子类的.class加载进来，在做子类的工作。</p>
<p>另外在 Java 中子类中都会有默认的调用父类的默认构造函数即super() 如果父类声明了有参构造函数，那么如果没有显式声明无参构造，子类就会爆出语法错误，无法调用父类的无参构造。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/13/classfile/" data-id="cm8pkpl4j00024stvbiz64csz" data-title="ClassFile" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/" rel="tag">字节码</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-G1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/12/G1/" class="article-date">
  <time class="dt-published" datetime="2024-09-11T16:00:00.000Z" itemprop="datePublished">2024-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/12/G1/">G1 垃圾收集器介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>之前根据 Sun 的内存管理白皮书介绍了在 HotSpot JVM 分代算法中的几个垃圾收集器，本文将介绍 G1 垃圾收集器。</p>
<p>G1 的主要关注点在于达到<strong>可控的停顿时间</strong>，在这个基础上尽可能提高吞吐量，这一点非常重要。</p>
<p>G1 被设计用来长期取代 CMS 收集器，和 CMS 相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。区别在于，G1 没有 CMS 的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间。</p>
<p>如果你的应用使用了较大的堆（如 6GB 及以上）而且还要求有较低的垃圾收集停顿时间（如 0.5 秒），那么 G1 是你绝佳的选择，是时候放弃 CMS 了。</p>
<p><strong>阅读建议</strong>：本文力求用简单的话介绍清楚 G1 收集器，但是并不会重复介绍每一个细节，所以希望读者了解其他几个收集器的工作过程，尤其是 CMS 收集器。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3-1742964906329-3.png" alt="G1 收集器"></p>
<h2 id="G1-总览"><a href="#G1-总览" class="headerlink" title="G1 总览"></a>G1 总览</h2><p>首先是内存划分上，之前介绍的分代收集器将整个堆分为年轻代、老年代和永久代，每个代的空间是确定的。</p>
<p>而 G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3-1742964906329-3.png" alt="内存划分"></p>
<p>执行垃圾收集时，和 CMS 一样，G1 收集线程在标记阶段和应用程序线程<strong>并发</strong>执行，标记结束后，G1 也就知道哪些区块基本上是垃圾，存活对象极少，G1 会先从这些区块下手，因为从这些区块能很快释放得到很大的可用空间，<strong>这也是为什么 G1 被取名为 Garbage-First 的原因</strong>。</p>
<blockquote>
<p>这里只不过是先介绍些概念，没看懂没关系，往下看</p>
</blockquote>
<p>在 G1 中，目标停顿时间非常非常重要，用 -XX:MaxGCPauseMillis=200 指定期望的停顿时间。</p>
<p>G1 使用了<strong>停顿预测模型</strong>来满足用户指定的停顿时间目标，并基于目标来选择进行垃圾回收的区块数量。G1 采用增量回收的方式，每次回收一些区块，而不是整堆回收。</p>
<p>我们要知道 G1 不是一个实时收集器，它会尽力满足我们的停顿时间要求，但也不是绝对的，它基于之前垃圾收集的数据统计，估计出在用户指定的停顿时间内能收集多少个区块。</p>
<p><strong>注意：</strong>G1 有和应用程序一起运行的并发阶段，也有 stop-the-world 的并行阶段。但是，<strong>Full GC 的时候还是单线程运行的</strong>，所以我们应该尽量避免发生 Full GC，后面我们也会介绍什么时候会触发 Full GC。</p>
<p><strong>G1 内存占用</strong></p>
<p>G1 比 ParallelOld 和 CMS 会需要更多的内存消耗，那是因为有部分内存消耗于簿记（accounting）上，如以下两个数据结构：</p>
<ul>
<li><strong>Remembered Sets</strong>：每个区块都有一个 RSet，用于记录进入该区块的对象引用（如区块 A 中的对象引用了区块 B，区块 B 的 Rset 需要记录这个信息），它用于实现收集过程的并行化以及使得区块能进行独立收集。总体上 Remembered Sets 消耗的内存小于 5%。</li>
<li><strong>Collection Sets</strong>：将要被回收的区块集合。GC 时，在这些区块中的对象会被复制到其他区块中，总体上 Collection Sets 消耗的内存小于 1%。</li>
</ul>
<h2 id="G1-工作流程"><a href="#G1-工作流程" class="headerlink" title="G1 工作流程"></a>G1 工作流程</h2><p>前面啰里啰嗦说了挺多的，唯一要记住的就是，G1 的设计目标就是尽力满足我们的目标停顿时间上的要求。</p>
<p>本节介绍 G1 的收集过程，G1 收集器主要包括了以下 4 种操作：</p>
<ul>
<li>1、年轻代收集</li>
<li>2、并发收集，和应用线程同时执行</li>
<li>3、混合式垃圾收集</li>
<li>*、必要时的 Full GC</li>
</ul>
<p>接下来，我们进行一一介绍。</p>
<h3 id="年轻代收集"><a href="#年轻代收集" class="headerlink" title="年轻代收集"></a>年轻代收集</h3><p>首先，我们来看下 G1 的堆结构：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8ca16868.png" alt="G1 GC 内存布局"></p>
<p>年轻代中的垃圾收集流程（Young GC）：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2.png" alt="Young GC"></p>
<p>我们可以看到，年轻代收集概念上和之前介绍的其他分代收集器大差不差的，但是它的年轻代会动态调整。</p>
<h3 id="Old-GC-并发标记周期"><a href="#Old-GC-并发标记周期" class="headerlink" title="Old GC / 并发标记周期"></a>Old GC / 并发标记周期</h3><p>接下来是 Old GC 的流程（含 Young GC 阶段），其实把 Old GC  理解为<strong>并发周期</strong>是比较合理的，不要单纯地认为是清理老年代的区块，因为这一步和年轻代收集也是相关的。下面我们介绍主要流程：</p>
<ol>
<li><p>初始标记：stop-the-world，它伴随着一次普通的 Young GC 发生，然后对 Survivor 区（root region）进行标记，因为该区可能存在对老年代的引用。</p>
<blockquote>
<p>因为 Young GC 是需要 stop-the-world 的，所以并发周期直接重用这个阶段，虽然会增加 CPU 开销，但是停顿时间只是增加了一小部分。</p>
</blockquote>
</li>
<li><p>扫描根引用区：因为先进行了一次 YGC，所以当前年轻代只有 Survivor 区有存活对象，它被称为根引用区。扫描 Survivor 到老年代的引用，该阶段必须在下一次 Young GC 发生前结束。</p>
<blockquote>
<p>这个阶段不能发生年轻代收集，如果中途 Eden 区真的满了，也要等待这个阶段结束才能进行 Young GC。</p>
</blockquote>
</li>
<li><p>并发标记：寻找整个堆的存活对象，该阶段可以被 Young GC 中断。</p>
<blockquote>
<p>这个阶段是并发执行的，中间可以发生多次 Young GC，Young GC 会中断标记过程</p>
</blockquote>
</li>
<li><p>重新标记：stop-the-world，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法。</p>
<blockquote>
<p>Oracle 的资料显示，这个阶段会回收完全空闲的区块</p>
</blockquote>
</li>
<li><p>清理：清理阶段真正回收的内存很少。</p>
</li>
</ol>
<p>到这里，G1 的一个并发周期就算结束了，其实就是主要完成了垃圾定位的工作，定位出了哪些分区是垃圾最多的。因为整堆一般比较大，所以这个周期应该会比较长，中间可能会被多次 stop-the-world 的 Young GC 打断。</p>
<h3 id="混合垃圾回收周期"><a href="#混合垃圾回收周期" class="headerlink" title="混合垃圾回收周期"></a>混合垃圾回收周期</h3><p>并发周期结束后是混合垃圾回收周期，不仅进行年轻代垃圾收集，而且回收之前标记出来的老年代的垃圾最多的部分区块。</p>
<p>混合垃圾回收周期会持续进行，直到几乎所有的被标记出来的分区（垃圾占比大的分区）都得到回收，然后恢复到常规的年轻代垃圾收集，最终再次启动并发周期。</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>到这里我们已经说了年轻代收集、并发周期、混合回收周期了，大家要熟悉这几个阶段的工作。</p>
<p>下面我们来介绍特殊情况，那就是会导致 <strong>Full GC</strong> 的情况，也是我们需要极力避免的：</p>
<ol>
<li><p>concurrent mode failure：并发模式失败，CMS 收集器也有同样的概念。G1 并发标记期间，如果在标记结束前，老年代被填满，G1 会放弃标记。</p>
<blockquote>
<p>这个时候说明</p>
<ul>
<li>堆需要增加了，</li>
<li>或者需要调整并发周期，如增加并发标记的线程数量，让并发标记尽快结束</li>
<li>或者就是更早地进行并发周期，默认是整堆内存的 45% 被占用就开始进行并发周期。</li>
</ul>
</blockquote>
</li>
<li><p>晋升失败：并发周期结束后，是混合垃圾回收周期，伴随着年轻代垃圾收集，进行清理老年代空间，如果这个时候清理的速度小于消耗的速度，导致老年代不够用，那么会发生晋升失败。</p>
<blockquote>
<p>说明混合垃圾回收需要更迅速完成垃圾收集，也就是说在混合回收阶段，每次年轻代的收集应该处理更多的老年代已标记区块。</p>
</blockquote>
</li>
<li><p>疏散失败：年轻代垃圾收集的时候，如果 Survivor 和 Old 区没有足够的空间容纳所有的存活对象。这种情况肯定是非常致命的，因为基本上已经没有多少空间可以用了，这个时候会触发 Full GC 也是很合理的。</p>
<blockquote>
<p>最简单的就是增加堆大小</p>
</blockquote>
</li>
<li><p>大对象分配失败，我们应该尽可能地不创建大对象，尤其是大于一个区块大小的那种对象。</p>
</li>
</ol>
<h3 id="简单小结"><a href="#简单小结" class="headerlink" title="简单小结"></a>简单小结</h3><p>看完上面的 Young GC 和 Old GC 等，很多读者可能还是很懵的，这里说几句不严谨的白话文帮助读者进行理解：</p>
<p>首先，最好不要把上面的 Old GC 当做是一次 GC 来看，而应该当做<strong>并发标记周期</strong>来理解，虽然它确实会释放出一些内存。</p>
<p>并发标记结束后，G1 也就知道了哪些区块是最适合被回收的，那些完全空闲的区块会在这这个阶段被回收。如果这个阶段释放了足够的内存出来，其实也就可以认为结束了一次 GC。</p>
<p>我们假设并发标记结束了，那么下次 GC 的时候，还是会先回收年轻代，如果从年轻代中得到了足够的内存，那么结束；过了几次后，年轻代垃圾收集不能满足需要了，那么就需要利用之前并发标记的结果，选择一些活跃度最低的老年代区块进行回收。直到最后，老年代会进入下一个并发周期。</p>
<p>那么什么时候会启动并发标记周期呢？这个是通过参数控制的，下面马上要介绍这个参数了，此参数默认值是 45，也就是说当堆空间使用了 45% 后，G1 就会进入并发标记周期。</p>
<h2 id="G1-参数配置和最佳实践"><a href="#G1-参数配置和最佳实践" class="headerlink" title="G1 参数配置和最佳实践"></a>G1 参数配置和最佳实践</h2><p>G1 调优的目标是尽量避免出现 Full GC，其实就是给老年代足够的空间，或相对更多的空间。</p>
<p>有以下几点我们可以进行调整的方向：</p>
<ul>
<li>增加堆大小，或调整老年代和年轻代的比例，这个很好理解</li>
<li>增加并发周期的线程数量，其实就是为了加快并发周期快点结束</li>
<li>让并发周期尽早开始，这个是通过设置堆使用占比来调整的（默认 45%）</li>
<li>在混合垃圾回收周期中回收更多的老年代区块</li>
</ul>
<p>G1 的很重要的目标是达到可控的停顿时间，所以很多的行为都以这个目标为出发点开展的。</p>
<p>我们通过设置 -XX:MaxGCPauseMillis=N 来指定停顿时间（单位 ms，默认 200ms），如果没有达到这个目标，G1 会通过各种方式来补救：调整年轻代和老年代的比例，调整堆大小，调整晋升的年龄阈值，调整混合垃圾回收周期中处理的老年代的区块数量等等。</p>
<p>当然了，调整每个参数满足了一个条件的同时往往也会引入另一个问题，比如为了降低停顿时间，我们可以减小年轻代的大小，可是这样的话就会增加年轻代垃圾收集的频率。如果我们减少混合垃圾回收周期处理的老年代区块数量，虽然可以更容易满足停顿时间要求，可是这样就会增加 Full GC 的风险等等。</p>
<p>下面介绍最常用也是最基础的一些参数的设置，涉及到更高级的调优参数设置，请读者自行参阅其他资料。</p>
<p><strong>参数介绍</strong>：</p>
<ul>
<li><p><strong>-XX:+UseG1GC</strong></p>
<p>使用 G1 收集器</p>
</li>
<li><p><strong>-XX:MaxGCPauseMillis=200</strong></p>
<p>指定目标停顿时间，默认值 200 毫秒。</p>
<blockquote>
<p>在设置 -XX:MaxGCPauseMillis 值的时候，不要指定为平均时间，而应该指定为满足 90% 的停顿在这个时间之内。记住，停顿时间目标是我们的目标，不是每次都一定能满足的。</p>
</blockquote>
</li>
<li><p><strong>-XX:InitiatingHeapOccupancyPercent=45</strong></p>
<p>整堆使用达到这个比例后，触发并发 GC 周期，默认 45%。</p>
<blockquote>
<p>如果要降低晋升失败的话，通常可以调整这个数值，使得并发周期提前进行</p>
</blockquote>
</li>
<li><p><strong>-XX:NewRatio=n</strong></p>
<p>老年代/年轻代，默认值 2，即 1/3 的年轻代，2/3 的老年代</p>
<blockquote>
<p>不要设置年轻代为固定大小，否则：</p>
<ul>
<li>G1 不再需要满足我们的停顿时间目标</li>
<li>不能再按需扩容或缩容年轻代大小</li>
</ul>
</blockquote>
</li>
<li><p><strong>-XX:SurvivorRatio=n</strong></p>
<p>Eden/Survivor，默认值 8，这个和其他分代收集器是一样的</p>
</li>
<li><p><strong>-XX:MaxTenuringThreshold =n</strong></p>
<p>从年轻代晋升到老年代的年龄阈值，也是和其他分代收集器一样的</p>
</li>
<li><p><strong>-XX:ParallelGCThreads=n</strong></p>
<p>并行收集时候的垃圾收集线程数</p>
</li>
<li><p><strong>-XX:ConcGCThreads=n</strong></p>
<p>并发标记阶段的垃圾收集线程数</p>
<blockquote>
<p>增加这个值可以让并发标记更快完成，如果没有指定这个值，JVM 会通过以下公式计算得到：</p>
<p>ConcGCThreads=(ParallelGCThreads + 2) / 4^3</p>
</blockquote>
</li>
<li><p><strong>-XX:G1ReservePercent=n</strong></p>
<p>堆内存的预留空间百分比，默认 10，用于降低晋升失败的风险，即默认地会将 10% 的堆内存预留下来。</p>
</li>
<li><p><strong>-XX:G1HeapRegionSize=n</strong></p>
<p>每一个 region 的大小，默认值为根据堆大小计算出来，取值 1MB~32MB，这个我们通常指定整堆大小就好了。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我自己仔细检查了几遍，主要内容都囊括了，我也不知道读者看完本文会不会是一脸懵逼。</p>
<p>如果有什么问题，可以在留言板上给我留言，<strong>我是 GC 的门外汉</strong>，如果有些问题我觉得自己能解答，我会尽力帮助大家。</p>
<p>最后，在这里推荐一些资料给感兴趣的读者：</p>
<p>Oracle 官方出品，本文的很多内容是翻译并解读这篇文章的：</p>
<p><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">Getting Started with the G1 Garbage Collector</a></p>
<p>帮助大家理解 G1 的日志：</p>
<p><a target="_blank" rel="noopener" href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs">Understanding G1 GC Logs</a></p>
<p>这里介绍 GC 的内容非常好：</p>
<p><a target="_blank" rel="noopener" href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1">https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1</a></p>
<p>《Java 性能权威指南》：非常好的一本书，建议读者有时间可以看看这本书中关于 GC 的介绍。</p>
<p>（全文完）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/12/G1/" data-id="cm8pkpl4h00014stv61uu34gh" data-title="G1 垃圾收集器介绍" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/G1/" rel="tag">G1</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/11/JVM/" class="article-date">
  <time class="dt-published" datetime="2024-09-10T16:00:00.000Z" itemprop="datePublished">2024-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/11/JVM/">JVM 介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JVM-是虚拟机吗？"><a href="#JVM-是虚拟机吗？" class="headerlink" title="JVM 是虚拟机吗？"></a>JVM 是虚拟机吗？</h1><h2 id="JVM-是什么？"><a href="#JVM-是什么？" class="headerlink" title="JVM 是什么？"></a>JVM 是什么？</h2><p><strong>Java Virtual Machine (JVM)</strong> 是 Java 平台的核心组件，它是一个**==程序运行环境==**，专门用来执行 Java 字节码（Bytecode）</p>
<p><strong>主要功能：</strong></p>
<ol>
<li><strong>跨平台支持</strong>：JVM 实现了 Java 的 “Write Once, Run Anywhere” 特性，使 Java 程序能够在不同操作系统上运行。</li>
<li>字节码解释和编译：JVM 将 Java 编译器生成的字节码（平台无关）转换为平台相关的机器代码，并执行。</li>
<li>内存管理：提供垃圾回收机制 (Garbage Collection, GC)。</li>
<li>安全性：内置安全检查机制，确保 Java 程序在受控环境中运行，防止恶意代码执行。</li>
</ol>
<h2 id="Hypervisor-VMM-是什么"><a href="#Hypervisor-VMM-是什么" class="headerlink" title="Hypervisor/VMM 是什么?"></a>Hypervisor/VMM 是什么?</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-Hyperviseur.svg.png" alt="undefined"></p>
<p>Hypervisor 是一种一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也可叫做虚拟机监视器，即 VMM（ virtual machine monitor ）。</p>
<ul>
<li>当服务器启动并执行 Hypervisor 时，它会加载所有虚拟机客户端的操作系统同时会分配给每一台虚拟机适量的内存，CPU，网络和磁盘。它允许多个操作系统（称为<strong>Guest OS</strong>）在同一台物理机器（称为<strong>Host</strong>）上同时运行，每个操作系统被隔离在独立的虚拟机中。</li>
<li>Hypervisor 负责资源分配，如 CPU、内存和存储，协调着这些硬件资源的访问，而且在各个虚拟机之间施加防护，处理虚拟机之间的通信和安全隔离。</li>
</ul>
<h2 id="JVM-与-Hypervisor-VMM-的对比"><a href="#JVM-与-Hypervisor-VMM-的对比" class="headerlink" title="JVM 与 Hypervisor/VMM 的对比"></a>JVM 与 Hypervisor/VMM 的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>JVM</th>
<th>Hypervisor/VMM</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>运行 Java 程序的虚拟环境</td>
<td>管理和运行多个虚拟机，每个虚拟机可运行不同操作系统</td>
</tr>
<tr>
<td><strong>虚拟化层级</strong></td>
<td>应用程序级虚拟化（针对 Java 字节码）</td>
<td>操作系统级虚拟化（针对硬件资源）</td>
</tr>
<tr>
<td><strong>管理对象</strong></td>
<td><strong>Java 字节码执行环境</strong></td>
<td>虚拟机管理和<strong>硬件资源虚拟化</strong></td>
</tr>
<tr>
<td><strong>依赖性</strong></td>
<td>必须安装在操作系统上，依赖操作系统环境</td>
<td>Type 1 可以直接运行在硬件上，Type 2 依赖操作系统</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>程序之间隔离性较弱，依赖 JVM 的安全机制</td>
<td>每个虚拟机互相独立，硬件级别隔离</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>Oracle HotSpot VM、OpenJDK JVM</td>
<td>VMware ESXi、VirtualBox、KVM、Hyper-V</td>
</tr>
</tbody></table>
<ol>
<li>在 VMware ESXi 上创建一个虚拟机；</li>
<li>在虚拟机内部运行一个 Guest OS，比如 Linux；</li>
<li>在 Linux 中安装 Java 环境并运行 JVM。</li>
</ol>
<h1 id="Java-Memory-Model-J-U-C"><a href="#Java-Memory-Model-J-U-C" class="headerlink" title="Java Memory Model(J.U.C)"></a><a href="../JavaSE/JUC/J%E2%80%A4U%E2%80%A4C.md">Java Memory Model(J.U.C)</a></h1><h1 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h1><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom: 80%;" />

<p>1.7之前， MetaSpace 在运行时内存区域，也是独立于堆、线程私有内存的一片线程共享内存</p>
<p>线程私有：<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>程序计数器 PC</strong></p>
<p>线程共享：堆、Metaspace、直接内存</p>
<p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p>
<h2 id="运行时数据区域-Runtime"><a href="#运行时数据区域-Runtime" class="headerlink" title="运行时数据区域(Runtime)"></a>运行时数据区域(Runtime)</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250103144549650.png" alt="image-20250103144549650"></p>
<h3 id="线程私有-Local"><a href="#线程私有-Local" class="headerlink" title="线程私有(Local)"></a>线程私有(Local)</h3><h4 id="程序计数器-Program-Counter"><a href="#程序计数器-Program-Counter" class="headerlink" title="==程序计数器==(Program Counter)"></a>==程序计数器==(Program Counter)</h4><ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。    </li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，当线程被切换回来时能够知道该线程上次运行的位置。</li>
<li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地 址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。</li>
<li>唯一不会出现 <code>OutOufMemoryError</code> 的内存区域，与线程的生命周期相同</li>
</ul>
<h4 id="虚拟机栈-VM-Stack"><a href="#虚拟机栈-VM-Stack" class="headerlink" title="==虚拟机栈==(VM Stack)"></a>==虚拟机栈==(VM Stack)</h4><ul>
<li>per thread：与线程的生命周期相同</li>
<li>所有的 Java 方法调用都是通过虚拟机栈来实现的，就是事实上的 Java 方法栈</li>
<li><strong>LIFO</strong>：只支持出栈和入栈两种操作</li>
</ul>
<h5 id="栈帧-Stack-Frame"><a href="#栈帧-Stack-Frame" class="headerlink" title="栈帧(Stack Frame)"></a>栈帧(Stack Frame)</h5><ul>
<li><p>每一次方法调用都会有一个对应的栈帧被压入VM Stack，调用结束时弹出一个栈帧。</p>
</li>
<li><p>每个<strong>栈帧</strong>中都拥有：局部变量表、操作数栈、动态链接、方法返回地址</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/stack-area.png" alt="Java 虚拟机栈" style="zoom:67%;" /></li>
</ul>
<p><strong>==局部变量表==<strong>：局部变量表存放了编译期可知的各种Java虚拟机</strong>基本数据类型</strong>（boolean、byte、char、short、int、 float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和<strong>returnAddress 类型</strong>（指向了一条字节码指令的地址）。</p>
<p>其存储空间以局部变量槽（Slot）来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。这里说的“大小”是指变量槽的数量， 虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</p>
<p><strong>==操作数栈==<strong>：主要作为</strong>方法调用的中转站</strong>使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的<strong>临时变量</strong>也会放在操作数栈中。方法执行过程中通过出栈、入栈完成计算操作。</p>
<p><strong>==动态链接==<strong>：主要用于</strong>一个方法需要调用其他方法</strong>的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为实际内存地址。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态链接</strong>。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/jvmimage-20220331175738692-1735821102490-10.png" alt="img"></p>
<h5 id="StackOverFlow-OutOfMemory-Error"><a href="#StackOverFlow-OutOfMemory-Error" class="headerlink" title="StackOverFlow/OutOfMemory Error"></a>StackOverFlow/OutOfMemory <strong>Error</strong></h5><p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong> </p>
<p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E7%9A%84%E7%AC%AC2%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="img"></p>
<p>**==方法返回地址==**：</p>
<ul>
<li><strong>记录调用点的字节码指令地址</strong>，以便方法执行完毕后能返回到正确的位置继续执行程序。<ol>
<li>JVM 创建一个栈帧并保存调用点的字节码指令地址（<code>result = add(2, 3)</code>）。</li>
<li>计算 <code>a + b</code> 的结果，并将值返回给调用点。</li>
<li>执行结束后，当前栈帧弹出，并根据<strong>返回地址</strong>继续执行 <code>System.out.println(result)</code></li>
</ol>
</li>
<li>保证方法调用的<strong>有序性</strong>和<strong>完整性</strong>，支持嵌套调用和递归处理。</li>
</ul>
<h4 id="本地方法栈-Native-Stack"><a href="#本地方法栈-Native-Stack" class="headerlink" title="==本地方法栈==(Native Stack)"></a>==本地方法栈==(Native Stack)</h4><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<h3 id="线程共享-Global"><a href="#线程共享-Global" class="headerlink" title="线程共享(Global)"></a>线程共享(Global)</h3><h4 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="==堆==(Heap)"></a>==堆==(Heap)</h4><p>Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，==几乎==所有的==对象实例==以及==数组==都在这里分配内存。 <a href="#threadlocal">现在还可以在线程栈上分配</a></p>
<p>堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>
<h5 id="堆分代-HotSpot-VM"><a href="#堆分代-HotSpot-VM" class="headerlink" title="堆分代(HotSpot VM)"></a>堆分代(HotSpot VM)</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/hotspot-heap-structure.png" alt="堆内存结构"></p>
<p> <strong>Eden</strong> 区、两个 <strong>Survivor</strong> 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。<strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用本地内存。</strong> </p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。不过，设置的值应该在 0-15，否则会爆出以下错误：MaxTenuringThreshold of 20 is invalid; must be between 0 and 15</p>
<h6 id="为什么年龄只能是-0-15"><a href="#为什么年龄只能是-0-15" class="headerlink" title="为什么年龄只能是 0-15?"></a>为什么年龄只能是 0-15?</h6><p>因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。</p>
<h6 id="堆内存一定分代管理吗"><a href="#堆内存一定分代管理吗" class="headerlink" title="堆内存一定分代管理吗?"></a>堆内存一定分代管理吗?</h6><p>在十年之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部 都基于“经典分代” 来设计，需要新生代、老年代收集器搭配才能工作。但是随着GC技术的发展，HotSpot里面也出现了不采用分代设计的新GC。</p>
<p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将 Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p>
<h5 id="字符串常量池-String-Constant-Pool"><a href="#字符串常量池-String-Constant-Pool" class="headerlink" title="==字符串常量池==(String Constant Pool)"></a>==字符串常量池==(String Constant Pool)</h5><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在字符串常量池中创建字符串对象 ”ab“</span><br><span class="line">// 将字符串对象 ”ab“ 的引用赋值给给 aa</span><br><span class="line">String aa = &quot;ab&quot;;</span><br><span class="line">// 直接返回字符串常量池中字符串对象 ”ab“，赋值给引用 bb</span><br><span class="line">String bb = &quot;ab&quot;;</span><br><span class="line">System.out.println(aa==bb); // true</span><br></pre></td></tr></table></figure>

<p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p>
<p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 <strong>字符串常量池</strong>和<strong>静态变量</strong>从<strong>永久代</strong>移动到了 Java <strong>堆</strong>中。主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
<blockquote>
<p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p>
</blockquote>
<h2 id="本地内存-Native-Memory-也是线程共享"><a href="#本地内存-Native-Memory-也是线程共享" class="headerlink" title="本地内存(Native Memory, 也是线程共享)"></a>本地内存(Native Memory, 也是线程共享)</h2><h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="==方法区==(Method Area)"></a>==方法区==(Method Area)</h3><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，方法区到底要如何实现那就是虚拟机自己要考虑的事情了。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。</p>
<p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>
<h4 id="永久代-PermGen-和-元空间-Metaspace"><a href="#永久代-PermGen-和-元空间-Metaspace" class="headerlink" title="永久代(PermGen) 和 元空间(Metaspace)"></a>永久代(PermGen) 和 元空间(Metaspace)</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250103142749020.png" alt="image-20250103142749020"></p>
<p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是<strong>永久代</strong>和<strong>元空间</strong>，接口可以看作是<strong>方法区</strong>，也就是说<strong>永久代</strong>以及<strong>元空间</strong>是 <strong>HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式</strong>。并且，<strong>永久代</strong>（Permanent Gen）是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了<strong>元空间</strong>（Metaspace）。</p>
<ul>
<li>整个<strong>永久代</strong>（PermGen）有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而<strong>元空间</strong>（Metaspace）使用的是本地内存，受<strong>本机可用内存</strong>的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li>
<li><strong>元空间</strong>（Metaspace）里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</li>
<li>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
</ul>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">/* 设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line"><span class="comment">				        如果未指定，根据运行时需求动态调整 */</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小 默认unlimited</span></span><br></pre></td></tr></table></figure>

<h4 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池(Runtime Constant Pool)"></a>运行时常量池(Runtime Constant Pool)</h4><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p>
<p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的 intern()方法。</p>
<p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/symbol-reference-and-direct-reference.png" alt="符号引用和直接引用"></p>
<p>常量池表会在类加载后存放到方法区的<strong>运行时常量池</strong>中。</p>
<p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p>
<h4 id="GC"><a href="#GC" class="headerlink" title="GC?"></a>GC?</h4><blockquote>
<p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选 择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤 其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
</blockquote>
<h3 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="==直接内存==(Direct Memory)"></a>==直接内存==(Direct Memory)</h3><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。它并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p>
<p>JDK 1.4 中新加入的 <strong>NIO（Non-Blocking I/O，也被称为 New I/O）</strong>，引入了一种基于<strong>通道（Channel）</strong>与<strong>缓存区（Buffer）</strong>的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到 本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError。</p>
<h2 id="HotSpot-VM-对象"><a href="#HotSpot-VM-对象" class="headerlink" title="HotSpot VM 对象"></a>HotSpot VM 对象</h2><h3 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h3><h4 id="类加载检查-metadata-check"><a href="#类加载检查-metadata-check" class="headerlink" title="类加载检查 metadata check"></a>类加载检查 metadata check</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，必须先执行类加载过程，确保 class metadata 已经加载到内存中，并在方法区中创建类的相关信息（如字段、方法、常量池等）。</p>
<h4 id="分配内存-memory-allocation"><a href="#分配内存-memory-allocation" class="headerlink" title="分配内存 memory allocation"></a>分配内存 memory allocation</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<h5 id="内存分配的两种方式"><a href="#内存分配的两种方式" class="headerlink" title="内存分配的两种方式"></a>内存分配的两种方式</h5><ul>
<li><strong>指针碰撞</strong>(Bump the Pointer): <ul>
<li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew, G1, ZGC</li>
</ul>
</li>
<li><strong>空闲列表</strong>(Free List): <ul>
<li>适用场合：堆内存不规整的情况下。</li>
<li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块来划分给对象实例，最后更新列表记录。类似操作系统分配内存</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 算法是”清除”，还是”压缩”，复制算法的内存也是规整的（Serial, Parallel, PCompact 对于年轻代的收集）。</p>
<h5 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a>内存分配并发问题</h5><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机可以采用以下方式来保证堆内存分配的线程安全：</p>
<ul>
<li><strong>CAS + 失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS + 失败重试的方式保证更新操作的原子性。</strong> </li>
<li><strong>TLAB (Thread Local Allocation Buffer)：</strong> 为每一个线程预先在堆的 Eden 区分配一小块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</li>
</ul>
<h5 id="逃逸分析优化"><a href="#逃逸分析优化" class="headerlink" title="逃逸分析优化"></a><span id="threadlocal">逃逸分析优化</span></h5><p><strong>逃逸分析优化</strong>：将不逃逸的对象直接分配到栈或使用标量替换，避免堆内存分配。</p>
<p>随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果<strong>某些方法中的对象引用没有被返回或者未被外面使用</strong>（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>
<h4 id="初始化零值-set-to-zero"><a href="#初始化零值-set-to-zero" class="headerlink" title="初始化零值 set to zero"></a>初始化零值 set to zero</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。（例如，整型为0，浮点型为0.0，引用类型为null等）</p>
<h4 id="设置对象头-set-object-header"><a href="#设置对象头-set-object-header" class="headerlink" title="设置对象头 set object header"></a>设置对象头 set object header</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<ul>
<li><strong>Mark Word</strong>: 存储对象的 hashcode, GC 年龄, 锁状态标志等</li>
<li><strong>Klass Pointer</strong>: 指向方法区中的 class metadata，确定对象的类型。</li>
<li>对于数组来说，还有数组的长度信息。</li>
</ul>
<h4 id="执行-init-方法-execute-lt-init-gt"><a href="#执行-init-方法-execute-lt-init-gt" class="headerlink" title="执行 init 方法 execute &lt;init&gt;"></a>执行 init 方法 execute &lt;init&gt;</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><h4 id="64-位-JVM-下的对象内存布局"><a href="#64-位-JVM-下的对象内存布局" class="headerlink" title="64 位 JVM 下的对象内存布局"></a>64 位 JVM 下的对象内存布局</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/57e6e147dbe447d0b96b4d310f01846atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<table>
<thead>
<tr>
<th>部分</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Mark Word</strong></td>
<td>8 字节</td>
<td>存储对象状态信息，如哈希码、锁信息和 GC 标记。</td>
</tr>
<tr>
<td><strong>Klass Pointer</strong></td>
<td>8 字节</td>
<td>指向对象所属类的类型元数据，便于方法调度和类型检查。</td>
</tr>
<tr>
<td><strong>数组长度（可选）</strong></td>
<td>4 字节 (可选)</td>
<td>如果是数组对象，会额外包含存储数组长度的字段。</td>
</tr>
<tr>
<td><strong>实例数据</strong></td>
<td>动态分配</td>
<td>存储实例变量的值，按照字段声明顺序对齐存储（按 4 字节或 8 字节对齐）。</td>
</tr>
<tr>
<td><strong>对齐填充</strong></td>
<td>动态填充</td>
<td>保证对象大小是 8 字节的倍数，以便提高内存访问效率。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">20.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 64 位 JVM 上，内存布局如下：</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>对象头 - Mark Word</strong></td>
<td>8 字节</td>
<td>哈希码、锁信息、GC 状态等。</td>
</tr>
<tr>
<td><strong>对象头 - Klass Pointer</strong></td>
<td>8 字节</td>
<td>指向类元数据的指针。</td>
</tr>
<tr>
<td><strong>实例数据</strong></td>
<td>12 字节</td>
<td>包括 <code>a</code> (4 字节)、<code>flag</code> (1 字节)、填充 (3 字节) 和 <code>value</code> (8 字节)。</td>
</tr>
<tr>
<td><strong>对齐填充</strong></td>
<td>4 字节</td>
<td>保证对象大小为 8 字节的倍数。</td>
</tr>
</tbody></table>
<p>总大小：<strong>32 字节</strong>（对齐填充确保 8 字节对齐）。</p>
<p>Java 对象头主要由 <strong>Mark Word</strong> 和 <strong>Klass Pointer</strong> 组成，存储对象状态信息和类型元数据指针。</p>
<ul>
<li>支持 JVM 的垃圾回收、同步机制（锁）、偏向锁及哈希计算等操作。</li>
<li>数组对象还包含额外的长度字段以支持动态数组存储。</li>
<li>由于对象头是二进制存储格式，不是直接可读的文本信息，需要工具或命令解析其内容，如 <code>jol</code> 或 <code>javap -v</code>。</li>
</ul>
<h4 id="对象头-Object-Header"><a href="#对象头-Object-Header" class="headerlink" title="对象头(Object Header)"></a>对象头(Object Header)</h4><p>Java 对象头（Object Header）是 <strong>Java 对象在内存中的元数据信息</strong>，主要用于支持 JVM 的对象管理和操作</p>
<h5 id="Mark-Word-的详细解析"><a href="#Mark-Word-的详细解析" class="headerlink" title="Mark Word 的详细解析"></a>Mark Word 的详细解析</h5><p>用于存储对象的运行时状态信息，包括：</p>
<ul>
<li><strong>锁状态标记</strong>（轻量级锁、重量级锁等）</li>
<li><strong>哈希码</strong>（HashCode）</li>
<li><strong>GC 标记</strong>（垃圾回收标记位）</li>
<li><strong>年龄计数器</strong>（GC 年龄，用于晋升到老年代的判断）</li>
</ul>
<p>Mark Word 的具体结构会根据对象状态发生变化：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>标记位</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong>未锁定（默认状态）</strong></td>
<td>01</td>
<td>对象哈希码、GC 年龄等信息。</td>
</tr>
<tr>
<td><strong>轻量级锁定</strong></td>
<td>00</td>
<td>指向栈中锁记录的指针（Lock Record）。</td>
</tr>
<tr>
<td><strong>重量级锁定</strong></td>
<td>10</td>
<td>指向重量级锁的指针（Monitor 对象）。</td>
</tr>
<tr>
<td><strong>GC 标记</strong></td>
<td>11</td>
<td>标记 GC 状态。</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>01</td>
<td>偏向线程 ID、时间戳等信息（启用偏向锁时）。</td>
</tr>
</tbody></table>
<p>示例 1：Mark Word 示例（未锁定状态）</p>
<p>假设一个对象未加锁且未偏向：</p>
<table>
<thead>
<tr>
<th>偏向锁</th>
<th>锁状态</th>
<th>GC 年龄</th>
<th>对象哈希码 (HashCode)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>01</td>
<td>000000</td>
<td>00101011100011000111100011000101</td>
</tr>
</tbody></table>
<ul>
<li>偏向锁：0 表示未偏向线程。</li>
<li>锁状态：01 表示未加锁状态。</li>
<li>GC 年龄：000000 表示对象的 GC 年龄为 0。</li>
<li>哈希码：对象哈希值经过位移和组合后存储在 Mark Word 中。</li>
</ul>
<p>示例 2：轻量级锁</p>
<p>对象进入轻量级锁定状态：</p>
<table>
<thead>
<tr>
<th>偏向锁</th>
<th>锁状态</th>
<th>指针内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>00</td>
<td>指向线程栈中 Lock Record（锁记录）的指针地址。</td>
</tr>
</tbody></table>
<h5 id="Klass-Pointer（类型指针）"><a href="#Klass-Pointer（类型指针）" class="headerlink" title="Klass Pointer（类型指针）"></a>Klass Pointer（类型指针）</h5><p>指向对象的<strong>类元数据</strong>（Class Metadata），用于标识该对象的具体类型及方法表等信息。</p>
<p>Klass Pointer 是一个指向方法区中 <strong>类元数据</strong> 的指针，包含以下信息：</p>
<ul>
<li>对象所属类的名称和继承关系。</li>
<li>类字段和方法表指针（用于动态方法分派）。</li>
<li>类的内存布局及实例大小信息。</li>
</ul>
<p><strong>作用：</strong>帮助 JVM 在运行时支持<strong>多态</strong>和<strong>类型检查</strong>。</p>
<h5 id="数组对象的额外信息"><a href="#数组对象的额外信息" class="headerlink" title="数组对象的额外信息"></a>数组对象的额外信息</h5><p>如果对象是数组类型，则会额外存储<strong>数组长度信息</strong>。</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数组长度字段</strong></td>
<td>4 字节</td>
<td>存储数组元素的个数。</td>
</tr>
<tr>
<td><strong>元素数据</strong></td>
<td>动态大小</td>
<td>实际存储数组元素的连续内存空间。</td>
</tr>
</tbody></table>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p>
<h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p>
<p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄池地址，在对象被移动或者GC时只会改变句柄池中的实例数据指针，而 reference 本身不需要修改。缺点是多一次指针解析，性能略低。</p>
<h4 id="直接指针-HotSpot-VM"><a href="#直接指针-HotSpot-VM" class="headerlink" title="直接指针(HotSpot VM)"></a>直接指针(HotSpot VM)</h4><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p>
<p>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销，更适合现代高性能 JVM 和 GC，如 G1 和 ZGC，这些 GC 使用并发机制降低对象移动成本，同时提高访问速度。</p>
<h3 id="JOL-分析对象内存布局"><a href="#JOL-分析对象内存布局" class="headerlink" title="JOL 分析对象内存布局"></a>JOL 分析对象内存布局</h3><p>Java Object Layout</p>
<ul>
<li><p><strong>JOL 的核心功能</strong></p>
<ol>
<li><strong>对象内存布局分析</strong><br>检查 Java 对象的结构，包括对象头信息、实例数据以及填充字节（padding）。</li>
<li><strong>对象大小计算</strong><br>精确测量对象占用的内存空间，有助于优化内存使用。</li>
<li><strong>对象对齐规则分析</strong><br>研究 Java 虚拟机的内存对齐方式和效率。</li>
<li><strong>偏向锁与轻量级锁的状态分析</strong><br>观察锁状态以及对象头的变化，帮助理解 Java 并发机制的底层实现。</li>
</ol>
</li>
<li><p>JOL 是基于 JVM 实现的，具体表现可能因 JVM 版本和平台而异。</p>
</li>
<li><p>使用 JOL 分析锁状态时，需要结合 <code>-XX:+UseBiasedLocking</code> 等 JVM 参数。</p>
</li>
<li><p>JOL 不支持所有类型的对象分析，例如直接内存分配的对象需要其他工具辅助。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLExample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">boolean</span> b;</span><br><span class="line">        <span class="type">long</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印对象内存布局</span></span><br><span class="line">        <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(example).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">org.example.JOLExample<span class="variable">$Example</span> <span class="keyword">object</span> internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                     VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">8</span>        (<span class="keyword">object</span> header)                 <span class="number">0x0000000000000000</span></span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>    <span class="keyword">int</span> JOLExample<span class="variable">$Example</span>.a            <span class="number">0</span></span><br><span class="line">     <span class="number">12</span>     <span class="number">1</span> <span class="keyword">boolean</span> JOLExample<span class="variable">$Example</span>.b           <span class="literal">false</span></span><br><span class="line">     <span class="number">13</span>     <span class="number">3</span>        (alignment/padding gap)</span><br><span class="line">     <span class="number">16</span>     <span class="number">8</span>   long JOLExample<span class="variable">$Example</span>.c            <span class="number">0</span></span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">3</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">3</span> bytes total</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OFFSET：字段或数据在对象中的偏移量（单位字节）。</span></span><br><span class="line"><span class="comment"> * SIZE：字段占用的字节数。</span></span><br><span class="line"><span class="comment"> * TYPE/DESCRIPTION：字段类型和名称。</span></span><br><span class="line"><span class="comment"> * VALUE：字段的当前值。</span></span><br><span class="line"><span class="comment"> * alignment/padding：由于内存对齐，填充的字节数，保证效率。</span></span><br><span class="line"><span class="comment"> * Instance size：对象的总大小（包括填充字节）。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="JVM-调参"><a href="#JVM-调参" class="headerlink" title="JVM 调参"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html">JVM 调参</a></h1><h2 id="JDK-分析工具"><a href="#JDK-分析工具" class="headerlink" title="JDK 分析工具"></a>JDK 分析工具</h2><p>除了之前提到的 JOL 是运行在 JVM 上的分析工具，还有很多命令行和可视化工具，主要用于监控、性能分析、内存管理和线程死锁与阻塞分析。</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>主要用途</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JConsole</strong></td>
<td>实时监控 JVM 性能</td>
<td>本地或远程简单监控应用性能</td>
</tr>
<tr>
<td><strong>VisualVM</strong></td>
<td>高级性能分析和内存快照分析</td>
<td>找出性能瓶颈和内存泄漏问题</td>
</tr>
<tr>
<td><strong>jstat</strong></td>
<td>JVM 性能统计和 GC 监控</td>
<td>快速诊断内存和垃圾回收问题</td>
</tr>
<tr>
<td><strong>jmap</strong></td>
<td>查看堆信息，生成堆快照</td>
<td>内存分析和排查内存泄漏</td>
</tr>
<tr>
<td><strong>jhat</strong></td>
<td>分析堆快照，与jmap配合</td>
<td>离线分析堆对象引用关系</td>
</tr>
<tr>
<td><strong>jstack</strong></td>
<td>查看线程堆栈信息</td>
<td>排查线程死锁和阻塞问题</td>
</tr>
<tr>
<td><strong>jinfo</strong></td>
<td>查看和调整 JVM 参数</td>
<td>动态调整配置，调试运行时环境</td>
</tr>
<tr>
<td><strong>JMC/JFR</strong></td>
<td>高级分析工具，支持低开销记录</td>
<td>深入分析生产环境性能问题（低性能影响）</td>
</tr>
</tbody></table>
<p>除了 <strong>JOL (Java Object Layout)</strong> 之外，还有以下几款同类型的 Java 内存分析和对象布局工具，可以用于分析 Java 对象结构、内存占用及内存管理相关问题：</p>
<p>JDK </p>
<table>
<thead>
<tr>
<th>工具</th>
<th>类型</th>
<th>主要用途</th>
<th>是否免费</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JOL</strong></td>
<td>对象布局分析</td>
<td>内存对齐、对象头、填充字节分析</td>
<td>是</td>
</tr>
<tr>
<td><strong>Arthas</strong></td>
<td>在线诊断工具</td>
<td>实时分析线程、内存、锁状态，适合生产环境</td>
<td>是</td>
</tr>
<tr>
<td><strong>MAT</strong></td>
<td>堆内存分析</td>
<td>内存泄漏、引用链分析</td>
<td>是</td>
</tr>
<tr>
<td><strong>javap</strong></td>
<td>字节码分析工具</td>
<td>查看编译后的字节码结构，研究 JVM 执行过程</td>
<td>是</td>
</tr>
</tbody></table>
<h1 id="GC-的对象"><a href="#GC-的对象" class="headerlink" title="GC 的对象"></a>GC 的对象</h1><p><strong>失去引用</strong>是指一个对象在程序中不再被任何变量或其他对象引用，从而变成<strong>不可达对象</strong>。这些对象无法通过代码访问，因此被认为是<strong>垃圾</strong>，可以由<strong>垃圾回收器（GC）</strong>回收并释放内存。对象失去引用意味着程序无法再访问它，它将成为垃圾回收的候选对象。当程序对对象的引用断开或超出作用域后，JVM 会在合适的时机将其回收以优化内存使用。</p>
<p><strong>引用的定义</strong>：引用是指程序中的变量指向堆内存中的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里变量 <code>str</code> 引用了字符串对象 <code>&quot;Hello&quot;</code>。</p>
<h2 id="失去引用的几种情况"><a href="#失去引用的几种情况" class="headerlink" title="失去引用的几种情况"></a>失去引用的几种情况</h2><ol>
<li><p><strong>变量重新赋值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">str = <span class="literal">null</span>; <span class="comment">// 原来的 &quot;Hello&quot; 对象失去了引用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">str1 = str2; <span class="comment">// &quot;Hello&quot; 对象失去了引用</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>作用域结束</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">example</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&quot;Temporary&quot;</span>; <span class="comment">// 创建引用</span></span><br><span class="line">&#125; <span class="comment">// 方法结束，temp 超出作用域，失去引用</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对象被移除出集合</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">list.remove(<span class="number">0</span>); <span class="comment">// 元素 &quot;A&quot; 失去了引用</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对象之间的引用关系断开</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"><span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">n1.next = n2;</span><br><span class="line">n1.next = <span class="literal">null</span>; <span class="comment">// n2 失去了引用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="失去引用后的处理"><a href="#失去引用后的处理" class="headerlink" title="失去引用后的处理"></a>失去引用后的处理</h2><ol>
<li><strong>垃圾回收</strong>：JVM 会自动检测失去引用的对象，并在适当的时机进行垃圾回收（GC）。</li>
<li><strong>内存释放</strong>：GC 回收这些对象占用的堆内存，使其可供新对象使用。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>内存泄漏：如果对象仍然被引用，但实际上不再使用，就会导致垃圾回收器无法回收它们，形成内存泄漏。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 对象持续引用导致内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>显式释放引用</strong>：可以通过将对象引用赋值为 <code>null</code> 来帮助垃圾回收器更快地释放内存，但通常不需要显式操作，JVM 会自动管理内存。</p>
</li>
</ol>
<h2 id="GC-管理的对象范围"><a href="#GC-管理的对象范围" class="headerlink" title="GC 管理的对象范围"></a>GC 管理的对象范围</h2><ol>
<li><strong>堆内存中的对象</strong><ul>
<li>**新生代 (Young Generation)**：短生命周期对象，通常是临时变量和局部变量。</li>
<li>**老年代 (Old Generation)**：生命周期较长的对象，例如缓存对象或单例对象。</li>
<li>**元空间 (Metaspace)**：类的元数据和常量池。</li>
</ul>
</li>
<li><strong>非 GC 管理的对象</strong><ul>
<li><strong>栈上的局部变量</strong>：存储在线程栈中，不由 GC 管理，方法结束后自动销毁。</li>
<li>**直接内存 (Direct Memory)**：例如 NIO 的直接缓冲区，需要显式释放。</li>
<li><strong>静态变量</strong>：存储在方法区中（元空间），生命周期随类加载器而定，不属于 GC 管理对象。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="GC-回收的对象条件"><a href="#GC-回收的对象条件" class="headerlink" title="GC 回收的对象条件"></a>GC 回收的对象条件</h2><h3 id="不可达对象"><a href="#不可达对象" class="headerlink" title="不可达对象"></a>不可达对象</h3><p>如果一个对象无法通过<strong>GC Roots</strong>直接或间接引用，则它被视为不可达对象，可以被 GC 回收。</p>
<h3 id="GC-Roots-可达"><a href="#GC-Roots-可达" class="headerlink" title="GC Roots 可达"></a>GC Roots 可达</h3><p>以下对象被视为 GC Roots，是垃圾回收的起始点：</p>
<ol>
<li><strong>栈中的局部变量和方法参数</strong>（线程栈帧中引用的对象）。</li>
<li><strong>静态变量引用的对象</strong>。</li>
<li><strong>常量引用的对象</strong>。</li>
<li><strong>类加载器引用的对象</strong>。</li>
<li><strong>JNI 引用的本地代码对象</strong>（如 Native 方法）。</li>
<li><strong>活动线程引用的对象</strong>。</li>
</ol>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>GC 使用<strong>可达性分析算法</strong>判断对象是否可达。如果从 GC Roots 无法找到路径引用某个对象，则它被视为垃圾对象。</p>
<hr>
<h2 id="强引用-软引用-弱引用-虚引用"><a href="#强引用-软引用-弱引用-虚引用" class="headerlink" title="强引用/软引用/弱引用/虚引用"></a>强引用/软引用/弱引用/虚引用</h2><p>Java 提供了 4 种不同强度的引用类型，用于控制对象的生命周期：</p>
<ol>
<li><strong>强引用 (Strong Reference)</strong><ul>
<li>默认引用类型，不可回收。</li>
<li>示例：<code>String s = &quot;Hello&quot;;</code></li>
<li>只有强引用断开，GC 才会考虑回收对象。</li>
</ul>
</li>
<li><strong>软引用 (Soft Reference)</strong><ul>
<li>适合缓存数据，内存不足时才会回收。</li>
<li>示例：<code>SoftReference&lt;String&gt; sr = new SoftReference&lt;&gt;(new String(&quot;Cache&quot;));</code></li>
</ul>
</li>
<li><strong>弱引用 (Weak Reference)</strong><ul>
<li>GC 时会立即回收，无论内存是否充足。</li>
<li>示例：<code>WeakReference&lt;String&gt; wr = new WeakReference&lt;&gt;(new String(&quot;Temp&quot;));</code></li>
</ul>
</li>
<li><strong>虚引用 (Phantom Reference)</strong><ul>
<li>不影响对象生命周期，仅用于检测对象何时被 GC 回收。</li>
<li>示例：<code>PhantomReference&lt;String&gt; pr = new PhantomReference&lt;&gt;(new String(&quot;Test&quot;), refQueue);</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="触发-GC-的条件"><a href="#触发-GC-的条件" class="headerlink" title="触发 GC 的条件"></a>触发 GC 的条件</h2><ol>
<li><strong>内存不足</strong>：年轻代或老年代空间耗尽。</li>
<li>**调用 System.gc()**：请求 JVM 进行 GC，但不保证立即执行。</li>
<li><strong>对象失去引用</strong>：对象不可达，进入 GC 阶段。</li>
<li><strong>类加载和卸载</strong>：类元数据或方法区空间不足时触发 GC。</li>
<li><strong>手动释放资源</strong>：如关闭文件流、网络连接等，减少内存压力。</li>
</ol>
<h2 id="GC-示例"><a href="#GC-示例" class="headerlink" title="GC 示例"></a>GC 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 强引用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> obj1;        <span class="comment">// 共享引用</span></span><br><span class="line">        obj1 = <span class="literal">null</span>;               <span class="comment">// obj1 失去引用，但 obj2 仍指向它</span></span><br><span class="line">        System.gc();               <span class="comment">// 提示 GC 执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><code>obj1</code> 被赋值为 <code>null</code>，但 <code>obj2</code> 仍然引用对象，因此不会被回收。</li>
<li>若同时将 <code>obj2</code> 设置为 <code>null</code>，对象变为不可达对象，则 GC 会将其回收。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/11/JVM/" data-id="cm8pzsrbv0000wotv15l47xmw" data-title="JVM 介绍" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM%E8%B0%83%E5%8F%82/" rel="tag">JVM调参</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" rel="tag">内存区域</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hash" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/15/hash/" class="article-date">
  <time class="dt-published" datetime="2024-08-14T16:00:00.000Z" itemprop="datePublished">2024-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/15/hash/">哈希函数的工程应用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">散列函数 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h2 id="Hash-是什么"><a href="#Hash-是什么" class="headerlink" title="Hash 是什么"></a>Hash 是什么</h2><p>哈希（Hash）的原理是通过一种<strong>特定的函数</strong>，将任意长度的输入（也称为键）<strong>映射</strong>为固定长度的输出（称为哈希值、哈希码或散列值）。这种函数称为<strong>哈希函数</strong>或<strong>散列函数</strong>。哈希主要用于快速查找、数据完整性验证等方面，下面具体解释其原理和应用：</p>
<h2 id="哈希函数的原理"><a href="#哈希函数的原理" class="headerlink" title="哈希函数的原理"></a>哈希函数的原理</h2><p>哈希函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（又叫<strong>哈希值</strong>）（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。</p>
<p>哈希函数的基本目标是<strong>将不同的输入映射为不同的输出</strong>。常见哈希函数的特性包括：</p>
<ul>
<li><strong>确定性</strong>：相同的输入永远会产生相同的哈希值。</li>
<li><strong>效率</strong>：计算哈希值的过程非常快，便于快速存取和查找。</li>
<li><strong>分布均匀</strong>：不同的输入尽可能分布到不同的哈希值上，以减少哈希冲突。</li>
<li><strong>不可逆性</strong>：通常不能通过哈希值反推出原始输入（主要在密码学中强调）。<ul>
<li>攻破：能够找出具有相同哈希值的一对报文，但是从一个已知报文篡改成具有相同哈希值的报文仍然没有方法</li>
</ul>
</li>
</ul>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>哈希函数将无限多的输入映射到有限的输出空间，因此必然会发生不同输入产生相同哈希值的情况，即<strong>哈希冲突</strong>。常见的处理冲突方法有：</p>
<ul>
<li><p><strong>链地址法（链表法）</strong>：在哈希表中，每个位置存储一个链表，当出现冲突时将数据插入链表。（JDK HashMap）链地址法适用于经常进行插入和删除的情况。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-20230822202707.png" alt="img"></p>
</li>
<li><p><strong>开放地址法</strong>：通过探测和寻找空位存储冲突的数据，例如线性探测、二次探测、伪随机探测再散列等。二次探测消除了线性探测的聚集问题，这种聚集问题叫做原始聚集</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-20230822203134.png" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-20230822203306.png" alt="img"></p>
</li>
<li><p><strong>再哈希法</strong>：当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
</li>
</ul>
<h2 id="哈希应用"><a href="#哈希应用" class="headerlink" title="哈希应用"></a>哈希应用</h2><ul>
<li><strong>哈希表</strong>：用于快速存储和查找数据，常用的数据结构之一。</li>
<li><strong>数据完整性</strong>：验证数据的完整性，如文件校验和。</li>
<li><strong>密码学</strong>：生成数据的“指纹”，用于验证用户密码、数字签名等。</li>
</ul>
<h2 id="哈希函数的常见算法"><a href="#哈希函数的常见算法" class="headerlink" title="哈希函数的常见算法"></a>哈希函数的常见算法</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MD5">MD5消息摘要算法</a><strong>（英语：</strong>MD5 Message-Digest Algorithm</strong>），一种被广泛使用的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>，可以产生出一个128位（16个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>）的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97">散列</a>值（hash value），用于确保信息传输完整一致。曾被用于文件校验、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SSL">SSL</a>/<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TLS">TLS</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IPsec">IPsec</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Secure_Shell">SSH</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2404002">深入解析MD5哈希算法：原理、应用与安全性-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37257569">MD5算法 - 知乎 (zhihu.com)</a></p>
<ul>
<li>将报文按模2^64^取余，追加在报文后面</li>
<li>在报文和余数之间填充若干位，使得总长度为512的整数倍，第一位是1其他位是0</li>
<li>按照512位一块，分成若干块，分割之后再把每块分成4个128位的数据块，送到4个不同的哈希函数进行4轮计算，每一轮按照32位的小块进行运算，一直到最后计算出MD5报文摘要代码。</li>
</ul>
<h3 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h3><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F">安全散列算法</a><strong>（英语：</strong>Secure Hash Algorithm</strong>，缩写为<strong>SHA</strong>）是一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>家族，是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%81%94%E9%82%A6%E8%B5%84%E6%96%99%E5%A4%84%E7%90%86%E6%A0%87%E5%87%86">FIPS</a>所认证的安全<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">散列算法</a>。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的几率很高。</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/news/351438.html">什么是 SHA 加密？ SHA-1 与 SHA-2 - FreeBuf网络安全行业门户</a></p>
<h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">循环冗余校验</a><strong>（英语：</strong>Cyclic redundancy check</strong>，通称“<strong>CRC</strong>”）是一种根据网络数据包或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E6%AA%94%E6%A1%88">电脑文件</a>等数据产生简短固定位数校验码的一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">散列函数</a>，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。</p>
<p><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html">什么是CRC（Cyclic Redundancy Check）？如何解决CRC错误？ - 华为 (huawei.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E6%A0%A1%E9%AA%8C%E5%92%8C">校验和 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<h3 id="分布式哈希算法—服务节点集群、DHT"><a href="#分布式哈希算法—服务节点集群、DHT" class="headerlink" title="分布式哈希算法—服务节点集群、DHT"></a>分布式哈希算法—服务节点集群、DHT</h3><p><strong>分布式哈希函数</strong>：用于负载均衡和分布式存储，如一致性哈希。</p>
<h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/120814088">一致性哈希算法原理详解-CSDN博客</a> </p>
<p>如果简单的用服务器数量取模来进行负载均衡，一旦新增或者故障移除使服务器数变化，就会导致同一个key，一开始存储在A服务器上，数量变化后，去B服务器查询，也就是被分配到了与之前不同的服务器上，导致缓存大量失效，缓存失效的根本原因是：普通哈希算法的映射规则与节点数量高度耦合，导致节点数量变化时，几乎所有数据的映射关系都会变动。因此，之前缓存的绝大部分数据都会失效，无法在原有的缓存节点上找到，导致缓存命中率急剧下降。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/7903f62393641e5f3cafa28b059321b6.png" alt="取模" style="zoom: 75%;" />

<ul>
<li><p>一致性哈希通过对2^32^取模，将各个服务器进行哈希，分配到哈希环上，可以使用IP地址或者主机名哈希</p>
</li>
<li><p>把数据key也分配到哈希环上面，然后顺时针寻找离自己最近的服务器（哈希值）</p>
</li>
</ul>
<p>如下图所示，一台服务器挂了，不会影响到它之后的key，最小化缓存失效的影响</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111180255460.png" alt="image-20241111180255460"></p>
<h5 id="哈希环倾斜—虚拟节点"><a href="#哈希环倾斜—虚拟节点" class="headerlink" title="哈希环倾斜—虚拟节点"></a>哈希环倾斜—虚拟节点</h5><p>如下图所示，服务器节点较少，导致大部分key都缓存在A服务器上，数据分布不均匀，削弱了负载均衡的效果</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111180439707.png" alt="image-20241111180439707" style="zoom:50%;" />

<p>还有一种情况，节点数过少，只有AB</p>
<p>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点，一个实际物理节点可以对应多个虚拟节点，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大，hash环倾斜所带来的影响就越小，同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射。一个节点挂掉不至于将所有请求打到另一个节点上导致连续崩溃，起到负载均衡的作用。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111180905461.png" alt="image-20241111180905461" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2084611-20220527090607907-112778299.png" alt="img" style="zoom: 80%;" />



<h5 id="应用：DHT"><a href="#应用：DHT" class="headerlink" title="应用：DHT"></a>应用：DHT</h5><p>DHT 将<strong>键值对 (key-value)</strong> 存储在多个分布式节点中，通过哈希函数映射键值到节点位置，实现快速查找和存储。</p>
<ul>
<li>**键 (Key)**：唯一标识数据项的标记。</li>
<li>**值 (Value)**：存储的实际数据或其引用。</li>
<li><strong>哈希函数</strong>：将键映射到固定长度的哈希值，用于定位数据。</li>
</ul>
<p>DHT 使用<strong>一致性哈希算法</strong>（Consistent Hashing）将节点和数据映射到一个<strong>哈希环</strong>上，确保节点的加入或退出只影响少量数据的重新分布。</p>
<p><strong>存储数据</strong>：</p>
<ul>
<li>数据通过哈希函数生成键，例如 <code>hash(key)</code>。</li>
<li>键定位到负责存储的节点。</li>
</ul>
<p><strong>查找数据</strong>：</p>
<ul>
<li>查询方根据相同哈希规则计算键的哈希值，找到对应节点。</li>
<li>请求直接或逐步（路由）传递到存储数据的节点。</li>
</ul>
<p><strong>节点变化处理</strong>：</p>
<ul>
<li>新节点加入：重新分配部分数据给新节点。</li>
<li>节点退出：其数据重新分配到其他节点上，保证冗余备份和数据一致性。</li>
</ul>
<p>应用：</p>
<p><strong>P2P 网络</strong>：</p>
<ul>
<li>BitTorrent 使用 DHT 寻找资源和共享文件。</li>
<li>Kad 网络（eMule）基于 Kademlia 算法实现。</li>
</ul>
<p><strong>分布式缓存</strong>：</p>
<ul>
<li>Cassandra、DynamoDB 等分布式数据库利用 DHT 进行数据分布和一致性维护。</li>
</ul>
<p><strong>区块链和去中心化存储</strong>：</p>
<ul>
<li>IPFS（InterPlanetary File System）利用 DHT 定位文件存储位置。</li>
</ul>
<p><strong>分布式文件系统</strong>：</p>
<ul>
<li>Chord、Pastry、Tapestry 等协议用于存储和检索分布式文件。</li>
</ul>
<p><strong>Chord</strong>：环形结构，使用一致性哈希算法，支持动态节点增减。</p>
<p><strong>Kademlia</strong>：基于二叉树的路由协议，用于 eMule 和 BitTorrent。</p>
<p><strong>Pastry</strong>：支持高效查找和动态扩展，适用于大型网络。</p>
<p><strong>Tapestry</strong>：与 Pastry 类似，优化了搜索路径和延迟控制。</p>
<h4 id="哈希插槽"><a href="#哈希插槽" class="headerlink" title="哈希插槽"></a>哈希插槽</h4><p>详见redis cluster的哈希插槽实现</p>
<h2 id="应用：哈希表"><a href="#应用：哈希表" class="headerlink" title="应用：哈希表"></a>应用：哈希表</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">散列表 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>哈希表在大多数实现中，本质上是<strong>一个大数组</strong>，其中每个元素称为<strong>桶（bucket）</strong>。在这个大数组的基础上，通过哈希函数将键映射到数组的索引位置来存储和查找数据。</p>
<p>本质还是一个数组，但是数组的角标和键挂钩，在数组角标位置存储值，根据键就能很快找到对应的索引。</p>
<h3 id="哈希表的实现原理"><a href="#哈希表的实现原理" class="headerlink" title="哈希表的实现原理"></a>哈希表的实现原理</h3><ol>
<li><p><strong>一个大数组</strong>：哈希表的核心数据结构是一个数组，用于存储数据的位置。每个数组元素可以直接存储数据（若无冲突）或指向链表、红黑树等其他结构（若发生冲突）。</p>
</li>
<li><p><strong>数组中的每个元素即为一个桶</strong>：</p>
<ul>
<li>当多个键的哈希值映射到同一个索引位置（即哈希冲突）时，这个位置的元素会作为桶的“起点”，桶内部可以使用链表或树结构来存储多个值。</li>
<li>在 JDK 的 <code>HashMap</code> 中，每个桶初始是一个链表，当冲突元素超过一定数量时，该桶会从链表转换为红黑树结构，以提升查找效率。</li>
</ul>
</li>
<li><p><strong>桶数组的大小</strong>：一般是固定大小或者按需扩容。例如，Java 中的 <code>HashMap</code> 会在达到一定负载因子后（通常为 0.75）自动扩容，将原数组容量扩大一倍。这相当于增加了存储空间，从而减小了发生冲突的概率。</p>
</li>
</ol>
<h3 id="多数组的情况"><a href="#多数组的情况" class="headerlink" title="多数组的情况"></a>多数组的情况</h3><p>一般情况下，哈希表只使用一个数组来存储桶。但在一些特殊的场景下，可能会用到多个数组：</p>
<ul>
<li><strong>分布式哈希表（DHT）</strong>：在分布式系统中，数据分布在不同的服务器上，可以视作多个“数组”分布在不同节点上。</li>
<li><strong>分区哈希表</strong>：在特定应用场景中，有时会对哈希表进行分区，每个分区对应一个独立的数组，以实现分片存储或负载均衡。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在常见的哈希表实现（如 <code>HashMap</code>）中，通常是<strong>一个大数组</strong>来管理桶，在冲突发生时每个桶内可能使用链表或红黑树等结构存储多个值。</p>
<h3 id="JDK-HashMap"><a href="#JDK-HashMap" class="headerlink" title="JDK HashMap"></a>JDK HashMap</h3><p>是的，<code>HashMap</code> 是基于哈希实现的。在 JDK 的 <code>HashMap</code> 中，底层实现利用了<strong>数组 + 链表 + 红黑树</strong>的结构来存储键值对。其主要原理包括以下几个关键步骤：</p>
<h4 id="哈希计算"><a href="#哈希计算" class="headerlink" title="哈希计算"></a>哈希计算</h4><p><code>HashMap</code> 使用键的 <code>hashCode()</code> 方法来计算哈希值。计算哈希值后，会进一步通过位运算来<strong>优化分布</strong>，从而减少哈希冲突。具体来说，<code>HashMap</code> 会对哈希值进行一次扰动处理，使得高位和低位信息更加均匀地影响到数组索引。</p>
<p>例如，在 JDK 8 中使用了以下计算方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组索引映射"><a href="#数组索引映射" class="headerlink" title="数组索引映射"></a>数组索引映射</h4><p><code>HashMap</code> 的底层是一个<strong>数组</strong>，称为<strong>桶数组</strong>。通过 <code>(n - 1) &amp; hash</code> 的操作，哈希值被映射到数组的某个索引位置（其中 <code>n</code> 是桶数组的长度，且 <code>n</code> 始终为 2 的幂）。这种位运算的方式比取模运算更加高效。</p>
<h4 id="处理哈希冲突"><a href="#处理哈希冲突" class="headerlink" title="处理哈希冲突"></a>处理哈希冲突</h4><p>如果多个键的哈希值映射到了相同的数组索引（即发生哈希冲突），<code>HashMap</code> 会在该索引处使用<strong>链表</strong>或<strong>红黑树</strong>来存储这些冲突的键值对。</p>
<ul>
<li><strong>链表</strong>：在 JDK 8 及之前，当冲突的键较少时，<code>HashMap</code> 使用链表将冲突的键连接起来。链表的插入操作简单，但是查找速度是 <code>O(n)</code>。</li>
<li><strong>红黑树</strong>：在 JDK 8 中，如果某个桶中的元素数量超过一定阈值（默认是 8），链表会转化为<strong>红黑树</strong>结构，从而提升查找效率至 <code>O(log n)</code>。</li>
</ul>
<h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h4><p>当 <code>HashMap</code> 的负载因子（元素个数 / 数组容量）超过某个阈值（默认是 0.75），<code>HashMap</code> 会<strong>进行扩容</strong>。扩容会将桶数组的大小扩大为原来的两倍，并重新分配所有元素的位置。这一过程称为<strong>rehash</strong>，它会重新计算所有键的索引，以减少哈希冲突。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>JDK 中的 <code>HashMap</code> 是通过哈希函数来计算键的哈希值，并将其映射到数组的索引。遇到冲突时，采用链表或红黑树存储方式，并通过动态扩容和重哈希来保证存取效率。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h4><p>当你往简单数组或列表中插入新数据时，将不会根据插入项的值来确定该插入项的索引值。这意味着新插入项的索引值与数据值之间没有直接关系。这样的话，当你需要在数组或列表中搜索相应值的时候，你必须遍历已有的集合。若集合中存在大量的数据，就会影响数据查找的效率。</p>
<p>针对这个问题，你可以考虑使用哈希表。<strong>利用哈希表你可以通过对 “值” 进行哈希处理来获得该值对应的键或索引值</strong>，然后把该值存放到列表中对应的索引位置。这意味着索引值是由插入项的值所确定的，当你需要判断列表中是否存在该值时，只需要对值进行哈希处理并在相应的索引位置进行搜索即可，这时的搜索速度是非常快的。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-ba324df953f121b077f7bdc2a6109f0a_r.jpg"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133002751.png" alt="image-20241111133002751"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133015151.png" alt="image-20241111133015151"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133059526.png" alt="image-20241111133059526"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133111464.png" alt="image-20241111133111464"></p>
<p>插入数据时顺便将数据键添加进布隆过滤器中，会根据n个哈希函数计算出n个索引，随后将这些索引位置1，因为哈希函数存在碰撞的可能，所以要计算出多个哈希值，图中使用了3个哈希值，fullstack和semlinker出现了完全重复，这就导致了误判。</p>
<p><strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在</strong> </p>
<p>如果哈希运算后任何一个索引位为0，则肯定不存在，否则可能存在</p>
<h4 id="误判率"><a href="#误判率" class="headerlink" title="误判率"></a>误判率</h4><p>幸运的是，布隆过滤器有一个可预测的误判率（FPP）：</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133418275.png" alt="image-20241111133418275" style="zoom: 33%;" />

<ul>
<li>n 是已经添加元素的数量；</li>
<li>k 哈希的次数；</li>
<li>m 布隆过滤器的长度（如比特数组的大小）；</li>
</ul>
<p>极端情况下，当布隆过滤器没有空闲空间时（满），每一次查询都会返回 true 。这也就意味着 m 的选择取决于期望预计添加元素的数量 n ，并且 m 需要远远大于 n 。</p>
<h4 id="最佳实践：Guava"><a href="#最佳实践：Guava" class="headerlink" title="最佳实践：Guava"></a>最佳实践：Guava</h4><p>guava的布隆过滤器直接使用即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建布隆过滤器对象</span></span><br><span class="line">BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">    Funnels.integerFunnel(),</span><br><span class="line">    <span class="number">1500</span>,</span><br><span class="line">    <span class="number">0.01</span>);</span><br><span class="line"><span class="comment">// 判断指定元素是否存在</span></span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 将元素添加进布隆过滤器</span></span><br><span class="line">filter.put(<span class="number">1</span>);</span><br><span class="line">filter.put(<span class="number">2</span>);</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/15/hash/" data-id="cm8pzfkut0000pgtv1wqlho3x" data-title="哈希函数的工程应用" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" rel="tag">一致性哈希</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/" rel="tag">哈希函数</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%93%88%E5%B8%8C%E6%8F%92%E6%A7%BD/" rel="tag">哈希插槽</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="tag">布隆过滤器</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/G1/" rel="tag">G1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM%E8%B0%83%E5%8F%82/" rel="tag">JVM调参</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" rel="tag">一致性哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" rel="tag">内存区域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/" rel="tag">哈希函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C%E6%8F%92%E6%A7%BD/" rel="tag">哈希插槽</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/" rel="tag">字节码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="tag">布隆过滤器</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/G1/" style="font-size: 10px;">G1</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/JVM/" style="font-size: 20px;">JVM</a> <a href="/tags/JVM%E8%B0%83%E5%8F%82/" style="font-size: 10px;">JVM调参</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" style="font-size: 10px;">一致性哈希</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" style="font-size: 10px;">内存区域</a> <a href="/tags/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/" style="font-size: 10px;">哈希函数</a> <a href="/tags/%E5%93%88%E5%B8%8C%E6%8F%92%E6%A7%BD/" style="font-size: 10px;">哈希插槽</a> <a href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/" style="font-size: 10px;">字节码</a> <a href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" style="font-size: 10px;">布隆过滤器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/25/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2024/09/13/classfile/">ClassFile</a>
          </li>
        
          <li>
            <a href="/2024/09/12/G1/">G1 垃圾收集器介绍</a>
          </li>
        
          <li>
            <a href="/2024/09/11/JVM/">JVM 介绍</a>
          </li>
        
          <li>
            <a href="/2024/08/15/hash/">哈希函数的工程应用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>