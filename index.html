<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream">
<meta property="og:url" content="http://scatteredream.github.io/index.html">
<meta property="og:site_name" content="scatteredream">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section">归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section">标签</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section">分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/01/Starter%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/01/Starter%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">自定义 starter</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T00:00:00+08:00">2025-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 01:01:40" itemprop="dateModified" datetime="2025-04-26T01:01:40+08:00">2025-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>==在 Spring Boot 生态中，“Starter” 本质上就是一组依赖的“捆绑包”，它的目标是让使用方 <strong>一行依赖</strong> 就把启动一个完整的 Spring Boot 应用所需的所有东西都拉过来。==</p>
<h1 id="父模块实现"><a href="#父模块实现" class="headerlink" title="父模块实现"></a>父模块实现</h1><p>父POM的作用：作为配置的样板、插件管理、依赖管理。</p>
<p><code>parent</code> 定义了继承关系，子模块从父 POM 继承配置。</p>
<p><code>modules</code> 定义了聚合关系，父 POM 聚合了需要统一管理的子模块。</p>
<p>在我们项目顶层的pom文件中，我们会看到dependencyManagement元素。通过它元素来管理jar包的版本，让子项目中引用一个依赖而不用显示的列出版本号。Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement元素中指定的版本号。</p>
<p>Dependencies相对于dependencyManagement，所有声明在dependencies里的依赖都会自动引入，并默认被所有的子项目继承，但是父项目引入依赖没有任何用处，所以只需要用dependencyManagement声明即可。</p>
<p>在使用springboot时，通常工程有自己的父模块，而<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.12.RELEASE/reference/html/using-boot-build-systems.html#using-boot-maven-without-a-parent">不能继承spring-boot-starter-parent</a>时，推荐按照下面的做法</p>
<p><code>&lt;type&gt;pom&lt;/type&gt;</code>，<code>&lt;scope&gt;import&lt;/scope&gt;</code>，表示将<code>spring-boot-dependencies</code> 中<code>dependencyManagement</code>下的<code>dependencies</code>插入到当前工程的<code>dependencyManagement</code>中，所以不存在依赖传递。当没有<code>&lt;scope&gt;import&lt;/scope&gt;</code>时，意思是将<code>spring-boot-dependencies</code> 的<code>dependencies</code>全部插入到当前工程的<code>dependencies</code>中，并且会依赖传递。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>3.4.4<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rpc.version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">rpc.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 其他依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;maven.compiler.source&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;maven.compiler.source&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>false<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 其他插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="starter-子模块实现"><a href="#starter-子模块实现" class="headerlink" title="starter 子模块实现"></a>starter 子模块实现</h1><p>starter——核心功能在 core 实现，一定要有<code>autoconfigure</code>以及<code>configuration-processor</code></p>
<ul>
<li>starter 依赖 core、==spring-boot-starter==（一行代码引入依赖的核心） <code>autoconfigure</code>其实也包括在内了</li>
<li>增强扩展性：core 的依赖全部改为 optional，然后在 starter 内再次依赖</li>
<li>名称：以spring-boot-starter结尾，易于辨识</li>
</ul>
<h1 id="使用-starter"><a href="#使用-starter" class="headerlink" title="使用 starter"></a>使用 starter</h1><p>直接在pom引入自定义 starter 即可</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/01/rpc-interpretation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/01/rpc-interpretation/" class="post-title-link" itemprop="url">基于 Netty 的 RPC 框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T00:00:00+08:00">2025-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 01:01:31" itemprop="dateModified" datetime="2025-04-26T01:01:31+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="wxy-rpc"><a href="#wxy-rpc" class="headerlink" title="wxy-rpc"></a>wxy-rpc</h1><p>这是一个同步调用的 RPC 框架。</p>
<p>服务消费方包装好 RpcRequest，做完服务发现之后发送网络请求，使用 Promise 来进行异步请求的同步等待 await(timeout) 与收到 RpcResponse 之后的 setSuccess(rpcMessage)。</p>
<p>服务提供方收到 RpcRequest，根据服务名称在本地注册中心找到实现类，执行调用，返回结果封装在 RpcResponse 内。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250423123418951.png" alt="责任链"></p>
<h2 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h2><p>成熟的 RPC 框架一般会提供四种调用方式，分别为同步 Sync、异步 Future、回调 Callback和单向 Oneway。RPC 框架的性能和吞吐量与合理使用调用方式是息息相关的，下面我们逐一介绍下四种调用方式的实现原理。</p>
<ul>
<li>Sync 同步调用。客户端线程发起 RPC 调用后，当前线程会一直阻塞，直至服务端返回结果或者处理超时异常。Sync 同步调用一般是 RPC 框架默认的调用方式，为了保证系统可用性，客户端设置合理的超时时间是非常重要的。虽说 Sync 是同步调用，但是客户端线程和服务端线程并不是同一个线程，实际在 RPC 框架内部还是异步处理的。Sync 同步调用的过程如下图所示。</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Sync同步调用.png" alt="Sync同步调用" style="zoom:67%;" />

<ul>
<li>Future 异步调用。客户端发起调用后不会再阻塞等待，而是拿到 RPC 框架返回的 Future 对象，调用结果会被服务端缓存，客户端自行决定后续何时获取返回结果。当客户端主动获取结果时，该过程是阻塞等待的。Future 异步调用过程如下图所示。</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Future异步调用.png" alt="Future异步调用" style="zoom:67%;" />

<ul>
<li>Callback 回调调用。如下图所示，客户端发起调用时，将 Callback 对象传递给 RPC 框架，无须同步等待返回结果，直接返回。当获取到服务端响应结果或者超时异常后，再执行用户注册的 Callback 回调。所以 Callback 接口一般包含 onResponse 和 onException 两个方法，分别对应成功返回和异常返回两种情况。</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Callback回调调用.png" alt="Callback回调调用" style="zoom:67%;" />

<ul>
<li>Oneway 单向调用。客户端发起请求之后直接返回，忽略返回结果。Oneway 方式是最简单的，具体调用过程如下图所示。</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Onway单向调用.png" alt="Onway单向调用" style="zoom:67%;" />

<p>四种调用方式都各有优缺点，很难说异步方式一定会比同步方式效果好，在不用的业务场景可以按需选取更合适的调用方式。</p>
<h2 id="framework-core"><a href="#framework-core" class="headerlink" title="==framework-core=="></a>==framework-core==</h2><p><strong>config</strong> 线程池配置类 <strong>factory</strong> 单例工厂和线程池工厂</p>
<h3 id="common（消息体定义、注册信息）"><a href="#common（消息体定义、注册信息）" class="headerlink" title="common（消息体定义、注册信息）"></a>common（消息体定义、注册信息）</h3><p>包括消息体的三种类型，以及注册中心提供的服务信息 <code>ServiceInfo</code>。</p>
<ul>
<li><code>RpcRequest</code> 包含 服务名称（服务名+版本）、方法名、参数类型、参数</li>
<li><code>RpcResponse</code> 包含 返回值、发生异常时的异常信息</li>
<li><code>HeartBeatMessage</code> 包含字符串（PING/PONG）</li>
<li><code>ServiceInfo</code> 应用名称、服务名称、版本号、服务提供方主机地址、端口号。</li>
</ul>
<h3 id="utils（ServiceUtil）"><a href="#utils（ServiceUtil）" class="headerlink" title="utils（ServiceUtil）"></a>utils（ServiceUtil）</h3><p><code>String serviceKey(String serviceName, String version)</code> 根据服务名称和版本号生成注册服务的key</p>
<p><code>Map toMap(ServiceInfo serviceInfo)</code> 将ServiceInfo转换成Map 用于nacos注册</p>
<p><code>ServiceInfo toServiceInfo（Map map）</code> 将Map转换成ServiceInfo 用于nacos发现</p>
<blockquote>
<p>nacos instance 的metadata是一个map，键和值都是字符串。</p>
<p>port是 int 类型，Gson 解析出 8080 会变成 Number 类型 8080.0 变成Double，因此要把8080转成字符串。</p>
<p><code>map.put(&quot;port&quot;, serviceInfo.getPort().toString());</code> </p>
<p><code>map.put(&quot;port&quot;, Integer.parseInt(map.getOrDefault(&quot;port&quot;, &quot;0&quot;).toString()))</code> </p>
</blockquote>
<h3 id="enums（消息头参数）"><a href="#enums（消息头参数）" class="headerlink" title="enums（消息头参数）"></a>enums（消息头参数）</h3><ul>
<li><code>MessageStatus</code> <code>code</code>=01 代表成功/失败</li>
<li><code>MessageType</code> <code>type</code>=01表示正常的请求与响应 23表示心跳的ping 与pong</li>
<li><code>SerializationType</code>  <code>type</code> = 0-4 分别对应5种序列化算法，可以根据输入的序列化算法名称匹配对应的序列化方式，默认为Hessian，也可根据type匹配。</li>
</ul>
<h3 id="protocol-constant（协议定义相关）"><a href="#protocol-constant（协议定义相关）" class="headerlink" title="protocol/constant（协议定义相关）"></a>protocol/constant（协议定义相关）</h3><ul>
<li><code>RpcMessage</code> 封装好的 Rpc 协议信息<ul>
<li><code>MessageHeader header</code> 消息头</li>
<li><code>Object body</code> 携带的消息内容（可能是 <code>RpcRequest</code>，<code>RpcResponse</code>，也可能是心跳 <code>HeartBeatMessage</code>）</li>
</ul>
</li>
<li><code>MessageHeader</code>  消息头<ul>
<li>4B 魔数 1B 版本号  均有<strong>默认填充</strong> </li>
<li>1B <code>serializerType</code></li>
<li>1B <code>messageType</code> </li>
<li>1B <code>messageStatus</code> </li>
<li>4B <code>serialNumber</code> 有一个原子变量，每get一次就自增</li>
<li>4B <code>length</code> </li>
<li><strong>Builder 建造者模式</strong> 链式构造 build</li>
</ul>
</li>
</ul>
<blockquote>
<p>设计模式：建造者模式</p>
<ul>
<li><strong>解决复杂对象的构造问题</strong>：当一个对象需要多个参数（尤其包含大量可选参数）时，传统构造方法会变得臃肿且难以维护。</li>
<li><strong>避免“重叠构造器”反模式</strong>：无需编写多个不同参数组合的构造函数。</li>
<li><strong>防止对象的不一致状态</strong>：确保对象在构造完成后处于完整且一致的状态。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">优势</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>参数灵活</strong></td>
<td align="left">可选参数可自由组合，避免编写多个重载构造函数。</td>
</tr>
<tr>
<td align="left"><strong>代码可读性高</strong></td>
<td align="left">链式调用清晰表达参数含义（如 <code>.age(30).email(&quot;...&quot;)</code>）。</td>
</tr>
<tr>
<td align="left"><strong>对象状态一致性</strong></td>
<td align="left">通过 <code>build()</code> 方法统一校验参数，确保对象构造完成后合法且完整。</td>
</tr>
<tr>
<td align="left"><strong>与不可变对象兼容</strong></td>
<td align="left">适合构建不可变（<code>final</code>）对象，所有参数在构造时一次性设置。</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="serialization（序列化相关）"><a href="#serialization（序列化相关）" class="headerlink" title="==serialization（序列化相关）=="></a>==serialization（序列化相关）==</h3><ul>
<li><code>Serialization</code> 接口，定义了 <code>serialize()</code>和 <code>deserialize()</code> 两个方法 共有5个实现（Gson、Kryo、JDK、Protostuff、Hessian）使用 SPI 标注，表示这个类是可扩展的（可插拔）</li>
<li><code>SerializationFactory</code> 工厂模式，使用工厂方法创建序列化实例。</li>
</ul>
<blockquote>
<p>设计模式：工厂模式</p>
<ul>
<li>提供了一种创建对象的方式，使得创建对象的过程与使用对象的过程分离。</li>
<li>工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。</li>
<li>通过使用工厂模式，可以将对象的创建逻辑封装在一个工厂类中，而不是在客户端代码中直接实例化对象，这样可以提高代码的可维护性和可扩展性。</li>
</ul>
</blockquote>
<p><strong>Gson</strong>：默认不支持class序列化，需要自己实现</p>
<p><strong>Kryo</strong>：Kryo 线程不安全，所以使用 ThreadLocal 保存 kryo 对象</p>
<p><strong>Protostuff</strong>：提前分配好 LinkedBuffer，避免每次进行序列化都需要重新分配 buffer 内存空间</p>
<p>序列化无需双方约定，只需要客户端规定好就可以，写入MessageHeader以后，双方的codec自己会根据对应字段选择相同的序列化/反序列化方式。</p>
<h3 id="exception（异常）"><a href="#exception（异常）" class="headerlink" title="exception（异常）"></a>exception（异常）</h3><p>定义了RPCException和SerializeException来封装框架的异常</p>
<h3 id="codec（编解码、粘包处理）"><a href="#codec（编解码、粘包处理）" class="headerlink" title="==codec（编解码、粘包处理）=="></a>==codec（编解码、粘包处理）==</h3><p><code>MessageToByteEncoder&lt;T&gt;</code> 负责编码 <code>ByteToMessageDecoder</code> 负责解码</p>
<ul>
<li><p>在 Netty 的 Pipeline 中，通常将两者结合使用：</p>
<ol>
<li>**<code>LengthFieldBasedFrameDecoder</code>**：解决粘包/半包， 提取完整帧。</li>
<li>**<code>MessageToMessageCodec</code>**：拆分后的数据帧（如<code>ByteBuf</code>）与业务对象转换。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline()</span><br><span class="line">  <span class="comment">// 第一步：处理粘包/半包，输出完整ByteBuf帧</span></span><br><span class="line">  .addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">  <span class="comment">// 第二步：将ByteBuf解码为Java对象</span></span><br><span class="line">  .addLast(<span class="keyword">new</span> <span class="title class_">MyMessageCodec</span>())</span><br><span class="line">  <span class="comment">// 第三步：处理业务逻辑</span></span><br><span class="line">  .addLast(<span class="keyword">new</span> <span class="title class_">BusinessHandler</span>());</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>SharableRpcMessageCodec</code></strong></p>
<ul>
<li>可共享的 Rpc 消息编码解码器，继承自 <code>MessageToMessageCodec&lt;ByteBuf, RpcMessage&gt;</code> 重写其 <code>encode(ctx, msg, out)</code> 与 <code>decode(ctx, msg, out)</code> 方法。使用此编解码器必须配合 <code>RpcFrameDecoder</code> 进行使用， 以保证得到完整的数据包。不同于 <code>io.netty.handler.codec.ByteToMessageCodec</code> 的编解码器，共享编解码器无需 保存 <code>ByteBuf</code> 的状态信息。</li>
<li>为了支持多线程共享，编解码器 Handler 应该是 <strong>无状态或线程安全</strong> 的。<code>@Sharable</code> 是 <strong>Netty 框架</strong>中一个重要的注解，用于标记 <code>ChannelHandler</code> 是否可以被多个 <code>Channel</code>（连接）<strong>安全共享</strong>。（默认情况下会为每一个Channel创建一个新的Handler实例，不能复用）<ul>
<li>仅当 <code>Handler</code> <strong>无状态</strong>或<strong>线程安全</strong>时，才应添加 <code>@Sharable</code>：</li>
<li><strong>统计类 Handler</strong>（如监控请求总数、连接数）。</li>
<li><strong>无状态 Handler</strong>（不保存任何与特定 <code>Channel</code> 相关的数据）。</li>
<li><strong>工具类 Handler</strong>（如日志记录、编解码器等）。</li>
</ul>
</li>
<li>入：<code>Bytebuf</code> -&gt; <code>RpcMessage</code> （解码）：先判断魔数，然后是版本号，之后是其余的字段，根据信息构造出消息头，然后根据消息类型反序列化消息体，rpc请求和响应的消息分别对应的是 <code>RpcRequest</code> 和 <code>RpcResponse</code>，心跳对应的是 <code>String</code> ，将这些信息拼成一个 <code>RpcMessage</code>，传递到下一个出站处理器</li>
<li>出：<code>RpcMessage</code>-&gt; <code>Bytebuf</code> （编码）：消息头发出时根据 <code>RpcMessage</code> 的消息头直接发送协议的对应字段，发到 <code>length</code> 以后暂停，将 <code>body</code> 序列化成为<code>byte</code> 数组，之后设置消息头的长度字段，然后将长度字段也写入，最后将消息体发出，传递到下一个出站处理器</li>
</ul>
</li>
<li><p><code>RpcFrameDecoder</code> </p>
<ul>
<li><p>粘包拆包编码器，固定长度的帧解码器，通过约定用定长字节表示接下来数据的长度。非共享，保存 <code>ByteBuf</code> 的状态信息。继承自 <code>LengthFieldBasedFrameDecoder</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RpcFrameDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxFrameLength    数据帧的最大长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lengthFieldOffset 长度域的偏移字节数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lengthFieldLength 长度域所占的字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RpcFrameDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TCP 是无边界的字节流，考虑到 RPC 框架特性，排除了固定长度/分隔符/channel短连接，采用消息长度+消息体的模式。不同 <code>Channel</code>之间肯定会互相干扰，因此不能使用 <code>@Sharable</code> 注解</p>
</li>
</ul>
</li>
</ul>
<h3 id="loadbalance（负载均衡）"><a href="#loadbalance（负载均衡）" class="headerlink" title="==loadbalance（负载均衡）=="></a>==loadbalance（负载均衡）==</h3><p>本项目实现了 Random、RoundRobin、ConsistentHash 三种负载均衡算法</p>
<p>在分布式系统中，服务提供者和服务消费者都会有多台节点，如何保证服务提供者所有节点的负载均衡呢？客户端在发起调用之前，需要感知有多少服务端节点可用，然后从中选取一个进行调用。客户端需要拿到服务端节点的状态信息，并根据不同的策略实现负载均衡算法。负载均衡策略是影响 RPC 框架吞吐量很重要的一个因素，下面我们介绍几种最常用的负载均衡策略。</p>
<ul>
<li>Round-Robin 轮询。Round-Robin 是最简单有效的负载均衡策略，并没有考虑服务端节点的实际负载水平，而是依次轮询服务端节点。</li>
<li>Weighted Round-Robin 权重轮询。对不同负载水平的服务端节点增加权重系数，这样可以通过权重系数降低性能较差或者配置较低的节点流量。权重系数可以根据服务端负载水平实时进行调整，使集群达到相对均衡的状态。</li>
<li>Least Connections 最少连接数。客户端根据服务端节点当前的连接数进行负载均衡，客户端会选择连接数最少的一台服务器进行调用。Least Connections 策略只是服务端其中一种维度，我们可以演化出最少请求数、CPU 利用率最低等其他维度的负载均衡方案。</li>
<li>Consistent Hash 一致性 Hash。目前主流推荐的负载均衡策略，Consistent Hash 是一种特殊的 Hash 算法，在服务端节点扩容或者下线时，尽可能保证客户端请求还是固定分配到同一台服务器节点。Consistent Hash 算法是采用哈希环来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash，然后为对象选择对应的服务器节点，在哈希环中顺时针查找距离对象 Hash 值最近的服务器节点。</li>
</ul>
<p>此外，负载均衡算法可以是多种多样的，客户端可以记录例如健康状态、连接数、内存、CPU、Load 等更加丰富的信息，根据综合因素进行更好地决策。</p>
<ul>
<li><code>LoadBalance</code> 接口定义了 <code>ServiceInfo select(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</code> ，SPI 注解表示可扩展。</li>
<li><code>AbstractLoadBalance</code> 实现了 <code>select</code> 考虑到 无invokers、单invokers 的情况，体现了 模版方法 的设计模式，让实现类自己实现 <code>doSelect</code> 方法。</li>
</ul>
<blockquote>
<p>设计模式：模板方法 （示例：HttpServlet 的 service() 方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他如 PUT、DELETE 等也可以类似处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>本项目实现了 Random、RoundRobin、ConsistentHash 三种负载均衡算法</p>
<p>在分布式系统中，服务提供者和服务消费者都会有多台节点，如何保证服务提供者所有节点的负载均衡呢？客户端在发起调用之前，需要感知有多少服务端节点可用，然后从中选取一个进行调用。客户端需要拿到服务端节点的状态信息，并根据不同的策略实现负载均衡算法。负载均衡策略是影响 RPC 框架吞吐量很重要的一个因素，下面我们介绍几种最常用的负载均衡策略。</p>
<ul>
<li>Round-Robin 轮询。Round-Robin 是最简单有效的负载均衡策略，并没有考虑服务端节点的实际负载水平，而是依次轮询服务端节点。</li>
<li>Weighted Round-Robin 权重轮询。对不同负载水平的服务端节点增加权重系数，这样可以通过权重系数降低性能较差或者配置较低的节点流量。权重系数可以根据服务端负载水平实时进行调整，使集群达到相对均衡的状态。</li>
<li>Least Connections 最少连接数。客户端根据服务端节点当前的连接数进行负载均衡，客户端会选择连接数最少的一台服务器进行调用。Least Connections 策略只是服务端其中一种维度，我们可以演化出最少请求数、CPU 利用率最低等其他维度的负载均衡方案。</li>
<li>Consistent Hash 一致性 Hash。目前主流推荐的负载均衡策略，Consistent Hash 是一种特殊的 Hash 算法，在服务端节点扩容或者下线时，尽可能保证客户端请求还是固定分配到同一台服务器节点。Consistent Hash 算法是采用哈希环来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash，然后为对象选择对应的服务器节点，在哈希环中顺时针查找距离对象 Hash 值最近的服务器节点。</li>
</ul>
<p>此外，负载均衡算法可以是多种多样的，客户端可以记录例如健康状态、连接数、内存、CPU、Load 等更加丰富的信息，根据综合因素进行更好地决策。</p>
</blockquote>
<h3 id="discovery-registry"><a href="#discovery-registry" class="headerlink" title="==discovery/registry=="></a>==discovery/registry==</h3><p>在分布式系统中，不同服务之间应该如何通信呢？传统的方式可以通过 HTTP 请求调用、保存服务端的服务列表等，这样做需要开发者主动感知到服务端暴露的信息，系统之间耦合严重。为了更好地将客户端和服务端解耦，以及实现服务优雅上线和下线，于是注册中心就出现了。</p>
<p>在 RPC 框架中，主要是使用注册中心来实现服务注册和发现的功能。服务端节点上线后自行向注册中心注册服务列表，节点下线时需要从注册中心将节点元数据信息移除。客户端向服务端发起调用时，自己负责从注册中心获取服务端的服务列表，然后在通过负载均衡算法选择其中一个服务节点进行调用。以上是最简单直接的服务端和客户端的发布和订阅模式，不需要再借助任何中间服务器，性能损耗也是最小的。</p>
<p>现在思考一个问题，服务在下线时需要从注册中心移除元数据，那么注册中心怎么才能感知到服务下线呢？我们最先想到的方法就是节点主动通知的实现方式，当节点需要下线时，向注册中心发送下线请求，让注册中心移除自己的元数据信息。但是如果节点异常退出，例如断网、进程崩溃等，那么注册中心将会一直残留异常节点的元数据，从而可能造成服务调用出现问题。</p>
<p>为了避免上述问题，实现服务优雅下线比较好的方式是采用主动通知 + 心跳检测的方案。除了主动通知注册中心下线外，还需要增加节点与注册中心的心跳检测功能，这个过程也叫作探活。心跳检测可以由节点或者注册中心负责，例如注册中心可以向服务节点每 60s 发送一次心跳包，如果 3 次心跳包都没有收到请求结果，可以任务该服务节点已经下线。</p>
<p>由此可见，采用注册中心的好处是可以解耦客户端和服务端之间错综复杂的关系，并且能够实现对服务的动态管理。服务配置可以支持动态修改，然后将更新后的配置推送到客户端和服务端，无须重启任何服务。</p>
<p>心跳检测：</p>
<p>Nacos: 客户端默认5秒发送一次心跳，服务端15s未收到心跳会将实例标记为不健康，超过30s就会删除实例</p>
<p>ZK: 临时节点（Ephemeral）本身就具备心跳检测特性，超时后节点自动删除（默认40s）</p>
<h4 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h4><blockquote>
<p>Nacos 是阿里开源的一站式服务发现、配置管理和服务管理平台。它可以作为注册中心使用，也支持配置中心功能，是服务治理的核心组件之一，类似于 Eureka、Consul、Zookeeper。<em>适合AP，高可用，健康检查机制更加可靠</em></p>
</blockquote>
<table>
<thead>
<tr>
<th>特性</th>
<th>Nacos</th>
<th>Eureka</th>
<th>Consul</th>
<th>Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td>CAP 理论倾向</td>
<td>AP(+CP)</td>
<td>AP</td>
<td>CP</td>
<td>CP</td>
</tr>
<tr>
<td>支持健康检查</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>支持配置中心</td>
<td>✅</td>
<td>❌</td>
<td>部分</td>
<td>❌</td>
</tr>
<tr>
<td>UI 管理界面</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>动态感知能力</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌（延迟）</td>
</tr>
</tbody></table>
<p><strong>服务注册</strong>（Service Registration）：一个服务启动后把自己的信息（如 IP、端口等）注册到 Nacos。</p>
<p><strong>服务发现</strong>（Service Discovery）：别的服务通过服务名从 Nacos 查询到这个服务的实例信息，然后进行调用。</p>
<p>==Nacos 注册中心的核心功能（命名服务 NamingService）==</p>
<p>在微服务架构中，服务的实例通常是动态变化的（可能会横向扩展、下线），不能写死 IP 和端口。使用命名服务的好处是：</p>
<ul>
<li>动态管理服务实例</li>
<li>实现服务的自动上下线</li>
<li>支持客户端负载均衡</li>
<li>解耦服务之间的调用</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>Zookeeper</th>
<th>Nacos</th>
<th>Eureka</th>
<th>Consul</th>
</tr>
</thead>
<tbody><tr>
<td>CAP 理论倾向</td>
<td><strong>CP</strong></td>
<td>AP</td>
<td>AP</td>
<td>CP</td>
</tr>
<tr>
<td>强一致性</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>服务宕机会下线</td>
<td>✅（临时节点）</td>
<td>✅（心跳）</td>
<td>❌（延迟）</td>
<td>✅</td>
</tr>
<tr>
<td>Watcher 机制</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>配置中心功能</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
<td>有限</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>服务（Service）</td>
<td>一个服务的逻辑名，如 <code>user-service</code></td>
</tr>
<tr>
<td>实例（Instance）</td>
<td>服务的一个具体实现，如 <code>user-service 192.168.1.10:8080 healthy metadata</code></td>
</tr>
<tr>
<td>命名空间（Namespace）</td>
<td>用于服务隔离，可以做多环境管理，比如开发、测试、生产环境</td>
</tr>
<tr>
<td>分组（Group）</td>
<td>用于对服务进行逻辑分组，默认是 <code>DEFAULT_GROUP</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NamingService</span> <span class="variable">naming</span> <span class="operator">=</span> NacosFactory.createNamingService(<span class="string">&quot;127.0.0.1:8848&quot;</span>);</span><br><span class="line"><span class="comment">// 注册服务</span></span><br><span class="line">naming.registerInstance(<span class="string">&quot;user-service&quot;</span>, <span class="string">&quot;192.168.1.100&quot;</span>, <span class="number">8080</span>);</span><br><span class="line"><span class="comment">// 获取服务实例列表</span></span><br><span class="line">List&lt;Instance&gt; instances = naming.getAllInstances(<span class="string">&quot;user-service&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure>

<h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><blockquote>
<p>Zookeeper 是一个开源的<strong>分布式协调框架</strong>，用于实现分布式系统中的统一配置管理、命名服务、分布式锁、主从选举等功能。在微服务体系中，它也可以作为注册中心使用，比如 Dubbo 体系就常用 ZK。<em>CP，强一致性，不过临时节点删除可能有一点延迟</em> </p>
</blockquote>
<table>
<thead>
<tr>
<th>功能点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册</td>
<td>服务提供者在 ZooKeeper 的 <code>/services/&#123;serviceName&#125;/providers</code> 路径下创建==临时节点==（Ephemeral Node），节点内容为服务元数据。</td>
</tr>
<tr>
<td>服务发现</td>
<td>消费者监听 <code>/services/&#123;serviceName&#125;/providers</code> 的子节点变化（==Watcher== 机制），实时获取服务列表。</td>
</tr>
<tr>
<td>健康检查</td>
<td>依赖==临时节点==的机制，服务宕机/断连节点会自动消失。</td>
</tr>
<tr>
<td>动态感知</td>
<td>使用 Watcher 机制，监听节点变化自动感知上下线，通过 Watcher 通知消费者刷新本地缓存。</td>
</tr>
<tr>
<td>数据一致性</td>
<td>强一致性（CP系统），适合对一致性要求高的场景。</td>
</tr>
</tbody></table>
<p>ZooKeeper 的 Watcher 机制保证消费者在节点增删时立即收到通知，触发本地缓存更新。</p>
<p>若 ZooKeeper 会话超时，消费者需重新注册 Watcher 并全量拉取数据。</p>
<p>缓存当前服务列表的快照，并在 Watcher 回调中对比差异，实现增量更新。</p>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><ul>
<li><p><code>ServiceDiscovery</code> 接口</p>
<ul>
<li><code>ServiceInfo discover(RpcRequest request)</code> 服务发现</li>
<li><code>default List&lt;ServiceInfo&gt; getServices(String serviceName)</code> 返回所有服务提供方</li>
<li><code>void destroy()</code> 摧毁连接</li>
</ul>
</li>
<li><p><code>NacosServiceDiscovery</code> </p>
<ul>
<li><p><code>LoadBalance loadBalance</code> 负载均衡算法</p>
</li>
<li><p><code>Map&lt;String, List&lt;ServiceInfo&gt;&gt; serviceMap</code> 本地缓存</p>
</li>
<li><p>构造器：提供负载均衡算法，nacos 地址 </p>
</li>
<li><p>```java<br>this.loadBalance = loadBalance;<br>this.namingService = NamingFactory.createNamingService(“localhost:8848”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `void destroy()` 关闭 命名服务</span><br><span class="line"></span><br><span class="line">  - `ServiceInfo discover(RpcRequest request)` 调用`getServices()`得到服务信息传给负载均衡器返回结果</span><br><span class="line"></span><br><span class="line">  - `List&lt;ServiceInfo&gt; getServices(String serverName)` </span><br><span class="line"></span><br><span class="line">    先看看缓存里有没有，没有就从NamingService里获取`List&lt;Instances&gt;`，通过stream映射到`List&lt;ServiceInfo&gt;`，将list作为服务名对应的值加到本地缓存里面。与此同时，订阅 NamingEvent，`subscribe(String serviceName, EventListener el)` 实现 `EventListener` 的 `onEvent(Event e)`，`Event` 转成 `NamingEvent`，从 NamingEvent 获取服务信息`getInstances`，更新至本地缓存。</span><br><span class="line"></span><br><span class="line">- `ZookeeperServiceDiscovery` </span><br><span class="line"></span><br><span class="line">  - `ServiceDiscovery&lt;ServiceInfo&gt; serviceDiscovery` Curator 提供的服务发现组件</span><br><span class="line"></span><br><span class="line">  - `Map&lt;String, List&lt;ServiceInfo&gt;&gt; serviceMap`</span><br><span class="line"></span><br><span class="line">    将服务列表缓存到本地内存，当服务发生变化时，由 serviceCache 进行服务列表更新操作，当 zk 挂掉时，将保存当前服务列表以便继续提供服务。</span><br><span class="line"></span><br><span class="line">  - `Map&lt;String, ServiceCache&lt;ServiceInfo&gt;&gt; serviceCacheMap`  </span><br><span class="line"></span><br><span class="line">    将在zk中的服务数据缓存至本地，并监听服务变化，实时更新缓存</span><br><span class="line">    服务本地缓存，将服务缓存到本地并增加 watch 事件，当远程服务发生改变时自动更新服务缓存</span><br><span class="line"></span><br><span class="line">  - 构造器：提供负载均衡算法，zk地址</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    this.loadBalance = loadBalance;</span><br><span class="line">    // 创建zk客户端示例 (会话超时，连接超时，指数退避重试)</span><br><span class="line">    client = CuratorFrameworkFactory</span><br><span class="line">            .newClient(registryAddress, SESSION_TIMEOUT, CONNECT_TIMEOUT,</span><br><span class="line">                    new ExponentialBackoffRetry(BASE_SLEEP_TIME, MAX_RETRY));</span><br><span class="line">    // 开启客户端通信</span><br><span class="line">    client.start();</span><br><span class="line">    // 构建 ServiceDiscovery 服务注册中心 建造者模式</span><br><span class="line">    serviceDiscovery = ServiceDiscoveryBuilder.builder(ServiceInfo.class)</span><br><span class="line">            .client(client)</span><br><span class="line">            .serializer(new JsonInstanceSerializer&lt;&gt;(ServiceInfo.class))</span><br><span class="line">            .basePath(BASE_PATH)</span><br><span class="line">            .build();</span><br><span class="line">    // 开启 服务发现</span><br><span class="line">    serviceDiscovery.start();</span><br></pre></td></tr></table></figure></li>
<li><p><code>void destroy()</code> 关闭缓存，关闭服务发现中心，关闭客户端</p>
</li>
<li><p><code>ServiceInfo discover(RpcRequest request)</code> 调用<code>getServices()</code>得到服务信息传给负载均衡器返回结果</p>
</li>
<li><p><code>List&lt;ServiceInfo&gt; getServices(String serverName)</code> </p>
<p>先查本地缓存，没有就构建缓存 <code>ServiceCache&lt;ServiceInfo&gt;</code>（这个是实时更新的缓存），使用建造者模式赋值服务名称。添加缓存事件监听器 <code>ServiceCacheListener</code>：重写 <code>cacheChanged()</code>，一旦缓存发生改变，就<code>getInstances</code> 获取 <code>List&lt;ServiceInstance&lt;ServiceInfo&gt;&gt;</code> 通过 <code>getPayload()</code> 获取<code>ServiceInfo</code>。连接状态改变只打印信息。将&lt;服务名，对应的实时缓存&gt;存到 <code>ServiceCacheMap</code> 里面，也存到本地缓存里面。</p>
</li>
</ul>
</li>
</ul>
<h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><ul>
<li><code>ServiceRegistry</code><ul>
<li><code>register(ServiceInfo info)</code> 注册</li>
<li><code>unregister(ServiceInfo info)</code> 注销</li>
<li><code>destroy()</code> 摧毁连接</li>
</ul>
</li>
<li><code>NacosServiceRegistry</code> <ul>
<li>注册：构建 <code>Instance</code>，将 <code>ServiceInfo</code> 转为 <code>Map</code> 作为其 metadata 进行注册</li>
<li>注销：构建 <code>Instance</code>，将 <code>ServiceInfo</code> 转为 <code>Map</code> 作为其 metadata 进行注销</li>
</ul>
</li>
<li><code>ZookeeperServiceRegistry</code><ul>
<li>注册：将 <code>ServiceInfo</code> 构建为 <code>ServiceInstance&lt;ServiceInfo&gt;</code> ，然后进行注册</li>
<li>注销：将 <code>ServiceInfo</code> 构建为 <code>ServiceInstance&lt;ServiceInfo&gt;</code> ，然后进行注销</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Nacos 直接拿 <code>NamingService</code> 使用就可以，<code>Instance</code> 中的 <strong>metadata</strong> 是 <code>ServiceInfo</code> 转换成的 Map</p>
<ul>
<li>服务发现的时候，数据来源就是 <code>NamingService</code> 本身。</li>
</ul>
<p>ZK 需要手动用 Curator API 构造注册中心， <code>ServiceInstance&lt;ServiceInfo&gt;</code> 的 <strong>payload</strong> 是 <code>ServiceInfo</code> </p>
<ul>
<li>服务发现的时候，数据主要来源是本地的实时缓存 <code>ServiceCache&lt;ServiceInfo&gt;</code>。</li>
</ul>
<h3 id="extension-（SPI）"><a href="#extension-（SPI）" class="headerlink" title="extension （SPI）"></a>extension （SPI）</h3><p>已实现，参考Dubbo部分源码，实现了自定义的SPI机制，目前仅支持根据接口类型加载配置文件中的所有具体的扩展实现类，并且可以根据指定的key获取特定的实现类，具体实现类逻辑在 <code>com.wxy.rpc.core.extension.ExtensionLoader</code> 中。</p>
<p>服务存储目录在 <code>resource/META-INF/extensions</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protostuff=com.wxy.rpc.core.serialization.protostuff.ProtostuffSerialization</span><br><span class="line">kryo=com.wxy.rpc.core.serialization.kryo.KryoSerialization</span><br><span class="line">json=com.wxy.rpc.core.serialization.json.JsonSerialization</span><br><span class="line">jdk=com.wxy.rpc.core.serialization.jdk.JdkSerialization</span><br><span class="line">hessian=com.wxy.rpc.core.serialization.hessian.HessianSerialization</span><br></pre></td></tr></table></figure>

<p>与类解耦的单例生成器 Holder。</p>
<h4 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h4><p>ExtensionLoader 通过一系列map缓存减少无用的对象创建：</p>
<p><code>Map&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; classToLoaderMap</code>  loader缓存（接口，loader）</p>
<ul>
<li>关联方法：<code>ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type)</code> type必须有SPI注解才能返回对应的Loader</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250426001316156.png" alt="单例缓存"></p>
<h4 id="ExtensionFactory"><a href="#ExtensionFactory" class="headerlink" title="ExtensionFactory"></a>ExtensionFactory</h4><p>然后使用工厂类，先根据type获取loader，然后根据name得到对象。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250426001516610.png" alt="Factory" style="zoom:50%;" />

<h4 id="AutoConfiguration"><a href="#AutoConfiguration" class="headerlink" title="AutoConfiguration"></a>AutoConfiguration</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250426001729767.png" alt="自动装配类" style="zoom:50%;" />

<p>如图，单例工厂，从配置读取 key，然后让加载器加载key对应的实现类。</p>
<h2 id="server-spring-boot"><a href="#server-spring-boot" class="headerlink" title="server-spring-boot"></a>server-spring-boot</h2><h3 id="store"><a href="#store" class="headerlink" title="==store=="></a>==store==</h3><p><code>LocalServiceCache</code> 服务提供者的本地注册中心</p>
<p>从调用信息 RpcRequest 中解析出的服务名映射到本地实现类.class <code>ConcurrentHashMap</code></p>
<p><code>static addService(String serviceName, Object obj)</code>  添加服务</p>
<p><code>static Object getService(String serviceName)</code>  获得服务</p>
<p><code>static void removeService(Object obj)</code> 移除服务</p>
<h3 id="handler"><a href="#handler" class="headerlink" title="==handler=="></a>==handler==</h3><p><code>RpcRequestHandler</code> 执行调用的核心</p>
<p><code>Object handleRpcRequest(RpcRequest request)</code></p>
<p>从本地注册中心 <code>LocalServiceCache</code> 获取服务，通过反射执行调用，返回结果。</p>
<h3 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h3><p><code>RpcServer</code> 接口 定义了 <code>start(Integer port)</code> 方法，有三个实现（Http、Netty、Socket）</p>
<h4 id="http"><a href="#http" class="headerlink" title="http"></a><span id="httpserver">http</span></h4><p><code>HttpRpcRequestHandler</code> 处理器，单例模式，责任链模式，相当于回调函数 核心方法 <code>handler.handle(req, resp)</code> 将 <code>RpcRequestHandler</code> 的结果以及异常封装到 <code>RpcResponse</code> 中，发回到序列化流中。</p>
<p><code>HttpRpcServer</code> 启动 tomcat ，主要是设置好 Servlet</p>
<p><code>DispatcherServlet</code> 分发 Servlet，前端控制器模式，使用线程池处理，来一个请求就开一个线程，关于参数：IO密集型 为 cpuNum *2 ，cpu密集型应为 cpuNum + 1 </p>
<p><a href="#httpclient">http 客户端</a> </p>
<h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a><span id="socketserver">socket</span></h4><p><code>SocketRpcServer</code> 启动 ServerSocket bind 端口，在死循环中 accept 还被阻塞，只要服务端socket不关闭（抛出 IOException），就会一直在循环里。除非关闭serversocket/网络问题。建立连接就在线程池开一个任务。</p>
<p><code>SocketRpcRequestHandler</code> 实现了 <code>Runnable</code> 接口，将 <code>RpcRequestHandler</code> 的结果以及异常封装到 <code>RpcResponse</code> 中，发回到序列化流中。</p>
<p><a href="#socketclient">socket 客户端</a> </p>
<h4 id="netty"><a href="#netty" class="headerlink" title="netty"></a><span id="nettyserver">netty</span></h4><p><a href="#nettyclient">netty 客户端</a> </p>
<p><code>NettyRpcRequestHandler</code> </p>
<blockquote>
<p>继承自 <code>SimpleChannelInboundHandler&lt;RpcMessage&gt;</code> 表示入站处理器处理RpcMessage。</p>
<p>只接收你想要的类型（即泛型指定的类型）；</p>
<p>消息处理完之后，<strong>自动释放 ByteBuf</strong>，避免内存泄漏（比 <code>ChannelInboundHandlerAdapter</code> 更安全）。</p>
</blockquote>
<p>重写了 <code>channelRead0</code> 方法。相当于进入一个消息的处理器。<strong>新开一个任务提交到线程池</strong>：先判断消息类型，如果是心跳请求PING，那么就设置回复的RpcMessage为心跳响应，然后设置好头部信息，消息体为 PONG。剩下的就是客户端的Rpc请求了，像其他方法一样将RpcRequest提取出来交给handler处理，设置好type status body 就发到下一个处理器（codec）。</p>
<p><code>ctx.writeAndFlush(responseRpcMessage).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</code></p>
<p><code>finally:  ReferenceCountUtil.release(msg);</code> 防止内存泄露</p>
<p>==心跳检测==：<code>userEventTriggered</code> 用户自定义事件，当触发读空闲(<code>IdleState.READER_IDLE</code>)时，也就是 30s 没有读的内容，就自动关闭【客户端channel】连接 </p>
<p><code>NettyRpcServer</code></p>
<ul>
<li><p><code>EventLoopGroup</code> 每个 <code>EventLoopGroup</code> 默认使用多个线程（CPU 核数 * 2）</p>
<blockquote>
<p>Netty 的线程模型是什么？为什么要用 boss/worker 分离？</p>
<p>Netty 使用的是 <strong>Reactor 多线程模型</strong>，将连接处理和读写事件分离，避免阻塞。</p>
<ul>
<li><code>bossGroup</code> 负责处理 <strong>accept（连接建立）</strong> 事件 将接受的连接注册到 Worker Group 的某个线程上，通常1-2个线程即可</li>
<li><code>workerGroup</code> 负责处理 <strong>read/write（数据通信）</strong> 事件，执行实际的业务处理，通常 为 cpu core *2 </li>
</ul>
<p>这样设计可以保证即使某个连接在业务处理时耗时较长，也不会阻塞新连接的接入，提高并发性能和系统的稳定性。</p>
</blockquote>
</li>
<li><p><code>ServerBootstrap</code> 启动类 配置参数</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">serverBootstrap.group(boss, worker) <span class="comment">// 指定线程组 group(parentGroup, childGroup)</span></span><br><span class="line">.channel(NioServerSocketChannel.class) <span class="comment">// 指定服务端 Channel 类型</span></span><br><span class="line">.childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>) <span class="comment">// 关闭 Nagle 算法，更及时发送数据</span></span><br><span class="line">.childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>) <span class="comment">// TCP 底层心跳机制（不是业务层心跳，2小时）</span></span><br><span class="line">.option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)<span class="comment">/* 表示用于临时存放完成三次握手的请求的队列的最大长度,</span></span><br><span class="line"><span class="comment">    								   	若连接建立频繁，服务器处理创建新连接较慢，可适当调大 */</span></span><br><span class="line">    </span><br><span class="line">.handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG)) <span class="comment">// ParentGroup 的处理器，记录日志</span></span><br><span class="line">    </span><br><span class="line">.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<span class="comment">// 客户端首次请求，为此连接分配一个</span></span><br><span class="line">    <span class="meta">@Override</span>                                          <span class="comment">// 新的SocketChannel (lazy init)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//  心跳机制，30s内没有收到客户端的请求就关闭连接，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">RpcFrameDecoder</span>());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SharableRpcMessageCodec</span>());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyRpcRequestHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 绑定端口，同步等待绑定成功 生命周期 bind </span></span><br><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(inetAddress, port).sync();</span><br><span class="line">log.debug(<span class="string">&quot;Rpc server add &#123;&#125; started on the port &#123;&#125;.&quot;</span>, inetAddress, port);</span><br><span class="line"><span class="comment">// 等待服务端监听端口关闭，如果不写这句，主线程会直接退出，Netty 服务就被销毁了。</span></span><br><span class="line">channelFuture.channel().closeFuture().sync();</span><br><span class="line"><span class="comment">// 这里 netty 已经封装好了异步接受逻辑，bind通常用sync等待一次，然后监听channel的关闭即可。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>EventLoop</code> 事件处理单元 <code>ChannelHandler</code>  业务处理逻辑 <code>ChannelPipeline</code>  处理器链</p>
<p><code>ByteBuf</code>  高效字节容器</p>
<p><code>Channel</code>  网络连接通道</p>
<p><code>NioServerSocketChannel</code> 用于 boss 的Channel，<code>SocketChannel</code> 用于 worker </p>
</blockquote>
<p>Netty 的 <code>ChannelPipeline</code> 是一个基于责任链模式的事件处理链，每个请求或响应都会从一个 handler 流向下一个 handler，形成链式处理。</p>
<p><code>[字节流] -&gt; ([心跳检测]) -&gt; [帧解码器] -&gt; [消息解码器] -&gt; [业务处理器]</code> </p>
<table>
<thead>
<tr>
<th>Handler 名称</th>
<th>作用说明</th>
<th>方向</th>
</tr>
</thead>
<tbody><tr>
<td><code>IdleStateHandler</code></td>
<td>空闲连接检测（30 秒无读事件会触发 READER_IDLE）实现应用层心跳机制（比 TCP 更灵活）更适合业务层快速检测连接状态</td>
<td>入站</td>
</tr>
<tr>
<td><code>RpcFrameDecoder</code></td>
<td>拆包/粘包处理，按协议规则拆出完整消息帧</td>
<td>入站</td>
</tr>
<tr>
<td><code>SharableRpcMessageCodec</code></td>
<td>编解码器，将 ByteBuf ↔ 自定义消息（RpcMessage）相互转换</td>
<td>双向</td>
</tr>
<tr>
<td><code>NettyRpcRequestHandler</code></td>
<td>业务逻辑处理器，处理请求、调用本地服务、写回响应</td>
<td>入站</td>
</tr>
</tbody></table>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250423123418951.png" alt="责任链"></p>
<p><a href="#nettyclient">netty 客户端</a></p>
<h2 id="client-spring-boot"><a href="#client-spring-boot" class="headerlink" title="client-spring-boot"></a>client-spring-boot</h2><h3 id="common"><a href="#common" class="headerlink" title="common"></a>common</h3><p><code>RequestMetadata</code> 封装请求，有 RpcMessage serverAddr port timeout 字段。</p>
<h3 id="handler-1"><a href="#handler-1" class="headerlink" title="handler"></a>handler</h3><p><code>RpcResponseHandler</code> 继承自 <code>SimpleChannelInboundHandler&lt;RpcMessage&gt;</code> </p>
<blockquote>
<p><strong>Netty 中的 Promise 机制</strong> </p>
<p>RPC 是远程调用，发送请求和得到响应的过程属于异步操作，Promise 机制用来解决 “客户端怎么知道哪个响应对应哪个请求？怎么挂起等待，又怎么唤醒？”的问题。</p>
<p>Netty 提供的 <code>DefaultPromise&lt;V&gt;</code> 是一个线程安全的对象，用来异步地接收并处理计算结果。你可以把它理解为一个 <strong>可手动完成的 Future</strong>。它有几个特点：</p>
<ul>
<li>在请求发送后立刻返回，不阻塞</li>
<li>把结果放入 Promise 中，调用方通过 <code>promise.get()</code> 或回调拿到结果</li>
<li>由响应处理器来手动调用 <code>promise.setSuccess(response)</code> 来填充结果</li>
</ul>
<p>实践中通常会用一个 <code>Map&lt;requestId, Promise&lt;RpcResponse&gt;&gt;</code> 保存请求对应的 Promise。具体流程如下：</p>
<ol>
<li><strong>发送请求之前：</strong><ul>
<li>创建一个 <code>DefaultPromise&lt;RpcResponse&gt;</code> 对象</li>
<li>存入全局请求池（Map）中：<code>promises.put(requestId, promise)</code></li>
</ul>
</li>
<li><strong>接收响应时：</strong><ul>
<li>从请求池里通过 <code>requestId</code> 找到对应的 <code>Promise</code></li>
<li>执行 <code>promise.setSuccess(response)</code>，通知结果已经到了</li>
</ul>
</li>
<li><strong>调用方阻塞等待结果（可选）：</strong><ul>
<li><code>promise.get()</code> 或 <code>promise.await()</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 发请求之前保存 promise</span></span><br><span class="line">DefaultPromise&lt;RpcResponse&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutor);</span><br><span class="line">RpcResponsePool.put(requestId, promise);</span><br><span class="line">channel.writeAndFlush(rpcMessage);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 接收响应时设置结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcMessage msg)</span> &#123;</span><br><span class="line">    <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> (RpcResponse) msg.getBody();</span><br><span class="line">    Promise&lt;RpcResponse&gt; promise = RpcResponsePool.remove(response.getRequestId()); <span class="comment">// 防内存泄露</span></span><br><span class="line">    <span class="keyword">if</span> (promise != <span class="literal">null</span>) &#123;</span><br><span class="line">        promise.setSuccess(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取结果</span></span><br><span class="line"><span class="type">RpcResponse</span> <span class="variable">result</span> <span class="operator">=</span> promise.get();</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>Map&lt;Integer, Promise&lt;RpcMessage&gt;&gt; UNPROCESSED_RPC_RESPONSES</code> 未处理的响应请求，跟 sequenceId 相对应</p>
<p><code>channelRead0</code> 如果是 <code>RpcResponse</code>，从map中拿出对应的响应，如果响应中没有异常，代表 <code>Promise</code> 成功。如果是心跳回应，则记录日志。</p>
<p><code>userEventTriggered(ctx, Object evt)</code> 用户自定义事件处理器，处理写空闲（<code>WRITE_IDLE</code>），当检测到写空闲15s 以后自动发送一个心跳检测数据包。如果 <code>evt</code> 是 <code>IdleStateEvent</code>，那么就构建一个 心跳检查的 RpcMessage，这里使用 Kryo 序列化以达到最好的效果。</p>
<h3 id="transport-1"><a href="#transport-1" class="headerlink" title="transport"></a>transport</h3><p><code>RpcClient</code> </p>
<p><code>RpcMessage sendRpcRequest(RequestMetadata requestMetadata)</code>  </p>
<h4 id="http-1"><a href="#http-1" class="headerlink" title="http"></a><span id="httpclient">http</span></h4><p><code>sendRpcRequest(RequestMetadata requestMetadata)</code> </p>
<p>根据 RequestMetadata，拿出 RpcMessage，取出 RpcRequest 并通过 Http 连接序列化发送，阻塞等待读取 RpcResponse，读取之后封装为 RpcMessage返回。</p>
<p><code>HttpRpcClient 发送和接受的数据为：RpcRequest，Response</code> </p>
<p><a href="#httpserver">http 服务端</a> </p>
<h4 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a><span id="socketclient">socket</span></h4><p><code>sendRpcRequest(RequestMetadata requestMetadata)</code>   socket connect 获取数据</p>
<p><code>SocketRpcClient 发送和接受的数据为：RpcRequest, RpcResponse</code></p>
<p><a href="#socketserver">socket 服务端</a> </p>
<h4 id="netty-1"><a href="#netty-1" class="headerlink" title="netty"></a><span id="nettyclient">netty</span></h4><table>
<thead>
<tr>
<th>场景</th>
<th>你的职责</th>
</tr>
</thead>
<tbody><tr>
<td>Channel 断开</td>
<td>触发 <code>channelInactive()</code> 或 <code>exceptionCaught()</code> 时，尝试<strong>重连</strong></td>
</tr>
<tr>
<td>连接池中拿到无效 Channel</td>
<td>检查 <code>channel.isActive()</code>，如果无效：<strong>close 并重新连接</strong></td>
</tr>
<tr>
<td>心跳失败或无响应</td>
<td>在 <code>IdleStateHandler</code> 的事件中<strong>关闭旧连接并重建</strong></td>
</tr>
<tr>
<td>重试次数限制</td>
<td>设置最大重试次数，避免死循环</td>
</tr>
</tbody></table>
<blockquote>
<p><code>ChannelProvider</code> 获取Channel的工具类</p>
<ul>
<li><code>Map&lt;String, Channel&gt; channels</code> 存储 channel 对象，key 为 ip:port</li>
<li><code>get(host,port)</code> 取出 活跃的 channel，不活跃的/null 从map移除</li>
<li><code>get(inetSocketAddress)</code> 同上</li>
<li><code>set(host,port,channel)</code> 将 host:port 与 Channel 映射</li>
</ul>
</blockquote>
<p><code>NettyRpcClient</code> </p>
<p><code>BootStrap</code> 启动类，注册 NioSocketChannel 超时时间，5s连接超时。handler 设置为 15s写空闲的IdleStateHandler，粘包拆包解码器、codec、ResponseHandler 。提供 ChannelProvider 工具类</p>
<p><code>EventLoopGroup</code> 每个事件循环对象对应一个线程，维护一个 Selector，用来处理io事件</p>
<p><code>getChannel(inetSocketAddress)</code>首先从map中获取，获取不到就主动去连接 <code>doConnect</code></p>
<p><code>doConnect(inetSocketAddress)</code> ：</p>
<p>方式1：</p>
<p>随后sync()同步阻塞等待 channel 的 closeFuture()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// connect 会返回一个 异步的 ChannelFuture</span></span><br><span class="line"><span class="comment">// sync() 同步等待异步connect连接成功 </span></span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(inetSocketAddress).sync().channel();</span><br><span class="line"><span class="comment">// 同步阻塞等待异步关闭完成</span></span><br><span class="line">channel.closeFuture().sync();</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<p>指数退避重连，使用 CompletetableFuture 阻塞获取 channel，future 成功时返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> Channel <span class="title function_">doConnectWithRetry</span><span class="params">(InetSocketAddress inetSocketAddress, <span class="type">int</span> remainingRetries)</span>&#123;</span><br><span class="line">    CompletableFuture&lt;Channel&gt; cf = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">    bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener)future -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remainingRetries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> calculateRetryDelay(remainingRetries);</span><br><span class="line">                log.info(<span class="string">&quot;Retrying connection to &#123;&#125; in &#123;&#125; ms&quot;</span>, inetSocketAddress, delay);</span><br><span class="line">                eventLoopGroup.schedule(() -&gt; doConnectWithRetry(inetSocketAddress, remainingRetries - <span class="number">1</span>), delay, TimeUnit.MILLISECONDS); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Failed to connect to &#123;&#125; after &#123;&#125; retries&quot;</span>, inetSocketAddress, MAX_RETRIES);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;Connected to &#123;&#125; successfully&quot;</span>, inetSocketAddress);</span><br><span class="line">            cf.complete(future.channel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> cf.get();</span><br><span class="line">    channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;The client has been disconnected from server [&#123;&#125;].&quot;</span>, inetSocketAddress.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> channel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">calculateRetryDelay</span><span class="params">(<span class="type">int</span> remainingRetries)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">attempt</span> <span class="operator">=</span> MAX_RETRIES - remainingRetries + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>) (Math.pow(<span class="number">2</span>, attempt) * <span class="number">500</span>); <span class="comment">// 指数退避基础500ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后是</p>
<p><code>sendRpcRequest()</code> ：</p>
<p>根据requestMetadata获取channel对象<code>getChannel()</code>。</p>
<p><code>promise = DefaultPromise&lt;&gt;(channel.eventLoop());</code></p>
<p>获取sequenceId，将promise存入map，把rpcMessage写入channel（异步的）addListener。</p>
<p>对于timeout，使用 promise 的 await 方法。isSuccess 则调用 getNow() 返回响应结果 RpcMessage。</p>
<p><a href="#nettyserver">netty 服务端</a> </p>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="==proxy=="></a>==proxy==</h3><p>代理对象生成过程：</p>
<ol>
<li><p>首先需要一个得到代理对象的工厂类，里面有一个工厂方法返回的就是代理对象。</p>
</li>
<li><p>如何创建代理对象：</p>
<p>JDK：<code>Proxy.newInstance(目标接口类加载器, 目标接口的数组, 实现InvocationHandler接口的invoke方法)</code></p>
<p>CGLIB: <code>Enhancer.create(目标类, 实现MethodInterceptor接口的intercept方法)</code></p>
</li>
<li><p>记住 <code>invoke</code> 和 <code>intercept</code> 就是拿着 <code>method</code>和 <code>args</code>为所欲为，当然也可以在实现类自己加参数，工厂类自己也要加参数</p>
</li>
<li><p>如果你想得到代理对象，那么就调用工厂类的工厂方法。</p>
</li>
</ol>
<p>RPC 框架怎么做到像调用本地接口一样调用远端服务呢？这必须依赖动态代理来实现。需要创建一个代理对象，在代理对象中完成数据报文编码，然后发起调用发送数据给服务提供方，以此屏蔽 RPC 框架的调用细节。因为代理类是在运行时生成的，所以代理类的生成速度、生成的字节码大小都会影响 RPC 框架整体的性能和资源消耗，所以需要慎重选择动态代理的实现方案。动态代理比较主流的实现方案有以下几种：JDK 动态代理、Cglib、Javassist、ASM、Byte Buddy，我们简单做一个对比和介绍。</p>
<ul>
<li>JDK 动态代理。在运行时可以动态创建代理类，但是 JDK 动态代理的功能比较局限，代理对象必须实现一个接口，否则抛出异常。因为代理类会继承 Proxy 类，然而 Java 是不支持多重继承的，只能通过接口实现多态。JDK 动态代理所生成的代理类是接口的实现类，不能代理接口中不存在的方法。JDK 动态代理是通过反射调用的形式代理类中的方法，比直接调用肯定是性能要慢的。</li>
<li>Cglib 动态代理。Cglib 是基于 ASM 字节码生成框架实现的，通过字节码技术生成的代理类，所以代理类的类型是不受限制的。而且 Cglib 生成的代理类是继承于被代理类，所以可以提供更加灵活的功能。在代理方法方面，Cglib 是有优势的，它采用了 FastClass 机制，为代理类和被代理类各自创建一个 Class，这个 Class 会为代理类和被代理类的方法分配 index 索引，FastClass 就可以通过 index 直接定位要调用的方法，并直接调用，这是一种空间换时间的优化思路。</li>
<li>Javassist 和 ASM。二者都是 Java 字节码操作框架，使用起来难度较大，需要开发者对 Class 文件结构以及 JVM 都有所了解，但是它们都比反射的性能要高。Byte Buddy 也是一个字节码生成和操作的类库，Byte Buddy 功能强大，相比于 Javassist 和 ASM，Byte Buddy 提供了更加便捷的 API，用于创建和修改 Java 类，无须理解字节码的格式，而且 Byte Buddy 更加轻量，性能更好。</li>
</ul>
<h4 id="代理实例工厂"><a href="#代理实例工厂" class="headerlink" title="代理实例工厂"></a>代理实例工厂</h4><p>建立一个本地的代理对象缓存，不用每次都重新new代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientStubProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery discovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient rpcClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClientProperties properties;</span><br><span class="line">    <span class="comment">// 本地代理对象缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; proxyMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz, String version)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) proxyMap.computeIfAbsent(ServiceUtil.serviceKey(clazz.getName(), version), serviceName -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果目标类是一个接口或者 是 java.lang.reflect.Proxy 的子类 则默认使用 JDK 动态代理</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.isInterface() || Proxy.isProxyClass(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Proxy.newProxyInstance(clazz.getClassLoader(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;clazz&#125;, <span class="comment">// 注意，这里的接口是 clazz 本身（即，要代理的实现类所实现的接口）</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ClientStubInvocationHandler</span>(discovery, rpcClient, properties, serviceName));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 使用 CGLIB 动态代理</span></span><br><span class="line">                <span class="keyword">return</span> Enhancer.create(clazz, </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ClientStubMethodInterceptor</span>(discovery, rpcClient, properties, serviceName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h4><p>重写 MethodInterceptor 中的 intercept() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientStubMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient rpcClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClientProperties properties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> RemoteMethodCall.remoteCall(serviceDiscovery, rpcClient, serviceName, properties, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h4><p>重写 InvocationHandler 中的 invoke() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientStubInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient rpcClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClientProperties properties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> RemoteMethodCall.remoteCall(serviceDiscovery, rpcClient, serviceName, properties, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RemoteMethodCall-发起-RPC-的公共方法"><a href="#RemoteMethodCall-发起-RPC-的公共方法" class="headerlink" title="RemoteMethodCall 发起 RPC 的公共方法"></a>RemoteMethodCall 发起 RPC 的公共方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">remoteCall</span><span class="params">(ServiceDiscovery serviceDiscovery, RpcClient rpcClient, String serviceName, 	</span></span><br><span class="line"><span class="params">                                RpcClientProperties properties, Method method, Object[] args)</span>&#123;</span><br><span class="line">    <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageHeader</span>().build(properties.getSerialization());</span><br><span class="line">    <span class="comment">// 构建 RpcRequest: serviceName, methodName, parameterTypes, args</span></span><br><span class="line">    <span class="comment">// 构建 RpcMessage</span></span><br><span class="line">    <span class="comment">// 服务发现：得到负载均衡后返回的服务信息 serviceInfo</span></span><br><span class="line">    <span class="comment">// 根据 serviceInfo, properties, 与 rpcMessage 构建 RequestMetadata</span></span><br><span class="line">    <span class="comment">// client 调用 sendRpcRequest(rpcMetadata) 返回的 rpcMessage</span></span><br><span class="line">    <span class="comment">// rpcMessage 解包出 rpcResponse 提取 value 返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>服务端的Spring：</p>
<p>==需要按照是否有@RpcService注解进行 Bean 的注册。谁能注册？谁来执行注册？（手动实现Scanner以BeanDefinitionRegistrar），然后把被注解的bean加入本地缓存map，准备执行 RequestHandler== </p>
<p>客户端的Spring：</p>
<p>==所有的 bean 都已经注册并导入好了，唯一的问题是 RestController 里面，出现 HelloService 字段，需要将其进行替换为代理对象！== </p>
<h2 id="Spring-Bean-生命周期一览"><a href="#Spring-Bean-生命周期一览" class="headerlink" title="Spring Bean 生命周期一览"></a>Spring Bean 生命周期一览</h2><h3 id="IoC-容器启动过程"><a href="#IoC-容器启动过程" class="headerlink" title="==IoC 容器启动过程=="></a>==IoC 容器启动过程==</h3><ol>
<li><p>Spring IoC 启动入口：<code>AnnotationConfigApplicationContext</code> 或 Spring Boot 的 <code>SpringApplication.run(...)</code> </p>
</li>
<li><p>加载配置类（带 <code>@Configuration</code>、<code>@ComponentScan</code>、<code>@Import</code> 等注解）</p>
</li>
<li><p> <strong>扫描、注册阶段</strong> （由 <code>ClassPathBeanDefinitionScanner</code> 完成）</p>
</li>
</ol>
<ul>
<li>扫描被 <code>@ComponentScan</code> 指定的包</li>
<li>找到带注解的类（如 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code>）</li>
<li>解析为 <code>BeanDefinition</code>，使用 <code>BeanDefinitionRegistry</code> 将其注册进<code>beanDefinitionMap</code>还未创建对象。<ul>
<li>修改Bean定义：执行所有 <code>BeanFactoryPostProcessor</code> 的实现类（如 <code>PropertySourcesPlaceholderConfigurer</code>），允许对 <code>BeanDefinition</code> 进行修改（例如替换占位符）。</li>
<li><strong>提前实例化处理器</strong>：注册 <code>BeanPostProcessor</code> 实现类（如 <code>AutowiredAnnotationBeanPostProcessor</code>），这些处理器需在普通Bean之前初始化，以便后续处理其他Bean的创建。</li>
<li>初始化消息源以及事件广播器</li>
</ul>
</li>
</ul>
<ol start="4">
<li><p><strong>实例化阶段</strong>（容器对于单例且非懒加载的 Bean）</p>
<p>对每个要使用的 Bean：</p>
<ul>
<li><p>（主要是针对懒加载或者<code>Scope = prototype</code>）存在性检查：Scope判断（若为单例则检查到单例缓存）以及循环依赖判断（如果当前正在创建就从单例缓存获取原始对象）</p>
</li>
<li><p><strong>实例化</strong>：从 <code>BeanDefinitionRegistry</code> 获取<code> BeanDefinition</code>，包含类名、作用域、初始化方法等元数据。检查是否存在未满足的依赖（如通过<code>@DependsOn</code>指定的前置依赖，或者<code>@Order</code>加载顺序）最后<strong>实例化</strong>对象（通过反射或者工厂方法调用<code>Constructor</code>创建原始对象）</p>
</li>
<li><p><strong>依赖注入</strong>： <code>@Autowired/@Resource</code> 递归调用<code>getBean()</code>获取依赖bean，通过三级缓存（<code>singletonFactories</code>、<code>earlySingletonObjects</code>、<code>singletonObjects</code>）提前暴露对象引用，解决setter的循环依赖。设置好属性。</p>
</li>
<li><p>Aware 接口回调：如果实现了 <code>XXXAware</code> 接口，则通过 <code>setXXX</code> 注入容器底层信息。如名称，类加载器等</p>
</li>
<li><p><code>BeanPostProcessor</code>: 每个bean在构建的过程中，Spring都会遍历所有的<code>BeanPostProcessor</code>的实现类，调用实现类中的方法，入参为构建好的bean。要实现无感的对bean的处理必须使用 <code>BeanPostProcessor</code>。</p>
<table>
<thead>
<tr>
<th>方法（按照先后顺序）</th>
<th>方法所属</th>
</tr>
</thead>
<tbody><tr>
<td>1. <code>Object postProcessBeforeInitialization()</code></td>
<td><code>BeanPostProcessor</code></td>
</tr>
<tr>
<td>2. <code>@PostConstruct</code> 标注的方法</td>
<td>JSR-250 规定</td>
</tr>
<tr>
<td>3. <code>void afterPropertiesSet()</code></td>
<td><code>InitializingBean</code></td>
</tr>
<tr>
<td>4. <code>init()</code></td>
<td><code>@Bean (initMethod =  init)</code></td>
</tr>
<tr>
<td>5. <code>Object postProcessAfterInitialization()</code></td>
<td><code>BeanPostProcessor</code></td>
</tr>
</tbody></table>
<p> <strong>5 是 AOP 动态代理的关键阶段</strong>：Spring 在这里可能会返回代理对象替代原对象</p>
</li>
</ul>
</li>
<li><p><strong>完成容器启动</strong>：触发 <code>ContextRefreshedEvent</code>，通知监听器容器已就绪。<strong>此时可以通过 <code>getBean()</code> 获取单例 Bean</strong>，如果是懒加载或者<code>Scope = prototype</code>的则会在主动调用 <code>getBean()</code> 的时候才实例化。</p>
</li>
</ol>
<h3 id="Bean-生命周期"><a href="#Bean-生命周期" class="headerlink" title="Bean 生命周期"></a>Bean 生命周期</h3><ol>
<li><p>Bean 实例化(仅为构造出对象)</p>
<ul>
<li><strong>触发条件</strong>：①容器启动 ②首次请求 Bean 时 <code>getBean() 或者依赖注入</code>。</li>
<li><strong>方式</strong>：通过构造函数或工厂方法创建 Bean 的实例。</li>
<li><strong>异常</strong>：若依赖无法解析或构造函数抛出异常，Bean 创建失败。</li>
</ul>
</li>
<li><p>属性赋值 Populate Properties</p>
<ul>
<li><strong>依赖注入</strong>：通过 <code>@Autowired</code>、<code>@Resource</code>、XML 配置等方式注入属性。</li>
<li>**处理 <code>@Value</code>**：解析并注入 SpEL 表达式或占位符的值。</li>
</ul>
</li>
<li><p>Aware 接口回调 与 <code>BeanPostProcessor </code>前置处理、初始化、后置处理。</p>
</li>
<li><p>就绪状态</p>
<ul>
<li>Bean 完全初始化，可被应用程序使用。</li>
<li><strong>Singleton Bean</strong> 会被缓存，后续请求直接获取。</li>
<li><strong>Prototype Bean</strong> 每次请求创建新实例（无后续销毁步骤）。</li>
</ul>
</li>
<li><p>Bean 对象销毁回调</p>
<ul>
<li><p><code>@PreDestroy</code> JSR-250</p>
</li>
<li><p><code>destroy()-&gt;</code>  DisposableBean</p>
</li>
<li><p><code>close()</code> @Bean (destroyMethod =  close)</p>
</li>
</ul>
</li>
<li><p>Bean 对象销毁</p>
<ul>
<li><strong>触发条件</strong>：容器关闭时（如 <code>close()</code> 方法调用）。</li>
<li><strong>作用域影响</strong>：仅 Singleton Bean 会执行销毁回调，Prototype Bean 需手动清理。</li>
</ul>
</li>
</ol>
<h3 id="SpringBoot-启动"><a href="#SpringBoot-启动" class="headerlink" title="SpringBoot 启动"></a>SpringBoot 启动</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.run()</span><br><span class="line">    ├── 创建 SpringApplication</span><br><span class="line">    ├── prepareEnvironment</span><br><span class="line">    ├── createApplicationContext <span class="comment">// 创建应用上下文</span></span><br><span class="line">    ├── refresh() <span class="comment">// AbstractApplicationContext#refresh() 方法 启动 IOC 容器</span></span><br><span class="line">        ├── postProcessBeanFactory(beanFactory)</span><br><span class="line">        ├── prepareBeanFactory(beanFactory)</span><br><span class="line">        ├── invokeBeanFactoryPostProcessors(beanFactory)</span><br><span class="line">        ├── registerBeanPostProcessors, initMessageSource/initEventMulticaster </span><br><span class="line">        ├── onRefresh (Web容器启动)</span><br><span class="line">        ├── registerListeners</span><br><span class="line">        ├── finishBeanFactoryInitialization <span class="comment">// 初始化所有非懒加载单例 Bean </span></span><br><span class="line">        └── finishRefresh (发布ContextRefreshedEvent)</span><br><span class="line">    ├── 调用 CommandLineRunner.run(String... args) ApplicationRunner(String... args)</span><br><span class="line">    └── ApplicationReady</span><br></pre></td></tr></table></figure>

<p><a href="#boot">由此可见 CommandLineRunner 是在容器启动完成以后执行的。可以实现这个接口的 run 方法来注入参数。</a></p>
<h2 id="Spring-扫描自定义注解"><a href="#Spring-扫描自定义注解" class="headerlink" title="Spring 扫描自定义注解"></a>Spring 扫描自定义注解</h2><h3 id="RpcComponentScan-：扫描、注册-RpcService的类，实例化时将其加入本地缓存"><a href="#RpcComponentScan-：扫描、注册-RpcService的类，实例化时将其加入本地缓存" class="headerlink" title="@RpcComponentScan ：扫描、注册@RpcService的类，实例化时将其加入本地缓存"></a><code>@RpcComponentScan</code> ：扫描、注册<code>@RpcService</code>的类，实例化时将其加入本地缓存</h3><p>扫描、注册的具体过程：</p>
<ol>
<li>扫描到 <code>@Configuration</code> 配置类，又扫到了 <code>@Import(RpcBeanDefinitionRegistrar.class)</code> </li>
<li>通过 <code>RpcBeanDefinitionRegistrar</code> 的 <code>registerBeanDefinitions(AnnotationMetadata data, BeanDefinitionRegistry registry)</code> 进行动态注册，其中 <code>data</code> 参数为被@Import注解 的类（这里是注解<code>@RpcComponentScan</code>）解析出要扫描的包路径，<code>registry</code> 为注册bean的核心。在里面 new 一个 <code>RpcClassPathBeanDefinitionScanner(registry, RpcService.class)</code> 在其构造函数里添加针对 RpcService.class 的 TypeFilter。</li>
<li>设置好 scanner 的 <code>resourceloader</code>，增强代码健壮性。调用 scanner 的 <code>scan(basePackages)</code> 方法，此方法会在内部调用 scanner 的 <code>registry</code> 进行 bean 的注册。</li>
</ol>
<h4 id="定义-BeanDefinition-扫描器"><a href="#定义-BeanDefinition-扫描器" class="headerlink" title="定义 BeanDefinition 扫描器"></a>定义 BeanDefinition 扫描器</h4><blockquote>
<p><code>ClassPathBeanDefinitionScanner</code> 是 Spring 框架中的一个类，用于从指定的类路径中扫描符合条件的类，并将其注册为 Spring 容器中的 Bean 定义。</p>
<p>主要功能：</p>
<ul>
<li>扫描类路径：根据指定的包路径，扫描类路径下的所有类。</li>
<li>过滤条件：通过过滤器（如注解过滤器、类型过滤器等）筛选出符合条件的类。</li>
<li>注册 Bean 定义：将符合条件的类的元信息（<code>BeanDefinition</code>）注册到 Spring 容器中。<strong>核心：<code>BeanDefinitionRegistry</code></strong> </li>
</ul>
<p>核心用途：</p>
<ul>
<li>用于实现自定义注解扫描和动态注册 Bean。</li>
<li>常见于 Spring 的扩展机制中，例如自定义注解的扫描器。</li>
</ul>
<p>工作流程：</p>
<ol>
<li><p>指定需要扫描的包路径<code>basePackages</code>。</p>
</li>
<li><p>配置过滤器（如只扫描带有特定注解的类）。 <code>addIncludeFilter(TypeFilter tf)</code> </p>
</li>
<li><blockquote>
<p>TypeFilter 接口需要实现<code>boolean match(MetadataReader reader, MetadataReaderFactory factory)</code> </p>
</blockquote>
</li>
<li><p>调用 <code>scan(String... basePackages)</code> 方法，扫描并注册符合条件的类。</p>
</li>
</ol>
</blockquote>
<p><code>RpcClassPathBeanDefinitionScanner</code> 继承了 <code>ClassPathBeanDefinitionScanner</code> </p>
<p>构造函数调用 <code>this.addIncludeFilter(new AnnotationTypeFilter(this.annotationType));</code> 注册想要扫描的注解类。通过 父类的 scan 方法扫包</p>
<hr>
<h4 id="使用-Import-注解结合-Registrar-动态注册-BeanDefinition"><a href="#使用-Import-注解结合-Registrar-动态注册-BeanDefinition" class="headerlink" title="使用 @Import 注解结合 Registrar 动态注册 BeanDefinition"></a>使用 @Import 注解结合 Registrar 动态注册 BeanDefinition</h4><blockquote>
<p><code>@Import</code>注解</p>
<ul>
<li>Allows for importing <code>@Configuration</code> classes, <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ImportSelector.html"><code>ImportSelector</code></a> and <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ImportBeanDefinitionRegistrar.html"><code>ImportBeanDefinitionRegistrar</code></a> implementations, as well as regular <strong>component</strong> classes</li>
</ul>
<p><strong>将一个类或多个类注入到 Spring 的 IOC 容器中</strong>，等价于在配置类中手动用 <code>@Bean</code> 或 <code>@ComponentScan</code> 注册。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250423120651325.png" alt="三种等价的导入方式" style="zoom: 35%;" />

<p><code>ImportBeanDefinitionRegistrar</code>   它通常与 <code>@Import</code> 注解一起使用，允许开发者在 Spring 容器启动时通过编程方式向容器中动态注册 Bean。</p>
<ul>
<li>动态注册 Bean：通过实现 <code>ImportBeanDefinitionRegistrar</code>接口，可以在运行时根据需要向 Spring 容器中注册 Bean。</li>
<li>扩展 Spring 配置：允许开发者在 Spring 的配置阶段插入自定义逻辑，动态调整 Bean 的定义和注册。</li>
</ul>
<p><code>ImportSelector</code> 例如 <code>AutoConfigurationImportSelector</code> 实现自动装配的核心</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(MyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableMyFeature &#123;&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(</span></span><br><span class="line"><span class="params">            AnnotationMetadata importingClassMetadata, // 被<span class="meta">@Import</span>注解的类，这里是 EnableMyFeature 接口的信息（关键）</span></span><br><span class="line"><span class="params">            BeanDefinitionRegistry registry  // 用于注册 Bean 定义的注册表，开发者可以通过它向容器中动态添加 Bean</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(MyService.class);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;myService&quot;</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMyFeature</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上，相当于在底层手动注册了一个类到IoC容器中。</p>
<p>Spring 的 <code>ConfigurationClassPostProcessor</code> 在处理 <code>@Import</code> 时，<strong>会检查被导入的类是否实现了 <code>Aware</code> 接口（如 <code>EnvironmentAware</code>、<code>ResourceLoaderAware</code>、<code>BeanFactoryAware</code> 等）</strong>，并会调用对应的方法注入你需要的对象（resourceLoader environment beanFactoryAware）等。为了以防万一，让自定义的Registerar实现ResourceLoaderAware，重写其setLoader，设置好scanner以后再扫描</p>
</blockquote>
<p>自定义 Rpc 组件扫描注解<br><code>RpcComponentScan</code> 注解用 <code>@Import</code> 引入了 <code>RpcBeanDefinitionRegistrar</code> 类，而这个类是一个 <code>ImportBeanDefinitionRegistrar</code> 的实现类， Spring 容器在解析该类型的 Bean 时会调用其 <code>importBeanDefRegistrar.registerBeanDefinitions(AnnotationMetadata, BeanDefinitionRegistry)</code> 方法， 将 <code>@RpcComponentScan</code> 注解上的信息提取成 <code>AnnotationMetadata</code> 以及容器注册器对象作为此方法的参数，这个就是自定义注解式组件扫描的关键逻辑。</p>
<p>metadata.getAnnotationAttributes(RpcComponent.class.getName()) 返回 RpcComponent 注解的属性和值(basePackages)，是一个map。从attributes中提取basePackages的值。未指定则扫描被注解类所在的包。随后构建一个扫描器，添加针对自定义注解的过滤器，开始扫描（注册）</p>
<hr>
<h4 id="Bean-处理器"><a href="#Bean-处理器" class="headerlink" title="Bean 处理器"></a>Bean 处理器</h4><p>@RpcService 注解</p>
<p><code>RpcServerBeanPostProcessor</code> 实现了 BeanPostProcessor</p>
<p>有服务注册、RpcServer、以及RpcServerProperties 3个字段。</p>
<p><code>public Object postProcessAfterInitialization(Object bean, String beanName)</code> 重写此方法配置好服务 Bean： 如果当前的bean被RpcService注解标注（也就是服务类的实现类），获取其注解的值，得到其暴露的接口的对象，由此得到接口名字，和版本拼接形成服务名，再根据properties配置构建好 ServiceInfo，<strong>然后进行服务注册，在本地缓存map加入服务bean</strong>.</p>
<p>还实现了 CommandLineRunner：新开一个线程启动服务器，增加关闭勾子强制清除注册中心的连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; rpcServer.start(properties.getPort())).start();</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当服务关闭之后，将服务从 注册中心 上清除（关闭连接）</span></span><br><span class="line">            serviceRegistry.destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RpcReference：利用反射把-Bean-的字段替换成代理对象"><a href="#RpcReference：利用反射把-Bean-的字段替换成代理对象" class="headerlink" title="@RpcReference：利用反射把 Bean 的字段替换成代理对象"></a><code>@RpcReference</code>：利用反射把 Bean 的字段替换成代理对象</h3><p>定义了<strong>接口类型</strong>、版本号、<strong>负载均衡</strong>、<strong>超时时间</strong>、mock，可以在字段、方法、注解上面使用</p>
<p>自动配置：除去负载均衡、服务发现、客户端类型，还有<strong>代理工厂</strong>、RpcClientBeanPostProcessor、RpcClientExitDisposableBean（这些都是需要注入 bean 的参数的）</p>
<p>客户端这边唯一的问题是 RestController 里面，出现 HelloService 字段，需要将其进行替换为代理对象。</p>
<p>如果字段被 @RpcReference 注解，那么就从注解中提取相关信息（接口全限定名+版本号），交给代理工厂生产代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line">    <span class="comment">// 遍历所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="comment">// 判断是否被 RpcReference 注解标注</span></span><br><span class="line">        <span class="keyword">if</span> (field.isAnnotationPresent(RpcReference.class)) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);<span class="comment">// 关闭安全检查 因为是 private</span></span><br><span class="line">            field.set(bean, proxy); <span class="comment">// 设置域的值为代理对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SpringBoot-自动装配：自动装配框架内部的-Bean"><a href="#SpringBoot-自动装配：自动装配框架内部的-Bean" class="headerlink" title="SpringBoot 自动装配：自动装配框架内部的 Bean"></a>SpringBoot 自动装配：自动装配框架内部的 Bean</h2><p>自动装配基于自动装配类，所以要把所有的bean都用bean方法的形式注册到容器中。</p>
<p>包括之前讲的 服务发现、服务注册、代理工厂、BeanPostProcessor、ConfigurationProperties等。</p>
<p>Bean 方法不需要使用Autowired在参数上注解！！！！</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html">SpringBoot 自动装配原理详解</a> </p>
<p>自动装配可以简单理解为：<strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p>
<ul>
<li>没有 Spring Boot 的时候，我们写一个 RestFul Web 服务，还首先需要自己写 Configuration 配置类，写 Bean 方法。</li>
<li>但有了 SpringBoot，只需要引入依赖，启动 SpringBootApplication 即可。</li>
</ul>
<blockquote>
<p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SpringBoot 2.x  在 META-INF/spring.factories </span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.example.rpc.RpcServerAutoConfiguration</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># SpringBoot 3 在 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</span></span><br><span class="line"><span class="attr">com.example.rpc.RpcServerAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。</p>
</blockquote>
<h3 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h3><p>机制核心 @EnableAutoConfiguration (@SpringBootApplication 的一部分) </p>
<p>底层通过 @Import(AutoConfigurationImportSelector.class) 加载所有自动配置类（通过 spring.factories 找到） 这个ImportSelector很重要，通过 selectImport</p>
<p>方法扫描获取所有符合条件的类的全限定类名，将这些类注册到 IoC 容器。核心调用路径如下：</p>
<p><code>selectImport-&gt;getAutoConfigurationEntry-&gt;getCandidateConfigurations-&gt;SpringFactoriesLoader.loadFactoryNames-&gt;loadSpringFactories</code> 不光是这个依赖下的<code>META-INF/spring.factories</code>被读取到，所有 Spring Boot Starter 下的<code>META-INF/spring.factories</code>都会被读取到。后边会根据条件进行逐层筛选。</p>
<h3 id="示例-创建-starter"><a href="#示例-创建-starter" class="headerlink" title="示例 创建 starter"></a>示例 创建 starter</h3><blockquote>
<p>引入 starter-validation</p>
<p>@Validated注解加到类上，下面这些注解可以用到 字段、参数</p>
<p>@NotBlank @Email  @Min(1)  @Max(91)</p>
<p>@Pattern(regexp = “^[a-zA-Z0-9]{8,16}$”,message = “用户名只能是长度在8至16”      + “之间的包含数字和大小写字母的字符串”)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;rpc.server&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String address;<span class="keyword">private</span> Integer port;<span class="keyword">private</span> String appName;</span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;zookeeper|nacos&quot;, message = &quot;必须是 nacos或者zookeeper&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String registry;</span><br><span class="line">    <span class="keyword">private</span> String transport;<span class="keyword">private</span> String registryAddr;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcServerProperties</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        <span class="built_in">this</span>.port = <span class="number">8080</span>;</span><br><span class="line">        <span class="built_in">this</span>.appName = <span class="string">&quot;provider-1&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.registry = <span class="string">&quot;zookeeper&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.transport = <span class="string">&quot;netty&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.registryAddr = <span class="string">&quot;127.0.0.1:2181&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pojo 类 + @ConfigurationProperties注解，可在 application.yml 中按照前缀配置属性。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rpc.server.app-name</span>=<span class="string">provider-1</span></span><br><span class="line"><span class="attr">rpc.server.port</span>=<span class="string">9991</span></span><br><span class="line"><span class="attr">rpc.server.registry</span>=<span class="string">zookeeper</span></span><br><span class="line"><span class="attr">rpc.server.registry-addr</span>=<span class="string">39.108.66.202:2181</span></span><br><span class="line"><span class="attr">rpc.server.transport</span>=<span class="string">netty</span></span><br><span class="line"><span class="comment"># 设置指定包下的日志显示级别 INFO/DEBUG/WARNING/OFF</span></span><br><span class="line"><span class="attr">logging.level.com.wxy.rpc</span>=<span class="string">info</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@ConditionalOnProperty</code></td>
<td>属性Property，满足一定的条件才生效</td>
</tr>
<tr>
<td><code>@ConditionalOnMissingBean</code></td>
<td>只有没有这个类型的 Bean 时才生效 (用户自定义实现了Bean方法，可以替换这个自动装配的)</td>
</tr>
<tr>
<td><code>@ConditionalOnClass</code></td>
<td>类路径下有某个类才生效</td>
</tr>
<tr>
<td><code>@ConditionalOnBean</code></td>
<td>依赖的 Bean 存在才生效</td>
</tr>
<tr>
<td><code>@Primary</code></td>
<td>多个同类的 Bean 存在时首选注入</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RpcServerProperties.class)</span> <span class="comment">// 绑定 pojo 作为 properties</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerAutoConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RpcServerProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;registry&quot;, havingValue = &quot;zookeeper&quot;, matchIfMissing = true)</span><span class="comment">// property 的 registry 字段的 value = zookeeper 才生效，如果配置项不存在也会生效</span></span><br><span class="line">    <span class="keyword">public</span> ServiceRegistry <span class="title function_">serviceRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(properties.get)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZookeeperServiceRegistry</span>(properties.getRegistryAddr());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;registry&quot;, havingValue = &quot;nacos&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceRegistry <span class="title function_">nacosServiceRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosServiceRegistry</span>(properties.getRegistryAddr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(&#123;ServiceRegistry.class, RpcServer.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServerBeanPostProcessor <span class="title function_">rpcServerBeanPostProcessor</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Autowired</span> ServiceRegistry serviceRegistry,</span></span><br><span class="line"><span class="params">		<span class="meta">@Autowired</span> RpcServer rpcServer,</span></span><br><span class="line"><span class="params">        <span class="meta">@Autowired</span> RpcServerProperties properties)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcServerBeanPostProcessor</span>(serviceRegistry, rpcServer, properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：添加 <code>spring-boot-starter-data-redis</code> 后，可直接注入 <code>RedisTemplate</code>。</p>
<table>
<thead>
<tr>
<th align="left">特征</th>
<th align="left">Starter 模块</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>命名</strong></td>
<td align="left">以 <code>-spring-boot-starter</code> 结尾</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">包含 <code>spring-boot-autoconfigure</code></td>
</tr>
<tr>
<td align="left"><strong>自动配置</strong></td>
<td align="left">有 <code>@AutoConfiguration</code> 类，并注册到 <code>spring.factories</code> 或 <code>AutoConfiguration.imports</code></td>
</tr>
<tr>
<td align="left"><strong>配置属性</strong></td>
<td align="left">包含 <code>@ConfigurationProperties</code> 类</td>
</tr>
<tr>
<td align="left"><strong>功能入口</strong></td>
<td align="left">提供开箱即用的 Bean，无需用户手动配置。可通过 <code>application.properties</code> 或 <code>@Bean</code> 覆盖 Starter 的默认配置。</td>
</tr>
</tbody></table>
<ol>
<li><p>实现自动配置类 AutoConfiguration </p>
</li>
<li><p>按照 SpringBoot 版本将配置类的全限定名引入指定路径下。</p>
</li>
<li><p>新建 starter 模块，添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 必须依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可选：配置注解处理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 你的模块核心实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-server-spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>操作系统：Windows + Linux</li>
<li>集成开发工具：IntelliJ IDEA</li>
<li>项目技术栈：SpringBoot 2.5.2 + JDK 1.8 + Netty 4.1.65.Final</li>
<li>项目依赖管理工具：Maven 4.0.0</li>
<li>注册中心：Zookeeeper 3.7.1</li>
</ul>
<h2 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h2><ul>
<li>启动 Zookeeper 服务器：进入到zk的bin目录，输入命令 <code>./zkServer.sh</code></li>
<li>启动 provider 模块 ProviderApplication</li>
<li>启动 consumer 模块 ConsumerApplication</li>
<li>测试：浏览器输入 <a target="_blank" rel="noopener" href="http://localhost:8080/hello/zhangsan">http://localhost:8080/hello/zhangsan</a> ，成功返回：<code>hello, zhangsan</code>，rpc 调用成功。</li>
<li>调用接口 100 次耗时 26ms，调用 10_0000 次耗时 25164 ms。</li>
</ul>
<h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p><strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/434083702">JMH</a></strong></p>
<p><code>JMH</code>即<code>Java Microbenchmark Harness</code>，是<code>Java</code>用来做基准测试的一个工具，该工具由<code>OpenJDK</code>提供并维护，测试结果可信度高。</p>
<p>相对于 Jmeter、ab ，它通过编写代码的方式进行压测，在特定场景下会更能评估某项性能。</p>
<p>本次通过使用 JMH 来压测 RPC 的性能（官方也是使用JMH压测）</p>
<p>启动 10000 个线程同时访问 sayHello 接口，总共进行 3 轮测试，测试结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Benchmark                                          Mode     Cnt      Score       Error  Units</span><br><span class="line">BenchmarkTest.testSayHello                        thrpt       3  29288.573 ± 20780.318  ops/s</span><br><span class="line">BenchmarkTest.testSayHello                         avgt       3      0.532 ±     6.159   s/op</span><br><span class="line">BenchmarkTest.testSayHello                       sample  395972      0.382 ±     0.002   s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.00    sample              0.003               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.50    sample              0.318               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.90    sample              0.387               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.95    sample              0.840               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.99    sample              2.282               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.999   sample              2.470               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.9999  sample              2.496               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p1.00    sample              2.508               s/op</span><br><span class="line">BenchmarkTest.testSayHello                           ss       3      0.118 ±     0.051   s/op</span><br></pre></td></tr></table></figure>

<p>测试曲线图：</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/rpc10000并发测试结果.png">

<p>同时，在同样的条件下，启动 5000（1w个电脑会卡死） 个线程同时对 <strong>Dubbo2.7.14</strong> 发起 RPC 调用，得到的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Benchmark                                       Mode     Cnt      Score      Error  Units</span><br><span class="line">StressTest.testSayHello                        thrpt       3  41549.866 ± 9703.455  ops/s</span><br><span class="line">StressTest.testSayHello                         avgt       3      0.119 ±    0.034   s/op</span><br><span class="line">StressTest.testSayHello                       sample  611821      0.123 ±    0.001   s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.00    sample              0.042              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.50    sample              0.119              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.90    sample              0.129              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.95    sample              0.139              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.99    sample              0.195              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.999   sample              0.446              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.9999  sample              0.455              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p1.00    sample              0.456              s/op</span><br><span class="line">StressTest.testSayHello                           ss       3      0.058 ±    0.135   s/op</span><br></pre></td></tr></table></figure>



<p><strong>结果</strong>：<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/dubbo5000并发测试结果.png"></p>
<table>
<thead>
<tr>
<th></th>
<th>RPC</th>
<th>RPC</th>
<th>Dubbo2.7.14</th>
</tr>
</thead>
<tbody><tr>
<td>并发数</td>
<td>10000</td>
<td>5000</td>
<td>5000</td>
</tr>
<tr>
<td>TPS</td>
<td>29288</td>
<td>31675</td>
<td>41549</td>
</tr>
<tr>
<td>RTT</td>
<td>95% 8ms</td>
<td>xxx</td>
<td>95% 50ms</td>
</tr>
<tr>
<td>AVGTime/OP</td>
<td>0.532</td>
<td>0.532</td>
<td>0.119</td>
</tr>
<tr>
<td>OOM</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<p>对比了 jmeter、Apache-Benmark（ab）、jmh 这三个压测工具，个人比较推荐使用jmh，原因有：</p>
<ul>
<li>jmh压测简单，只需要引入依赖，声明注解</li>
<li>准确性高，目前大多数性能压测都是使用jmh</li>
<li>缺点就是代码入侵</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/31/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/31/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">并发集合框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-31 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-31T00:00:00+08:00">2024-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 11:20:46" itemprop="dateModified" datetime="2025-04-26T11:20:46+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="并发安全-Map"><a href="#并发安全-Map" class="headerlink" title="并发安全 Map"></a>并发安全 Map</h2><p><strong><code>ConcurrentSkipListMap</code></strong> : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="JDK-1-7-Segment-ReentrantLock"><a href="#JDK-1-7-Segment-ReentrantLock" class="headerlink" title="JDK 1.7: Segment(ReentrantLock)"></a>JDK 1.7: Segment(ReentrantLock)</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java7_concurrenthashmap.png" alt="Java7 ConcurrentHashMap 存储结构"></p>
<p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，</p>
<p>JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 继承自 <code>ReentrantLock</code>。每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p>
<ul>
<li><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</li>
<li><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 数组属于链表结构。</li>
</ul>
<p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>
<p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>
<p>JDK 1.7 最大并发度是 Segment 的个数，默认是 16</p>
<h4 id="JDK-1-8-Node-CAS-synchronized"><a href="#JDK-1-8-Node-CAS-synchronized" class="headerlink" title="JDK 1.8: Node+CAS+synchronized"></a>JDK 1.8: Node+CAS+synchronized</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构"></p>
<p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是==直接用 <code>Node</code>== 数组+链表+红黑树的数据结构来实现，并发控制使用 ==<code>synchronized</code> 和 CAS== 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
<p>JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p>
<ul>
<li><p>每个 <strong>桶（bucket）</strong> 对应一个链表或红黑树，用于解决<strong>哈希冲突</strong>。</p>
</li>
<li><p>如果链表长度超过一定阈值（默认为 8），链表会自动转换为<strong>红黑树</strong>，提高查询效率。</p>
</li>
<li><p>红黑树的情况需要使用 **<code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树。<code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p>
</li>
</ul>
<p>JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p>
<p><strong>链表的线程安全性</strong> </p>
<p>在 <strong>ConcurrentHashMap</strong> 中，链表本身不是直接加锁的，而是通过更细粒度的<strong>CAS（Compare-And-Swap）机制</strong>和<strong>自旋锁</strong>来保证线程安全：</p>
<ol>
<li><strong>插入节点</strong>时通过 CAS 更新表头或表尾。</li>
<li><strong>查询节点</strong>时允许并发读操作，而不会阻塞其他线程。</li>
<li><strong>扩容操作</strong>采用链表迁移的方式，通过分段迁移减少阻塞时间。</li>
</ol>
<h4 id="不保证复合操作原子性"><a href="#不保证复合操作原子性" class="headerlink" title="不保证复合操作原子性"></a>不保证复合操作原子性</h4><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！</p>
<p>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作，例如先判断某个键是否存在<code>containsKey(key)</code>，然后根据结果进行插入或更新<code>put(key, value)</code>。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低</p>
<h2 id="并发安全-List"><a href="#并发安全-List" class="headerlink" title="并发安全 List"></a>并发安全 List</h2><h3 id="线程不安全-ArrayList"><a href="#线程不安全-ArrayList" class="headerlink" title="线程不安全 ArrayList"></a>线程不安全 ArrayList</h3><p>我们通常使用的ArrayList就是线程不安全的，举个简单的例子</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestList</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并发修改异常</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;4&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">   at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">   at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">   at java.util.AbstractCollection.toString(AbstractCollection.java:<span class="number">461</span>)</span><br><span class="line">   at java.lang.String.valueOf(String.java:<span class="number">2994</span>)</span><br><span class="line">   at java.io.PrintStream.println(PrintStream.java:<span class="number">821</span>)</span><br><span class="line">   at com.hnguigu.<span class="keyword">unsafe</span>.TestList.lambda$main$<span class="number">0</span>(TestList.java:<span class="number">20</span>)</span><br><span class="line">   at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案，有以下几种！</strong></p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">concurrent</span>.<span class="property">CopyOnWriteArrayList</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestList</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * 1. List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                list.<span class="title function_">add</span>(<span class="variable constant_">UUID</span>.<span class="title function_">randomUUID</span>().<span class="title function_">toString</span>().<span class="title function_">substring</span>(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(list);</span><br><span class="line">            &#125;,<span class="title class_">String</span>.<span class="title function_">valueOf</span>(i)).<span class="title function_">start</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种通用优化策略。</p>
<p>CopyOnWrite容器即写入时复制的容器。<strong>通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</strong>这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据。CopyOnWrite并发容器用于读多写少的并发场景。</p>
<blockquote>
<p>CopyOnWriteArrayList 比 Vector 厉害在哪里？</p>
</blockquote>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224114551267-580082797.png" alt="CopyOnWrite"></p>
<p>CopyOnWriteArrayList底层采用了Lock锁，是JDK层面的，效率高！</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221223214340940-165732240.png" alt="VectorSource"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ul>
<li>CopyOnWriteArrayList 并发安全且性能比 Vector 好。Vector 是增删改查方法都加了synchronized 来保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而 CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于 Vector。</li>
<li>线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据一致性问题。这种实现只是保证数据的<strong>最终一致性</strong>，不能保证数据的<strong>实时一致性</strong>。在添加到拷贝数据而还没进行替换的时候，读到的仍然是旧数据。</li>
<li>内存占用问题。如果对象比较大，内存写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。 这个时候，我们应该考虑其他的容器，例如 ConcurrentHashMap。</li>
<li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点 多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种 操作分分钟引起故障。</li>
</ul>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector底层采用了Synchronized加锁的方式，保证了数据的安全性，但是效率低下！</p>
<p>解释一下：Synchronized是Java内置的机制，是JVM层面的，效率低是因为底层操作依赖于操作系统，操作系统切换线程要从用户态切换到内核态，花费很多时间。</p>
<h2 id="并发安全-Set"><a href="#并发安全-Set" class="headerlink" title="并发安全 Set"></a>并发安全 Set</h2><h3 id="线程不安全-HashSet"><a href="#线程不安全-HashSet" class="headerlink" title="线程不安全 HashSet"></a>线程不安全 HashSet</h3><p>Set和List同样是多线程下不安全的集合类，同样会报并发修改异常！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSet</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="keyword">set</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSet</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * set集合没有可替换的集合</span></span><br><span class="line"><span class="comment">         * 1. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 2. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;String&gt; <span class="keyword">set</span> = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="keyword">set</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和面试官谈到这里，一般都会问hashSet的底层实现原理。<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224125000674-1551081400.png" alt="hashSetSource"></p>
<p>底层其实就是用hashMap实现的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224125144809-649163275.png" alt="hashSetAdd"></p>
<p>HashSet底层使用了哈希表来支持的，特点：存储快 往HashSet添加元素的时候，HashSet会先调用元素的HashCode方法得到元素的哈希值，然后通过元素的哈希值经过异或移位等运算，就可以算出该元素在哈希表中的存储位置。如果算出的元素存储的位置目前没有任何元素存储，那么该元素可以直接存储在该位置上；如果算出的元素的存储位置上目前已经有了其他的元素，那么还会调用该元素的equals方法 ，与该位置的元素进行比较一次，如果过equals方法返回的是true，那么该位置上的元素就会被视为重复元素，不允许被添加，如果false，则允许添加。</p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><strong><code>BlockingQueue</code></strong> 是 Java 并发包（<code>java.util.concurrent</code>）中的一个接口，专门用于<strong>线程安全的生产者-消费者模型</strong>。它支持线程在队列为空或已满时自动阻塞，从而简化了多线程编程中的同步问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/arrayblockingqueue-class-diagram.png" alt="ArrayBlockingQueue 类图"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>线程安全：<ul>
<li>内部使用锁和条件变量（Condition）实现线程安全操作。</li>
</ul>
</li>
<li>阻塞机制：<ul>
<li>当队列为空时，获取元素的线程会被阻塞，直到队列中有可用元素。</li>
<li>当队列已满时，添加元素的线程会被阻塞，直到队列有空间。</li>
</ul>
</li>
<li>常用场景：<ul>
<li><strong>生产者-消费者模型</strong>，生产者向队列中添加数据，消费者从队列中取数据。</li>
<li>控制线程执行顺序或流量，避免资源争抢。</li>
</ul>
</li>
</ol>
<p><strong><code>BlockingQueue</code></strong> : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><code>ArrayBlockingQueue</code> </p>
<ul>
<li><strong>best performance</strong> </li>
<li>单lock 双condition 算法，必须显式设置容量</li>
<li>底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。</li>
</ul>
<p><code>LinkedBlockingQueue</code> / <code>LinkedBlockingDeque</code></p>
<ul>
<li>2 locks 2 conditions，默认Integer.MAX_VALUE</li>
<li>底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。</li>
</ul>
<p><code>SynchronousQueue</code></p>
<ul>
<li>每次插入操作必须等待一个取出操作，否则就会阻塞，适合高并发传递数据。</li>
<li>不允许null</li>
<li>本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。</li>
</ul>
<p><code>DelayQueue</code></p>
<ul>
<li>延时队列，只有到期的元素才能被取出，适合定时任务或延迟执行场景。</li>
<li>elements must implement <code>java.util.concurrent.Delayed</code> </li>
</ul>
<p><code>LinkedTransferQueue</code></p>
<ul>
<li>waits for consumer to consume the element (message passing need to be guaranteed)</li>
</ul>
<p><strong><code>ConcurrentLinkedQueue</code></strong> :</p>
<ul>
<li>高效的并发队列，使用链表实现。一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li>
</ul>
<p><code>PriorityBlockingQueue</code></p>
<ul>
<li>concurrent version of <code>PriorityQueue</code></li>
<li>无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</li>
<li>基于优先级堆实现的无界阻塞队列，元素按优先级排序，不保证 FIFO。</li>
</ul>
<h3 id="主要方法-put-take-offer-poll"><a href="#主要方法-put-take-offer-poll" class="headerlink" title="主要方法: put-take offer-poll"></a>主要方法: put-take offer-poll</h3><p>add、remove实际上是对offer的封装</p>
<ul>
<li><strong>插入元素：</strong><ul>
<li><code>put(E e)</code>：如果队列已满，阻塞等待空间。</li>
<li><code>offer(E e)</code>: 非阻塞插入<ul>
<li><code>offer(E e, long timeout, TimeUnit unit)</code>：带自旋的非阻塞插入</li>
</ul>
</li>
</ul>
</li>
<li><strong>取出元素：</strong> <ul>
<li><code>take()</code>：如果队列为空，阻塞等待数据。</li>
<li><code>poll()</code>: 非阻塞获取<ul>
<li><code>poll(long timeout, TimeUnit unit)</code>：带自旋的非阻塞获取</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查队列状态：</strong><ul>
<li><code>size()</code>：返回当前元素数量。</li>
<li><code>remainingCapacity()</code>：返回剩余可用空间。</li>
</ul>
</li>
<li>队列数据迁移<ul>
<li><code>int elemCount = queue.drainTo(list);</code></li>
<li> <code>drainTo</code> 会一次性将队列中所有元素存放到列表，如果队列中有元素，且成功存到 list 中则 <code>drainTo</code> 会返回本次转移到 list 中的元素数，若队列为空，<code>drainTo</code> 则直接返回 0</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    queue.put(i); <span class="comment">// 阻塞插入</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> queue.take(); <span class="comment">// 阻塞获取</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>实际上就是生产者——消费者模式的具体实现</p>
<p>加锁访问共享区域，阻塞使用的是和锁相关的condition条件变量，细化了等待条件</p>
<p>condition.await    condition.signal/signalAll   就是使用了这个细节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE <span class="number">8</span></span><br><span class="line"><span class="type">int</span> buffer[MAXSIZE];</span><br><span class="line"><span class="type">int</span> <span class="variable">fill_ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">use_ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">	fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> buffer[use_ptr];</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">cond_t notEmpty,notFull;</span><br><span class="line">mutex_t mutex;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == MAXSIZE)</span><br><span class="line">            cond_wait(&amp;notEmpty, &amp;mutex);</span><br><span class="line">    	put(i);</span><br><span class="line">        printf(<span class="string">&quot;producer:%d puts value:%d&quot;</span>, gettid(), i);</span><br><span class="line">        cond_signal((&amp;notFull);</span><br><span class="line">    	mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">            cond_wait(&amp;isEmpty, &amp;mutex);</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> get();</span><br><span class="line">        printf(<span class="string">&quot;pid:%d gets value:%d&quot;</span>, gettid(), value);</span><br><span class="line">        cond_signal(&amp;isFull);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                    </span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/26/Netty%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/26/Netty%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">Netty 最佳实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-26T00:00:00+08:00">2024-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 00:59:08" itemprop="dateModified" datetime="2025-04-26T00:59:08+08:00">2025-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerBestPractice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BOSS_THREADS</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">// 接收连接线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WORKER_THREADS</span> <span class="operator">=</span> <span class="number">8</span>;   <span class="comment">// 处理连接线程数（建议CPU核心数×2）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_CONNECTION</span> <span class="operator">=</span> <span class="number">1000</span>;<span class="comment">// 最大连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup bossGroup;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup workerGroup;</span><br><span class="line">    <span class="keyword">private</span> Channel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ConnectionCounterHandler</span> <span class="variable">connectionCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionCounterHandler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NettyServerBestPractice</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建线程组（根据系统选择Epoll）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">useEpoll</span> <span class="operator">=</span> Epoll.isAvailable();</span><br><span class="line">        bossGroup = createEventLoopGroup(BOSS_THREADS, <span class="string">&quot;ServerBoss&quot;</span>);</span><br><span class="line">        workerGroup = createEventLoopGroup(WORKER_THREADS, <span class="string">&quot;ServerWorker&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 配置ServerBootstrap</span></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(useEpoll ? EpollServerSocketChannel.class : NioServerSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))  <span class="comment">// Server端日志</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">                        configurePipeline(ch.pipeline());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 3. TCP参数配置</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)          <span class="comment">// 等待连接队列长度</span></span><br><span class="line">                .option(ChannelOption.SO_REUSEADDR, <span class="literal">true</span>)         <span class="comment">// 端口重用</span></span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)     <span class="comment">// 禁用Nagle算法</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)    <span class="comment">// 保活检测</span></span><br><span class="line">                .childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">WriteBufferWaterMark</span>(<span class="number">32</span> * <span class="number">1024</span>, <span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 绑定端口（带重试机制）</span></span><br><span class="line">        bindWithRetry(bootstrap, PORT, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 注册监控钩子</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::shutdownGracefully));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带重试的端口绑定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindWithRetry</span><span class="params">(ServerBootstrap bootstrap, <span class="type">int</span> port, <span class="type">int</span> retryCount)</span> &#123;</span><br><span class="line">        bootstrap.bind(port).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                serverChannel = future.channel();</span><br><span class="line">                System.out.printf(<span class="string">&quot;Server started on port %d (using %s)&quot;</span>,</span><br><span class="line">                        port, serverChannel.getClass().toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retryCount == <span class="number">0</span>) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Failed to bind after max retries: &quot;</span> + future.cause());</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.printf(<span class="string">&quot;Bind failed, retry %d... Cause: %s&quot;</span>,</span><br><span class="line">                        retryCount, future.cause().getMessage());</span><br><span class="line">                bootstrap.config().group().schedule(() -&gt; </span><br><span class="line">                        bindWithRetry(bootstrap, port, retryCount - <span class="number">1</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 管道配置（可扩展）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configurePipeline</span><span class="params">(ChannelPipeline pipeline)</span> &#123;</span><br><span class="line">        pipeline.addLast(<span class="string">&quot;connCounter&quot;</span>, connectionCounter)  <span class="comment">// 连接数统计</span></span><br><span class="line">                .addLast(<span class="string">&quot;logging&quot;</span>, <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG)) <span class="comment">// 连接级日志</span></span><br><span class="line">                .addLast(<span class="string">&quot;idleCheck&quot;</span>, <span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, TimeUnit.SECONDS))</span><br><span class="line">                .addLast(<span class="string">&quot;frameDecoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>*<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">                .addLast(<span class="string">&quot;business&quot;</span>, <span class="keyword">new</span> <span class="title class_">ServerBusinessHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优雅关闭（支持平滑重启）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">shutdownGracefully</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Initiating server shutdown...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 关闭顺序：ServerChannel -&gt; WorkerGroup -&gt; BossGroup</span></span><br><span class="line">        <span class="keyword">if</span> (serverChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">            serverChannel.close().syncUninterruptibly();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 先关闭WorkerGroup（处理现有连接）</span></span><br><span class="line">        <span class="keyword">if</span> (workerGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            workerGroup.shutdownGracefully(<span class="number">0</span>, <span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .addListener(f -&gt; logShutdownProgress(<span class="string">&quot;WorkerGroup&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 最后关闭BossGroup</span></span><br><span class="line">        <span class="keyword">if</span> (bossGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            bossGroup.shutdownGracefully(<span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .addListener(f -&gt; logShutdownProgress(<span class="string">&quot;BossGroup&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Current connections: &quot;</span> + connectionCounter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建优化的EventLoopGroup</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup <span class="title function_">createEventLoopGroup</span><span class="params">(<span class="type">int</span> threads, String namePrefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Epoll.isAvailable() ? </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">EpollEventLoopGroup</span>(threads, <span class="keyword">new</span> <span class="title class_">DefaultThreadFactory</span>(namePrefix)) :</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(threads, <span class="keyword">new</span> <span class="title class_">DefaultThreadFactory</span>(namePrefix));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logShutdownProgress</span><span class="params">(String component)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s shutdown %s%n&quot;</span>, component,</span><br><span class="line">                ((Future&lt;?&gt;)<span class="built_in">this</span>).isSuccess() ? <span class="string">&quot;success&quot;</span> : <span class="string">&quot;failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端业务处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ServerBusinessHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">            <span class="comment">// 业务处理逻辑</span></span><br><span class="line">            ctx.writeAndFlush(<span class="string">&quot;Server response&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Server error: &quot;</span> + cause.getMessage());</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> &#123;</span><br><span class="line">            <span class="comment">// 空闲连接关闭</span></span><br><span class="line">            <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Closing idle connection: &quot;</span> + ctx.channel());</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接数统计处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConnectionCounterHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelDuplexHandler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">connectionCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> connectionCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; MAX_CONNECTION) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Connection limit exceeded: &quot;</span> + count);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;New connection. Total: &quot;</span> + count);</span><br><span class="line">            ctx.fireChannelActive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> connectionCount.decrementAndGet();</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection closed. Remaining: &quot;</span> + count);</span><br><span class="line">            ctx.fireChannelInactive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> connectionCount.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="服务端关键设计说明"><a href="#服务端关键设计说明" class="headerlink" title="服务端关键设计说明"></a><strong>服务端关键设计说明</strong></h3><ol>
<li><p><strong>线程模型优化</strong></p>
<ul>
<li><strong>双线程组架构</strong>：BossGroup（接收连接） + WorkerGroup（处理IO）</li>
<li><strong>线程命名</strong>：使用<code>DefaultThreadFactory</code>明确线程用途</li>
<li><strong>Epoll提升性能</strong>：自动检测并启用Epoll（Linux）</li>
</ul>
</li>
<li><p><strong>连接管理</strong></p>
<ul>
<li><strong>连接数控制</strong>：通过<code>ConnectionCounterHandler</code>限制最大连接</li>
<li><strong>空闲检测</strong>：300秒无活动自动关闭连接</li>
<li><strong>平滑重启</strong>：先关闭接收新连接，再处理现存连接</li>
</ul>
</li>
<li><p><strong>资源管理</strong></p>
<ul>
<li><strong>关闭顺序</strong>：ServerChannel → WorkerGroup → BossGroup</li>
<li><strong>优雅关闭</strong>：允许正在处理的请求完成</li>
<li><strong>内存保护</strong>：通过<code>WriteBufferWaterMark</code>防止OOM</li>
</ul>
</li>
<li><p><strong>可观测性</strong></p>
<ul>
<li><strong>两级日志</strong>：ServerBootstrap级别 + 每个连接级别</li>
<li><strong>连接数监控</strong>：实时统计活跃连接</li>
<li><strong>关闭进度跟踪</strong>：记录各组件关闭状态</li>
</ul>
</li>
<li><p><strong>协议处理</strong></p>
<ul>
<li><strong>解决粘包</strong>：使用<code>LengthFieldBasedFrameDecoder</code></li>
<li><strong>扩展点设计</strong>：<code>configurePipeline()</code>方法允许子类扩展</li>
</ul>
</li>
<li><p><strong>可靠性增强</strong></p>
<ul>
<li><strong>端口绑定重试</strong>：自动重试最多3次</li>
<li><strong>异常熔断</strong>：连接数超限立即拒绝</li>
<li><strong>防雪崩</strong>：限制单个连接的内存使用</li>
</ul>
</li>
</ol>
<hr>
<h3 id="生产环境建议"><a href="#生产环境建议" class="headerlink" title="生产环境建议"></a><strong>生产环境建议</strong></h3><ol>
<li><p><strong>参数调优</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建议调整以下参数：</span></span><br><span class="line">.option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)       <span class="comment">// 根据QPS调整</span></span><br><span class="line">.childOption(ChannelOption.SO_RCVBUF, <span class="number">128</span> * <span class="number">1024</span>) <span class="comment">// 接收缓冲区</span></span><br><span class="line">.childOption(ChannelOption.SO_SNDBUF, <span class="number">128</span> * <span class="number">1024</span>) <span class="comment">// 发送缓冲区</span></span><br><span class="line">.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) <span class="comment">// 内存池</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>监控集成</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加指标采集</span></span><br><span class="line">pipeline.addLast(<span class="string">&quot;metrics&quot;</span>, <span class="keyword">new</span> <span class="title class_">MetricsHandler</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义监控Handler示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MetricsHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelDuplexHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Counter</span> <span class="variable">receivedMessages</span> <span class="operator">=</span> Metrics.counter(<span class="string">&quot;server.messages.received&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        receivedMessages.increment();</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>安全增强</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加SSL/TLS支持</span></span><br><span class="line">.childHandler(<span class="keyword">new</span> <span class="title class_">SslContextBuilder</span>()</span><br><span class="line">    .forServer(cert, key)</span><br><span class="line">    .build().newHandler(ByteBufAllocator.DEFAULT))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加IP白名单</span></span><br><span class="line">pipeline.addFirst(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientIP</span> <span class="operator">=</span> ((InetSocketAddress) ctx.channel().remoteAddress()).getHostString();</span><br><span class="line">        <span class="keyword">if</span> (!allowList.contains(clientIP)) &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>流量控制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局流量整形（10MB/s）</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> <span class="title class_">GlobalTrafficShapingHandler</span>(</span><br><span class="line">        workerGroup, <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="与客户端的对比差异"><a href="#与客户端的对比差异" class="headerlink" title="与客户端的对比差异"></a><strong>与客户端的对比差异</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>服务端</th>
<th>客户端</th>
</tr>
</thead>
<tbody><tr>
<td>线程模型</td>
<td>Boss+Worker双线程组</td>
<td>单EventLoopGroup</td>
</tr>
<tr>
<td>连接管理</td>
<td>需要处理大量并发连接</td>
<td>管理单个/少量连接</td>
</tr>
<tr>
<td>关闭顺序</td>
<td>ServerChannel→Worker→Boss</td>
<td>Channel→EventLoopGroup</td>
</tr>
<tr>
<td>协议处理</td>
<td>需要处理多种客户端协议</td>
<td>遵循服务端协议</td>
</tr>
<tr>
<td>性能优化重点</td>
<td>吞吐量、连接数</td>
<td>延迟、重连机制</td>
</tr>
<tr>
<td>典型配置</td>
<td>SO_BACKLOG、连接数限制</td>
<td>CONNECT_TIMEOUT、重试</td>
</tr>
<tr>
<td>安全需求</td>
<td>需防范DDoS、实现访问控制</td>
<td>处理证书认证</td>
</tr>
</tbody></table>
<hr>
<h3 id="典型问题解决方案"><a href="#典型问题解决方案" class="headerlink" title="典型问题解决方案"></a><strong>典型问题解决方案</strong></h3><ol>
<li><p><strong>TIME_WAIT过多</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用端口复用</span></span><br><span class="line">.option(ChannelOption.SO_REUSEADDR, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>内存泄漏检测</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动时配置（需增加开销）</span></span><br><span class="line">ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>处理慢客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加读超时限制</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ReadTimeoutHandler</span>(<span class="number">30</span>, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure></li>
<li><p><strong>定制线程模型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用自定义线程池处理耗时操作</span></span><br><span class="line"><span class="type">EventExecutorGroup</span> <span class="variable">businessGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>(<span class="number">16</span>);</span><br><span class="line">pipeline.addLast(businessGroup, <span class="string">&quot;asyncHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">AsyncBusinessHandler</span>());</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>以上实现涵盖Netty服务端的核心最佳实践，建议根据实际业务需求进行以下扩展：</p>
<ol>
<li><strong>协议层</strong>：添加认证/心跳机制</li>
<li><strong>管理层</strong>：实现HTTP管理端点查看连接状态</li>
<li><strong>可观测性</strong>：集成APM监控工具</li>
<li><strong>高可用</strong>：结合服务发现组件实现集群部署</li>
</ol>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>以下是Netty客户端建立连接的最佳实践示例代码，包含详细的注释和关键设计说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientBestPractice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RETRY</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 最大重试次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASE_DELAY</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// 基础重试延迟(ms)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isShuttingDown</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup workerGroup;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NettyClientBestPractice</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 配置线程组</span></span><br><span class="line">        workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); <span class="comment">// 建议根据业务调整线程数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 配置Bootstrap</span></span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        bootstrap.group(workerGroup)</span><br><span class="line">                .channel(NioSocketChannel.class) <span class="comment">// 根据OS选择Epoll</span></span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">3000</span>) <span class="comment">// 连接超时</span></span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>) <span class="comment">// TCP保活</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                        <span class="comment">// 3. 配置管道流水线</span></span><br><span class="line">                        ch.pipeline()</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO)) <span class="comment">// 日志</span></span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">ClientBusinessHandler</span>()); <span class="comment">// 业务处理器</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 异步连接（非阻塞）</span></span><br><span class="line">        connectWithRetry(bootstrap, HOST, PORT, MAX_RETRY);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 注册优雅关闭钩子</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::shutdownGracefully));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带指数退避的重连机制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connectWithRetry</span><span class="params">(Bootstrap bootstrap, String host, <span class="type">int</span> port, <span class="type">int</span> retry)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShuttingDown) <span class="keyword">return</span>;</span><br><span class="line">			</span><br><span class="line">            bootstrap.connect(host, port).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Connected to server!&quot;</span>);</span><br><span class="line">                channel = future.channel();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 6. 注册连接关闭监听</span></span><br><span class="line">                channel.closeFuture().addListener(closeFuture -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Connection closed, attempting reconnect...&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!isShuttingDown) &#123;</span><br><span class="line">                        connectWithRetry(bootstrap, host, port, MAX_RETRY);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retry == <span class="number">0</span>) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Connection failed after max retries: &quot;</span> + future.cause());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">attempt</span> <span class="operator">=</span> MAX_RETRY - retry + <span class="number">1</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.pow(<span class="number">2</span>, attempt) * <span class="number">500</span>);</span><br><span class="line">                System.err.printf(<span class="string">&quot;Connect failed, retry %d after %dms: %s\n&quot;</span>, </span><br><span class="line">                        retry, delay, future.cause().getMessage());</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 7. 定时重连（避免阻塞EventLoop）</span></span><br><span class="line">                bootstrap.config().group().schedule(() -&gt; </span><br><span class="line">                        connectWithRetry(bootstrap, host, port, retry - <span class="number">1</span>), </span><br><span class="line">                        delay, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优雅关闭（可被多次调用）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">shutdownGracefully</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShuttingDown) <span class="keyword">return</span>;</span><br><span class="line">        isShuttingDown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 关闭顺序：Channel -&gt; EventLoopGroup</span></span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123;</span><br><span class="line">            channel.close().addListener(future -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Channel closed successfully&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9. 优雅关闭线程组</span></span><br><span class="line">        <span class="keyword">if</span> (workerGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            workerGroup.shutdownGracefully(<span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">                    .addListener((GenericFutureListener&lt;Future&lt;? <span class="built_in">super</span> Void&gt;&gt;) future -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;EventLoopGroup shutdown complete&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示例业务处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClientBusinessHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection established, send auth packet&quot;</span>);</span><br><span class="line">            <span class="comment">// 连接建立后发送认证数据等业务逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">            <span class="comment">// 处理服务器响应</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Business exception: &quot;</span> + cause.getMessage());</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关键设计说明"><a href="#关键设计说明" class="headerlink" title="关键设计说明"></a><strong>关键设计说明</strong></h3><ol>
<li><p><strong>线程模型优化</strong></p>
<ul>
<li>使用独立的<code>EventLoopGroup</code>（推荐1-2线程）</li>
<li>禁止在 ChannelHandler 中执行阻塞操作</li>
</ul>
</li>
<li><p><strong>连接管理</strong></p>
<ul>
<li>内置指数退避重连机制（避免DDoS式重连）</li>
<li>连接关闭自动触发重连（通过<code>closeFuture</code>监听）</li>
<li>支持强制关闭标识<code>isShuttingDown</code> </li>
</ul>
</li>
<li><p><strong>资源管理</strong></p>
<ul>
<li>正确关闭顺序：Channel -&gt; EventLoopGroup</li>
<li>添加Shutdown Hook确保资源释放</li>
<li>使用<code>shutdownGracefully</code>避免强制中断</li>
</ul>
</li>
<li><p><strong>异常处理</strong></p>
<ul>
<li>连接失败时打印具体原因</li>
<li>业务层异常统一在<code>exceptionCaught</code>处理</li>
<li>重试机制记录每次失败原因</li>
</ul>
</li>
<li><p><strong>可观测性</strong></p>
<ul>
<li>内置<code>LoggingHandler</code>记录网络事件</li>
<li>关键节点添加状态日志</li>
</ul>
</li>
<li><p><strong>扩展性设计</strong></p>
<ul>
<li>通过<code>ChannelInitializer</code>灵活配置Pipeline</li>
<li>支持NIO/Epoll自动切换（通过系统属性）</li>
</ul>
</li>
</ol>
<hr>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a><strong>使用建议</strong></h3><ol>
<li><p><strong>生产环境配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建议设置TCP参数</span></span><br><span class="line">.option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">.option(ChannelOption.SO_REUSEADDR, <span class="literal">true</span>)</span><br><span class="line">.option(ChannelOption.WRITE_BUFFER_WATER_MARK, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WriteBufferWaterMark</span>(<span class="number">32</span> * <span class="number">1024</span>, <span class="number">64</span> * <span class="number">1024</span>))</span><br></pre></td></tr></table></figure></li>
<li><p><strong>连接池管理</strong></p>
<ul>
<li>高并发场景建议使用连接池</li>
<li>参考实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Channel&gt; pool = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> pool.poll();</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bootstrap.connect().sync().channel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>性能监控</strong></p>
<ul>
<li>添加MetricHandler统计QPS/延迟</li>
<li>使用Netty自带<code>ChannelTrafficShapingHandler</code></li>
</ul>
</li>
</ol>
<hr>
<h3 id="典型问题处理"><a href="#典型问题处理" class="headerlink" title="典型问题处理"></a><strong>典型问题处理</strong></h3><ol>
<li><p><strong>连接泄漏检测</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加空闲检测</span></span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">60</span>, TimeUnit.SECONDS))</span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>流量整形</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制发送速率（1MB/s）</span></span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ChannelTrafficShapingHandler</span>(<span class="number">1024</span> * <span class="number">1024</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></li>
<li><p><strong>协议设计建议</strong></p>
<ul>
<li>使用LengthFieldBasedFrameDecoder解决粘包</li>
<li>建议Protobuf/FlatBuffers等高效序列化</li>
</ul>
</li>
</ol>
<hr>
<p>以上实现遵循Netty最佳实践，具备生产级可靠性，可根据具体业务需求扩展调整。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/11/01/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/01/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Java 集合框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-01T00:00:00+08:00">2024-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 00:58:03" itemprop="dateModified" datetime="2025-04-26T00:58:03+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p>并发集合见 JUC</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-collection-hierarchy.png" alt="Java 集合框架概览"></p>
<h2 id="Collecion-单列"><a href="#Collecion-单列" class="headerlink" title="Collecion 单列"></a>Collecion 单列</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915133525868-1735477273565-35-1735477280164-37.png" alt="Collection"></p>
<ul>
<li><code>List</code>系列：添加元素有序，可重复，有索引<ul>
<li><code>ArrayList</code></li>
<li><code>LinkedList</code></li>
</ul>
</li>
<li><code>Set</code>系列：添加元素无序，不重复，无索引<ul>
<li><code>HashSet</code> 无序不重复无索引<ul>
<li><code>LinkedHashSet</code> 有序不重复无索引</li>
</ul>
</li>
<li><code>TreeSet</code> 按照大小默认升序排序 不重复 无索引</li>
</ul>
</li>
</ul>
<h3 id="Collection-Methods"><a href="#Collection-Methods" class="headerlink" title="Collection Methods"></a>Collection Methods</h3><ul>
<li><code>boolean add(E e)</code>  <code>boolean isEmpty()</code> <code>boolean remove(E e)</code> <code>boolean contains(Object o)</code> </li>
<li><code>void clear()</code> <code>int size()</code> </li>
<li><code>Object[] toArray()</code>:集合colletion转换成对象<strong>数组</strong> （返回Object数组是为了防止添加不同类型的对象）重载的<code>toArray(String[] strs)</code> 方法能够返回一个String数组<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914230120510.png" alt="toArray"></li>
<li><code>void addAll(Collections&lt;E&gt; c2)</code> <code>c1.addAll(c2)</code> 把c2的数据全部加入c1中</li>
</ul>
<h3 id="Collection-遍历"><a href="#Collection-遍历" class="headerlink" title="Collection 遍历"></a>Collection 遍历</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = collection.iterator();<span class="comment">//默认在第一个对象</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;<span class="comment">//判断迭代器是否能继续指向下一个</span></span><br><span class="line"> System.out.println(it.next()); <span class="comment">//迭代器返回现在指向的对象，之后指向下一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最好是一次<code>hasNext()</code>对应一次<code>next()</code></p>
<h4 id="for-Each增强循环"><a href="#for-Each增强循环" class="headerlink" title="for-Each增强循环"></a>for-Each增强循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; colle = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String name:colle)&#123;</span><br><span class="line">&#125;<span class="comment">//colle代表要遍历的集合名，name代表集合中每个元素的名字</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果等同于迭代器Iterator</p>
<h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">colle.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span>&#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">colle.forEach(s-&gt;System.out.println(s));</span><br><span class="line">colle.forEach(System.out::println);<span class="comment">//前后参数一样</span></span><br></pre></td></tr></table></figure>

<p>action已经实现了Consumer接口的accept方法</p>
<p>内部实现还是增强for循环，将colle集合中的元素t送到action的accept()处，相当于用元素t执行accept()方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914234023283.png" alt="forEach"></p>
<h3 id="List-支持索引"><a href="#List-支持索引" class="headerlink" title="List 支持索引"></a>List 支持索引</h3><p><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code> </p>
<ul>
<li><code>void add(int index, E e)</code>(add()重载)</li>
<li><code>E remove(int index)</code> 返回remove的数据</li>
<li><code>E get(int index)</code>返回指定索引的数据</li>
<li><code>E set(int index, E e)</code> 修改指定索引数据，返回原来的数据</li>
<li><code>List&lt;E&gt; sublist(int from, int to)</code> 返回一个list里面装有[from,to)部分的list</li>
</ul>
<h4 id="List-遍历"><a href="#List-遍历" class="headerlink" title="List 遍历"></a>List 遍历</h4><ul>
<li>for-Each-Loop Lambda Iterator</li>
<li>for循环（支持索引）</li>
</ul>
<h4 id="ArrayList-基于数组"><a href="#ArrayList-基于数组" class="headerlink" title="ArrayList 基于数组"></a>ArrayList 基于数组</h4><ul>
<li>基于<u><strong>数组</strong></u>实现 <strong>对象数组</strong> </li>
<li>查询速度快 (索引) O(1) 集合末端元素有时可以达到 O(1)</li>
<li>删除效率低，添加效率极低，基本都需要整体移动甚至扩容 都是 O(n) </li>
<li>有参构造：指定长度，不够再添</li>
</ul>
<p>适用场景：索引查询，数据量不大</p>
<p>数据量大还要频繁进行增删操作，不适合！</p>
<ol>
<li>动态扩容</li>
<li>创建指定大小</li>
<li>指定泛型，确保元素安全</li>
<li>线程不安全</li>
</ol>
<h5 id="ArrayList-扩容-源码分析：grow-int-minCapacity"><a href="#ArrayList-扩容-源码分析：grow-int-minCapacity" class="headerlink" title="ArrayList 扩容 源码分析：grow(int minCapacity)"></a>ArrayList <strong>扩容</strong> 源码分析：<code>grow(int minCapacity)</code></h5><p>三种创建方式：默认容量为 10</p>
<ol>
<li>空参：首先创建的是一个==空==数组 <em>懒加载的运用</em>   </li>
<li>参数为 n：创建==容量为n==的对象数组，0则创建空数组</li>
<li>参数为 collection：将 collection 的内容复制进入 新的 ArrayList 中</li>
</ol>
<ol>
<li>==无参构造，先使用一个长度为0的对象数组== <ul>
<li><code>Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</code></li>
</ul>
</li>
<li>==添加首个元素，创建长度为10的对象数组==  <ul>
<li><code>elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</code></li>
</ul>
</li>
<li>存满后，再添加时创建扩容1.5倍的数组，原内容加进去<ul>
<li><code>newCap = oldCap + oldCap &gt;&gt; 1</code></li>
<li> <code>Arrays.copyof(elementData,newCap)</code></li>
</ul>
</li>
<li>一次加多个元素，addAll，1.5 倍或者10个放不下，新创建数组长度以实际为准<code>minCapacity</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入一个元素，此时元素个数size = 0，存放元素的数组容量 length = 0，因此正好符合扩容条件：<code>grow(int minCapacity)</code> 对于普通的add，此处 <code>minCapacity = size + 1</code>，也就是现元素个数+1</p>
<p><strong>==扩容逻辑==</strong></p>
<p>空数组扩容到<code>max</code>[ ==10== , <code>minCapacity</code> ], <code>minCapacity</code>是用来应对<code>addAll()</code>的</p>
<p>非空数组扩容到==原来的1.5倍==，当然1.5倍导致溢出则扩容到minCapacity即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="comment">// 最小容量应为size+1, length为数组的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//当前大小</span></span><br><span class="line">    <span class="comment">// 1. 如果是无参构造就是空数组: DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || </span><br><span class="line">    	elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                minCapacity - oldCapacity, <span class="comment">/* minimum growth  */</span></span><br><span class="line">                oldCapacity &gt;&gt; <span class="number">1</span>  <span class="comment">/* preferred GROWTH 0.5倍 原长度*/</span>);</span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1.1 上面是空数组，那就是默认容量 10 和 size+1 进行比较 创建比较大的那个</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength,<span class="type">int</span> minGrowth,<span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line">    <span class="comment">// preconditions not checked because of inlining</span></span><br><span class="line">    <span class="comment">// assert oldLength &gt;= 0</span></span><br><span class="line">    <span class="comment">// assert minGrowth &gt; 0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth); <span class="comment">// might overflow</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefLength;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// put code cold in a separate method</span></span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上来说，最好在向 <code>ArrayList</code> 添加大量元素之前用 <code>ensureCapacity(minCapacity)</code> 方法，以减少增量重新分配的次数</p>
<h5 id="Vector-Deprecated"><a href="#Vector-Deprecated" class="headerlink" title="Vector(Deprecated)"></a><del>Vector(Deprecated)</del></h5><p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 。</p>
<p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全，但是并发性能较差。</p>
<h5 id="Stack-Deprecated"><a href="#Stack-Deprecated" class="headerlink" title="Stack(Deprecated)"></a><del>Stack(Deprecated)</del></h5><ul>
<li><code>Vector</code> 和 <code>Stack</code> 两者都是线程安全的，都是使用 <code>synchronized</code> 关键字进行同步处理。</li>
<li><code>Stack</code> 继承自 <code>Vector</code>，是一个后进先出的栈，而 <code>Vector</code> 是一个列表。</li>
</ul>
<p>随着 Java 并发编程的发展，<code>Vector</code> 和 <code>Stack</code> 已经被淘汰，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p>
<h4 id="LinkedList-基于链表"><a href="#LinkedList-基于链表" class="headerlink" title="LinkedList 基于链表"></a>LinkedList 基于链表</h4><ul>
<li>基于<u>双向链表</u>实现，比单链表快</li>
<li>查询速度慢O(n)，<strong>对首尾元素操作极快</strong> O(1)</li>
<li>添加和删除不需要扩容，位移 不过还是O(n)的时间复杂度</li>
<li>线程不安全</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/linkedlist-unlink.jpg" alt="unlink 方法逻辑"></p>
<p>新增双链尾首尾特有方法：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915001950393.png" alt="LinkedList"></p>
<p>适用场景：</p>
<ul>
<li><p>对首尾的操作性能很高，LinkedList可以用来实现先进先出(FIFO)的 <strong>队列</strong></p>
<ul>
<li><p><code>LinkedList queue = new LinkedList&lt;&gt;();</code></p>
</li>
<li><p><code>Enqueue</code>⇔<code>addLast</code> <code>Dequeue</code>⇔<code>removeFirst</code></p>
</li>
</ul>
</li>
<li><p>可以实现<strong>Stack</strong> 栈</p>
<ul>
<li><p><code>LinkedList stack = new LinkedList&lt;&gt;();</code></p>
</li>
<li><p><code>push</code>⇔<code>addFirst</code> <code>Pop</code>⇔<code>removeFirst</code></p>
</li>
<li><p><code>push</code> <code>pop</code>方法已经由官方写入API可直接调用</p>
</li>
</ul>
</li>
</ul>
<h3 id="Queue：FIFO"><a href="#Queue：FIFO" class="headerlink" title="Queue：FIFO"></a>Queue：FIFO</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>add/remove实际上是对offer/poll的封装</p>
<ol>
<li><strong>添加元素的方法</strong></li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>add(E e)</code></strong></td>
<td>将指定元素插入队列，如果队列已满，则抛出 <code>IllegalStateException</code> 异常。</td>
</tr>
<tr>
<td><strong><code>offer(E e)</code></strong></td>
<td>将指定元素插入队列，如果队列已满，则返回 <code>false</code> 而不抛异常。</td>
</tr>
</tbody></table>
<p><strong>2. 移除元素的方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>remove()</code></strong></td>
<td>移除队列头部的元素，如果队列为空，则抛出 <code>NoSuchElementException</code> 异常。</td>
</tr>
<tr>
<td><strong><code>poll()</code></strong></td>
<td>移除队列头部的元素，如果队列为空，则返回 <code>null</code>。</td>
</tr>
</tbody></table>
<p><strong>3. 查看元素的方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>element()</code></strong></td>
<td>查看队列头部的元素，不移除。如果队列为空，则抛出 <code>NoSuchElementException</code> 异常。</td>
</tr>
<tr>
<td><strong><code>peek()</code></strong></td>
<td>查看队列头部的元素，不移除。如果队列为空，则返回 <code>null</code>。</td>
</tr>
</tbody></table>
<h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><ul>
<li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循FIFO</li>
<li><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素，LinkedList就实现了Deque，因此可以用来模拟栈和队列<ul>
<li>Deque 常用的方法就是对头尾元素的 <code>add/remove/get</code> <code>offer/poll/peek</code>，前者会抛异常，后者不会抛异常只会返回 false(offer) 或者 null(poll/peek) 。</li>
<li>pop = removeFirst   push = addFirst。</li>
</ul>
</li>
</ul>
<h5 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h5><p>基于可变长的数组和双指针来实现，<code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>详见 JUC</p>
<h3 id="Set-不重复"><a href="#Set-不重复" class="headerlink" title="Set 不重复"></a>Set 不重复</h3><p><code>Set&lt;Integer&gt; set = new HashSet();</code>//无序</p>
<p><code>Set&lt;Integer&gt; set = new LinkedHashSet();</code> //有序</p>
<p><code>Set&lt;Integer&gt; set = new TreeSet()</code> //排序</p>
<h4 id="HashSet-无序"><a href="#HashSet-无序" class="headerlink" title="HashSet 无序"></a>HashSet 无序</h4><ul>
<li>每个对象都有哈希值，int类型，通过<code>hashCode()</code>返回</li>
<li>也可能相同，大部分情况下是相同的</li>
<li>增删改查性能较好，类比查字典，只要看到偏旁就能定位大概的位置</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915124422018.png" alt="JDK 8 之前的 HashSet">数据过多会导致链表过长，查询性能降低，然后就扩容，加载因子0.75*16=12，占到12个数据就开始扩容，2倍大小</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915125104423.png" alt="HashSet 底层结构"></li>
<li>二叉搜索树：小的存左边，大的存右边，一样的不存</li>
<li>平衡二叉树：左右高度差不超过1</li>
<li>红黑树：自平衡的二叉搜索树 </li>
<li>无序，不重复，无索引！<ul>
<li>内容一样的两个对象s1s2，HashSet认为他们不一样</li>
<li>对于HashSet可以重写对象类的<code>equals()</code>方法，比较对象的内容而不是地址，重写<code>hashCode()</code>方法根据对象的内容计算哈希值。<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915125944598.png" alt="equals hashcode"></li>
</ul>
</li>
</ul>
<h5 id="去重原理：Hashmap-put-k-v"><a href="#去重原理：Hashmap-put-k-v" class="headerlink" title="去重原理：Hashmap put(k,v)"></a>去重原理：Hashmap put(k,v)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns: true if this set did not already contain the specified element</span></span><br><span class="line"><span class="comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而 map 的 put ，只有在key不存在时返回null，其他时候返回旧值，因此key不存在正好能够去重</p>
<h4 id="LinkedHashSet-有序"><a href="#LinkedHashSet-有序" class="headerlink" title="LinkedHashSet 有序"></a>LinkedHashSet 有序</h4><ul>
<li>在HashSet基础上，每个元素多了一个双链表机制记录前后位置，原来链表依然存在，双链表仅用来记录**==添加==先后顺序**</li>
<li>占用内存相对多</li>
</ul>
<h4 id="TreeSet-可自定义排序"><a href="#TreeSet-可自定义排序" class="headerlink" title="TreeSet 可自定义排序"></a>TreeSet 可自定义排序</h4><ul>
<li>不重复无索引，<strong>可排序</strong>。底层红黑树</li>
<li>对数值类型按照大小升序排序，对字符串类型按照首字符编号升序排序</li>
<li>自定义<code>Student</code>对象无法直接排序<ul>
<li><ol>
<li>让<code>Student</code>类实现<code>Comparable</code>接口，重写<code>int compareTo()</code>方法</li>
</ol>
</li>
<li><ol start="2">
<li><code>TreeSet</code>有参构造，用<code>Comparator</code>实现对象指定比较规则，2规则优先</li>
</ol>
</li>
<li>如果指定排序规则是年龄，年龄相等的是不会存的</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a><span id="concurrentmodificaiton">ConcurrentModificationException</span></h3><ul>
<li><p>遍历集合并删除集合中的元素时，会导致元素位置移动但索引没有及时更新导致的漏操作</p>
</li>
<li><p>迭代器会报错，<code>fori</code> 循环会正常执行但返回结果错误</p>
</li>
<li><p><code>fori</code> 循环：i– 、倒着遍历</p>
</li>
<li><p>迭代器：不能调用集合自己的删除，要调用迭代器自己的删除，相当于也是做了i–的操作</p>
</li>
<li><p>0     1    2    3<br>a     b    c    d</p>
<p>删除b以后，索引为1，下一步是i++，中间插一个i–让索引不变(正序遍历)<br>删除b以后，索引为1，下一步是i–，不影响正常的遍历（倒序遍历）</p>
</li>
</ul>
<p>迭代器遍历的是开始遍历那一刻拿到的集合拷贝，遍历期间原集合发生的修改迭代器不知道。</p>
<p><strong>不要==在 forEach 循环里进行元素的 <code>remove/add</code> 操作==。remove 元素请使用 <code>Iterator</code> 方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> userNames.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterator.next().equals(<span class="string">&quot;Hollis&quot;</span>)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>removeIf：遍历并删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br></pre></td></tr></table></figure>

<p><strong>==如果并发操作==，在使用iterator迭代的时候使用synchronized或者Lock进行同步，或者使用JUC</strong> </p>
<p>并发情况下使用juc的并发集合，这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li>可以不传参数，也可以传一个，两个多个，也可以传数组，接收数据比较灵活</li>
<li>对外是灵活接收数据，对内就是一个数组</li>
<li>一个参数列表只有一个可变参数，而且要放在最后</li>
</ul>
<h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915140018933.png" alt="Collections"></p>
<ul>
<li><code>addAll(Collection&lt;? super T&gt; c, T...elements)</code>为集合批量添加数据<ul>
<li>泛型属于多态写法，<code>Animal</code>的<code>List</code>可以接收猫<code>Cat</code>和狗<code>Dog</code>作为可变参数</li>
</ul>
</li>
<li><code>shuffle(List&lt;?&gt; list)</code> 打乱 ==list== 的顺序</li>
<li><code>sort(List&lt;?&gt; list)</code> 帮助list排好序，自定义类要实现<code>Comparable</code>接口</li>
<li><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> 帮助list排好序,自定义排序规则 <code>Animal</code> 的<code>Comparator</code>可以给<code>Cat</code>排序</li>
</ul>
<p>重写T的toString方法，控制println的输出</p>
<h2 id="Map-双列-K-V"><a href="#Map-双列-K-V" class="headerlink" title="Map 双列 (K-V)"></a>Map 双列 (K-V)</h2><ul>
<li>键值对集合 <code>key-value</code></li>
<li><code>key</code>不允许重复 <code>value</code>允许重复</li>
</ul>
<ol>
<li><code>HashMap</code>无序、不重复、无索引,键相同的会覆盖值</li>
<li><code>LinkedHashMap</code>有序(添加顺序)、不重复、无索引</li>
<li><code>TreeMap</code>大小默认升序、不重复、无索引</li>
</ol>
<p><code>Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();</code></p>
<h3 id="Map-常用方法"><a href="#Map-常用方法" class="headerlink" title="Map 常用方法"></a>Map 常用方法</h3><ul>
<li><code>put(K key, V value)</code>把键值对加入Map</li>
<li><code>void clear()</code> <code>int size()</code> <code>boolean isEmpty()</code> </li>
<li><code>boolean containsKey(Object key)</code> 是否有某个键</li>
<li><code>boolean containsValue(V val)</code>是否有值<code>val</code> </li>
<li><code>V get(Object key)</code> 根据键获取值 不存在返回<code>null</code></li>
<li><code>V remove(Object key)</code>根据键获取值, 删除</li>
<li><code>Set&lt;K&gt; keySet()</code> 获取包含所有键的集合，无序不重复无索引</li>
<li><code>Collection&lt;V&gt; values()</code> 获取所有值的集合，<strong>可重复</strong> </li>
<li><code>map1.putAll(Map&lt;E&gt; map2)</code>map2所有元素加入map1，能覆盖的覆盖</li>
</ul>
<h3 id="Map-遍历方式"><a href="#Map-遍历方式" class="headerlink" title="Map 遍历方式"></a>Map 遍历方式</h3><ol>
<li><p>键找值</p>
<ol>
<li><code>keySet()</code> 获取所有键</li>
<li><code>V get(Object key)</code> 根据键找值</li>
</ol>
</li>
<li><p>键值对</p>
<ol>
<li><p><code>Map.Entry&lt;K,V&gt;</code> API自带的Entry类型把Key-Value看做一个整体</p>
</li>
<li><p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> 返回一个Set，包含所有Entry对象</p>
</li>
<li><p>增强for循环遍历<code>Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entryset</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry: entryset)&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Lambda表达式(<strong>Most Simple</strong>)</p>
<ul>
<li><code>map.forEach((k,v)-&gt;&#123;System.out.println(k + &quot;+&quot; + v)&#125;)</code></li>
<li><code>forEach</code>方法的参数是<code>BiConsumer</code>接口的实现对象，要求重写<code>action</code>函数(遍历的时候要做的事情)</li>
<li><code>forEach</code>方法具体的实现：用增强for循环遍历键值对组成的的Set</li>
</ul>
</li>
</ol>
<h3 id="HashMap-无序"><a href="#HashMap-无序" class="headerlink" title="HashMap 无序"></a>HashMap 无序</h3><h4 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a><a href="#hashmap-%E5%92%8C-hashset-%E5%8C%BA%E5%88%AB">HashMap 和 HashSet 区别</a></h4><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th align="center"><code>HashMap</code></th>
<th align="center"><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了 <code>Map</code> 接口</td>
<td align="center">实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put()</code>向 map 中添加元素</td>
<td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<ul>
<li>增删改查数据，性能都较好的集合</li>
<li>无序不重复无索引</li>
<li>Key依赖hashCode和equals保证键的唯一性</li>
<li>如果存储自定义对象，重写上述方法即可</li>
<li>HashSet实际上就是HashMap实现的，只关注键</li>
<li>线程不安全</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/jdk1.8_hashmap.png" alt="JDK 1.8 之后的内部结构-HashMap"></p>
<h4 id="HashTable-Deprecated"><a href="#HashTable-Deprecated" class="headerlink" title="HashTable(Deprecated)"></a><del>HashTable(Deprecated)</del></h4><p><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。基本都是直接在方法中加<code>synchronized</code>，性能比ConcurrentHashMap弱很多。与 Hashmap相比线程安全，不支持null</p>
<h4 id="HashMap-遍历"><a href="#HashMap-遍历" class="headerlink" title="HashMap 遍历"></a>HashMap 遍历</h4><p><code>EntrySet</code> 之所以比 <code>KeySet</code> 的性能高是因为，<code>KeySet</code> 在循环时使用了 <code>map.get(key)</code>，而 <code>map.get(key)</code> 相当于又遍历了一遍 Map 集合去查询 <code>key</code> 所对应的值。为什么要用“又”这个词？那是因为<strong>在使用迭代器或者 for 循环时，其实已经遍历了一遍 Map 集合了，因此再使用 <code>map.get(key)</code> 查询时，相当于遍历了两遍</strong>。</p>
<p>而 <code>EntrySet</code> 只遍历了一遍 Map 集合，之后通过代码“Entry&lt;Integer, String&gt; entry = iterator.next()”把对象的 <code>key</code> 和 <code>value</code> 值都放入到了 <code>Entry</code> 对象中，因此再获取 <code>key</code> 和 <code>value</code> 值时就无需再遍历 Map 集合，只需要从 <code>Entry</code> 对象中取值就可以了。</p>
<p>所以，**<code>EntrySet</code> 的性能比 <code>KeySet</code> 的性能高出了一倍，因为 <code>KeySet</code> 相当于循环了两遍 Map 集合，而 <code>EntrySet</code> 只循环了一遍**。</p>
<h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>默认的<strong>数组长度</strong>为 16，也就是<strong>容量 or 桶数量（capacity / number of buckets）</strong></p>
<p>数据过多会导致链表过长，查询性能降低</p>
<p><strong>加载因子（loadfactor）</strong>为 0.75</p>
<p>元素个数达到<strong>阈值（threshold）</strong>: capacity*loadfactor = 16*0.75 = 12 ，扩容到原来的两倍</p>
<p>扩容后，需要将原数组中的所有元素重新计算哈希值，并放入新的桶中，这个过程称为<strong>rehash</strong>，会有性能损耗，因此要尽量减少扩容次数。</p>
<h5 id="为什么容量必须是-2-n"><a href="#为什么容量必须是-2-n" class="headerlink" title="为什么容量必须是 2^n^"></a>为什么容量必须是 2^n^</h5><ol>
<li>容量cap 参与 hash % cap 运算，相当于截取低位，cap 如果是2的幂次方，cap-1就是全1，hash % cap = hash &amp; (cap-1)，通过位运算提高了效率。</li>
<li>还有一方面，因为cap-1是全1，因此hash的每一位都能充分参与运算，降低了哈希冲突的风险。</li>
<li>扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。详见下文的<a href="#rehash">rehashing</a></li>
</ol>
<h4 id="链表转红黑树"><a href="#链表转红黑树" class="headerlink" title="链表转红黑树"></a>链表转红黑树</h4><p>JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，<strong>如果当前数组的长度小于 64</strong>，那么会选择<strong>先进行数组扩容</strong>，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="FIELDs-属性字段"><a href="#FIELDs-属性字段" class="headerlink" title="FIELDs 属性字段"></a>FIELDs 属性字段</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量（数组长度），必须是2的幂次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量，必须小于2的30次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认加载因子 LoadFactor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表转换成树的阈值（链表长度）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树转换回链表的阈值（链表长度）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表转换成树的阈值（数组容量）</span></span><br><span class="line"><span class="comment"> * 应该至少为TREEIFY_THRESHOLD的4倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<h5 id="节点-Node-lt-K-V-gt"><a href="#节点-Node-lt-K-V-gt" class="headerlink" title="节点 Node&lt;K,V&gt;"></a>节点 Node&lt;K,V&gt;</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// 哈希值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 设置新的返回旧的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;value = newValue;<span class="keyword">return</span> oldValue;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Map.Entry&lt;?, ?&gt; e</span><br><span class="line">                &amp;&amp; Objects.equals(key, e.getKey())</span><br><span class="line">                &amp;&amp; Objects.equals(value, e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Contructor"><a href="#Contructor" class="headerlink" title="Contructor"></a>Contructor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> * 数组 table 每个 Entry 都是一个 节点Node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructors</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    	initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line"><span class="comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> (n &lt; <span class="number">0</span>)? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>四个构造方法中，都初始化了负载因子 loadFactor，由于 HashMap 中没有 capacity 这样的字段，即使指定了初始化容量 initialCapacity ，也只是通过 tableSizeFor() 扩容到与 initialCapacity 最接近的 2 的幂次方大小，然后<strong>暂时赋值给 threshold ，后续通过 resize 方法将 threshold 赋值给 newCap 进行 table 的初始化。</strong> </p>
<h6 id="使用另一个map构造-putMapEntries-map"><a href="#使用另一个map构造-putMapEntries-map" class="headerlink" title="使用另一个map构造 putMapEntries(map)"></a>使用另一个map构造 <code>putMapEntries(map)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// s 是实际个数，dt 就是添加 s 个元素的最小容量 ceil 向上取整</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">dt</span> <span class="operator">=</span> Math.ceil(s / (<span class="type">double</span>)loadFactor);</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((dt &lt; (<span class="type">double</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)dt : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 如果超过</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已经初始化，只要超过阈值就要 resize</span></span><br><span class="line">            <span class="comment">// Because of linked-list bucket constraints, we cannot</span></span><br><span class="line">            <span class="comment">// expand all at once, but can reduce total resize</span></span><br><span class="line">            <span class="comment">// effort by repeated doubling now vs later</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt; threshold &amp;&amp; table.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="getNode"><a href="#getNode" class="headerlink" title="getNode()"></a><code>getNode()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n, hash; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; (hash = hash(key))]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 快速检查头节点</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e; <span class="comment">// 从头节点开始遍历。</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="putVal"><a href="#putVal" class="headerlink" title="putVal()"></a><code>putVal()</code></h5><p>体现了懒加载的思想，只有真正put的时候才初始化资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1. 如果没有初始化，先调用resize初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 2.1 没有哈希冲突的情况</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 2.2 出现了哈希冲突/值重复，在else逻辑里return</span></span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// .......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 没有哈希冲突或者值重复，元素自增与扩容策略</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">// 用于LinkedHashMap支持LRU实现,HashMap无用</span></span><br><span class="line">    <span class="comment">// 4. key值不存在,则返回值是null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="哈希冲突-值重复"><a href="#哈希冲突-值重复" class="headerlink" title="哈希冲突/值重复"></a>哈希冲突/值重复</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 是链表/树的第一个节点</span></span><br><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">/* 1. 快速判断第一个节点table[i]的key是否与插入的key一样 先判断 hash </span></span><br><span class="line"><span class="comment">				若相同就将现在的节点p赋给e，然后在4中处理。     */</span> 		</span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; <span class="comment">// key 的 hash </span></span><br><span class="line"><span class="comment">// 1.5 短路逻辑：先用 == 比较地址，地址不同再用equals比较内容（K需要重写equals）</span></span><br><span class="line">	((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br><span class="line"><span class="comment">// 2. 树节点去执行树的逻辑</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">// 3. 链表节点</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">// 3.0 边遍历边比较是否出现了重复key, binCount+1 能得出链表长度</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.1 一直遍历到了尾部，说明肯定没有重复的，在链表尾端创建新 Node</span></span><br><span class="line">            p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 3.2 如果到了 TREEIFY_THRESHOLD 就触发 treeifyBin 扩容或</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            <span class="comment">// 3.3 跳出循环 e == null, 不会走重复的逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.5 判断key是否重复 重复就直接跳出，去4处理key的重复情况 e!=null</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        p = e;<span class="comment">// 遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. key 重复 应对1和3.5的重复情况 </span></span><br><span class="line"><span class="comment">// 	在putIfAbsent中，onlyIfAbsent = true, 在put中，onlyIfAbsent = false</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="comment">// putIfAbsent只有原值null才能赋值</span></span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>) </span><br><span class="line">        e.value = value;</span><br><span class="line">    afterNodeAccess(e);<span class="comment">//回调方法，只在LinkedHashMap中实现,可维护访问顺序(如LRU)</span></span><br><span class="line">    <span class="comment">// 4.5 key值如果存在,则会返回原先被替换掉的value值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode()"></a><code>removeNode()</code></h5><p>remove主要有两个：一个是remove(key)，返回值为被删除的value，如果节点不存在则返回null</p>
<p>另一个是remove(key,value) 用来表示只有key对应的值为value时才移除，返回值为boolean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">/**  1. 寻找匹配到key的节点</span></span><br><span class="line"><span class="comment">      *  短路条件1: table 不为空(已初始化过)</span></span><br><span class="line"><span class="comment">      *  短路条件2: key 对应的桶不为空</span></span><br><span class="line"><span class="comment">      *  同时满足上述两个条件才会进入正式判断，否则直接返回 null</span></span><br><span class="line"><span class="comment">      *  p 现在是桶的第一个节点。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 1.1 快速检查: 先检查桶的第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 1.2 开始遍历， e 相当于 tmp</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 树节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 链表节点</span></span><br><span class="line">                <span class="keyword">do</span> &#123; </span><br><span class="line">                    <span class="comment">// 1.2.1 找到了节点，直接break，将e赋给node</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">//  p是e的前驱</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 2. 正式开始删除节点</span></span><br><span class="line"><span class="comment">          * node 为将要删除的节点</span></span><br><span class="line"><span class="comment">          * remove(k,v)-&gt;matchValue=true | remove(k)-&gt;matchValue = false</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// 对应 1.1 快速检查, 将node.next赋值给tab[i]</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//对应 1.2.1, p 是 node 的前驱节点， 直接将node.next赋给p.next</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;<span class="comment">// 减小容量</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;<span class="comment">// 返回被删除的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="resize"><a href="#resize" class="headerlink" title="resize()"></a><code>resize()</code></h5><p>用于初始化或扩容，初始化就调用属性字段里面的 threshold 初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//—————————扩容——————————</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// threshold * 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//————————初始化——————————</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">    <span class="comment">// 创建时指定了初始化容量或者负载因子 就会把算出的容量暂时存放到threshold中</span></span><br><span class="line">    <span class="comment">// 			在这里进行新容量的初始化</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 创建时无参构造，就使用默认的 capacity 和 threshold 对容量和阈值进行初始化</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建时指定了初始化容量或者负载因子，在这里进行新阈值的初始化，</span></span><br><span class="line">        <span class="comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// 新的阈值。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 正式创建新的数组, 可以看到分配大小为 newCap</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// oldTab 的 rehash</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新的 Table 数组;</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="rehashing-oldTab"><a href="#rehashing-oldTab" class="headerlink" title="rehashing oldTab"></a><span id="rehash">rehashing oldTab</span></h6><p>索引本质还是哈希值对容量取余。</p>
<p>HashMap 扩容时采用的容量是 <strong>2 的幂次方</strong>，它的二进制特性使得新容量只在<strong>高位多出一位 1</strong>。</p>
<p>元素 A B 的哈希值分别为 2 和 6，容量从 4 扩容到 8：</p>
<ul>
<li><code>0010 &amp; 0011 = 0010</code> <code>0110 &amp; 0011 = 0010</code>  旧索引均为 2</li>
<li><code>0010 &amp; 0111 = 0010</code> <code>0110 &amp; 0111 = 0110</code>  新索引分别为 2 和 6</li>
</ul>
<p><strong>二者的区别仅在于高位是否为 1</strong>：避免了复杂的哈希重算，仅通过简单的位运算就完成了分配。</p>
<p>本质上还是取hash值的低位，原来只取低两位，只有这两位参与运算，新的需要取低三位，那么此时直接和原容量 <code>0100</code> 相与，看看第三位是不是0，如果第三位是0，索引当然不变，如果第三位是1，新的索引就是原索引+原容量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;<span class="comment">// tmp</span></span><br><span class="line">    <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="literal">null</span>)<span class="comment">// 如果没有后继节点，直接映射到新的哈希位即可</span></span><br><span class="line">            newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">		<span class="comment">// e.hash &amp; (newCap - 1) 等价于 e.hash % newCap</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 树：</span></span><br><span class="line">            ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order 保证原来的顺序</span></span><br><span class="line">            Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>; <span class="comment">// 低索引，索引不变</span></span><br><span class="line">            Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>; <span class="comment">// 高索引，索引变化</span></span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            <span class="comment">// 链表尾插法</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                next = e.next;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 还在原桶</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 换到新桶</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在旧桶的，索引不变</span></span><br><span class="line">                loTail.next = <span class="literal">null</span>;</span><br><span class="line">                newTab[j] = loHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在新桶的，新索引为原索引+原容量</span></span><br><span class="line">                hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                newTab[j + oldCap] = hiHead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTab;</span><br></pre></td></tr></table></figure>

<h6 id="链表尾插法-防止多线程死循环"><a href="#链表尾插法-防止多线程死循环" class="headerlink" title="链表尾插法 防止多线程死循环"></a><strong>链表尾插法</strong> 防止多线程死循环</h6><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p>
<p>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p>
<blockquote>
<p><code>if (tail == null)     head = e; </code></p>
<p><code>else tail.next = e;</code>    </p>
<p><code>tail = e;</code>    </p>
</blockquote>
<h5 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin()"></a><code>treeifyBin()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果容量没有超过阈值64，优先扩容！</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashMap-有序"><a href="#LinkedHashMap-有序" class="headerlink" title="LinkedHashMap 有序"></a>LinkedHashMap 有序</h3><ul>
<li>有序（添加顺序） 不重复 无索引</li>
<li>HashMap加了双链表机制记录添加顺序</li>
<li>LinkedHashSet实际上就是LinkedHashMap实行的</li>
</ul>
<p>继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看</p>
<h3 id="TreeMap-可自定义排序-定向搜索"><a href="#TreeMap-可自定义排序-定向搜索" class="headerlink" title="TreeMap 可自定义排序 定向搜索"></a>TreeMap 可自定义排序 定向搜索</h3><ul>
<li>基于红黑树，TreeSet跟TreeMap原理一样</li>
<li>排序：自定义排序规则<ul>
<li>自定义的类实现<code>Comparable</code>接口，重写 <code>int compareTo(Object o)</code>方法</li>
<li>TreeMap的有参构造 参数是<code>Comparator</code>的实现对象，重写了<code>int compare()</code>方法</li>
</ul>
</li>
</ul>
<h4 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h4><p><code>Map&lt;String,List&lt;String&gt;&gt; cityMap = new HashMap&lt;&gt;();</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915170039061.png" alt="嵌套"></p>
<h2 id="Arrays-数组操作"><a href="#Arrays-数组操作" class="headerlink" title="Arrays 数组操作"></a>Arrays 数组操作</h2><ul>
<li><p><code>toString(Object[] arr)</code> 返回一个数组字符串，每个元素调用<code>toString()</code>转换成字符串，用<code>[,,,]</code>拼接成一个总字符串</p>
</li>
<li><p> <code>copyOfRange(Object[] arr, from, to)</code> 返回值为数组， 内容为arr中索引 <strong>[from, to)</strong> 的部分</p>
</li>
<li><p><code>copyOf(Object[] arr, int newlength)</code> 返回值为数组，内容为arr的内容，长度为newlength，不够的用0补齐，索引超出的截断</p>
</li>
<li><p><code>setAll</code>  第二个参数是接口<code>IntToDoubleFunction</code>的实现对象，重写了<code>applyAsDouble(int value)</code>方法，value是数组的索引，返回对数组中内容进行操作的结果，图中是将数组内容乘以0.8。这个对象传进来以后，对数组进行遍历，都用<code>applyAsDouble</code>的方法进行操作。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913170741004.png" alt="applyAsDouble"></p>
</li>
<li><p><code>sort([] arr)</code> 对arr升序排序(默认升序)</p>
</li>
<li><p><code>asList()</code>:只能加<strong>引用类型</strong>，基本数据类型需要改成包装类，并且返回的<code>List</code>是不能运用<code>add remove clear</code>方法的，这个<code>list</code>是<code>AbstractList</code>的子类，如果要访问<code>utils</code>只能将返回的这个<code>List</code>添加到<code>new ArrayList&lt;&gt;()</code>作为有参构造</p>
</li>
</ul>
<h3 id="对象数组排序"><a href="#对象数组排序" class="headerlink" title="对象数组排序"></a>对象数组排序</h3><p><strong>自己指定比较规则</strong> </p>
<ul>
<li><p>方法1：对象类实现<code>Comparable&lt;E&gt;</code>这个泛型接口，类中重写<code>int compareTo(E e)</code> 方法，将E改为自己的对象类型。</p>
<ul>
<li>约定，左边大于右边 return 正整数，小于 return 负整数，等于 return 0;（升序排序）</li>
<li><code>return this.age - o.age</code>  注意返回值是int double可以调用<code>Double.compare(o1.height, o2.height)</code></li>
<li>调用<code>Arrays.sort(students)</code>即可</li>
</ul>
</li>
<li><p>方法2：实现<code>Comparator</code>这个泛型接口，运用</p>
<ul>
<li><p>sort有一个重载函数，第一个参数是对象数组<code>T[] arr</code>，第二个参数是<code>Comparator&lt;? super T&gt; comparator</code></p>
</li>
<li><p>泛型接口做参数用匿名内部类实现，类中重写<code>int compare(T o1,T o2)</code>方法，同时注意返回的是int</p>
</li>
<li><p>```java<br>Arrays.sort(students, new Comparator<Students>(){</p>
<pre><code>@Override
public int compare(Student o1, Student o2)&#123;
    return Double.compare(o1.height,o2.height);//升序
&#125;
</code></pre>
<p>})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ArrayList有自己的sort方法，实现同Comparator，可以免去泛型的指定</span><br><span class="line"></span><br><span class="line"># Stream流</span><br><span class="line"></span><br><span class="line">- 需要有**数据源**，集合/数组等</span><br><span class="line">- 调用流水线的方法对集合处理、计算</span><br><span class="line">- 支持链式方法</span><br><span class="line"></span><br><span class="line">![stream 流](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915171033434-1735476275516-27.png)</span><br><span class="line"></span><br><span class="line">得到流，filter forEach</span><br><span class="line"></span><br><span class="line">## 常见方法</span><br><span class="line"></span><br><span class="line">### 获取Stream流</span><br><span class="line"></span><br><span class="line">- 流的泛型就是集合中元素的类型</span><br><span class="line">- **集合**：`set.stream()` </span><br><span class="line">- **数组**：</span><br><span class="line">  - `Arrays.stream(T[] array)`</span><br><span class="line">  - `Stream&lt;T&gt;.of(T...values)` </span><br><span class="line">- Map：处理键用`keySet`，处理值用`values` Map.Entry用`entrySet` ![entrySet](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915171810424-1735476275516-28.png)</span><br><span class="line"></span><br><span class="line">### 中间方法</span><br><span class="line"></span><br><span class="line">- 返回新的Stream流支持链式编程</span><br><span class="line">- `filter`:接口的实现`filter(s-&gt;s.getAge&gt;=23 &amp;&amp; s.getAge&lt;=30)`重写`boolean test()`方法返回值是一个布尔变量。**筛选条件** s就代表集合中的元素</span><br><span class="line">- `sorted`:无参数默认根据值升序排序，有参数（实现`Comparator`接口并重写`int compare(o1,o2)`）自定义排序规则。**排序**</span><br><span class="line">- `limit(long maxSize)`:取前3个对象 </span><br><span class="line">- `skip(long n)`:跳过前n个对象，“指针”移动到对应位置，可以实现逻辑分页</span><br><span class="line">- `distinct()`:去重</span><br><span class="line">- `map(mapper)`:把集合中元素映射，mapper `map(Student::getName)` `map(s-&gt;s.getName())` 把集合中的元素 通过映射方法`mapper` 转换成对应元素</span><br><span class="line">- `distinct()`:去重复，**自定义**类型对象如果希望对比内容，应该重写`hashCode()` `equals()`方法</span><br><span class="line">- `Stream.concat(st1,st2)`:合并两个流内容,返回新的流</span><br><span class="line">- `boxed()` 基本数据类型装箱操作</span><br><span class="line"></span><br><span class="line">### 终结方法 void</span><br><span class="line"></span><br><span class="line">- （没有返回值）</span><br><span class="line">- `void forEach(action)`: `forEach(s-&gt;System.out.println(s))` 元素s -&gt; 指定s想做的事情</span><br><span class="line">- `long count()`: 返回经过前面处理以后集合剩下的元素个数</span><br><span class="line">- `max((o1,o2)-&gt;Double.compare(o1.getScore(),o2.getScore()))` </span><br><span class="line">- `min()`同`max()` 实现`Comparator`</span><br><span class="line">- `get()`:用于在`min max`后接收对象</span><br><span class="line">- `collect(Collectors.toList())` `collect(Collectors.toSet())` 把流收集起来转换成集合</span><br><span class="line">- `collect(Collectors.toMap(a-&gt;a.getName() , a-&gt;a.getHeight()))` 两个接口做参数，Lambda表达式。如果遇到`key`冲突，`toMap`需要调用重载函数，启用第三个参数，`(o1,o2)-&gt;o2`表示前后`key`冲突时，后添加的`value`会覆盖之前的`value`</span><br><span class="line">- `collect(Collectors.groupingBy(Shop::getTypeId))`把流收集起来，并按照typeId分组，返回一个typeId:集合Map</span><br><span class="line">- `toArray()`将流中的元素收集到一个`Object`**数组中** </span><br><span class="line">- `toArray(len -&gt; new Student[len])`将流中的元素收集到一个指定`Student`类型的数组中 方法引用`toArray(Student[]::new)` 此处参数是`IntFunction&lt;A[]&gt;`接口的实现对象`generator` 重写函数需要`return`一个对应类型的数组，故可以用此写法</span><br><span class="line"></span><br><span class="line">### toList() &amp; collect(Collectors.toList())</span><br><span class="line"></span><br><span class="line">- 确定其是一个不再被set/add/remove的list 可使用 Stream `toList`; 如果使用`collect(Collectors.toList())` ,sonar或idea自带以及第三方的一些code checker会爆warning, 以本人经验，可以使用`collect(Collectors.toCollection(ArrayList::new))`来代替</span><br><span class="line"></span><br><span class="line">另外ListOf也是返回的不可增删改的List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Lambda表达式省略规则 REVIEW</span><br><span class="line"></span><br><span class="line">- 只有一个参数可以省略`()` ，没有参数不能省略</span><br><span class="line"></span><br><span class="line">- `-&gt;`后是具体的函数重写，多条语句需要`&#123;&#125;` `;` 单条语句可以省略分号</span><br><span class="line"></span><br><span class="line">  - 单条语句分为有返回值和无返回值，只有一行`return`的可以省略`return`关键字，没有返回值的比如输出`System.out.println(s)` 就要注意了</span><br><span class="line">  - `a-&gt;a.getName()` 要么getName()的返回值 matters 要么没有返回值 </span><br><span class="line"></span><br><span class="line">- 方法引用</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  Function&lt;Item, String&gt; getNameFunction = item -&gt; item.getName();</span><br><span class="line">  </span><br><span class="line">  Item item = new Item(&quot;Apple&quot;);</span><br><span class="line">  String name = getNameFunction.apply(item);  // 返回 &quot;Apple&quot;</span><br><span class="line">  </span><br><span class="line">  R apply(T t);//抽象方法 给一个T，返回R类型</span><br><span class="line">  String apply(Item item);//泛型将接口具体化</span><br><span class="line">  </span><br><span class="line">  /*</span><br><span class="line">  键：return 键 </span><br><span class="line">  值：return 值 </span><br><span class="line">  转换成 Lambda 表达式 调用的函数必须有返回值的</span><br><span class="line">  */</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>操作数组：最终的目的仍然是数组、集合</p>
<h1 id="集合最佳实践"><a href="#集合最佳实践" class="headerlink" title="集合最佳实践"></a>集合最佳实践</h1><p>（1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。</p>
<p>（2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。</p>
<p>（3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。</p>
<p>（4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。</p>
<p>（5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。</p>
<p>（6）尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。</p>
<h2 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h2><p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 <code>O(1)</code>。</p>
<p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 <code>O(1)</code>，不过，也有很多复杂度不是 <code>O(1)</code> 的，比如 <code>java.util.concurrent</code> 包下的 <code>ConcurrentLinkedQueue</code>。<code>ConcurrentLinkedQueue</code> 的 <code>isEmpty()</code> 方法通过 <code>first()</code> 方法进行判断，其中 <code>first()</code> 方法返回的是队列中第一个值不为 <code>null</code> 的节点（节点值为<code>null</code>的原因是在迭代器中使用的逻辑删除）</p>
<h2 id="集合遍历-iterator-并发修改异常"><a href="#集合遍历-iterator-并发修改异常" class="headerlink" title="集合遍历 iterator 并发修改异常"></a><a href="#concurrentmodificaiton">集合遍历 iterator 并发修改异常</a></h2><h2 id="集合转-Map"><a href="#集合转-Map" class="headerlink" title="集合转 Map"></a>集合转 Map</h2><p>**在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。 **</p>
<h2 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h2><p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line"><span class="comment">//没有指定类型的话会报错</span></span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型</p>
<h2 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h2><p><strong><code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</strong> </p>
<p>toList() &amp; collect(Collectors.toList())</p>
<p><code>Arrays.asList()</code> 或者流的<code>toList()</code>或者<code>List.of()</code>，得到的List只能读，不能进行修改操作，因为这个list是AbstarctList的实现类，并没有实现修改的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><code>List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code> 也可以</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">单例模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-20T00:00:00+08:00">2024-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 01:01:23" itemprop="dateModified" datetime="2025-04-26T01:01:23+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h1><h2 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="keyword">return</span> instance;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全，但是可能造成资源的浪费</p>
<h2 id="懒汉-双重校验锁-DCL"><a href="#懒汉-双重校验锁-DCL" class="headerlink" title="懒汉 双重校验锁 DCL"></a><u><strong>懒汉 双重校验锁 DCL</strong></u></h2><ol>
<li>懒汉（延迟初始化） 要素：无参构造私有，进行判断<strong>「线程不安全」</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原来的实现容易出现线程安全问题，改进：<code>getInstance()</code>变成 <code>synchronized</code> 方法。<ul>
<li><p><strong>锁范围太大</strong>：性能差，同步开销大。正常的执行路径不需要同步，只需要在创建实例的时候进行锁定即可。</p>
<ul>
<li><p>锁对象的选择：<strong>两个不相关的方法不要使用同一把锁</strong>。<strong>并且要注意不能出现死锁互相等待</strong>。</p>
</li>
<li><p>class：适用于保护静态变量或者类级别的共享资源，如果是为了保护某个对象的状态，就应该使用this。</p>
</li>
<li><p>this可能的问题：这边在内部使用this调用task.dosth()，另一边一个完全无关的业务使用 task做锁。</p>
</li>
<li><p>死锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Friend</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bow</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在向 &quot;</span> + other.name + <span class="string">&quot; 鞠躬&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟执行延迟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            other.bowBack(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bowBack</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在回礼 &quot;</span> + other.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 死锁：a和b同时向对方bow，先都锁住了自己，bowBack的时候就会造成互相等待</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>未二次判空</strong>：线程 A 通过了条件判断，获取了锁，开始创建实例，就在同时，线程B也通过判断等待锁释放，在线程 A 出来之后线程B又进去创建了一次。</p>
</li>
<li><p><strong>指令重排序</strong>：Java 允许指令重排序，创建对象可以分为 1. 分配内存地址 2. 在这块内存地址创建对象 3. 将 对象的引用 instance 指向这块地址。如果2 3的顺序颠倒，线程 A 进去之后在完全创建对象之前就将 instance 置为 非null，线程B就会以为别人已经创建好了，直接返回 instance 引用，线程B拿到以后就开始使用，其中就会随机发生空指针或者状态异常等其他难以复现调试的bug。引入 volatile，表示这个变量不允许指令重排，且线程对它的写入会立刻对其他线程可见。避免发生拿到错误对象的情况</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// 1. 禁止指令重排序</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;<span class="comment">// 2. 锁的范围缩小</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;<span class="comment">// 3. 二次判空</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用场景：</p>
<ul>
<li><strong>单例模式</strong>：延迟初始化全局唯一的对象。</li>
<li><strong>高并发资源初始化</strong>：如数据库连接池、线程池等。</li>
<li><strong>框架中的扩展点加载</strong>：如 Dubbo 的 <code>ExtensionLoader</code> 按需加载扩展类。</li>
</ul>
<h2 id="双重校验锁-与类解耦"><a href="#双重校验锁-与类解耦" class="headerlink" title="双重校验锁 (与类解耦)"></a><u>双重校验锁 (与类解耦)</u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> T instance;</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;T&gt; supplier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">(Supplier&lt;T&gt; supplier)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = supplier.get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T instance;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>&#123;</span><br><span class="line">        instance = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 在外部实现</span></span><br></pre></td></tr></table></figure>



<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a><u><strong>枚举 enum</strong></u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>天然线程安全，并且能够防止反射攻击</p>
<h2 id="Holder-静态内部类-（利用类加载机制）"><a href="#Holder-静态内部类-（利用类加载机制）" class="headerlink" title="Holder 静态内部类 （利用类加载机制）"></a><u><strong>Holder 静态内部类 （利用类加载机制）</strong></u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Holder 在 Singleton 加载时并不会被加载，只有第一次调用 <code>getInstance()</code> 才会加载 Holder，然后创建单例。</p>
<h2 id="CAS-自旋"><a href="#CAS-自旋" class="headerlink" title="CAS 自旋"></a>CAS 自旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;Singleton&gt; instance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">current</span> <span class="operator">=</span> instance.get();</span><br><span class="line">            <span class="keyword">if</span> (current != <span class="literal">null</span>) <span class="keyword">return</span> current;</span><br><span class="line">            current = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">if</span> (instance.compareAndSet(<span class="literal">null</span>, current)) &#123; <span class="comment">// 期望值为 null，设置值为 current</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无锁，非阻塞，线程安全。实现较为复杂，追求极致性能才考虑</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/classfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/classfile/" class="post-title-link" itemprop="url">ClassFile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 00:59:52" itemprop="dateModified" datetime="2025-04-26T00:59:52+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ClassFile-字节码"><a href="#ClassFile-字节码" class="headerlink" title="ClassFile 字节码"></a>ClassFile 字节码</h1><p>Java 字节码是 Java 编译器将 Java 源代码编译成的 <strong>中间表示格式</strong>，它运行在 <strong>Java 虚拟机（JVM）</strong> 上。Java 字节码文件的扩展名为 **<code>.class</code>**，可以通过 <strong><code>javap -c</code></strong> 命令查看其内容。</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。本章中， 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它完全不 需要以磁盘文件的形式存在。</p>
<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。</p>
<h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BytecodeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译和查看字节码指令</strong> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac BytecodeExample.java</span><br><span class="line">javap -c BytecodeExample</span><br><span class="line"><span class="comment"># 打印类中每个方法的反汇编代码，例如组成 Java 字节码的指令。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCodeExample</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> MAX;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ByteCodeExample</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iload_0</span><br><span class="line">       <span class="number">1</span>: iload_1</span><br><span class="line">       <span class="number">2</span>: iadd</span><br><span class="line">       <span class="number">3</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_2</span><br><span class="line">       <span class="number">1</span>: iconst_3</span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method add:(II)I</span></span><br><span class="line">       <span class="number">5</span>: istore_1</span><br><span class="line">       <span class="number">6</span>: getstatic     #<span class="number">13</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">9</span>: iload_1</span><br><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">19</span>                 <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节码指令解释"><a href="#字节码指令解释" class="headerlink" title="字节码指令解释"></a><span id="code">字节码指令解释</span></h3><h4 id="构造方法：BytecodeExample"><a href="#构造方法：BytecodeExample" class="headerlink" title="构造方法：BytecodeExample()"></a>构造方法：BytecodeExample()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ByteCodeExample</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0           <span class="comment">// 将 this 引用加载到操作数栈</span></span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>			<span class="comment">// 返回</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：自动生成的默认构造函数，调用 <code>Object</code> 的构造函数。</p>
<h4 id="add-方法：add-int-int"><a href="#add-方法：add-int-int" class="headerlink" title="add 方法：add(int, int)"></a>add 方法：add(int, int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iload_0              <span class="comment">// 加载第一个参数 a</span></span><br><span class="line">       <span class="number">1</span>: iload_1              <span class="comment">// 加载第二个参数 b</span></span><br><span class="line">       <span class="number">2</span>: iadd                 <span class="comment">// 执行整数相加</span></span><br><span class="line">       <span class="number">3</span>: ireturn              <span class="comment">// 返回结果</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ol>
<li>**<code>iload_0</code>、<code>iload_1</code>**：将参数加载到操作数栈。</li>
<li>**<code>iadd</code>**：弹出栈顶两个整数并执行加法运算，再将结果压入栈顶。</li>
<li>**<code>ireturn</code>**：将栈顶的结果返回给调用者。</li>
</ol>
<h4 id="main-方法：main-String"><a href="#main-方法：main-String" class="headerlink" title="main 方法：main(String[])"></a>main 方法：main(String[])</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_2           <span class="comment">// 将常量 2 压入栈</span></span><br><span class="line">       <span class="number">1</span>: iconst_3           <span class="comment">// 将常量 3 压入栈</span></span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">7</span>   <span class="comment">// 调用静态方法 add(2, 3)</span></span><br><span class="line">       <span class="number">5</span>: istore_1           <span class="comment">// 将结果保存到局部变量表中的索引 1</span></span><br><span class="line">       <span class="number">6</span>: getstatic     #<span class="number">13</span>  <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">9</span>: iload_1            <span class="comment">// 加载变量 result</span></span><br><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">19</span>  <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span>             <span class="comment">// 结束 main 方法</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>**<code>iconst_2</code> 和 <code>iconst_3</code>**：将常量 2 和 3 压入栈顶。</li>
<li>**<code>invokestatic</code>**：调用静态方法 <code>add</code>，返回结果并压入栈顶。</li>
<li>**<code>istore_1</code>**：将结果存入局部变量表的索引 1（变量 result）。</li>
<li>**<code>getstatic</code>**：加载 <code>System.out</code> 对象到栈顶，用于后续方法调用。</li>
<li>**<code>invokevirtual</code>**：调用 <code>println</code> 方法打印结果。</li>
</ul>
<h3 id="常见字节码指令表"><a href="#常见字节码指令表" class="headerlink" title="常见字节码指令表"></a>常见字节码指令表</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>aload_x</strong></td>
<td>将引用变量加载到操作数栈</td>
</tr>
<tr>
<td><strong>iload_x</strong></td>
<td>将 int 型变量加载到操作数栈</td>
</tr>
<tr>
<td><strong>istore_x</strong></td>
<td>将 int 型值从栈顶存入局部变量表</td>
</tr>
<tr>
<td><strong>iconst_x</strong></td>
<td>将常量 x 压入操作数栈</td>
</tr>
<tr>
<td><strong>iadd</strong></td>
<td>执行整数加法</td>
</tr>
<tr>
<td><strong>isub</strong></td>
<td>执行整数减法</td>
</tr>
<tr>
<td><strong>invokestatic</strong></td>
<td>调用静态方法</td>
</tr>
<tr>
<td><strong>invokevirtual</strong></td>
<td>调用对象的实例方法</td>
</tr>
<tr>
<td><strong>return</strong></td>
<td>方法结束，返回 void</td>
</tr>
<tr>
<td><strong>ireturn</strong></td>
<td>方法结束，返回 int 值</td>
</tr>
</tbody></table>
<h2 id="class-文件结构-ClassFile"><a href="#class-文件结构-ClassFile" class="headerlink" title=".class 文件结构(ClassFile)"></a>.class 文件结构(ClassFile)</h2><p>ClassFile 结构定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;<span class="comment">// first 4 bytes of the file must be 0xCAFEBABE</span></span><br><span class="line">    u2             minor_version;<span class="comment">// 次版本号                        2 bytes</span></span><br><span class="line">    u2             major_version;<span class="comment">// 主版本号 比如 JDK 21 对应 65.0   2 bytes </span></span><br><span class="line">    </span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量 2 bytes</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    </span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记   </span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    </span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口数量</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//字段数量</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/16d5ec47609818fc.jpeg" alt="ClassFile 内容分析"></p>
<h3 id="常量池-cp-info-constant-pool-constant-pool-count-1"><a href="#常量池-cp-info-constant-pool-constant-pool-count-1" class="headerlink" title="常量池 cp_info constant_pool[constant_pool_count-1]"></a>常量池 <code>cp_info constant_pool[constant_pool_count-1]</code></h3><p>常量池是 ClassFile 的核心，存储类的常量信息，如字符串、字段名、方法名和方法描述符等。</p>
<p>计数器 constant_pool_count 表示常量池项的数量（从 1 开始计数）。（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp_info <span class="punctuation">&#123;</span></span><br><span class="line">    u1 tag;                  <span class="comment">// 常量类型标志      1 byte</span></span><br><span class="line">    u1 info<span class="punctuation">[</span><span class="punctuation">]</span>;               <span class="comment">// 常量值或引用      1 byte</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">标志（tag）</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_utf8_info</td>
<td align="center">1</td>
<td align="center">UTF-8 编码的字符串</td>
</tr>
<tr>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">3</td>
<td align="center">整形字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Float_info</td>
<td align="center">4</td>
<td align="center">浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Long_info</td>
<td align="center">5</td>
<td align="center">长整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Double_info</td>
<td align="center">6</td>
<td align="center">双精度浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Class_info</td>
<td align="center">7</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_String_info</td>
<td align="center">8</td>
<td align="center">字符串类型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_FieldRef_info</td>
<td align="center">9</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodRef_info</td>
<td align="center">10</td>
<td align="center">类中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_InterfaceMethodRef_info</td>
<td align="center">11</td>
<td align="center">接口中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">12</td>
<td align="center">字段或方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodType_info</td>
<td align="center">16</td>
<td align="center">标志方法类型</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodHandle_info</td>
<td align="center">15</td>
<td align="center">表示方法句柄</td>
</tr>
<tr>
<td align="center">CONSTANT_InvokeDynamic_info</td>
<td align="center">18</td>
<td align="center">表示一个动态方法调用点</td>
</tr>
</tbody></table>
<h3 id="类访问标志-access-flags"><a href="#类访问标志-access-flags" class="headerlink" title="类访问标志 access flags"></a>类访问标志 <code>access flags</code></h3><p>定义类或接口的修饰符：</p>
<table>
<thead>
<tr>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x0001 (ACC_PUBLIC)</td>
<td>公共类。</td>
</tr>
<tr>
<td>0x0010 (ACC_FINAL)</td>
<td>不可继承（final）。</td>
</tr>
<tr>
<td>0x0020 (ACC_SUPER)</td>
<td>支持 invokespecial。</td>
</tr>
<tr>
<td>0x0200 (ACC_INTERFACE)</td>
<td>接口。</td>
</tr>
<tr>
<td>0x0400 (ACC_ABSTRACT)</td>
<td>抽象类或接口。</td>
</tr>
<tr>
<td>0x1000 (ACC_SYNTHETIC)</td>
<td>编译器自动生成的类或方法。</td>
</tr>
<tr>
<td>0x2000 (ACC_ANNOTATION)</td>
<td>注解类。</td>
</tr>
<tr>
<td>0x4000 (ACC_ENUM)</td>
<td>枚举类。</td>
</tr>
</tbody></table>
<h3 id="当前类和父类的索引-this-class-super-class"><a href="#当前类和父类的索引-this-class-super-class" class="headerlink" title="当前类和父类的索引 this_class super_class"></a>当前类和父类的索引 <code>this_class</code> <code>super_class</code></h3><ul>
<li><strong>this_class</strong> 指向当前类在常量池中的索引，描述类名。</li>
<li>super_class 指向父类的索引。<ul>
<li>如果父类是 <code>java.lang.Object</code>，其值为 0。</li>
</ul>
</li>
</ul>
<h4 id="接口索引集合-interfaces-interface-count"><a href="#接口索引集合-interfaces-interface-count" class="headerlink" title="接口索引集合 interfaces[interface_count]"></a>接口索引集合 <code>interfaces[interface_count]</code></h4><p>接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p>
<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h4 id="字段集合-field-info-fields-fields-count"><a href="#字段集合-field-info-fields-fields-count" class="headerlink" title="字段集合 field_info fields[fields_count]"></a>字段集合 <code>field_info fields[fields_count]</code></h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">field_info <span class="punctuation">&#123;</span></span><br><span class="line">    u2 access_flags;       <span class="comment">// 访问标志字段的作用域（public ,private,protected修饰符），是实例变量还是类变量（static修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</span></span><br><span class="line">    u2 name_index;         <span class="comment">// 字段名称 对常量池的引用</span></span><br><span class="line">    u2 descriptor_index;   <span class="comment">// 描述符 对常量池的引用</span></span><br><span class="line">    u2 attributes_count;   <span class="comment">// 属性计数器</span></span><br><span class="line">    attribute_info attributes<span class="punctuation">[</span><span class="punctuation">]</span>; <span class="comment">// 属性表</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p>
<p>字段的访问标志位：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20201031084342859.png" alt="字段的 access_flag 的取值"></p>
<h4 id="方法表-method-info-methods-methods-count"><a href="#方法表-method-info-methods-methods-count" class="headerlink" title="方法表 method_info methods[methods_count]"></a>方法表 <code>method_info methods[methods_count]</code></h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info <span class="punctuation">&#123;</span></span><br><span class="line">    u2 access_flags;       <span class="comment">// </span></span><br><span class="line">    u2 name_index;         <span class="comment">// 方法名 对常量池的引用</span></span><br><span class="line">    u2 descriptor_index;   <span class="comment">// 描述符 对常量池的引用</span></span><br><span class="line">    u2 attributes_count;   <span class="comment">// 属性计数器</span></span><br><span class="line">    attribute_info attributes<span class="punctuation">[</span><span class="punctuation">]</span>; <span class="comment">// 属性表</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
<p>方法的访问标志位：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20201031084248965.png" alt="方法表的 access_flag 取值"></p>
<h4 id="属性表-attribute-info-attributes-attributes-count"><a href="#属性表-attribute-info-attributes-attributes-count" class="headerlink" title="属性表 attribute_info attributes[attributes_count]"></a>属性表 <code>attribute_info attributes[attributes_count]</code></h4><p>存储与类、字段或方法相关的附加信息，如注解、调试信息等。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>存储方法的字节码指令。</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>常量值属性（如 static final 常量）。</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>行号表，用于调试信息映射源代码行。</td>
</tr>
<tr>
<td>SourceFile</td>
<td>源文件名属性，用于调试信息。</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法抛出的异常信息。</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>方法中局部变量的信息（调试用途）。</td>
</tr>
<tr>
<td>Deprecated</td>
<td>标记类、方法或字段为废弃。</td>
</tr>
</tbody></table>
<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<p>比如在上文<a href="#code">字节码指令解释</a>的部分，方法的Code属性就是字节码指令</p>
<h2 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose BytecodeExample <span class="comment">// 打印有关所选类别的附加信息</span></span><br><span class="line"></span><br><span class="line">Classfile /C<span class="punctuation">:</span>/Users/Lenovo/Desktop/coding/JavaSingle/BytecodeExample.class</span><br><span class="line">  Last modified <span class="number">2025</span>年<span class="number">1</span>月<span class="number">3</span>日; size <span class="number">555</span> bytes</span><br><span class="line">  SHA<span class="number">-256</span> checksum <span class="number">2</span>ade518b0d7194939efe9f3eefc0d055e21b70bab639130f050bc35282fa976b</span><br><span class="line">  Compiled from <span class="string">&quot;ByteCodeExample.java&quot;</span></span><br><span class="line">public class ByteCodeExample</span><br><span class="line">  minor version<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  major version<span class="punctuation">:</span> <span class="number">65</span></span><br><span class="line">  flags<span class="punctuation">:</span> (<span class="number">0x0021</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_SUPER</span><br><span class="line">  this_class<span class="punctuation">:</span> #<span class="number">8</span>                          <span class="comment">// ByteCodeExample</span></span><br><span class="line">  super_class<span class="punctuation">:</span> #<span class="number">2</span>                         <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 实现了0个接口</span></span><br><span class="line">  fields<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span>    <span class="comment">// 有3个字段 （成员变量）</span></span><br><span class="line">  methods<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span>  <span class="comment">// 有3个方法</span></span><br><span class="line">  attributes<span class="punctuation">:</span> <span class="number">1</span>  </span><br><span class="line">Constant pool<span class="punctuation">:</span></span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">2.</span>#<span class="number">3</span>          <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">4</span>             <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">3</span> = NameAndType        #<span class="number">5</span><span class="punctuation">:</span>#<span class="number">6</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">4</span> = Utf8               java/lang/Object</span><br><span class="line">   #<span class="number">5</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">6</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">8.</span>#<span class="number">9</span>          <span class="comment">// ByteCodeExample.add:(II)I</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">10</span>            <span class="comment">// ByteCodeExample</span></span><br><span class="line">   #<span class="number">9</span> = NameAndType        #<span class="number">11</span><span class="punctuation">:</span>#<span class="number">12</span>        <span class="comment">// add:(II)I</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               ByteCodeExample</span><br><span class="line">  #<span class="number">11</span> = Utf8               add</span><br><span class="line">  #<span class="number">12</span> = Utf8               (II)I</span><br><span class="line">  #<span class="number">13</span> = Fieldref           #<span class="number">14.</span>#<span class="number">15</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">14</span> = Class              #<span class="number">16</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">17</span><span class="punctuation">:</span>#<span class="number">18</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">17</span> = Utf8               out</span><br><span class="line">  #<span class="number">18</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">19</span> = Methodref          #<span class="number">20.</span>#<span class="number">21</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">  #<span class="number">20</span> = Class              #<span class="number">22</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">21</span> = NameAndType        #<span class="number">23</span><span class="punctuation">:</span>#<span class="number">24</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">22</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">23</span> = Utf8               println</span><br><span class="line">  #<span class="number">24</span> = Utf8               (I)V</span><br><span class="line">  #<span class="number">25</span> = Utf8               a</span><br><span class="line">  #<span class="number">26</span> = Utf8               I</span><br><span class="line">  #<span class="number">27</span> = Utf8               b</span><br><span class="line">  #<span class="number">28</span> = Utf8               MAX</span><br><span class="line">  #<span class="number">29</span> = Utf8               D</span><br><span class="line">  #<span class="number">30</span> = Utf8               ConstantValue</span><br><span class="line">  #<span class="number">31</span> = Double             <span class="number">12.0</span>d</span><br><span class="line">  #<span class="number">33</span> = Utf8               Code</span><br><span class="line">  #<span class="number">34</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">35</span> = Utf8               main</span><br><span class="line">  #<span class="number">36</span> = Utf8               (<span class="punctuation">[</span>Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">37</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">38</span> = Utf8               ByteCodeExample.java</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  int a;</span><br><span class="line">    descriptor<span class="punctuation">:</span> I</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0000</span>)</span><br><span class="line"></span><br><span class="line">  int b;</span><br><span class="line">    descriptor<span class="punctuation">:</span> I</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0000</span>)</span><br><span class="line"></span><br><span class="line">  public static final double MAX;</span><br><span class="line">    descriptor<span class="punctuation">:</span> D</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0019</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_STATIC<span class="punctuation">,</span> ACC_FINAL</span><br><span class="line">    ConstantValue<span class="punctuation">:</span> double <span class="number">12.0</span>d</span><br><span class="line"></span><br><span class="line">  public ByteCodeExample();</span><br><span class="line">    descriptor<span class="punctuation">:</span> ()V</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code<span class="punctuation">:</span></span><br><span class="line">      stack=<span class="number">1</span><span class="punctuation">,</span> locals=<span class="number">1</span><span class="punctuation">,</span> args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span><span class="punctuation">:</span> aload_0</span><br><span class="line">         <span class="number">1</span><span class="punctuation">:</span> invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span><span class="punctuation">:</span> return</span><br><span class="line">      LineNumberTable<span class="punctuation">:</span></span><br><span class="line">        line <span class="number">1</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  public static int add(int<span class="punctuation">,</span> int);</span><br><span class="line">    descriptor<span class="punctuation">:</span> (II)I</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0009</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_STATIC</span><br><span class="line">    Code<span class="punctuation">:</span></span><br><span class="line">      stack=<span class="number">2</span><span class="punctuation">,</span> locals=<span class="number">2</span><span class="punctuation">,</span> args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span><span class="punctuation">:</span> iload_0</span><br><span class="line">         <span class="number">1</span><span class="punctuation">:</span> iload_1</span><br><span class="line">         <span class="number">2</span><span class="punctuation">:</span> iadd</span><br><span class="line">         <span class="number">3</span><span class="punctuation">:</span> ireturn</span><br><span class="line">      LineNumberTable<span class="punctuation">:</span></span><br><span class="line">        line <span class="number">6</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String<span class="punctuation">[</span><span class="punctuation">]</span>);</span><br><span class="line">    descriptor<span class="punctuation">:</span> (<span class="punctuation">[</span>Ljava/lang/String;)V</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0009</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_STATIC</span><br><span class="line">    Code<span class="punctuation">:</span></span><br><span class="line">      stack=<span class="number">2</span><span class="punctuation">,</span> locals=<span class="number">2</span><span class="punctuation">,</span> args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span><span class="punctuation">:</span> iconst_2</span><br><span class="line">         <span class="number">1</span><span class="punctuation">:</span> iconst_3</span><br><span class="line">         <span class="number">2</span><span class="punctuation">:</span> invokestatic  #<span class="number">7</span>                  <span class="comment">// Method add:(II)I</span></span><br><span class="line">         <span class="number">5</span><span class="punctuation">:</span> istore_1</span><br><span class="line">         <span class="number">6</span><span class="punctuation">:</span> getstatic     #<span class="number">13</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">9</span><span class="punctuation">:</span> iload_1</span><br><span class="line">        <span class="number">10</span><span class="punctuation">:</span> invokevirtual #<span class="number">19</span>                 <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">13</span><span class="punctuation">:</span> return</span><br><span class="line">      LineNumberTable<span class="punctuation">:</span></span><br><span class="line">        line <span class="number">10</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span><span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line">        line <span class="number">12</span><span class="punctuation">:</span> <span class="number">13</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">SourceFile<span class="punctuation">:</span> <span class="string">&quot;ByteCodeExample.java&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="ClassLoading"><a href="#ClassLoading" class="headerlink" title="ClassLoading"></a>ClassLoading</h1><h2 id="One-main-to-one-JVM-process"><a href="#One-main-to-one-JVM-process" class="headerlink" title="One main to one JVM process"></a>One main to one JVM process</h2><p>当我们启动一个Java程序，即启动一个main方法时，都将启动一个Java虚拟机进程，不管这个进程有多么复杂。而不同的JVM进程之间是不会相互影响的。这也就是为什么说，Java程序只有一个入口——main方法，让虚拟机调用。而两个main方法，对应的是2个JVM进程，启动的是两个不同的类加载器，操作的实际上是不同的类。故而不会互相影响。</p>
<h2 id="ClassLoading-Workflow"><a href="#ClassLoading-Workflow" class="headerlink" title="ClassLoading Workflow"></a>ClassLoading Workflow</h2><p>当我们使用一个类，如果这个类还未加载到内存中，系统会通过加载、连接、初始化对类进行初始化。完成后可以使用Using和卸载Unloading。</p>
<h3 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载(Loading)"></a>加载(Loading)</h3><p><strong>目的</strong>：将类的字节码文件从持久存储加载到内存的方法区，并生成对应的 <strong>Class 对象</strong>。</p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li>通过类名查找 <code>.class</code> 文件，并将其二进制字节码读入内存</li>
<li>将字节码中的静态存储结构转换为方法区中的 <strong>运行时数据结构</strong>。</li>
<li>在堆内存中创建一个 <strong>java.lang.Class</strong> 对象，作为对方法区载入数据的访问入口。</li>
</ol>
<p>类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定（不过，我们也能打破由双亲委派模型）。</p>
<p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>
<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。默认的loadClass方法最后就是Link的</p>
<h3 id="连接-Linking"><a href="#连接-Linking" class="headerlink" title="连接(Linking)"></a>连接(Linking)</h3><p>类连接：指的是把类的二进制数据合并到 JRE 中，这又分为 3 个阶段：</p>
<h4 id="验证-Verification"><a href="#验证-Verification" class="headerlink" title="验证(Verification)"></a>验证(Verification)</h4><p><strong>目的</strong>：检查载入Class文件数据的正确性，确保字节码文件符合 JVM 要求，不会危害虚拟机安全。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/class-loading-process-verification.png" alt="验证阶段示意图"></p>
<p><strong>具体检查</strong>：</p>
<ol>
<li><strong>文件格式验证</strong>：是否符合 Class 文件格式规范。</li>
<li><strong>元数据验证</strong>：类继承、接口实现是否正确。</li>
<li><strong>字节码验证</strong>：指令流是否合法，如变量初始化和栈操作正确。</li>
<li><strong>符号引用验证</strong>：类、字段、方法等是否存在。</li>
</ol>
<p><strong>结果</strong>：不合法的字节码会抛出 <strong>VerifyError</strong>。</p>
<p>文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候（解析阶段会介绍符号引用和直接引用）。</p>
<p>符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常NoSuchFieldError NoSuchMethodError IllegalAccessError。</p>
<h4 id="准备-Preparation"><a href="#准备-Preparation" class="headerlink" title="准备(Preparation)"></a>准备(Preparation)</h4><p>给类的==静态变量==分配存储空间，并进行==默认初始化，赋零值==。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p>
<p><strong>目的</strong>：为类的静态变量分配内存，并设置默认值（不会执行静态初始化）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行阶段</strong>：</p>
<ul>
<li>分配内存，并将 <code>a</code> 的初始值设为 <code>0</code>（默认值）。</li>
<li>注意：这里不会执行 <code>= 10</code>，赋值在初始化阶段完成。</li>
</ul>
<p>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</p>
<h4 id="解析-Resolution"><a href="#解析-Resolution" class="headerlink" title="解析(Resolution)"></a>解析(Resolution)</h4><p><strong>目的</strong>：将类的二进制数据中 常量池的 <strong>符号引用</strong> 替换为 <strong>直接引用</strong>。</p>
<ul>
<li><strong>符号引用</strong>：类、方法、字段等以字符串形式存在于常量池中。<ul>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</li>
<li>符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。</li>
</ul>
</li>
<li><strong>直接引用</strong>：实际内存地址或偏移量。<ul>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。</li>
<li>在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</li>
</ul>
</li>
</ul>
<h3 id="初始化-Initialization"><a href="#初始化-Initialization" class="headerlink" title="初始化(Initialization)"></a>初始化(Initialization)</h3><p>对类的静态变量、静态初始化块进行初始化，因此不是必须的。<strong>这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong> </p>
<p>初始化阶段就是执行类构造器<code>&lt;clinit&gt; ()</code>方法的过程。<code>&lt;clinit&gt; ()</code>并不是程序员在Java代码中直接编写 的方法，它是Javac编译器的自动生成物</p>
<p>对于<code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。</p>
<p>由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的 语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能<strong>访问到定义在静态语句块之前的变量，</strong> 在前面的静态语句块可以赋值定义在其后的变量，但是不能访问它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">         System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>&lt;clinit&gt; ()</code>方法与类的构造函数（即在虚拟机视角中的实例构造器<code>&lt;init&gt; ()</code>方法）不同，它不需要显 式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt; ()</code>方法执行前，父类的<code>&lt;init&gt; ()</code>方法已经执行 完毕。因此在Java虚拟机中第一个被执行的()方法的类型肯定是java.lang.Object</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250104142317079.png" alt="clinit"></p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li>按照声明顺序依次执行静态变量赋值和静态代码块。</li>
<li>若父类未初始化，会先初始化父类。</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123; a = <span class="number">20</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong>：<code>a = 20</code>（因为静态代码块会覆盖前面的赋值）。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>初始化是类加载的最后阶段，只有在首次使用类时触发。</li>
<li>使用场景：实例化对象、调用静态方法、访问静态变量等。</li>
</ul>
<h4 id="初始化的触发条件-主动"><a href="#初始化的触发条件-主动" class="headerlink" title="初始化的触发条件(主动)"></a>初始化的触发条件(主动)</h4><p>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行 强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》 则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之 前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始 化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ol>
<li>创建该类的实例对象</li>
<li>访问static变量</li>
<li>调用static方法</li>
</ol>
</li>
<li>反射调用时如 <code>Class.forName(&quot;...&quot;)</code>, <code>newInstance()</code> 等<ul>
<li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类</li>
</ul>
</li>
<li>初始化子类会触发父类的初始化</li>
<li>有 <code>default</code> 方法的接口实现类初始化，接口也要初始化</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li>
</ol>
<p>被动访问不会触发初始化：</p>
<ol>
<li>访问类的 <strong>常量</strong>（<code>static final</code> 修饰）因为常量位于 运行时常量池<ul>
<li>在编译阶段通过常量传播优化，已经将常量的值“hello world”直接存储在NotInitialization类的常量池中，以后NotInitialization对常量 ConstClass.HELLOWORLD的引用，实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成 Class文件后就已不存在任何联系了。</li>
</ul>
</li>
<li>通过 <strong>数组定义类引用</strong>（如 <code>Test[] arr</code>）。<ul>
<li>运行之后发现没有输出“SuperClass init！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。但是这段代码里面触发了 另一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是 一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由 字节码指令newarray触发。</li>
</ul>
</li>
<li>对于静态字段， 只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发 父类的初始化而不会触发子类的初始化。</li>
</ol>
<p>（注意：一个final类型的静态属性，如果在编译时已经得到了属性值，那么调用该属性时，不会导致该类初始化，因为这个相当于使用常量；使用ClassLoader()方法，只是加载该类，并未初始化。）</p>
<h3 id="使用-Using"><a href="#使用-Using" class="headerlink" title="使用(Using)"></a>使用(Using)</h3><p>类加载完成后，可以使用类创建实例、调用方法或访问字段。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>使用过程中 JVM 可能会进行 <strong>动态绑定</strong>（如多态方法调用）和 <strong>反射机制</strong>。 </li>
</ul>
<h3 id="卸载-Unloading"><a href="#卸载-Unloading" class="headerlink" title="卸载(Unloading)"></a>卸载(Unloading)</h3><p><strong>目的</strong>：当某些类不再被使用时，将其从内存中移除。</p>
<p><strong>条件</strong>：</p>
<ul>
<li>该类的所有实例已被回收。</li>
<li>该类的 ClassLoader 实例已被回收。</li>
<li>JVM 中没有该类的任何引用。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>卸载阶段只针对用户的使用自定义类加载器加载的类，Bootstrap 引导加载器加载的类不会被卸载。</li>
<li>GC 会回收 <strong>Class 对象</strong> 和相关的元数据。</li>
</ul>
<p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>类加载器是一个负责加载类的对象。<code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象。</p>
<p>在 Java 中，一个类用其全限定类名（即包名+类名）作为标识。</p>
<p>而在 JVM 中，一个类用其全限定类名和其类加载器作为标识。</p>
<h3 id="dynamic-lazy-loading-only-once"><a href="#dynamic-lazy-loading-only-once" class="headerlink" title="dynamic lazy loading, only once"></a>dynamic lazy loading, only once</h3><p>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。加载时机并没有明确的要求。</p>
<p>对于已经加载的类会被放在 <code>ClassLoader</code> 中的 <code>classes</code> 字段，这是一个存放Class对象的容器。在类加载的时候，首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p>
<p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="comment">// 由这个类加载器加载的类。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 由VM调用，用此类加载器记录每个已加载类。</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">        classes.addElement(c);</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><strong>Bootstrap ClassLoader</strong>（引导类加载器）：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级。加载核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类）。<ul>
<li>**<code>rt.jar</code>**：rt 代表“RunTime”，<code>rt.jar</code>是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</li>
</ul>
</li>
<li><strong>Extension ClassLoader</strong>（扩展类加载器）：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。<ul>
<li>Java 9 引入了模块系统，并且略微更改了上述的类加载器。Extension ClassLoader被改名为平台类加载器（Platform Classloader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由 Bootstrap ClassLoader 加载之外，其他的模块均由 Platform Classloader 所加载。</li>
</ul>
</li>
<li><strong>Application ClassLoader</strong>（应用类加载器）：加载应用程序的 <code>classpath</code> 下的类。</li>
<li><strong>自定义类加载器</strong>：用户实现的特殊需求类加载器。</li>
</ul>
<p>除了 <code>BootstrapClassLoader</code> 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 <code>ClassLoader</code>抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p>
<h3 id="加载器调用顺序"><a href="#加载器调用顺序" class="headerlink" title="加载器调用顺序"></a>加载器调用顺序</h3><p>每个 <code>ClassLoader</code> 可以通过<code>getParent()</code>获取其父 <code>ClassLoader</code>，如果获取到 <code>ClassLoader</code> 为<code>null</code>的话，那么该类是通过 <code>BootstrapClassLoader</code> 加载的。</p>
<ul>
<li>我们编写的 Java 类 <code>PrintClassLoaderTree</code> 的 <code>ClassLoader</code> 是<code>AppClassLoader</code>；</li>
<li><code>AppClassLoader</code>的父 <code>ClassLoader</code> 是 <code>ExtClassLoader</code>；</li>
<li><code>ExtClassLoader</code>的父 <code>ClassLoader</code> 是 <code>Bootstrap ClassLoader</code> </li>
</ul>
<p>其中，<code>BootstrapClassLoader</code>负责加载JRE的核心类库，它不是<code>ClassLoader</code>的子类，使用C++编写，因此我们在Java中看不到它，通过其子类的<code>getParent()</code>方法获取时，将返回<code>null</code>。</p>
<p><code>ExtClassLoader</code>和<code>AppClassLoader</code>为<code>ClassLoader</code>的子类。在 API 中看不到它们，他们位于 rt.jar 文件中，因此由<code>BootstrapClassLoader</code>进行加载，全限定类名分别为：</p>
<ul>
<li><p><code>sun.misc.Launcher$AppClassLoader</code> </p>
<ul>
<li><code>jdk.internal.loader.ClassLoaders$AppClassLoader</code> </li>
</ul>
</li>
<li><p><code>sun.misc.Launcher$ExtClassLoader</code> </p>
<ul>
<li><code>jdk.internal.loader.ClassLoaders$PlatformClassLoader</code> </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.stopTalking.crazy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="comment">//获取当前线程的类装载器 </span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader(); </span><br><span class="line">        <span class="comment">//获取System类的类装载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> System.class.getClassLoader(); </span><br><span class="line">        <span class="comment">//获取本类TestClassLoader的类加载器loader2 </span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> TestClassLoader.class.getClassLoader(); </span><br><span class="line">        <span class="comment">//获取loader2的父加载器 </span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader3</span> <span class="operator">=</span> loader2.getParent(); </span><br><span class="line">        <span class="comment">//获取loader2的父加载器的父加载器 </span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader4</span> <span class="operator">=</span> loader3.getParent(); </span><br><span class="line">        System.out.println(loader); </span><br><span class="line">        System.out.println(loader1); </span><br><span class="line">        System.out.println(loader2); </span><br><span class="line">        System.out.println(loader3); </span><br><span class="line">        System.out.println(loader4); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前线程类获取的类加载器是AppClassLoader</span></span><br><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@4aa298b7</span><br><span class="line"><span class="comment">//System类为根装载器加载，java中访问不到，所以为null</span></span><br><span class="line"><span class="literal">null</span> </span><br><span class="line"><span class="comment">//本类的类加载器当然也是AppClassLoader    </span></span><br><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@4aa298b7</span><br><span class="line">jdk.internal.loader.ClassLoaders$PlatformClassLoader@5caf905d</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义-ClassLoader"><a href="#自定义-ClassLoader" class="headerlink" title="自定义 ClassLoader"></a>自定义 ClassLoader</h3><p>需要继承 <code>ClassLoader</code>抽象类。<code>ClassLoader</code> 类有两个关键方法：</p>
<ul>
<li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li>
<li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li>
</ul>
<blockquote>
<p>建议 <code>ClassLoader</code>的子类重写 <code>findClass(String name)</code>方法而不是<code>loadClass(String name, boolean resolve)</code> 方法。</p>
</blockquote>
<p>如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p>
<h2 id="Parents-Delegation-Model"><a href="#Parents-Delegation-Model" class="headerlink" title="Parents Delegation Model"></a>Parents Delegation Model</h2><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</p>
<p>父辈委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
<p><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</p>
<p>父辈委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/class-loader-parents-delegation-model-1735908352601-36.png" alt="类加载器层次关系图"></p>
<p>另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承，多用组合少用继承。</strong></p>
<h3 id="java-lang-ClassLoader-loadClass"><a href="#java-lang-ClassLoader-loadClass" class="headerlink" title="java.lang.ClassLoader.loadClass()"></a><code>java.lang.ClassLoader.loadClass()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过，自底向上</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">        		<span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行连接操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li>
<li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li>
<li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li>
<li>如果子类加载器也无法加载这个类，那么它会抛出一个 <code>ClassNotFoundException</code> 异常。</li>
</ul>
<p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 <code>Class</code> 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</p>
<p>双亲委派很好地解决了各个类 加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被 称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变 的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p>
<blockquote>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务， 它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型 了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程 序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启 动类加载器是绝不可能认识、加载这些代码的，那该怎么办？ 为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方 法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内 都没有设置过的话，那这个类加载器默认就是应用程序类加载器。 有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类 加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行 为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性 原则，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、 JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供 者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了 java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加 载提供了一种相对合理的解决方案。</p>
</blockquote>
<p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p>
<p>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</p>
<p>但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。重写 <code>loadClass()</code>方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。另外，仅仅自定义加载器也不能够满足全部的要求。</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/classloader.html#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%96%B9%E6%B3%95">打破双亲委派模型方法 | JavaGuide</a> </p>
<h2 id="Classpath"><a href="#Classpath" class="headerlink" title="Classpath"></a>Classpath</h2><p><strong>Classpath</strong> 是 Java 应用程序运行时用来查找 <strong>类文件（.class）</strong> 和 <strong>资源文件</strong> 的路径。它定义了 JVM 加载类和资源的搜索目录。<strong>Classpath</strong> 指定了 JVM 在加载类时搜索的目录或 JAR 包路径。</p>
<p><strong>Classpath</strong> 是 JVM 加载类和资源的搜索路径，通常包括：</p>
<ol>
<li>当前目录 (<code>.</code>)。</li>
<li>指定的文件夹（包含 <code>.class</code> 文件或 JAR 包）。</li>
<li>第三方库文件（如 <code>lib/*.jar</code>）。</li>
</ol>
<p>在开发和运行 Java 程序时，可以通过命令行、环境变量或 IDE 设置 Classpath，以确保依赖文件和类可以正确加载。</p>
<h3 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h3><ol>
<li><p><strong>命令行设置：</strong><br>使用 <code>-classpath</code> 或 <code>-cp</code> 参数指定路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .;lib/* com.example.Main</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>“.”</strong> 表示当前目录。</li>
<li><strong>“lib/*”</strong> 表示 <code>lib</code> 文件夹下的所有 JAR 文件。</li>
</ul>
</li>
<li><p><strong>环境变量设置：</strong><br>设置全局环境变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CLASSPATH=/usr/local/app/classes:/usr/local/app/lib/*</span><br></pre></td></tr></table></figure>

<p>或 Windows 下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set CLASSPATH=.;lib\*</span><br></pre></td></tr></table></figure></li>
<li><p><strong>IDE 设置：</strong><br>在 IDE（如 IntelliJ IDEA、Eclipse）中，classpath 默认包含 <strong>src/main/java</strong> 和 <strong>target/classes</strong>，以及项目引用的依赖项。</p>
</li>
</ol>
<h3 id="Classpath-路径内容"><a href="#Classpath-路径内容" class="headerlink" title="Classpath 路径内容"></a>Classpath 路径内容</h3><p>Classpath 支持以下类型的路径：</p>
<ol>
<li><p><strong>目录路径：</strong></p>
<ul>
<li><p>包含编译好的类文件，如：<code>/home/user/classes</code>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp /home/user/classes Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>JAR 文件路径：</strong></p>
<ul>
<li><p>支持直接引用 JAR 包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp lib/example.jar Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>通配符路径：</strong></p>
<ul>
<li><p>可使用 <code>*</code> 引用多个 JAR 包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp lib/* Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>相对路径或绝对路径：</strong></p>
<ul>
<li>相对路径：<code>./lib</code>（当前目录）。</li>
<li>绝对路径：<code>/usr/lib/java/</code>.</li>
</ul>
</li>
</ol>
<h3 id="默认-Classpath-设置"><a href="#默认-Classpath-设置" class="headerlink" title="默认 Classpath 设置"></a>默认 Classpath 设置</h3><ol>
<li><p>如果未显式设置 <code>-classpath</code> 或 <code>CLASSPATH</code> 环境变量，JVM 默认搜索 <strong>当前目录（.）</strong>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java</span><br><span class="line">java Test</span><br></pre></td></tr></table></figure>

<p>默认会从当前目录加载 <code>Test.class</code> 文件。</p>
</li>
</ol>
<h3 id="示例-1：单个类文件"><a href="#示例-1：单个类文件" class="headerlink" title="示例 1：单个类文件"></a>示例 1：单个类文件</h3><p>假设有以下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/project/</span><br><span class="line">  Main.java</span><br></pre></td></tr></table></figure>

<p>编译与运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br><span class="line">java Main</span><br></pre></td></tr></table></figure>

<h3 id="示例-2：JAR-包依赖"><a href="#示例-2：JAR-包依赖" class="headerlink" title="示例 2：JAR 包依赖"></a>示例 2：JAR 包依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/project/</span><br><span class="line">  lib/</span><br><span class="line">    gson.jar</span><br><span class="line">  Main.java</span><br></pre></td></tr></table></figure>

<p>编译与运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac -cp lib/gson.jar Main.java</span><br><span class="line">java -cp lib/gson.jar:. Main</span><br></pre></td></tr></table></figure>

<h3 id="示例-3：多个-JAR-包"><a href="#示例-3：多个-JAR-包" class="headerlink" title="示例 3：多个 JAR 包"></a>示例 3：多个 JAR 包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp &quot;lib/*&quot; com.example.Main</span><br></pre></td></tr></table></figure>

<h2 id="加载顺序demo"><a href="#加载顺序demo" class="headerlink" title="加载顺序demo"></a>加载顺序demo</h2><p>这其实是去年校招时我遇到的一道阿里巴巴的笔试题(承认有点久远了-。-)，嗯，如果我没记错的话，当时是作为java方向的一道选做大题。当然题意没有这么直白，题目只要求你写出程序运行后所有system.out.println的输出结果，其中程序是题目给的，而各个system.out.println的执行顺序不同会导致最后程序输出的结果也不同。</p>
<p>具体的题目我肯定记不清，不过我们可以换个直接的问法，如果类A和类B中有静态变量，静态语句块，非静态变量，非静态语句块，构造函数，静态方法，非静态方法，同时类A继承类B，请问当实例化A时，类内部的加载顺序是什么?</p>
<p>当时我也是一头雾水，事后我就自己写了一个小Demo，这才知道了类内部的实际加载顺，测试代码如下：</p>
<p>Class B:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//静态变量 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;  System.out.println(<span class="string">&quot;Class B1:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//非静态变量</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;  i++;  System.out.println(<span class="string">&quot;Class B2:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  j++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;constructor B: &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态语句块</span></span><br><span class="line">    &#123; </span><br><span class="line">        i++; j++; </span><br><span class="line">        System.out.println(<span class="string">&quot;Class B:common blocks&quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bDisplay</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class B:static void bDisplay(): &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bTest</span><span class="params">()</span>&#123; </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class B:static void bTest():  &quot;</span>+<span class="string">&quot;i=&quot;</span>+i);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class A:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//静态变量 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;  System.out.println(<span class="string">&quot;Class A1:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//非静态变量</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;  i++;  System.out.println(<span class="string">&quot;Class A2:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="built_in">super</span>();  i++;  j++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;constructor A: &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态语句块</span></span><br><span class="line">    &#123; </span><br><span class="line">        i++; j++; </span><br><span class="line">        System.out.println(<span class="string">&quot;Class A:common blocks&quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aDisplay</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class A:static void aDisplay(): &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">aTest</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class A:static void aTest():  &quot;</span>+<span class="string">&quot;i=&quot;</span>+i);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class ClassLoading :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoading</span> &#123;      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span> &#123;    </span><br><span class="line">        A a=<span class="keyword">new</span> <span class="title class_">A</span>();    </span><br><span class="line">        a.aDisplay();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1484270652220239.jpg" alt="Java中类的加载顺序剖析（常用于面试题）"></p>
<p>通过上述示图，我们可以比较清晰的看出java类的整个加载过程。</p>
<ol>
<li>若要加载类A，则先加载执行其父类B(Object)的静态变量以及静态语句块(执行先后顺序按排列的先后顺序)。</li>
<li>然后再加载执行类A的静态变量以及静态语句块。(并且1、2步骤只会执行1次)</li>
<li>若需实例化类A，则先调用其父类B的构造函数,并且在调用其父类B的构造函数前,依次先调用父类B中的非静态变量及非静态语句块.最后再调用父类B中的构造函数初始化。</li>
<li>然后再依次调用类A中的非静态变量及非静态语句块.最后调用A中的构造函数初始化。( 并且3、4步骤可以重复执行)</li>
<li>而对于静态方法和非静态方法都是被动调用,即系统不会自动调用执行,所以用户没有调用时都不执行,主要区别在于静态方法可以直接用类名直接调用(实例化对象也可以),而非静态方法只能先实例化对象后才能调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父类--静态变量</span><br><span class="line">父类--静态初始化块</span><br><span class="line">子类--静态变量</span><br><span class="line">子类--静态初始化块</span><br><span class="line">*************in main***************</span><br><span class="line">父类--变量</span><br><span class="line">父类--初始化块</span><br><span class="line">父类--构造器</span><br><span class="line">子类--变量</span><br><span class="line">子类--初始化块</span><br><span class="line">子类--构造器</span><br><span class="line">*************second subclass***************</span><br><span class="line">父类--变量</span><br><span class="line">父类--初始化块</span><br><span class="line">父类--构造器</span><br><span class="line">子类--变量</span><br><span class="line">子类--初始化块</span><br><span class="line">子类--构造器</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<p>很显然在加载main方法后，静态变量不管父类还是子类的都执行了，然后才是父类和子类的的普通变量和构造器。这是因为，当要创建子类这个对象时，发现这个类需要一个父类，所以把父类的.class加载进来，然后依次初始化其普通变量和初始化代码块，最后其构造器，然后可以开始子类的工作，把子类的.class加载进来，在做子类的工作。</p>
<p>另外在 Java 中子类中都会有默认的调用父类的默认构造函数即super() 如果父类声明了有参构造函数，那么如果没有显式声明无参构造，子类就会爆出语法错误，无法调用父类的无参构造。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/12/G1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/12/G1/" class="post-title-link" itemprop="url">G1 垃圾收集器介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-12 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-12T00:00:00+08:00">2024-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 00:59:45" itemprop="dateModified" datetime="2025-04-26T00:59:45+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>之前根据 Sun 的内存管理白皮书介绍了在 HotSpot JVM 分代算法中的几个垃圾收集器，本文将介绍 G1 垃圾收集器。</p>
<p>G1 的主要关注点在于达到<strong>可控的停顿时间</strong>，在这个基础上尽可能提高吞吐量，这一点非常重要。</p>
<p>G1 被设计用来长期取代 CMS 收集器，和 CMS 相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。区别在于，G1 没有 CMS 的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间。</p>
<p>如果你的应用使用了较大的堆（如 6GB 及以上）而且还要求有较低的垃圾收集停顿时间（如 0.5 秒），那么 G1 是你绝佳的选择，是时候放弃 CMS 了。</p>
<p><strong>阅读建议</strong>：本文力求用简单的话介绍清楚 G1 收集器，但是并不会重复介绍每一个细节，所以希望读者了解其他几个收集器的工作过程，尤其是 CMS 收集器。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3-1742964906329-3.png" alt="G1 收集器"></p>
<h2 id="G1-总览"><a href="#G1-总览" class="headerlink" title="G1 总览"></a>G1 总览</h2><p>首先是内存划分上，之前介绍的分代收集器将整个堆分为年轻代、老年代和永久代，每个代的空间是确定的。</p>
<p>而 G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3-1742964906329-3.png" alt="内存划分"></p>
<p>执行垃圾收集时，和 CMS 一样，G1 收集线程在标记阶段和应用程序线程<strong>并发</strong>执行，标记结束后，G1 也就知道哪些区块基本上是垃圾，存活对象极少，G1 会先从这些区块下手，因为从这些区块能很快释放得到很大的可用空间，<strong>这也是为什么 G1 被取名为 Garbage-First 的原因</strong>。</p>
<blockquote>
<p>这里只不过是先介绍些概念，没看懂没关系，往下看</p>
</blockquote>
<p>在 G1 中，目标停顿时间非常非常重要，用 -XX:MaxGCPauseMillis=200 指定期望的停顿时间。</p>
<p>G1 使用了<strong>停顿预测模型</strong>来满足用户指定的停顿时间目标，并基于目标来选择进行垃圾回收的区块数量。G1 采用增量回收的方式，每次回收一些区块，而不是整堆回收。</p>
<p>我们要知道 G1 不是一个实时收集器，它会尽力满足我们的停顿时间要求，但也不是绝对的，它基于之前垃圾收集的数据统计，估计出在用户指定的停顿时间内能收集多少个区块。</p>
<p><strong>注意：</strong>G1 有和应用程序一起运行的并发阶段，也有 stop-the-world 的并行阶段。但是，<strong>Full GC 的时候还是单线程运行的</strong>，所以我们应该尽量避免发生 Full GC，后面我们也会介绍什么时候会触发 Full GC。</p>
<p><strong>G1 内存占用</strong></p>
<p>G1 比 ParallelOld 和 CMS 会需要更多的内存消耗，那是因为有部分内存消耗于簿记（accounting）上，如以下两个数据结构：</p>
<ul>
<li><strong>Remembered Sets</strong>：每个区块都有一个 RSet，用于记录进入该区块的对象引用（如区块 A 中的对象引用了区块 B，区块 B 的 Rset 需要记录这个信息），它用于实现收集过程的并行化以及使得区块能进行独立收集。总体上 Remembered Sets 消耗的内存小于 5%。</li>
<li><strong>Collection Sets</strong>：将要被回收的区块集合。GC 时，在这些区块中的对象会被复制到其他区块中，总体上 Collection Sets 消耗的内存小于 1%。</li>
</ul>
<h2 id="G1-工作流程"><a href="#G1-工作流程" class="headerlink" title="G1 工作流程"></a>G1 工作流程</h2><p>前面啰里啰嗦说了挺多的，唯一要记住的就是，G1 的设计目标就是尽力满足我们的目标停顿时间上的要求。</p>
<p>本节介绍 G1 的收集过程，G1 收集器主要包括了以下 4 种操作：</p>
<ul>
<li>1、年轻代收集</li>
<li>2、并发收集，和应用线程同时执行</li>
<li>3、混合式垃圾收集</li>
<li>*、必要时的 Full GC</li>
</ul>
<p>接下来，我们进行一一介绍。</p>
<h3 id="年轻代收集"><a href="#年轻代收集" class="headerlink" title="年轻代收集"></a>年轻代收集</h3><p>首先，我们来看下 G1 的堆结构：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8ca16868.png" alt="G1 GC 内存布局"></p>
<p>年轻代中的垃圾收集流程（Young GC）：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2.png" alt="Young GC"></p>
<p>我们可以看到，年轻代收集概念上和之前介绍的其他分代收集器大差不差的，但是它的年轻代会动态调整。</p>
<h3 id="Old-GC-并发标记周期"><a href="#Old-GC-并发标记周期" class="headerlink" title="Old GC / 并发标记周期"></a>Old GC / 并发标记周期</h3><p>接下来是 Old GC 的流程（含 Young GC 阶段），其实把 Old GC  理解为<strong>并发周期</strong>是比较合理的，不要单纯地认为是清理老年代的区块，因为这一步和年轻代收集也是相关的。下面我们介绍主要流程：</p>
<ol>
<li><p>初始标记：stop-the-world，它伴随着一次普通的 Young GC 发生，然后对 Survivor 区（root region）进行标记，因为该区可能存在对老年代的引用。</p>
<blockquote>
<p>因为 Young GC 是需要 stop-the-world 的，所以并发周期直接重用这个阶段，虽然会增加 CPU 开销，但是停顿时间只是增加了一小部分。</p>
</blockquote>
</li>
<li><p>扫描根引用区：因为先进行了一次 YGC，所以当前年轻代只有 Survivor 区有存活对象，它被称为根引用区。扫描 Survivor 到老年代的引用，该阶段必须在下一次 Young GC 发生前结束。</p>
<blockquote>
<p>这个阶段不能发生年轻代收集，如果中途 Eden 区真的满了，也要等待这个阶段结束才能进行 Young GC。</p>
</blockquote>
</li>
<li><p>并发标记：寻找整个堆的存活对象，该阶段可以被 Young GC 中断。</p>
<blockquote>
<p>这个阶段是并发执行的，中间可以发生多次 Young GC，Young GC 会中断标记过程</p>
</blockquote>
</li>
<li><p>重新标记：stop-the-world，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法。</p>
<blockquote>
<p>Oracle 的资料显示，这个阶段会回收完全空闲的区块</p>
</blockquote>
</li>
<li><p>清理：清理阶段真正回收的内存很少。</p>
</li>
</ol>
<p>到这里，G1 的一个并发周期就算结束了，其实就是主要完成了垃圾定位的工作，定位出了哪些分区是垃圾最多的。因为整堆一般比较大，所以这个周期应该会比较长，中间可能会被多次 stop-the-world 的 Young GC 打断。</p>
<h3 id="混合垃圾回收周期"><a href="#混合垃圾回收周期" class="headerlink" title="混合垃圾回收周期"></a>混合垃圾回收周期</h3><p>并发周期结束后是混合垃圾回收周期，不仅进行年轻代垃圾收集，而且回收之前标记出来的老年代的垃圾最多的部分区块。</p>
<p>混合垃圾回收周期会持续进行，直到几乎所有的被标记出来的分区（垃圾占比大的分区）都得到回收，然后恢复到常规的年轻代垃圾收集，最终再次启动并发周期。</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>到这里我们已经说了年轻代收集、并发周期、混合回收周期了，大家要熟悉这几个阶段的工作。</p>
<p>下面我们来介绍特殊情况，那就是会导致 <strong>Full GC</strong> 的情况，也是我们需要极力避免的：</p>
<ol>
<li><p>concurrent mode failure：并发模式失败，CMS 收集器也有同样的概念。G1 并发标记期间，如果在标记结束前，老年代被填满，G1 会放弃标记。</p>
<blockquote>
<p>这个时候说明</p>
<ul>
<li>堆需要增加了，</li>
<li>或者需要调整并发周期，如增加并发标记的线程数量，让并发标记尽快结束</li>
<li>或者就是更早地进行并发周期，默认是整堆内存的 45% 被占用就开始进行并发周期。</li>
</ul>
</blockquote>
</li>
<li><p>晋升失败：并发周期结束后，是混合垃圾回收周期，伴随着年轻代垃圾收集，进行清理老年代空间，如果这个时候清理的速度小于消耗的速度，导致老年代不够用，那么会发生晋升失败。</p>
<blockquote>
<p>说明混合垃圾回收需要更迅速完成垃圾收集，也就是说在混合回收阶段，每次年轻代的收集应该处理更多的老年代已标记区块。</p>
</blockquote>
</li>
<li><p>疏散失败：年轻代垃圾收集的时候，如果 Survivor 和 Old 区没有足够的空间容纳所有的存活对象。这种情况肯定是非常致命的，因为基本上已经没有多少空间可以用了，这个时候会触发 Full GC 也是很合理的。</p>
<blockquote>
<p>最简单的就是增加堆大小</p>
</blockquote>
</li>
<li><p>大对象分配失败，我们应该尽可能地不创建大对象，尤其是大于一个区块大小的那种对象。</p>
</li>
</ol>
<h3 id="简单小结"><a href="#简单小结" class="headerlink" title="简单小结"></a>简单小结</h3><p>看完上面的 Young GC 和 Old GC 等，很多读者可能还是很懵的，这里说几句不严谨的白话文帮助读者进行理解：</p>
<p>首先，最好不要把上面的 Old GC 当做是一次 GC 来看，而应该当做<strong>并发标记周期</strong>来理解，虽然它确实会释放出一些内存。</p>
<p>并发标记结束后，G1 也就知道了哪些区块是最适合被回收的，那些完全空闲的区块会在这这个阶段被回收。如果这个阶段释放了足够的内存出来，其实也就可以认为结束了一次 GC。</p>
<p>我们假设并发标记结束了，那么下次 GC 的时候，还是会先回收年轻代，如果从年轻代中得到了足够的内存，那么结束；过了几次后，年轻代垃圾收集不能满足需要了，那么就需要利用之前并发标记的结果，选择一些活跃度最低的老年代区块进行回收。直到最后，老年代会进入下一个并发周期。</p>
<p>那么什么时候会启动并发标记周期呢？这个是通过参数控制的，下面马上要介绍这个参数了，此参数默认值是 45，也就是说当堆空间使用了 45% 后，G1 就会进入并发标记周期。</p>
<h2 id="G1-参数配置和最佳实践"><a href="#G1-参数配置和最佳实践" class="headerlink" title="G1 参数配置和最佳实践"></a>G1 参数配置和最佳实践</h2><p>G1 调优的目标是尽量避免出现 Full GC，其实就是给老年代足够的空间，或相对更多的空间。</p>
<p>有以下几点我们可以进行调整的方向：</p>
<ul>
<li>增加堆大小，或调整老年代和年轻代的比例，这个很好理解</li>
<li>增加并发周期的线程数量，其实就是为了加快并发周期快点结束</li>
<li>让并发周期尽早开始，这个是通过设置堆使用占比来调整的（默认 45%）</li>
<li>在混合垃圾回收周期中回收更多的老年代区块</li>
</ul>
<p>G1 的很重要的目标是达到可控的停顿时间，所以很多的行为都以这个目标为出发点开展的。</p>
<p>我们通过设置 -XX:MaxGCPauseMillis=N 来指定停顿时间（单位 ms，默认 200ms），如果没有达到这个目标，G1 会通过各种方式来补救：调整年轻代和老年代的比例，调整堆大小，调整晋升的年龄阈值，调整混合垃圾回收周期中处理的老年代的区块数量等等。</p>
<p>当然了，调整每个参数满足了一个条件的同时往往也会引入另一个问题，比如为了降低停顿时间，我们可以减小年轻代的大小，可是这样的话就会增加年轻代垃圾收集的频率。如果我们减少混合垃圾回收周期处理的老年代区块数量，虽然可以更容易满足停顿时间要求，可是这样就会增加 Full GC 的风险等等。</p>
<p>下面介绍最常用也是最基础的一些参数的设置，涉及到更高级的调优参数设置，请读者自行参阅其他资料。</p>
<p><strong>参数介绍</strong>：</p>
<ul>
<li><p><strong>-XX:+UseG1GC</strong></p>
<p>使用 G1 收集器</p>
</li>
<li><p><strong>-XX:MaxGCPauseMillis=200</strong></p>
<p>指定目标停顿时间，默认值 200 毫秒。</p>
<blockquote>
<p>在设置 -XX:MaxGCPauseMillis 值的时候，不要指定为平均时间，而应该指定为满足 90% 的停顿在这个时间之内。记住，停顿时间目标是我们的目标，不是每次都一定能满足的。</p>
</blockquote>
</li>
<li><p><strong>-XX:InitiatingHeapOccupancyPercent=45</strong></p>
<p>整堆使用达到这个比例后，触发并发 GC 周期，默认 45%。</p>
<blockquote>
<p>如果要降低晋升失败的话，通常可以调整这个数值，使得并发周期提前进行</p>
</blockquote>
</li>
<li><p><strong>-XX:NewRatio=n</strong></p>
<p>老年代/年轻代，默认值 2，即 1/3 的年轻代，2/3 的老年代</p>
<blockquote>
<p>不要设置年轻代为固定大小，否则：</p>
<ul>
<li>G1 不再需要满足我们的停顿时间目标</li>
<li>不能再按需扩容或缩容年轻代大小</li>
</ul>
</blockquote>
</li>
<li><p><strong>-XX:SurvivorRatio=n</strong></p>
<p>Eden/Survivor，默认值 8，这个和其他分代收集器是一样的</p>
</li>
<li><p><strong>-XX:MaxTenuringThreshold =n</strong></p>
<p>从年轻代晋升到老年代的年龄阈值，也是和其他分代收集器一样的</p>
</li>
<li><p><strong>-XX:ParallelGCThreads=n</strong></p>
<p>并行收集时候的垃圾收集线程数</p>
</li>
<li><p><strong>-XX:ConcGCThreads=n</strong></p>
<p>并发标记阶段的垃圾收集线程数</p>
<blockquote>
<p>增加这个值可以让并发标记更快完成，如果没有指定这个值，JVM 会通过以下公式计算得到：</p>
<p>ConcGCThreads=(ParallelGCThreads + 2) / 4^3</p>
</blockquote>
</li>
<li><p><strong>-XX:G1ReservePercent=n</strong></p>
<p>堆内存的预留空间百分比，默认 10，用于降低晋升失败的风险，即默认地会将 10% 的堆内存预留下来。</p>
</li>
<li><p><strong>-XX:G1HeapRegionSize=n</strong></p>
<p>每一个 region 的大小，默认值为根据堆大小计算出来，取值 1MB~32MB，这个我们通常指定整堆大小就好了。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我自己仔细检查了几遍，主要内容都囊括了，我也不知道读者看完本文会不会是一脸懵逼。</p>
<p>如果有什么问题，可以在留言板上给我留言，<strong>我是 GC 的门外汉</strong>，如果有些问题我觉得自己能解答，我会尽力帮助大家。</p>
<p>最后，在这里推荐一些资料给感兴趣的读者：</p>
<p>Oracle 官方出品，本文的很多内容是翻译并解读这篇文章的：</p>
<p><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">Getting Started with the G1 Garbage Collector</a></p>
<p>帮助大家理解 G1 的日志：</p>
<p><a target="_blank" rel="noopener" href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs">Understanding G1 GC Logs</a></p>
<p>这里介绍 GC 的内容非常好：</p>
<p><a target="_blank" rel="noopener" href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1">https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1</a></p>
<p>《Java 性能权威指南》：非常好的一本书，建议读者有时间可以看看这本书中关于 GC 的介绍。</p>
<p>（全文完）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/11/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/11/JVM/" class="post-title-link" itemprop="url">JVM 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-11T00:00:00+08:00">2024-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 00:59:38" itemprop="dateModified" datetime="2025-04-26T00:59:38+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM-是虚拟机吗？"><a href="#JVM-是虚拟机吗？" class="headerlink" title="JVM 是虚拟机吗？"></a>JVM 是虚拟机吗？</h1><h2 id="JVM-是什么？"><a href="#JVM-是什么？" class="headerlink" title="JVM 是什么？"></a>JVM 是什么？</h2><p><strong>Java Virtual Machine (JVM)</strong> 是 Java 平台的核心组件，它是一个**==程序运行环境==**，专门用来执行 Java 字节码（Bytecode）</p>
<p><strong>主要功能：</strong></p>
<ol>
<li><strong>跨平台支持</strong>：JVM 实现了 Java 的 “Write Once, Run Anywhere” 特性，使 Java 程序能够在不同操作系统上运行。</li>
<li>字节码解释和编译：JVM 将 Java 编译器生成的字节码（平台无关）转换为平台相关的机器代码，并执行。</li>
<li>内存管理：提供垃圾回收机制 (Garbage Collection, GC)。</li>
<li>安全性：内置安全检查机制，确保 Java 程序在受控环境中运行，防止恶意代码执行。</li>
</ol>
<h2 id="Hypervisor-VMM-是什么"><a href="#Hypervisor-VMM-是什么" class="headerlink" title="Hypervisor/VMM 是什么?"></a>Hypervisor/VMM 是什么?</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-Hyperviseur.svg.png" alt="undefined"></p>
<p>Hypervisor 是一种一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也可叫做虚拟机监视器，即 VMM（ virtual machine monitor ）。</p>
<ul>
<li>当服务器启动并执行 Hypervisor 时，它会加载所有虚拟机客户端的操作系统同时会分配给每一台虚拟机适量的内存，CPU，网络和磁盘。它允许多个操作系统（称为<strong>Guest OS</strong>）在同一台物理机器（称为<strong>Host</strong>）上同时运行，每个操作系统被隔离在独立的虚拟机中。</li>
<li>Hypervisor 负责资源分配，如 CPU、内存和存储，协调着这些硬件资源的访问，而且在各个虚拟机之间施加防护，处理虚拟机之间的通信和安全隔离。</li>
</ul>
<h2 id="JVM-与-Hypervisor-VMM-的对比"><a href="#JVM-与-Hypervisor-VMM-的对比" class="headerlink" title="JVM 与 Hypervisor/VMM 的对比"></a>JVM 与 Hypervisor/VMM 的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>JVM</th>
<th>Hypervisor/VMM</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>运行 Java 程序的虚拟环境</td>
<td>管理和运行多个虚拟机，每个虚拟机可运行不同操作系统</td>
</tr>
<tr>
<td><strong>虚拟化层级</strong></td>
<td>应用程序级虚拟化（针对 Java 字节码）</td>
<td>操作系统级虚拟化（针对硬件资源）</td>
</tr>
<tr>
<td><strong>管理对象</strong></td>
<td><strong>Java 字节码执行环境</strong></td>
<td>虚拟机管理和<strong>硬件资源虚拟化</strong></td>
</tr>
<tr>
<td><strong>依赖性</strong></td>
<td>必须安装在操作系统上，依赖操作系统环境</td>
<td>Type 1 可以直接运行在硬件上，Type 2 依赖操作系统</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>程序之间隔离性较弱，依赖 JVM 的安全机制</td>
<td>每个虚拟机互相独立，硬件级别隔离</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>Oracle HotSpot VM、OpenJDK JVM</td>
<td>VMware ESXi、VirtualBox、KVM、Hyper-V</td>
</tr>
</tbody></table>
<ol>
<li>在 VMware ESXi 上创建一个虚拟机；</li>
<li>在虚拟机内部运行一个 Guest OS，比如 Linux；</li>
<li>在 Linux 中安装 Java 环境并运行 JVM。</li>
</ol>
<h1 id="Java-Memory-Model-J-U-C"><a href="#Java-Memory-Model-J-U-C" class="headerlink" title="Java Memory Model(J.U.C)"></a><a href="../JavaSE/JUC/J%E2%80%A4U%E2%80%A4C.md">Java Memory Model(J.U.C)</a></h1><h1 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h1><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom: 80%;" />

<p>1.7之前， MetaSpace 在运行时内存区域，也是独立于堆、线程私有内存的一片线程共享内存</p>
<p>线程私有：<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>程序计数器 PC</strong></p>
<p>线程共享：堆、Metaspace、直接内存</p>
<p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p>
<h2 id="运行时数据区域-Runtime"><a href="#运行时数据区域-Runtime" class="headerlink" title="运行时数据区域(Runtime)"></a>运行时数据区域(Runtime)</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250103144549650.png" alt="image-20250103144549650"></p>
<h3 id="线程私有-Local"><a href="#线程私有-Local" class="headerlink" title="线程私有(Local)"></a>线程私有(Local)</h3><h4 id="程序计数器-Program-Counter"><a href="#程序计数器-Program-Counter" class="headerlink" title="==程序计数器==(Program Counter)"></a>==程序计数器==(Program Counter)</h4><ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。    </li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，当线程被切换回来时能够知道该线程上次运行的位置。</li>
<li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地 址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。</li>
<li>唯一不会出现 <code>OutOufMemoryError</code> 的内存区域，与线程的生命周期相同</li>
</ul>
<h4 id="虚拟机栈-VM-Stack"><a href="#虚拟机栈-VM-Stack" class="headerlink" title="==虚拟机栈==(VM Stack)"></a>==虚拟机栈==(VM Stack)</h4><ul>
<li>per thread：与线程的生命周期相同</li>
<li>所有的 Java 方法调用都是通过虚拟机栈来实现的，就是事实上的 Java 方法栈</li>
<li><strong>LIFO</strong>：只支持出栈和入栈两种操作</li>
</ul>
<h5 id="栈帧-Stack-Frame"><a href="#栈帧-Stack-Frame" class="headerlink" title="栈帧(Stack Frame)"></a>栈帧(Stack Frame)</h5><ul>
<li><p>每一次方法调用都会有一个对应的栈帧被压入VM Stack，调用结束时弹出一个栈帧。</p>
</li>
<li><p>每个<strong>栈帧</strong>中都拥有：局部变量表、操作数栈、动态链接、方法返回地址</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/stack-area.png" alt="Java 虚拟机栈" style="zoom:67%;" /></li>
</ul>
<p><strong>==局部变量表==<strong>：局部变量表存放了编译期可知的各种Java虚拟机</strong>基本数据类型</strong>（boolean、byte、char、short、int、 float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和<strong>returnAddress 类型</strong>（指向了一条字节码指令的地址）。</p>
<p>其存储空间以局部变量槽（Slot）来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。这里说的“大小”是指变量槽的数量， 虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</p>
<p><strong>==操作数栈==<strong>：主要作为</strong>方法调用的中转站</strong>使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的<strong>临时变量</strong>也会放在操作数栈中。方法执行过程中通过出栈、入栈完成计算操作。</p>
<p><strong>==动态链接==<strong>：主要用于</strong>一个方法需要调用其他方法</strong>的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为实际内存地址。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态链接</strong>。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/jvmimage-20220331175738692-1735821102490-10.png" alt="img"></p>
<h5 id="StackOverFlow-OutOfMemory-Error"><a href="#StackOverFlow-OutOfMemory-Error" class="headerlink" title="StackOverFlow/OutOfMemory Error"></a>StackOverFlow/OutOfMemory <strong>Error</strong></h5><p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong> </p>
<p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E7%9A%84%E7%AC%AC2%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="img"></p>
<p>**==方法返回地址==**：</p>
<ul>
<li><strong>记录调用点的字节码指令地址</strong>，以便方法执行完毕后能返回到正确的位置继续执行程序。<ol>
<li>JVM 创建一个栈帧并保存调用点的字节码指令地址（<code>result = add(2, 3)</code>）。</li>
<li>计算 <code>a + b</code> 的结果，并将值返回给调用点。</li>
<li>执行结束后，当前栈帧弹出，并根据<strong>返回地址</strong>继续执行 <code>System.out.println(result)</code></li>
</ol>
</li>
<li>保证方法调用的<strong>有序性</strong>和<strong>完整性</strong>，支持嵌套调用和递归处理。</li>
</ul>
<h4 id="本地方法栈-Native-Stack"><a href="#本地方法栈-Native-Stack" class="headerlink" title="==本地方法栈==(Native Stack)"></a>==本地方法栈==(Native Stack)</h4><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<h3 id="线程共享-Global"><a href="#线程共享-Global" class="headerlink" title="线程共享(Global)"></a>线程共享(Global)</h3><h4 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="==堆==(Heap)"></a>==堆==(Heap)</h4><p>Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，==几乎==所有的==对象实例==以及==数组==都在这里分配内存。 <a href="#threadlocal">现在还可以在线程栈上分配</a></p>
<p>堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>
<h5 id="堆分代-HotSpot-VM"><a href="#堆分代-HotSpot-VM" class="headerlink" title="堆分代(HotSpot VM)"></a>堆分代(HotSpot VM)</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/hotspot-heap-structure.png" alt="堆内存结构"></p>
<p> <strong>Eden</strong> 区、两个 <strong>Survivor</strong> 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。<strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用本地内存。</strong> </p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。不过，设置的值应该在 0-15，否则会爆出以下错误：MaxTenuringThreshold of 20 is invalid; must be between 0 and 15</p>
<h6 id="为什么年龄只能是-0-15"><a href="#为什么年龄只能是-0-15" class="headerlink" title="为什么年龄只能是 0-15?"></a>为什么年龄只能是 0-15?</h6><p>因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。</p>
<h6 id="堆内存一定分代管理吗"><a href="#堆内存一定分代管理吗" class="headerlink" title="堆内存一定分代管理吗?"></a>堆内存一定分代管理吗?</h6><p>在十年之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部 都基于“经典分代” 来设计，需要新生代、老年代收集器搭配才能工作。但是随着GC技术的发展，HotSpot里面也出现了不采用分代设计的新GC。</p>
<p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将 Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p>
<h5 id="字符串常量池-String-Constant-Pool"><a href="#字符串常量池-String-Constant-Pool" class="headerlink" title="==字符串常量池==(String Constant Pool)"></a>==字符串常量池==(String Constant Pool)</h5><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在字符串常量池中创建字符串对象 ”ab“</span><br><span class="line">// 将字符串对象 ”ab“ 的引用赋值给给 aa</span><br><span class="line">String aa = &quot;ab&quot;;</span><br><span class="line">// 直接返回字符串常量池中字符串对象 ”ab“，赋值给引用 bb</span><br><span class="line">String bb = &quot;ab&quot;;</span><br><span class="line">System.out.println(aa==bb); // true</span><br></pre></td></tr></table></figure>

<p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p>
<p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 <strong>字符串常量池</strong>和<strong>静态变量</strong>从<strong>永久代</strong>移动到了 Java <strong>堆</strong>中。主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
<blockquote>
<p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p>
</blockquote>
<h2 id="本地内存-Native-Memory-也是线程共享"><a href="#本地内存-Native-Memory-也是线程共享" class="headerlink" title="本地内存(Native Memory, 也是线程共享)"></a>本地内存(Native Memory, 也是线程共享)</h2><h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="==方法区==(Method Area)"></a>==方法区==(Method Area)</h3><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，方法区到底要如何实现那就是虚拟机自己要考虑的事情了。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。</p>
<p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>
<h4 id="永久代-PermGen-和-元空间-Metaspace"><a href="#永久代-PermGen-和-元空间-Metaspace" class="headerlink" title="永久代(PermGen) 和 元空间(Metaspace)"></a>永久代(PermGen) 和 元空间(Metaspace)</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250103142749020.png" alt="image-20250103142749020"></p>
<p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是<strong>永久代</strong>和<strong>元空间</strong>，接口可以看作是<strong>方法区</strong>，也就是说<strong>永久代</strong>以及<strong>元空间</strong>是 <strong>HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式</strong>。并且，<strong>永久代</strong>（Permanent Gen）是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了<strong>元空间</strong>（Metaspace）。</p>
<ul>
<li>整个<strong>永久代</strong>（PermGen）有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而<strong>元空间</strong>（Metaspace）使用的是本地内存，受<strong>本机可用内存</strong>的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li>
<li><strong>元空间</strong>（Metaspace）里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</li>
<li>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
</ul>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">/* 设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line"><span class="comment">				        如果未指定，根据运行时需求动态调整 */</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小 默认unlimited</span></span><br></pre></td></tr></table></figure>

<h4 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池(Runtime Constant Pool)"></a>运行时常量池(Runtime Constant Pool)</h4><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p>
<p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的 intern()方法。</p>
<p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/symbol-reference-and-direct-reference.png" alt="符号引用和直接引用"></p>
<p>常量池表会在类加载后存放到方法区的<strong>运行时常量池</strong>中。</p>
<p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p>
<h4 id="GC"><a href="#GC" class="headerlink" title="GC?"></a>GC?</h4><blockquote>
<p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选 择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤 其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
</blockquote>
<h3 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="==直接内存==(Direct Memory)"></a>==直接内存==(Direct Memory)</h3><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。它并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p>
<p>JDK 1.4 中新加入的 <strong>NIO（Non-Blocking I/O，也被称为 New I/O）</strong>，引入了一种基于<strong>通道（Channel）</strong>与<strong>缓存区（Buffer）</strong>的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到 本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError。</p>
<h2 id="HotSpot-VM-对象"><a href="#HotSpot-VM-对象" class="headerlink" title="HotSpot VM 对象"></a>HotSpot VM 对象</h2><h3 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h3><h4 id="类加载检查-metadata-check"><a href="#类加载检查-metadata-check" class="headerlink" title="类加载检查 metadata check"></a>类加载检查 metadata check</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，必须先执行类加载过程，确保 class metadata 已经加载到内存中，并在方法区中创建类的相关信息（如字段、方法、常量池等）。</p>
<h4 id="分配内存-memory-allocation"><a href="#分配内存-memory-allocation" class="headerlink" title="分配内存 memory allocation"></a>分配内存 memory allocation</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<h5 id="内存分配的两种方式"><a href="#内存分配的两种方式" class="headerlink" title="内存分配的两种方式"></a>内存分配的两种方式</h5><ul>
<li><strong>指针碰撞</strong>(Bump the Pointer): <ul>
<li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew, G1, ZGC</li>
</ul>
</li>
<li><strong>空闲列表</strong>(Free List): <ul>
<li>适用场合：堆内存不规整的情况下。</li>
<li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块来划分给对象实例，最后更新列表记录。类似操作系统分配内存</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 算法是”清除”，还是”压缩”，复制算法的内存也是规整的（Serial, Parallel, PCompact 对于年轻代的收集）。</p>
<h5 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a>内存分配并发问题</h5><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机可以采用以下方式来保证堆内存分配的线程安全：</p>
<ul>
<li><strong>CAS + 失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS + 失败重试的方式保证更新操作的原子性。</strong> </li>
<li><strong>TLAB (Thread Local Allocation Buffer)：</strong> 为每一个线程预先在堆的 Eden 区分配一小块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</li>
</ul>
<h5 id="逃逸分析优化"><a href="#逃逸分析优化" class="headerlink" title="逃逸分析优化"></a><span id="threadlocal">逃逸分析优化</span></h5><p><strong>逃逸分析优化</strong>：将不逃逸的对象直接分配到栈或使用标量替换，避免堆内存分配。</p>
<p>随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果<strong>某些方法中的对象引用没有被返回或者未被外面使用</strong>（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>
<h4 id="初始化零值-set-to-zero"><a href="#初始化零值-set-to-zero" class="headerlink" title="初始化零值 set to zero"></a>初始化零值 set to zero</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。（例如，整型为0，浮点型为0.0，引用类型为null等）</p>
<h4 id="设置对象头-set-object-header"><a href="#设置对象头-set-object-header" class="headerlink" title="设置对象头 set object header"></a>设置对象头 set object header</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<ul>
<li><strong>Mark Word</strong>: 存储对象的 hashcode, GC 年龄, 锁状态标志等</li>
<li><strong>Klass Pointer</strong>: 指向方法区中的 class metadata，确定对象的类型。</li>
<li>对于数组来说，还有数组的长度信息。</li>
</ul>
<h4 id="执行-init-方法-execute-lt-init-gt"><a href="#执行-init-方法-execute-lt-init-gt" class="headerlink" title="执行 init 方法 execute &lt;init&gt;"></a>执行 init 方法 execute &lt;init&gt;</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><h4 id="64-位-JVM-下的对象内存布局"><a href="#64-位-JVM-下的对象内存布局" class="headerlink" title="64 位 JVM 下的对象内存布局"></a>64 位 JVM 下的对象内存布局</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/57e6e147dbe447d0b96b4d310f01846atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<table>
<thead>
<tr>
<th>部分</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Mark Word</strong></td>
<td>8 字节</td>
<td>存储对象状态信息，如哈希码、锁信息和 GC 标记。</td>
</tr>
<tr>
<td><strong>Klass Pointer</strong></td>
<td>8 字节</td>
<td>指向对象所属类的类型元数据，便于方法调度和类型检查。</td>
</tr>
<tr>
<td><strong>数组长度（可选）</strong></td>
<td>4 字节 (可选)</td>
<td>如果是数组对象，会额外包含存储数组长度的字段。</td>
</tr>
<tr>
<td><strong>实例数据</strong></td>
<td>动态分配</td>
<td>存储实例变量的值，按照字段声明顺序对齐存储（按 4 字节或 8 字节对齐）。</td>
</tr>
<tr>
<td><strong>对齐填充</strong></td>
<td>动态填充</td>
<td>保证对象大小是 8 字节的倍数，以便提高内存访问效率。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">20.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 64 位 JVM 上，内存布局如下：</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>对象头 - Mark Word</strong></td>
<td>8 字节</td>
<td>哈希码、锁信息、GC 状态等。</td>
</tr>
<tr>
<td><strong>对象头 - Klass Pointer</strong></td>
<td>8 字节</td>
<td>指向类元数据的指针。</td>
</tr>
<tr>
<td><strong>实例数据</strong></td>
<td>12 字节</td>
<td>包括 <code>a</code> (4 字节)、<code>flag</code> (1 字节)、填充 (3 字节) 和 <code>value</code> (8 字节)。</td>
</tr>
<tr>
<td><strong>对齐填充</strong></td>
<td>4 字节</td>
<td>保证对象大小为 8 字节的倍数。</td>
</tr>
</tbody></table>
<p>总大小：<strong>32 字节</strong>（对齐填充确保 8 字节对齐）。</p>
<p>Java 对象头主要由 <strong>Mark Word</strong> 和 <strong>Klass Pointer</strong> 组成，存储对象状态信息和类型元数据指针。</p>
<ul>
<li>支持 JVM 的垃圾回收、同步机制（锁）、偏向锁及哈希计算等操作。</li>
<li>数组对象还包含额外的长度字段以支持动态数组存储。</li>
<li>由于对象头是二进制存储格式，不是直接可读的文本信息，需要工具或命令解析其内容，如 <code>jol</code> 或 <code>javap -v</code>。</li>
</ul>
<h4 id="对象头-Object-Header"><a href="#对象头-Object-Header" class="headerlink" title="对象头(Object Header)"></a>对象头(Object Header)</h4><p>Java 对象头（Object Header）是 <strong>Java 对象在内存中的元数据信息</strong>，主要用于支持 JVM 的对象管理和操作</p>
<h5 id="Mark-Word-的详细解析"><a href="#Mark-Word-的详细解析" class="headerlink" title="Mark Word 的详细解析"></a>Mark Word 的详细解析</h5><p>用于存储对象的运行时状态信息，包括：</p>
<ul>
<li><strong>锁状态标记</strong>（轻量级锁、重量级锁等）</li>
<li><strong>哈希码</strong>（HashCode）</li>
<li><strong>GC 标记</strong>（垃圾回收标记位）</li>
<li><strong>年龄计数器</strong>（GC 年龄，用于晋升到老年代的判断）</li>
</ul>
<p>Mark Word 的具体结构会根据对象状态发生变化：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>标记位</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong>未锁定（默认状态）</strong></td>
<td>01</td>
<td>对象哈希码、GC 年龄等信息。</td>
</tr>
<tr>
<td><strong>轻量级锁定</strong></td>
<td>00</td>
<td>指向栈中锁记录的指针（Lock Record）。</td>
</tr>
<tr>
<td><strong>重量级锁定</strong></td>
<td>10</td>
<td>指向重量级锁的指针（Monitor 对象）。</td>
</tr>
<tr>
<td><strong>GC 标记</strong></td>
<td>11</td>
<td>标记 GC 状态。</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>01</td>
<td>偏向线程 ID、时间戳等信息（启用偏向锁时）。</td>
</tr>
</tbody></table>
<p>示例 1：Mark Word 示例（未锁定状态）</p>
<p>假设一个对象未加锁且未偏向：</p>
<table>
<thead>
<tr>
<th>偏向锁</th>
<th>锁状态</th>
<th>GC 年龄</th>
<th>对象哈希码 (HashCode)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>01</td>
<td>000000</td>
<td>00101011100011000111100011000101</td>
</tr>
</tbody></table>
<ul>
<li>偏向锁：0 表示未偏向线程。</li>
<li>锁状态：01 表示未加锁状态。</li>
<li>GC 年龄：000000 表示对象的 GC 年龄为 0。</li>
<li>哈希码：对象哈希值经过位移和组合后存储在 Mark Word 中。</li>
</ul>
<p>示例 2：轻量级锁</p>
<p>对象进入轻量级锁定状态：</p>
<table>
<thead>
<tr>
<th>偏向锁</th>
<th>锁状态</th>
<th>指针内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>00</td>
<td>指向线程栈中 Lock Record（锁记录）的指针地址。</td>
</tr>
</tbody></table>
<h5 id="Klass-Pointer（类型指针）"><a href="#Klass-Pointer（类型指针）" class="headerlink" title="Klass Pointer（类型指针）"></a>Klass Pointer（类型指针）</h5><p>指向对象的<strong>类元数据</strong>（Class Metadata），用于标识该对象的具体类型及方法表等信息。</p>
<p>Klass Pointer 是一个指向方法区中 <strong>类元数据</strong> 的指针，包含以下信息：</p>
<ul>
<li>对象所属类的名称和继承关系。</li>
<li>类字段和方法表指针（用于动态方法分派）。</li>
<li>类的内存布局及实例大小信息。</li>
</ul>
<p><strong>作用：</strong>帮助 JVM 在运行时支持<strong>多态</strong>和<strong>类型检查</strong>。</p>
<h5 id="数组对象的额外信息"><a href="#数组对象的额外信息" class="headerlink" title="数组对象的额外信息"></a>数组对象的额外信息</h5><p>如果对象是数组类型，则会额外存储<strong>数组长度信息</strong>。</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数组长度字段</strong></td>
<td>4 字节</td>
<td>存储数组元素的个数。</td>
</tr>
<tr>
<td><strong>元素数据</strong></td>
<td>动态大小</td>
<td>实际存储数组元素的连续内存空间。</td>
</tr>
</tbody></table>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p>
<h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p>
<p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄池地址，在对象被移动或者GC时只会改变句柄池中的实例数据指针，而 reference 本身不需要修改。缺点是多一次指针解析，性能略低。</p>
<h4 id="直接指针-HotSpot-VM"><a href="#直接指针-HotSpot-VM" class="headerlink" title="直接指针(HotSpot VM)"></a>直接指针(HotSpot VM)</h4><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p>
<p>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销，更适合现代高性能 JVM 和 GC，如 G1 和 ZGC，这些 GC 使用并发机制降低对象移动成本，同时提高访问速度。</p>
<h3 id="JOL-分析对象内存布局"><a href="#JOL-分析对象内存布局" class="headerlink" title="JOL 分析对象内存布局"></a>JOL 分析对象内存布局</h3><p>Java Object Layout</p>
<ul>
<li><p><strong>JOL 的核心功能</strong></p>
<ol>
<li><strong>对象内存布局分析</strong><br>检查 Java 对象的结构，包括对象头信息、实例数据以及填充字节（padding）。</li>
<li><strong>对象大小计算</strong><br>精确测量对象占用的内存空间，有助于优化内存使用。</li>
<li><strong>对象对齐规则分析</strong><br>研究 Java 虚拟机的内存对齐方式和效率。</li>
<li><strong>偏向锁与轻量级锁的状态分析</strong><br>观察锁状态以及对象头的变化，帮助理解 Java 并发机制的底层实现。</li>
</ol>
</li>
<li><p>JOL 是基于 JVM 实现的，具体表现可能因 JVM 版本和平台而异。</p>
</li>
<li><p>使用 JOL 分析锁状态时，需要结合 <code>-XX:+UseBiasedLocking</code> 等 JVM 参数。</p>
</li>
<li><p>JOL 不支持所有类型的对象分析，例如直接内存分配的对象需要其他工具辅助。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLExample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">boolean</span> b;</span><br><span class="line">        <span class="type">long</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印对象内存布局</span></span><br><span class="line">        <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(example).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">org.example.JOLExample<span class="variable">$Example</span> <span class="keyword">object</span> internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                     VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">8</span>        (<span class="keyword">object</span> header)                 <span class="number">0x0000000000000000</span></span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>    <span class="keyword">int</span> JOLExample<span class="variable">$Example</span>.a            <span class="number">0</span></span><br><span class="line">     <span class="number">12</span>     <span class="number">1</span> <span class="keyword">boolean</span> JOLExample<span class="variable">$Example</span>.b           <span class="literal">false</span></span><br><span class="line">     <span class="number">13</span>     <span class="number">3</span>        (alignment/padding gap)</span><br><span class="line">     <span class="number">16</span>     <span class="number">8</span>   long JOLExample<span class="variable">$Example</span>.c            <span class="number">0</span></span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">3</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">3</span> bytes total</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OFFSET：字段或数据在对象中的偏移量（单位字节）。</span></span><br><span class="line"><span class="comment"> * SIZE：字段占用的字节数。</span></span><br><span class="line"><span class="comment"> * TYPE/DESCRIPTION：字段类型和名称。</span></span><br><span class="line"><span class="comment"> * VALUE：字段的当前值。</span></span><br><span class="line"><span class="comment"> * alignment/padding：由于内存对齐，填充的字节数，保证效率。</span></span><br><span class="line"><span class="comment"> * Instance size：对象的总大小（包括填充字节）。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="JVM-调参"><a href="#JVM-调参" class="headerlink" title="JVM 调参"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html">JVM 调参</a></h1><h2 id="JDK-分析工具"><a href="#JDK-分析工具" class="headerlink" title="JDK 分析工具"></a>JDK 分析工具</h2><p>除了之前提到的 JOL 是运行在 JVM 上的分析工具，还有很多命令行和可视化工具，主要用于监控、性能分析、内存管理和线程死锁与阻塞分析。</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>主要用途</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JConsole</strong></td>
<td>实时监控 JVM 性能</td>
<td>本地或远程简单监控应用性能</td>
</tr>
<tr>
<td><strong>VisualVM</strong></td>
<td>高级性能分析和内存快照分析</td>
<td>找出性能瓶颈和内存泄漏问题</td>
</tr>
<tr>
<td><strong>jstat</strong></td>
<td>JVM 性能统计和 GC 监控</td>
<td>快速诊断内存和垃圾回收问题</td>
</tr>
<tr>
<td><strong>jmap</strong></td>
<td>查看堆信息，生成堆快照</td>
<td>内存分析和排查内存泄漏</td>
</tr>
<tr>
<td><strong>jhat</strong></td>
<td>分析堆快照，与jmap配合</td>
<td>离线分析堆对象引用关系</td>
</tr>
<tr>
<td><strong>jstack</strong></td>
<td>查看线程堆栈信息</td>
<td>排查线程死锁和阻塞问题</td>
</tr>
<tr>
<td><strong>jinfo</strong></td>
<td>查看和调整 JVM 参数</td>
<td>动态调整配置，调试运行时环境</td>
</tr>
<tr>
<td><strong>JMC/JFR</strong></td>
<td>高级分析工具，支持低开销记录</td>
<td>深入分析生产环境性能问题（低性能影响）</td>
</tr>
</tbody></table>
<p>除了 <strong>JOL (Java Object Layout)</strong> 之外，还有以下几款同类型的 Java 内存分析和对象布局工具，可以用于分析 Java 对象结构、内存占用及内存管理相关问题：</p>
<p>JDK </p>
<table>
<thead>
<tr>
<th>工具</th>
<th>类型</th>
<th>主要用途</th>
<th>是否免费</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JOL</strong></td>
<td>对象布局分析</td>
<td>内存对齐、对象头、填充字节分析</td>
<td>是</td>
</tr>
<tr>
<td><strong>Arthas</strong></td>
<td>在线诊断工具</td>
<td>实时分析线程、内存、锁状态，适合生产环境</td>
<td>是</td>
</tr>
<tr>
<td><strong>MAT</strong></td>
<td>堆内存分析</td>
<td>内存泄漏、引用链分析</td>
<td>是</td>
</tr>
<tr>
<td><strong>javap</strong></td>
<td>字节码分析工具</td>
<td>查看编译后的字节码结构，研究 JVM 执行过程</td>
<td>是</td>
</tr>
</tbody></table>
<h1 id="GC-的对象"><a href="#GC-的对象" class="headerlink" title="GC 的对象"></a>GC 的对象</h1><p><strong>失去引用</strong>是指一个对象在程序中不再被任何变量或其他对象引用，从而变成<strong>不可达对象</strong>。这些对象无法通过代码访问，因此被认为是<strong>垃圾</strong>，可以由<strong>垃圾回收器（GC）</strong>回收并释放内存。对象失去引用意味着程序无法再访问它，它将成为垃圾回收的候选对象。当程序对对象的引用断开或超出作用域后，JVM 会在合适的时机将其回收以优化内存使用。</p>
<p><strong>引用的定义</strong>：引用是指程序中的变量指向堆内存中的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里变量 <code>str</code> 引用了字符串对象 <code>&quot;Hello&quot;</code>。</p>
<h2 id="失去引用的几种情况"><a href="#失去引用的几种情况" class="headerlink" title="失去引用的几种情况"></a>失去引用的几种情况</h2><ol>
<li><p><strong>变量重新赋值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">str = <span class="literal">null</span>; <span class="comment">// 原来的 &quot;Hello&quot; 对象失去了引用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">str1 = str2; <span class="comment">// &quot;Hello&quot; 对象失去了引用</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>作用域结束</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">example</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&quot;Temporary&quot;</span>; <span class="comment">// 创建引用</span></span><br><span class="line">&#125; <span class="comment">// 方法结束，temp 超出作用域，失去引用</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对象被移除出集合</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">list.remove(<span class="number">0</span>); <span class="comment">// 元素 &quot;A&quot; 失去了引用</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对象之间的引用关系断开</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"><span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">n1.next = n2;</span><br><span class="line">n1.next = <span class="literal">null</span>; <span class="comment">// n2 失去了引用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="失去引用后的处理"><a href="#失去引用后的处理" class="headerlink" title="失去引用后的处理"></a>失去引用后的处理</h2><ol>
<li><strong>垃圾回收</strong>：JVM 会自动检测失去引用的对象，并在适当的时机进行垃圾回收（GC）。</li>
<li><strong>内存释放</strong>：GC 回收这些对象占用的堆内存，使其可供新对象使用。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>内存泄漏：如果对象仍然被引用，但实际上不再使用，就会导致垃圾回收器无法回收它们，形成内存泄漏。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 对象持续引用导致内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>显式释放引用</strong>：可以通过将对象引用赋值为 <code>null</code> 来帮助垃圾回收器更快地释放内存，但通常不需要显式操作，JVM 会自动管理内存。</p>
</li>
</ol>
<h2 id="GC-管理的对象范围"><a href="#GC-管理的对象范围" class="headerlink" title="GC 管理的对象范围"></a>GC 管理的对象范围</h2><ol>
<li><strong>堆内存中的对象</strong><ul>
<li>**新生代 (Young Generation)**：短生命周期对象，通常是临时变量和局部变量。</li>
<li>**老年代 (Old Generation)**：生命周期较长的对象，例如缓存对象或单例对象。</li>
<li>**元空间 (Metaspace)**：类的元数据和常量池。</li>
</ul>
</li>
<li><strong>非 GC 管理的对象</strong><ul>
<li><strong>栈上的局部变量</strong>：存储在线程栈中，不由 GC 管理，方法结束后自动销毁。</li>
<li>**直接内存 (Direct Memory)**：例如 NIO 的直接缓冲区，需要显式释放。</li>
<li><strong>静态变量</strong>：存储在方法区中（元空间），生命周期随类加载器而定，不属于 GC 管理对象。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="GC-回收的对象条件"><a href="#GC-回收的对象条件" class="headerlink" title="GC 回收的对象条件"></a>GC 回收的对象条件</h2><h3 id="不可达对象"><a href="#不可达对象" class="headerlink" title="不可达对象"></a>不可达对象</h3><p>如果一个对象无法通过<strong>GC Roots</strong>直接或间接引用，则它被视为不可达对象，可以被 GC 回收。</p>
<h3 id="GC-Roots-可达"><a href="#GC-Roots-可达" class="headerlink" title="GC Roots 可达"></a>GC Roots 可达</h3><p>以下对象被视为 GC Roots，是垃圾回收的起始点：</p>
<ol>
<li><strong>栈中的局部变量和方法参数</strong>（线程栈帧中引用的对象）。</li>
<li><strong>静态变量引用的对象</strong>。</li>
<li><strong>常量引用的对象</strong>。</li>
<li><strong>类加载器引用的对象</strong>。</li>
<li><strong>JNI 引用的本地代码对象</strong>（如 Native 方法）。</li>
<li><strong>活动线程引用的对象</strong>。</li>
</ol>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>GC 使用<strong>可达性分析算法</strong>判断对象是否可达。如果从 GC Roots 无法找到路径引用某个对象，则它被视为垃圾对象。</p>
<hr>
<h2 id="强引用-软引用-弱引用-虚引用"><a href="#强引用-软引用-弱引用-虚引用" class="headerlink" title="强引用/软引用/弱引用/虚引用"></a>强引用/软引用/弱引用/虚引用</h2><p>Java 提供了 4 种不同强度的引用类型，用于控制对象的生命周期：</p>
<ol>
<li><strong>强引用 (Strong Reference)</strong><ul>
<li>默认引用类型，不可回收。</li>
<li>示例：<code>String s = &quot;Hello&quot;;</code></li>
<li>只有强引用断开，GC 才会考虑回收对象。</li>
</ul>
</li>
<li><strong>软引用 (Soft Reference)</strong><ul>
<li>适合缓存数据，内存不足时才会回收。</li>
<li>示例：<code>SoftReference&lt;String&gt; sr = new SoftReference&lt;&gt;(new String(&quot;Cache&quot;));</code></li>
</ul>
</li>
<li><strong>弱引用 (Weak Reference)</strong><ul>
<li>GC 时会立即回收，无论内存是否充足。</li>
<li>示例：<code>WeakReference&lt;String&gt; wr = new WeakReference&lt;&gt;(new String(&quot;Temp&quot;));</code></li>
</ul>
</li>
<li><strong>虚引用 (Phantom Reference)</strong><ul>
<li>不影响对象生命周期，仅用于检测对象何时被 GC 回收。</li>
<li>示例：<code>PhantomReference&lt;String&gt; pr = new PhantomReference&lt;&gt;(new String(&quot;Test&quot;), refQueue);</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="触发-GC-的条件"><a href="#触发-GC-的条件" class="headerlink" title="触发 GC 的条件"></a>触发 GC 的条件</h2><ol>
<li><strong>内存不足</strong>：年轻代或老年代空间耗尽。</li>
<li>**调用 System.gc()**：请求 JVM 进行 GC，但不保证立即执行。</li>
<li><strong>对象失去引用</strong>：对象不可达，进入 GC 阶段。</li>
<li><strong>类加载和卸载</strong>：类元数据或方法区空间不足时触发 GC。</li>
<li><strong>手动释放资源</strong>：如关闭文件流、网络连接等，减少内存压力。</li>
</ol>
<h2 id="GC-示例"><a href="#GC-示例" class="headerlink" title="GC 示例"></a>GC 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 强引用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> obj1;        <span class="comment">// 共享引用</span></span><br><span class="line">        obj1 = <span class="literal">null</span>;               <span class="comment">// obj1 失去引用，但 obj2 仍指向它</span></span><br><span class="line">        System.gc();               <span class="comment">// 提示 GC 执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><code>obj1</code> 被赋值为 <code>null</code>，但 <code>obj2</code> 仍然引用对象，因此不会被回收。</li>
<li>若同时将 <code>obj2</code> 设置为 <code>null</code>，对象变为不可达对象，则 GC 会将其回收。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/15/hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/15/hash/" class="post-title-link" itemprop="url">哈希函数的工程应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-15T00:00:00+08:00">2024-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 00:59:33" itemprop="dateModified" datetime="2025-04-26T00:59:33+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/math/" itemprop="url" rel="index"><span itemprop="name">math</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">散列函数 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h2 id="Hash-是什么"><a href="#Hash-是什么" class="headerlink" title="Hash 是什么"></a>Hash 是什么</h2><p>哈希（Hash）的原理是通过一种<strong>特定的函数</strong>，将任意长度的输入（也称为键）<strong>映射</strong>为固定长度的输出（称为哈希值、哈希码或散列值）。这种函数称为<strong>哈希函数</strong>或<strong>散列函数</strong>。哈希主要用于快速查找、数据完整性验证等方面，下面具体解释其原理和应用：</p>
<h2 id="哈希函数的原理"><a href="#哈希函数的原理" class="headerlink" title="哈希函数的原理"></a>哈希函数的原理</h2><p>哈希函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（又叫<strong>哈希值</strong>）（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。</p>
<p>哈希函数的基本目标是<strong>将不同的输入映射为不同的输出</strong>。常见哈希函数的特性包括：</p>
<ul>
<li><strong>确定性</strong>：相同的输入永远会产生相同的哈希值。</li>
<li><strong>效率</strong>：计算哈希值的过程非常快，便于快速存取和查找。</li>
<li><strong>分布均匀</strong>：不同的输入尽可能分布到不同的哈希值上，以减少哈希冲突。</li>
<li><strong>不可逆性</strong>：通常不能通过哈希值反推出原始输入（主要在密码学中强调）。<ul>
<li>攻破：能够找出具有相同哈希值的一对报文，但是从一个已知报文篡改成具有相同哈希值的报文仍然没有方法</li>
</ul>
</li>
</ul>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>哈希函数将无限多的输入映射到有限的输出空间，因此必然会发生不同输入产生相同哈希值的情况，即<strong>哈希冲突</strong>。常见的处理冲突方法有：</p>
<ul>
<li><p><strong>链地址法（链表法）</strong>：在哈希表中，每个位置存储一个链表，当出现冲突时将数据插入链表。（JDK HashMap）链地址法适用于经常进行插入和删除的情况。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-20230822202707.png" alt="img"></p>
</li>
<li><p><strong>开放地址法</strong>：通过探测和寻找空位存储冲突的数据，例如线性探测、二次探测、伪随机探测再散列等。二次探测消除了线性探测的聚集问题，这种聚集问题叫做原始聚集</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-20230822203134.png" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-20230822203306.png" alt="img"></p>
</li>
<li><p><strong>再哈希法</strong>：当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
</li>
</ul>
<h2 id="哈希应用"><a href="#哈希应用" class="headerlink" title="哈希应用"></a>哈希应用</h2><ul>
<li><strong>哈希表</strong>：用于快速存储和查找数据，常用的数据结构之一。</li>
<li><strong>数据完整性</strong>：验证数据的完整性，如文件校验和。</li>
<li><strong>密码学</strong>：生成数据的“指纹”，用于验证用户密码、数字签名等。</li>
</ul>
<h2 id="哈希函数的常见算法"><a href="#哈希函数的常见算法" class="headerlink" title="哈希函数的常见算法"></a>哈希函数的常见算法</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MD5">MD5消息摘要算法</a><strong>（英语：</strong>MD5 Message-Digest Algorithm</strong>），一种被广泛使用的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>，可以产生出一个128位（16个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>）的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97">散列</a>值（hash value），用于确保信息传输完整一致。曾被用于文件校验、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SSL">SSL</a>/<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TLS">TLS</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IPsec">IPsec</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Secure_Shell">SSH</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2404002">深入解析MD5哈希算法：原理、应用与安全性-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37257569">MD5算法 - 知乎 (zhihu.com)</a></p>
<ul>
<li>将报文按模2^64^取余，追加在报文后面</li>
<li>在报文和余数之间填充若干位，使得总长度为512的整数倍，第一位是1其他位是0</li>
<li>按照512位一块，分成若干块，分割之后再把每块分成4个128位的数据块，送到4个不同的哈希函数进行4轮计算，每一轮按照32位的小块进行运算，一直到最后计算出MD5报文摘要代码。</li>
</ul>
<h3 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h3><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F">安全散列算法</a><strong>（英语：</strong>Secure Hash Algorithm</strong>，缩写为<strong>SHA</strong>）是一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>家族，是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%81%94%E9%82%A6%E8%B5%84%E6%96%99%E5%A4%84%E7%90%86%E6%A0%87%E5%87%86">FIPS</a>所认证的安全<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">散列算法</a>。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的几率很高。</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/news/351438.html">什么是 SHA 加密？ SHA-1 与 SHA-2 - FreeBuf网络安全行业门户</a></p>
<h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">循环冗余校验</a><strong>（英语：</strong>Cyclic redundancy check</strong>，通称“<strong>CRC</strong>”）是一种根据网络数据包或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E6%AA%94%E6%A1%88">电脑文件</a>等数据产生简短固定位数校验码的一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">散列函数</a>，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。</p>
<p><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html">什么是CRC（Cyclic Redundancy Check）？如何解决CRC错误？ - 华为 (huawei.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E6%A0%A1%E9%AA%8C%E5%92%8C">校验和 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<h3 id="分布式哈希算法—服务节点集群、DHT"><a href="#分布式哈希算法—服务节点集群、DHT" class="headerlink" title="分布式哈希算法—服务节点集群、DHT"></a>分布式哈希算法—服务节点集群、DHT</h3><p><strong>分布式哈希函数</strong>：用于负载均衡和分布式存储，如一致性哈希。</p>
<h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/120814088">一致性哈希算法原理详解-CSDN博客</a> </p>
<p>如果简单的用服务器数量取模来进行负载均衡，一旦新增或者故障移除使服务器数变化，就会导致同一个key，一开始存储在A服务器上，数量变化后，去B服务器查询，也就是被分配到了与之前不同的服务器上，导致缓存大量失效，缓存失效的根本原因是：普通哈希算法的映射规则与节点数量高度耦合，导致节点数量变化时，几乎所有数据的映射关系都会变动。因此，之前缓存的绝大部分数据都会失效，无法在原有的缓存节点上找到，导致缓存命中率急剧下降。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/7903f62393641e5f3cafa28b059321b6.png" alt="取模" style="zoom: 75%;" />

<ul>
<li><p>一致性哈希通过对2^32^取模，将各个服务器进行哈希，分配到哈希环上，可以使用IP地址或者主机名哈希</p>
</li>
<li><p>把数据key也分配到哈希环上面，然后顺时针寻找离自己最近的服务器（哈希值）</p>
</li>
</ul>
<p>如下图所示，一台服务器挂了，不会影响到它之后的key，最小化缓存失效的影响</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111180255460.png" alt="image-20241111180255460"></p>
<h5 id="哈希环倾斜—虚拟节点"><a href="#哈希环倾斜—虚拟节点" class="headerlink" title="哈希环倾斜—虚拟节点"></a>哈希环倾斜—虚拟节点</h5><p>如下图所示，服务器节点较少，导致大部分key都缓存在A服务器上，数据分布不均匀，削弱了负载均衡的效果</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111180439707.png" alt="image-20241111180439707" style="zoom:50%;" />

<p>还有一种情况，节点数过少，只有AB</p>
<p>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点，一个实际物理节点可以对应多个虚拟节点，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大，hash环倾斜所带来的影响就越小，同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射。一个节点挂掉不至于将所有请求打到另一个节点上导致连续崩溃，起到负载均衡的作用。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111180905461.png" alt="image-20241111180905461" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2084611-20220527090607907-112778299.png" alt="img" style="zoom: 80%;" />



<h5 id="应用：DHT"><a href="#应用：DHT" class="headerlink" title="应用：DHT"></a>应用：DHT</h5><p>DHT 将<strong>键值对 (key-value)</strong> 存储在多个分布式节点中，通过哈希函数映射键值到节点位置，实现快速查找和存储。</p>
<ul>
<li>**键 (Key)**：唯一标识数据项的标记。</li>
<li>**值 (Value)**：存储的实际数据或其引用。</li>
<li><strong>哈希函数</strong>：将键映射到固定长度的哈希值，用于定位数据。</li>
</ul>
<p>DHT 使用<strong>一致性哈希算法</strong>（Consistent Hashing）将节点和数据映射到一个<strong>哈希环</strong>上，确保节点的加入或退出只影响少量数据的重新分布。</p>
<p><strong>存储数据</strong>：</p>
<ul>
<li>数据通过哈希函数生成键，例如 <code>hash(key)</code>。</li>
<li>键定位到负责存储的节点。</li>
</ul>
<p><strong>查找数据</strong>：</p>
<ul>
<li>查询方根据相同哈希规则计算键的哈希值，找到对应节点。</li>
<li>请求直接或逐步（路由）传递到存储数据的节点。</li>
</ul>
<p><strong>节点变化处理</strong>：</p>
<ul>
<li>新节点加入：重新分配部分数据给新节点。</li>
<li>节点退出：其数据重新分配到其他节点上，保证冗余备份和数据一致性。</li>
</ul>
<p>应用：</p>
<p><strong>P2P 网络</strong>：</p>
<ul>
<li>BitTorrent 使用 DHT 寻找资源和共享文件。</li>
<li>Kad 网络（eMule）基于 Kademlia 算法实现。</li>
</ul>
<p><strong>分布式缓存</strong>：</p>
<ul>
<li>Cassandra、DynamoDB 等分布式数据库利用 DHT 进行数据分布和一致性维护。</li>
</ul>
<p><strong>区块链和去中心化存储</strong>：</p>
<ul>
<li>IPFS（InterPlanetary File System）利用 DHT 定位文件存储位置。</li>
</ul>
<p><strong>分布式文件系统</strong>：</p>
<ul>
<li>Chord、Pastry、Tapestry 等协议用于存储和检索分布式文件。</li>
</ul>
<p><strong>Chord</strong>：环形结构，使用一致性哈希算法，支持动态节点增减。</p>
<p><strong>Kademlia</strong>：基于二叉树的路由协议，用于 eMule 和 BitTorrent。</p>
<p><strong>Pastry</strong>：支持高效查找和动态扩展，适用于大型网络。</p>
<p><strong>Tapestry</strong>：与 Pastry 类似，优化了搜索路径和延迟控制。</p>
<h4 id="哈希插槽"><a href="#哈希插槽" class="headerlink" title="哈希插槽"></a>哈希插槽</h4><p>详见redis cluster的哈希插槽实现</p>
<h2 id="应用：哈希表"><a href="#应用：哈希表" class="headerlink" title="应用：哈希表"></a>应用：哈希表</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">散列表 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>哈希表在大多数实现中，本质上是<strong>一个大数组</strong>，其中每个元素称为<strong>桶（bucket）</strong>。在这个大数组的基础上，通过哈希函数将键映射到数组的索引位置来存储和查找数据。</p>
<p>本质还是一个数组，但是数组的角标和键挂钩，在数组角标位置存储值，根据键就能很快找到对应的索引。</p>
<h3 id="哈希表的实现原理"><a href="#哈希表的实现原理" class="headerlink" title="哈希表的实现原理"></a>哈希表的实现原理</h3><ol>
<li><p><strong>一个大数组</strong>：哈希表的核心数据结构是一个数组，用于存储数据的位置。每个数组元素可以直接存储数据（若无冲突）或指向链表、红黑树等其他结构（若发生冲突）。</p>
</li>
<li><p><strong>数组中的每个元素即为一个桶</strong>：</p>
<ul>
<li>当多个键的哈希值映射到同一个索引位置（即哈希冲突）时，这个位置的元素会作为桶的“起点”，桶内部可以使用链表或树结构来存储多个值。</li>
<li>在 JDK 的 <code>HashMap</code> 中，每个桶初始是一个链表，当冲突元素超过一定数量时，该桶会从链表转换为红黑树结构，以提升查找效率。</li>
</ul>
</li>
<li><p><strong>桶数组的大小</strong>：一般是固定大小或者按需扩容。例如，Java 中的 <code>HashMap</code> 会在达到一定负载因子后（通常为 0.75）自动扩容，将原数组容量扩大一倍。这相当于增加了存储空间，从而减小了发生冲突的概率。</p>
</li>
</ol>
<h3 id="多数组的情况"><a href="#多数组的情况" class="headerlink" title="多数组的情况"></a>多数组的情况</h3><p>一般情况下，哈希表只使用一个数组来存储桶。但在一些特殊的场景下，可能会用到多个数组：</p>
<ul>
<li><strong>分布式哈希表（DHT）</strong>：在分布式系统中，数据分布在不同的服务器上，可以视作多个“数组”分布在不同节点上。</li>
<li><strong>分区哈希表</strong>：在特定应用场景中，有时会对哈希表进行分区，每个分区对应一个独立的数组，以实现分片存储或负载均衡。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在常见的哈希表实现（如 <code>HashMap</code>）中，通常是<strong>一个大数组</strong>来管理桶，在冲突发生时每个桶内可能使用链表或红黑树等结构存储多个值。</p>
<h3 id="JDK-HashMap"><a href="#JDK-HashMap" class="headerlink" title="JDK HashMap"></a>JDK HashMap</h3><p>是的，<code>HashMap</code> 是基于哈希实现的。在 JDK 的 <code>HashMap</code> 中，底层实现利用了<strong>数组 + 链表 + 红黑树</strong>的结构来存储键值对。其主要原理包括以下几个关键步骤：</p>
<h4 id="哈希计算"><a href="#哈希计算" class="headerlink" title="哈希计算"></a>哈希计算</h4><p><code>HashMap</code> 使用键的 <code>hashCode()</code> 方法来计算哈希值。计算哈希值后，会进一步通过位运算来<strong>优化分布</strong>，从而减少哈希冲突。具体来说，<code>HashMap</code> 会对哈希值进行一次扰动处理，使得高位和低位信息更加均匀地影响到数组索引。</p>
<p>例如，在 JDK 8 中使用了以下计算方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组索引映射"><a href="#数组索引映射" class="headerlink" title="数组索引映射"></a>数组索引映射</h4><p><code>HashMap</code> 的底层是一个<strong>数组</strong>，称为<strong>桶数组</strong>。通过 <code>(n - 1) &amp; hash</code> 的操作，哈希值被映射到数组的某个索引位置（其中 <code>n</code> 是桶数组的长度，且 <code>n</code> 始终为 2 的幂）。这种位运算的方式比取模运算更加高效。</p>
<h4 id="处理哈希冲突"><a href="#处理哈希冲突" class="headerlink" title="处理哈希冲突"></a>处理哈希冲突</h4><p>如果多个键的哈希值映射到了相同的数组索引（即发生哈希冲突），<code>HashMap</code> 会在该索引处使用<strong>链表</strong>或<strong>红黑树</strong>来存储这些冲突的键值对。</p>
<ul>
<li><strong>链表</strong>：在 JDK 8 及之前，当冲突的键较少时，<code>HashMap</code> 使用链表将冲突的键连接起来。链表的插入操作简单，但是查找速度是 <code>O(n)</code>。</li>
<li><strong>红黑树</strong>：在 JDK 8 中，如果某个桶中的元素数量超过一定阈值（默认是 8），链表会转化为<strong>红黑树</strong>结构，从而提升查找效率至 <code>O(log n)</code>。</li>
</ul>
<h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h4><p>当 <code>HashMap</code> 的负载因子（元素个数 / 数组容量）超过某个阈值（默认是 0.75），<code>HashMap</code> 会<strong>进行扩容</strong>。扩容会将桶数组的大小扩大为原来的两倍，并重新分配所有元素的位置。这一过程称为<strong>rehash</strong>，它会重新计算所有键的索引，以减少哈希冲突。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>JDK 中的 <code>HashMap</code> 是通过哈希函数来计算键的哈希值，并将其映射到数组的索引。遇到冲突时，采用链表或红黑树存储方式，并通过动态扩容和重哈希来保证存取效率。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h4><p>当你往简单数组或列表中插入新数据时，将不会根据插入项的值来确定该插入项的索引值。这意味着新插入项的索引值与数据值之间没有直接关系。这样的话，当你需要在数组或列表中搜索相应值的时候，你必须遍历已有的集合。若集合中存在大量的数据，就会影响数据查找的效率。</p>
<p>针对这个问题，你可以考虑使用哈希表。<strong>利用哈希表你可以通过对 “值” 进行哈希处理来获得该值对应的键或索引值</strong>，然后把该值存放到列表中对应的索引位置。这意味着索引值是由插入项的值所确定的，当你需要判断列表中是否存在该值时，只需要对值进行哈希处理并在相应的索引位置进行搜索即可，这时的搜索速度是非常快的。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-ba324df953f121b077f7bdc2a6109f0a_r.jpg"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133002751.png" alt="image-20241111133002751"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133015151.png" alt="image-20241111133015151"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133059526.png" alt="image-20241111133059526"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133111464.png" alt="image-20241111133111464"></p>
<p>插入数据时顺便将数据键添加进布隆过滤器中，会根据n个哈希函数计算出n个索引，随后将这些索引位置1，因为哈希函数存在碰撞的可能，所以要计算出多个哈希值，图中使用了3个哈希值，fullstack和semlinker出现了完全重复，这就导致了误判。</p>
<p><strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在</strong> </p>
<p>如果哈希运算后任何一个索引位为0，则肯定不存在，否则可能存在</p>
<h4 id="误判率"><a href="#误判率" class="headerlink" title="误判率"></a>误判率</h4><p>幸运的是，布隆过滤器有一个可预测的误判率（FPP）：</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133418275.png" alt="image-20241111133418275" style="zoom: 33%;" />

<ul>
<li>n 是已经添加元素的数量；</li>
<li>k 哈希的次数；</li>
<li>m 布隆过滤器的长度（如比特数组的大小）；</li>
</ul>
<p>极端情况下，当布隆过滤器没有空闲空间时（满），每一次查询都会返回 true 。这也就意味着 m 的选择取决于期望预计添加元素的数量 n ，并且 m 需要远远大于 n 。</p>
<h4 id="最佳实践：Guava"><a href="#最佳实践：Guava" class="headerlink" title="最佳实践：Guava"></a>最佳实践：Guava</h4><p>guava的布隆过滤器直接使用即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建布隆过滤器对象</span></span><br><span class="line">BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">    Funnels.integerFunnel(),</span><br><span class="line">    <span class="number">1500</span>,</span><br><span class="line">    <span class="number">0.01</span>);</span><br><span class="line"><span class="comment">// 判断指定元素是否存在</span></span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 将元素添加进布隆过滤器</span></span><br><span class="line">filter.put(<span class="number">1</span>);</span><br><span class="line">filter.put(<span class="number">2</span>);</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
